## The GNU C Library Reference Manual



# The GNU C Library

# Reference Manual

Sandra Loosemore
with
Richard M. Stallman, Roland McGrath, Andrew Oram, and Ulrich Drepper

```
for version 2.
```

This isThe GNU C Library Reference Manual, for version 2.33.

Copyright?c 1993¨C2021 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under the terms of
the GNU Free Documentation License, Version 1.3 or any later version published by the
Free Software Foundation; with the Invariant Sections being ¡°Free Software Needs Free
Documentation¡± and ¡°GNU Lesser General Public License¡±, the Front-Cover texts being
¡°A GNU Manual¡±, and with the Back-Cover Texts as in (a) below. A copy of the license is
included in the section entitled"GNU Free Documentation License".

(a) The FSF¡¯s Back-Cover Text is: ¡°You have the freedom to copy and modify this GNU
manual. Buying copies from the FSF supports it in developing GNU and promoting software
freedom.¡±


## i



iii














- 1 Introduction.......................................... Short Contents
- 2 Error Reporting......................................
- 3 Virtual Memory Allocation And Paging..................
- 4 Character Handling...................................
- 5 String and Array Utilities..............................
- 6 Character Set Handling...............................
- 7 Locales and Internationalization........................
- 8 Message Translation.................................
- 9 Searching and Sorting................................
- 10 Pattern Matching...................................
- 11 Input/Output Overview..............................
- 12 Input/Output on Streams.............................
- 13 Low-Level Input/Output..............................
- 14 File System Interface.................................
- 15 Pipes and FIFOs....................................
- 16 Sockets............................................
- 17 Low-Level Terminal Interface..........................
- 18 Syslog.............................................
- 19 Mathematics.......................................
- 20 Arithmetic Functions.................................
- 21 Date and Time......................................
- 22 Resource Usage And Limitation........................
- 23 Non-Local Exits.....................................
- 24 Signal Handling.....................................
- 25 The Basic Program/System Interface....................
- 26 Processes..........................................
- 27 Inter-Process Communication..........................
- 28 Job Control........................................
- 29 System Databases and Name Service Switch..............
- 30 Users and Groups...................................
- 31 System Management.................................
- 32 System Configuration Parameters.......................
- 33 Cryptographic Functions..............................
- 34 Debugging support.................................. ii
- 35 Threads...........................................
- 36 Internal probes......................................
- 37 Tunables...........................................
- A C Language Facilities in the Library....................
- B Summary of Library Facilities..........................
- C Installing the GNU C Library.........................
- D Library Maintenance................................
- E Platform-specific facilities............................
- F Contributors to the GNU C Library....................
- G Free Software Needs Free Documentation...............
- H GNU Lesser General Public License....................
- I GNU Free Documentation License.....................
- Concept Index.........................................
- Type Index...........................................
- Function and Macro Index...............................
- Variable and Constant Macro Index.......................
- Program and File Index.................................
- 1 Introduction..................................... Table of Contents
- 1.1 Getting Started.................................................
- 1.2 Standards and Portability......................................
- 1.2.1 ISO C.....................................................
- 1.2.2 POSIX (The Portable Operating System Interface).........
- 1.2.2.1 POSIX Safety Concepts...............................
- 1.2.2.2 Unsafe Features.......................................
- 1.2.2.3 Conditionally Safe Features...........................
- 1.2.2.4 Other Safety Remarks................................
- 1.2.3 Berkeley Unix............................................
- 1.2.4 SVID (The System V Interface Description)...............
- 1.2.5 XPG (The X/Open Portability Guide)....................
- 1.3 Using the Library.............................................
- 1.3.1 Header Files..............................................
- 1.3.2 Macro Definitions of Functions............................
- 1.3.3 Reserved Names..........................................
- 1.3.4 Feature Test Macros......................................
- 1.4 Roadmap to the Manual.......................................
- 2 Error Reporting................................
- 2.1 Checking for Errors............................................
- 2.2 Error Codes...................................................
- 2.3 Error Messages................................................
- 3 Virtual Memory Allocation And Paging.....
- 3.1 Process Memory Concepts.....................................
- 3.2 Allocating Storage For Program Data..........................
- 3.2.1 Memory Allocation in C Programs........................
- 3.2.1.1 Dynamic Memory Allocation.........................
- 3.2.2 The GNU Allocator......................................
- 3.2.3 Unconstrained Allocation.................................
- 3.2.3.1 Basic Memory Allocation............................
- 3.2.3.2 Examples ofmalloc.................................
- 3.2.3.3 Freeing Memory Allocated withmalloc..............
- 3.2.3.4 Changing the Size of a Block.........................
- 3.2.3.5 Allocating Cleared Space.............................
- 3.2.3.6 Allocating Aligned Memory Blocks...................
- 3.2.3.7 Malloc Tunable Parameters..........................
- 3.2.3.8 Heap Consistency Checking..........................
- 3.2.3.9 Memory Allocation Hooks...........................
- 3.2.3.10 Statistics for Memory Allocation withmalloc.......
- 3.2.3.11 Summary ofmalloc-Related Functions..............
- 3.2.4 Allocation Debugging..................................... iv
- 3.2.4.1 How to install the tracing functionality...............
- 3.2.4.2 Example program excerpts...........................
- 3.2.4.3 Some more or less clever ideas.......................
- 3.2.4.4 Interpreting the traces...............................
- 3.2.5 Replacingmalloc.........................................
- 3.2.6 Obstacks.................................................
- 3.2.6.1 Creating Obstacks...................................
- 3.2.6.2 Preparing for Using Obstacks........................
- 3.2.6.3 Allocation in an Obstack.............................
- 3.2.6.4 Freeing Objects in an Obstack.......................
- 3.2.6.5 Obstack Functions and Macros.......................
- 3.2.6.6 Growing Objects.....................................
- 3.2.6.7 Extra Fast Growing Objects.........................
- 3.2.6.8 Status of an Obstack.................................
- 3.2.6.9 Alignment of Data in Obstacks.......................
- 3.2.6.10 Obstack Chunks....................................
- 3.2.6.11 Summary of Obstack Functions.....................
- 3.2.7 Automatic Storage with Variable Size.....................
- 3.2.7.1 allocaExample.....................................
- 3.2.7.2 Advantages ofalloca................................
- 3.2.7.3 Disadvantages ofalloca.............................
- 3.2.7.4 GNU C Variable-Size Arrays.........................
- 3.3 Resizing the Data Segment....................................
- 3.4 Memory Protection............................................
- 3.4.1 Memory Protection Keys.................................
- 3.5 Locking Pages.................................................
- 3.5.1 Why Lock Pages..........................................
- 3.5.2 Locked Memory Details...................................
- 3.5.3 Functions To Lock And Unlock Pages.....................
- 4 Character Handling............................
- 4.1 Classification of Characters....................................
- 4.2 Case Conversion...............................................
- 4.3 Character class determination for wide characters..............
- 4.4 Notes on using the wide character classes......................
- 4.5 Mapping of wide characters....................................
- 5 String and Array Utilities.....................
- 5.1 Representation of Strings......................................
- 5.2 String and Array Conventions.................................
- 5.3 String Length.................................................
- 5.4 Copying Strings and Arrays..................................
- 5.5 Concatenating Strings........................................
- 5.6 Truncating Strings while Copying.............................
- 5.7 String/Array Comparison....................................
- 5.8 Collation Functions...........................................
- 5.9 Search Functions............................................. v
- 5.9.1 Compatibility String Search Functions...................
- 5.10 Finding Tokens in a String..................................
- 5.11 Erasing Sensitive Data......................................
- 5.12 Shuffling Bytes..............................................
- 5.13 Obfuscating Data...........................................
- 5.14 Encode Binary Data........................................
- 5.15 Argz and Envz Vectors......................................
- 5.15.1 Argz Functions.........................................
- 5.15.2 Envz Functions.........................................
- 6 Character Set Handling......................
- 6.1 Introduction to Extended Characters.........................
- 6.2 Overview about Character Handling Functions................
- 6.3 Restartable Multibyte Conversion Functions..................
- 6.3.1 Selecting the conversion and its properties...............
- 6.3.2 Representing the state of the conversion.................
- 6.3.3 Converting Single Characters............................
- 6.3.4 Converting Multibyte and Wide Character Strings.......
- 6.3.5 A Complete Multibyte Conversion Example..............
- 6.4 Non-reentrant Conversion Function...........................
- 6.4.1 Non-reentrant Conversion of Single Characters...........
- 6.4.2 Non-reentrant Conversion of Strings.....................
- 6.4.3 States in Non-reentrant Functions.......................
- 6.5 Generic Charset Conversion..................................
- 6.5.1 Generic Character Set Conversion Interface..............
- 6.5.2 A completeiconvexample..............................
- 6.5.3 Some Details about othericonvImplementations........
- 6.5.4 TheiconvImplementation in the GNU C Library.......
- 6.5.4.1 Format ofgconv-modulesfiles......................
- 6.5.4.2 Finding the conversion path iniconv...............
- 6.5.4.3 iconvmodule data structures.......................
- 6.5.4.4 iconvmodule interfaces............................
- 7 Locales and Internationalization.............
- 7.1 What Effects a Locale Has...................................
- 7.2 Choosing a Locale............................................
- 7.3 Locale Categories............................................
- 7.4 How Programs Set the Locale................................
- 7.5 Standard Locales.............................................
- 7.6 Locale Names................................................
- 7.7 Accessing Locale Information.................................
- 7.7.1 localeconv: It is portable but
- 7.7.1.1 Generic Numeric Formatting Parameters............
- 7.7.1.2 Printing the Currency Symbol......................
- 7.7.1.3 Printing the Sign of a Monetary Amount............
- 7.7.2 Pinpoint Access to Locale Data..........................
- 7.8 A dedicated function to format numbers...................... vi
- 7.9 Yes-or-No Questions..........................................
- 8 Message Translation..........................
- 8.1 X/Open Message Catalog Handling...........................
- 8.1.1 Thecatgetsfunction family............................
- 8.1.2 Format of the message catalog files......................
- 8.1.3 Generate Message Catalogs files.........................
- 8.1.4 How to use thecatgetsinterface........................
- 8.1.4.1 Not using symbolic names..........................
- 8.1.4.2 Using symbolic names..............................
- 8.1.4.3 How does to this allow to develop...................
- 8.2 The Uniforum approach to Message Translation...............
- 8.2.1 Thegettextfamily of functions.........................
- 8.2.1.1 What has to be done to translate a message?........
- 8.2.1.2 How to determine which catalog to be used.........
- 8.2.1.3 Additional functions for more complicated situations..
- 8.2.1.4 How to specify the output character setgettextuses..
- 8.2.1.5 How to usegettextin GUI programs...............
- 8.2.1.6 User influence ongettext..........................
- 8.2.2 Programs to handle message catalogs forgettext........
- 9 Searching and Sorting........................
- 9.1 Defining the Comparison Function............................
- 9.2 Array Search Function........................................
- 9.3 Array Sort Function..........................................
- 9.4 Searching and Sorting Example...............................
- 9.5 Thehsearchfunction........................................
- 9.6 Thetsearchfunction........................................
- 10 Pattern Matching............................
- 10.1 Wildcard Matching..........................................
- 10.2 Globbing....................................................
- 10.2.1 Callingglob...........................................
- 10.2.2 Flags for Globbing.....................................
- 10.2.3 More Flags for Globbing................................
- 10.3 Regular Expression Matching................................
- 10.3.1 POSIX Regular Expression Compilation................
- 10.3.2 Flags for POSIX Regular Expressions...................
- 10.3.3 Matching a Compiled POSIX Regular Expression.......
- 10.3.4 Match Results with Subexpressions.....................
- 10.3.5 Complications in Subexpression Matching...............
- 10.3.6 POSIX Regexp Matching Cleanup......................
- 10.4 Shell-Style Word Expansion.................................
- 10.4.1 The Stages of Word Expansion.........................
- 10.4.2 Callingwordexp........................................
- 10.4.3 Flags for Word Expansion..............................
- 10.4.4 wordexpExample...................................... vii
- 10.4.5 Details of Tilde Expansion..............................
- 10.4.6 Details of Variable Substitution.........................
- 11 Input/Output Overview....................
- 11.1 Input/Output Concepts.....................................
- 11.1.1 Streams and File Descriptors...........................
- 11.1.2 File Position...........................................
- 11.2 File Names..................................................
- 11.2.1 Directories.............................................
- 11.2.2 File Name Resolution...................................
- 11.2.3 File Name Errors.......................................
- 11.2.4 Portability of File Names...............................
- 12 Input/Output on Streams..................
- 12.1 Streams.....................................................
- 12.2 Standard Streams...........................................
- 12.3 Opening Streams............................................
- 12.4 Closing Streams.............................................
- 12.5 Streams and Threads........................................
- 12.6 Streams in Internationalized Applications....................
- 12.7 Simple Output by Characters or Lines.......................
- 12.8 Character Input.............................................
- 12.9 Line-Oriented Input.........................................
- 12.10 Unreading.................................................
- 12.10.1 What Unreading Means...............................
- 12.10.2 UsingungetcTo Do Unreading.......................
- 12.11 Block Input/Output.......................................
- 12.12 Formatted Output.........................................
- 12.12.1 Formatted Output Basics..............................
- 12.12.2 Output Conversion Syntax............................
- 12.12.3 Table of Output Conversions..........................
- 12.12.4 Integer Conversions...................................
- 12.12.5 Floating-Point Conversions............................
- 12.12.6 Other Output Conversions.............................
- 12.12.7 Formatted Output Functions..........................
- 12.12.8 Dynamically Allocating Formatted Output............
- 12.12.9 Variable Arguments Output Functions.................
- 12.12.10 Parsing a Template String............................
- 12.12.11 Example of Parsing a Template String................
- 12.13 Customizingprintf.......................................
- 12.13.1 Registering New Conversions..........................
- 12.13.2 Conversion Specifier Options..........................
- 12.13.3 Defining the Output Handler..........................
- 12.13.4 printfExtension Example............................
- 12.13.5 PredefinedprintfHandlers...........................
- 12.14 Formatted Input...........................................
- 12.14.1 Formatted Input Basics............................... viii
- 12.14.2 Input Conversion Syntax..............................
- 12.14.3 Table of Input Conversions............................
- 12.14.4 Numeric Input Conversions............................
- 12.14.5 String Input Conversions..............................
- 12.14.6 Dynamically Allocating String Conversions............
- 12.14.7 Other Input Conversions..............................
- 12.14.8 Formatted Input Functions............................
- 12.14.9 Variable Arguments Input Functions...................
- 12.15 End-Of-File and Errors.....................................
- 12.16 Recovering from errors.....................................
- 12.17 Text and Binary Streams...................................
- 12.18 File Positioning............................................
- 12.19 Portable File-Position Functions............................
- 12.20 Stream Buffering...........................................
- 12.20.1 Buffering Concepts....................................
- 12.20.2 Flushing Buffers.......................................
- 12.20.3 Controlling Which Kind of Buffering...................
- 12.21 Other Kinds of Streams....................................
- 12.21.1 String Streams........................................
- 12.21.2 Programming Your Own Custom Streams.............
- 12.21.2.1 Custom Streams and Cookies.....................
- 12.21.2.2 Custom Stream Hook Functions..................
- 12.22 Formatted Messages........................................
- 12.22.1 Printing Formatted Messages..........................
- 12.22.2 Adding Severity Classes...............................
- 12.22.3 How to usefmtmsgandaddseverity..................
- 13 Low-Level Input/Output....................
- 13.1 Opening and Closing Files...................................
- 13.2 Input and Output Primitives................................
- 13.3 Setting the File Position of a Descriptor.....................
- 13.4 Descriptors and Streams.....................................
- 13.5 Dangers of Mixing Streams and Descriptors..................
- 13.5.1 Linked Channels.......................................
- 13.5.2 Independent Channels..................................
- 13.5.3 Cleaning Streams.......................................
- 13.6 Fast Scatter-Gather I/O.....................................
- 13.7 Copying data between two files..............................
- 13.8 Memory-mapped I/O........................................
- 13.9 Waiting for Input or Output.................................
- 13.10 Synchronizing I/O operations..............................
- 13.11 Perform I/O Operations in Parallel.........................
- 13.11.1 Asynchronous Read and Write Operations.............
- 13.11.2 Getting the Status of AIO Operations.................
- 13.11.3 Getting into a Consistent State........................
- 13.11.4 Cancellation of AIO Operations.......................
- 13.11.5 How to optimize the AIO implementation..............
- 13.12 Control Operations on Files................................ ix
- 13.13 Duplicating Descriptors....................................
- 13.14 File Descriptor Flags.......................................
- 13.15 File Status Flags...........................................
- 13.15.1 File Access Modes.....................................
- 13.15.2 Open-time Flags......................................
- 13.15.3 I/O Operating Modes.................................
- 13.15.4 Getting and Setting File Status Flags..................
- 13.16 File Locks..................................................
- 13.17 Open File Description Locks...............................
- 13.18 Open File Description Locks Example......................
- 13.19 Interrupt-Driven Input.....................................
- 13.20 Generic I/O Control operations............................
- 14 File System Interface........................
- 14.1 Working Directory..........................................
- 14.2 Accessing Directories........................................
- 14.2.1 Format of a Directory Entry............................
- 14.2.2 Opening a Directory Stream............................
- 14.2.3 Reading and Closing a Directory Stream................
- 14.2.4 Simple Program to List a Directory.....................
- 14.2.5 Random Access in a Directory Stream..................
- 14.2.6 Scanning the Content of a Directory....................
- 14.2.7 Simple Program to List a Directory, Mark II............
- 14.2.8 Low-level Directory Access.............................
- 14.3 Working with Directory Trees...............................
- 14.4 Hard Links..................................................
- 14.5 Symbolic Links..............................................
- 14.6 Deleting Files...............................................
- 14.7 Renaming Files.............................................
- 14.8 Creating Directories.........................................
- 14.9 File Attributes..............................................
- 14.9.1 The meaning of the File Attributes.....................
- 14.9.2 Reading the Attributes of a File........................
- 14.9.3 Testing the Type of a File..............................
- 14.9.4 File Owner.............................................
- 14.9.5 The Mode Bits for Access Permission...................
- 14.9.6 How Your Access to a File is Decided...................
- 14.9.7 Assigning File Permissions..............................
- 14.9.8 Testing Permission to Access a File.....................
- 14.9.9 File Times.............................................
- 14.9.10 File Size..............................................
- 14.9.11 Storage Allocation....................................
- 14.10 Making Special Files.......................................
- 14.11 Temporary Files...........................................
- 15 Pipes and FIFOs............................. x
- 15.1 Creating a Pipe.............................................
- 15.2 Pipe to a Subprocess........................................
- 15.3 FIFO Special Files..........................................
- 15.4 Atomicity of Pipe I/O.......................................
- 16 Sockets.......................................
- 16.1 Socket Concepts.............................................
- 16.2 Communication Styles.......................................
- 16.3 Socket Addresses............................................
- 16.3.1 Address Formats.......................................
- 16.3.2 Setting the Address of a Socket.........................
- 16.3.3 Reading the Address of a Socket........................
- 16.4 Interface Naming............................................
- 16.5 The Local Namespace.......................................
- 16.5.1 Local Namespace Concepts.............................
- 16.5.2 Details of Local Namespace.............................
- 16.5.3 Example of Local-Namespace Sockets...................
- 16.6 The Internet Namespace....................................
- 16.6.1 Internet Socket Address Formats.......................
- 16.6.2 Host Addresses.........................................
- 16.6.2.1 Internet Host Addresses...........................
- 16.6.2.2 Host Address Data Type..........................
- 16.6.2.3 Host Address Functions............................
- 16.6.2.4 Host Names.......................................
- 16.6.3 Internet Ports..........................................
- 16.6.4 The Services Database..................................
- 16.6.5 Byte Order Conversion.................................
- 16.6.6 Protocols Database.....................................
- 16.6.7 Internet Socket Example................................
- 16.7 Other Namespaces..........................................
- 16.8 Opening and Closing Sockets................................
- 16.8.1 Creating a Socket......................................
- 16.8.2 Closing a Socket........................................
- 16.8.3 Socket Pairs............................................
- 16.9 Using Sockets with Connections.............................
- 16.9.1 Making a Connection...................................
- 16.9.2 Listening for Connections...............................
- 16.9.3 Accepting Connections.................................
- 16.9.4 Who is Connected to Me?..............................
- 16.9.5 Transferring Data......................................
- 16.9.5.1 Sending Data......................................
- 16.9.5.2 Receiving Data....................................
- 16.9.5.3 Socket Data Options...............................
- 16.9.6 Byte Stream Socket Example...........................
- 16.9.7 Byte Stream Connection Server Example...............
- 16.9.8 Out-of-Band Data......................................
- 16.10 Datagram Socket Operations...............................
- 16.10.1 Sending Datagrams.................................... xi
- 16.10.2 Receiving Datagrams..................................
- 16.10.3 Datagram Socket Example............................
- 16.10.4 Example of Reading Datagrams.......................
- 16.11 TheinetdDaemon........................................
- 16.11.1 inetdServers.........................................
- 16.11.2 Configuringinetd.....................................
- 16.12 Socket Options.............................................
- 16.12.1 Socket Option Functions..............................
- 16.12.2 Socket-Level Options..................................
- 16.13 Networks Database.........................................
- 17 Low-Level Terminal Interface...............
- 17.1 Identifying Terminals........................................
- 17.2 I/O Queues.................................................
- 17.3 Two Styles of Input: Canonical or Not.......................
- 17.4 Terminal Modes.............................................
- 17.4.1 Terminal Mode Data Types.............................
- 17.4.2 Terminal Mode Functions...............................
- 17.4.3 Setting Terminal Modes Properly.......................
- 17.4.4 Input Modes...........................................
- 17.4.5 Output Modes.........................................
- 17.4.6 Control Modes.........................................
- 17.4.7 Local Modes...........................................
- 17.4.8 Line Speed.............................................
- 17.4.9 Special Characters......................................
- 17.4.9.1 Characters for Input Editing.......................
- 17.4.9.2 Characters that Cause Signals.....................
- 17.4.9.3 Special Characters for Flow Control................
- 17.4.9.4 Other Special Characters..........................
- 17.4.10 Noncanonical Input...................................
- 17.5 BSD Terminal Modes.......................................
- 17.6 Line Control Functions......................................
- 17.7 Noncanonical Mode Example................................
- 17.8 Reading Passphrases........................................
- 17.9 Pseudo-Terminals...........................................
- 17.9.1 Allocating Pseudo-Terminals...........................
- 17.9.2 Opening a Pseudo-Terminal Pair.......................
- 18 Syslog........................................
- 18.1 Overview of Syslog..........................................
- 18.2 Submitting Syslog Messages.................................
- 18.2.1 openlog................................................
- 18.2.2 syslog, vsyslog..........................................
- 18.2.3 closelog................................................
- 18.2.4 setlogmask.............................................
- 18.2.5 Syslog Example........................................
- 19 Mathematics................................. xii
- 19.1 Predefined Mathematical Constants.........................
- 19.2 Trigonometric Functions.....................................
- 19.3 Inverse Trigonometric Functions.............................
- 19.4 Exponentiation and Logarithms.............................
- 19.5 Hyperbolic Functions........................................
- 19.6 Special Functions...........................................
- 19.7 Known Maximum Errors in Math Functions.................
- 19.8 Pseudo-Random Numbers...................................
- 19.8.1 ISO C Random Number Functions......................
- 19.8.2 BSD Random Number Functions.......................
- 19.8.3 SVID Random Number Function.......................
- 19.9 Is Fast Code or Small Code preferred?.......................
- 20 Arithmetic Functions........................
- 20.1 Integers.....................................................
- 20.2 Integer Division.............................................
- 20.3 Floating Point Numbers.....................................
- 20.4 Floating-Point Number Classification Functions..............
- 20.5 Errors in Floating-Point Calculations........................
- 20.5.1 FP Exceptions.........................................
- 20.5.2 Infinity and NaN.......................................
- 20.5.3 Examining the FPU status word........................
- 20.5.4 Error Reporting by Mathematical Functions............
- 20.6 Rounding Modes............................................
- 20.7 Floating-Point Control Functions............................
- 20.8 Arithmetic Functions........................................
- 20.8.1 Absolute Value.........................................
- 20.8.2 Normalization Functions................................
- 20.8.3 Rounding Functions....................................
- 20.8.4 Remainder Functions...................................
- 20.8.5 Setting and modifying single bits of FP values..........
- 20.8.6 Floating-Point Comparison Functions...................
- 20.8.7 Miscellaneous FP arithmetic functions..................
- 20.9 Complex Numbers..........................................
- Decomposing of Complex Numbers.............................. 20.10 Projections, Conjugates, and
- 20.11 Parsing of Numbers........................................
- 20.11.1 Parsing of Integers....................................
- 20.11.2 Parsing of Floats......................................
- 20.12 Printing of Floats..........................................
- 20.13 Old-fashioned System V number-to-string functions.........
- 21 Date and Time............................... xiii
- 21.1 Time Basics.................................................
- 21.2 Time Types.................................................
- 21.3 Calculating Elapsed Time...................................
- 21.4 Processor And CPU Time...................................
- 21.4.1 CPU Time Inquiry.....................................
- 21.4.2 Processor Time Inquiry.................................
- 21.5 Calendar Time..............................................
- 21.5.1 Getting the Time.......................................
- 21.5.2 Setting and Adjusting the Time........................
- 21.5.3 Broken-down Time.....................................
- 21.5.4 Formatting Calendar Time.............................
- 21.5.5 Convert textual time and date information back........
- 21.5.5.1 Interpret string according to given format..........
- 21.5.5.2 A More User-friendly Way to Parse Times and Dates..
- 21.5.6 Specifying the Time Zone withTZ......................
- 21.5.7 Functions and Variables for Time Zones................
- 21.5.8 Time Functions Example...............................
- 21.6 Setting an Alarm............................................
- 21.7 Sleeping.....................................................
- 22 Resource Usage And Limitation............
- 22.1 Resource Usage.............................................
- 22.2 Limiting Resource Usage....................................
- 22.3 Process CPU Priority And Scheduling.......................
- 22.3.1 Absolute Priority.......................................
- 22.3.1.1 Using Absolute Priority............................
- 22.3.2 Realtime Scheduling....................................
- 22.3.3 Basic Scheduling Functions.............................
- 22.3.4 Traditional Scheduling..................................
- 22.3.4.1 Introduction To Traditional Scheduling............
- 22.3.4.2 Functions For Traditional Scheduling..............
- 22.3.5 Limiting execution to certain CPUs.....................
- 22.4 Querying memory available resources........................
- 22.4.1 Overview about traditional Unix memory handling......
- 22.4.2 How to get information about the memory subsystem?..
- 22.5 Learn about the processors available.........................
- 23 Non-Local Exits.............................
- 23.1 Introduction to Non-Local Exits.............................
- 23.2 Details of Non-Local Exits...................................
- 23.3 Non-Local Exits and Signals.................................
- 23.4 Complete Context Control...................................
- 24 Signal Handling.............................. xiv
- 24.1 Basic Concepts of Signals....................................
- 24.1.1 Some Kinds of Signals..................................
- 24.1.2 Concepts of Signal Generation..........................
- 24.1.3 How Signals Are Delivered..............................
- 24.2 Standard Signals............................................
- 24.2.1 Program Error Signals..................................
- 24.2.2 Termination Signals....................................
- 24.2.3 Alarm Signals..........................................
- 24.2.4 Asynchronous I/O Signals..............................
- 24.2.5 Job Control Signals.....................................
- 24.2.6 Operation Error Signals................................
- 24.2.7 Miscellaneous Signals...................................
- 24.2.8 Signal Messages........................................
- 24.3 Specifying Signal Actions....................................
- 24.3.1 Basic Signal Handling..................................
- 24.3.2 Advanced Signal Handling..............................
- 24.3.3 Interaction ofsignalandsigaction...................
- 24.3.4 sigactionFunction Example..........................
- 24.3.5 Flags forsigaction....................................
- 24.3.6 Initial Signal Actions...................................
- 24.4 Defining Signal Handlers....................................
- 24.4.1 Signal Handlers that Return............................
- 24.4.2 Handlers That Terminate the Process...................
- 24.4.3 Nonlocal Control Transfer in Handlers..................
- 24.4.4 Signals Arriving While a Handler Runs.................
- 24.4.5 Signals Close Together Merge into One.................
- 24.4.6 Signal Handling and Nonreentrant Functions............
- 24.4.7 Atomic Data Access and Signal Handling...............
- 24.4.7.1 Problems with Non-Atomic Access.................
- 24.4.7.2 Atomic Types.....................................
- 24.4.7.3 Atomic Usage Patterns............................
- 24.5 Primitives Interrupted by Signals............................
- 24.6 Generating Signals..........................................
- 24.6.1 Signaling Yourself......................................
- 24.6.2 Signaling Another Process..............................
- 24.6.3 Permission for usingkill..............................
- 24.6.4 Usingkillfor Communication.........................
- 24.7 Blocking Signals.............................................
- 24.7.1 Why Blocking Signals is Useful.........................
- 24.7.2 Signal Sets.............................................
- 24.7.3 Process Signal Mask....................................
- 24.7.4 Blocking to Test for Delivery of a Signal................
- 24.7.5 Blocking Signals for a Handler..........................
- 24.7.6 Checking for Pending Signals...........................
- 24.7.7 Remembering a Signal to Act On Later.................
- 24.8 Waiting for a Signal.........................................
- 24.8.1 Usingpause............................................
- 24.8.2 Problems withpause................................... xv
- 24.8.3 Usingsigsuspend......................................
- 24.9 Using a Separate Signal Stack...............................
- 24.10 BSD Signal Handling.......................................
- 25 The Basic Program/System Interface......
- 25.1 Program Arguments.........................................
- 25.1.1 Program Argument Syntax Conventions................
- 25.1.2 Parsing Program Arguments............................
- 25.2 Parsing program options usinggetopt.......................
- 25.2.1 Using thegetoptfunction..............................
- 25.2.2 Example of Parsing Arguments withgetopt............
- 25.2.3 Parsing Long Options withgetopt_long...............
- 25.2.4 Example of Parsing Long Options withgetopt_long....
- 25.3 Parsing Program Options with Argp.........................
- 25.3.1 Theargp_parseFunction..............................
- 25.3.2 Argp Global Variables..................................
- 25.3.3 Specifying Argp Parsers................................
- 25.3.4 Specifying Options in an Argp Parser...................
- 25.3.4.1 Flags for Argp Options............................
- 25.3.5 Argp Parser Functions..................................
- 25.3.5.1 Special Keys for Argp Parser Functions............
- 25.3.5.2 Argp Parsing State................................
- 25.3.5.3 Functions For Use in Argp Parsers.................
- 25.3.6 Combining Multiple Argp Parsers.......................
- 25.3.7 Flags forargp_parse...................................
- 25.3.8 Customizing Argp Help Output.........................
- 25.3.8.1 Special Keys for Argp Help Filter Functions........
- 25.3.9 Theargp_helpFunction...............................
- 25.3.10 Flags for theargp_helpFunction.....................
- 25.3.11 Argp Examples........................................
- 25.3.11.1 A Minimal Program Using Argp..................
- 25.3.11.2 A Program Using Argp with Only Default Options..
- 25.3.11.3 A Program Using Argp with User Options........
- 25.3.11.4 A Program Using Multiple Combined Argp Parsers..
- 25.3.12 Argp User Customization..............................
- 25.3.12.1 Parsing of Suboptions............................
- 25.3.13 Parsing of Suboptions Example........................
- 25.4 Environment Variables......................................
- 25.4.1 Environment Access....................................
- 25.4.2 Standard Environment Variables........................
- 25.5 Auxiliary Vector............................................
- 25.5.1 Definition ofgetauxval................................
- 25.6 System Calls................................................
- 25.7 Program Termination.......................................
- 25.7.1 Normal Termination....................................
- 25.7.2 Exit Status.............................................
- 25.7.3 Cleanups on Exit.......................................
- 25.7.4 Aborting a Program.................................... xvi
- 25.7.5 Termination Internals..................................
- 26 Processes.....................................
- 26.1 Running a Command........................................
- 26.2 Process Creation Concepts..................................
- 26.3 Process Identification........................................
- 26.4 Creating a Process..........................................
- 26.5 Executing a File.............................................
- 26.6 Process Completion.........................................
- 26.7 Process Completion Status..................................
- 26.8 BSD Process Wait Function.................................
- 26.9 Process Creation Example...................................
- 27 Inter-Process Communication..............
- 27.1 Semaphores.................................................
- 27.1.1 System V Semaphores..................................
- 27.1.2 POSIX Semaphores....................................
- 28 Job Control..................................
- 28.1 Concepts of Job Control.....................................
- 28.2 Controlling Terminal of a Process............................
- 28.3 Access to the Controlling Terminal..........................
- 28.4 Orphaned Process Groups...................................
- 28.5 Implementing a Job Control Shell...........................
- 28.5.1 Data Structures for the Shell...........................
- 28.5.2 Initializing the Shell....................................
- 28.5.3 Launching Jobs........................................
- 28.5.4 Foreground and Background............................
- 28.5.5 Stopped and Terminated Jobs..........................
- 28.5.6 Continuing Stopped Jobs...............................
- 28.5.7 The Missing Pieces.....................................
- 28.6 Functions for Job Control...................................
- 28.6.1 Identifying the Controlling Terminal....................
- 28.6.2 Process Group Functions...............................
- 28.6.3 Functions for Controlling Terminal Access..............
- 29 System Databases and Name Service Switch..
- 29.1 NSS Basics..................................................
- 29.2 The NSS Configuration File.................................
- 29.2.1 Services in the NSS configuration File...................
- 29.2.2 Actions in the NSS configuration.......................
- 29.2.3 Notes on the NSS Configuration File....................
- 29.3 NSS Module Internals.......................................
- 29.3.1 The Naming Scheme of the NSS Modules...............
- 29.3.2 The Interface of the Function in NSS Modules..........


```
xvii
```
```
29.4 Extending NSS.............................................. 842
29.4.1 Adding another Service to NSS......................... 842
29.4.2 Internals of the NSS Module Functions................. 843
```
30 Users and Groups........................... 845

```
30.1 User and Group IDs......................................... 845
30.2 The Persona of a Process.................................... 845
30.3 Why Change the Persona of a Process?...................... 846
30.4 How an Application Can Change Persona.................... 846
30.5 Reading the Persona of a Process............................ 847
30.6 Setting the User ID......................................... 848
30.7 Setting the Group IDs....................................... 849
30.8 Enabling and Disabling Setuid Access....................... 851
30.9 Setuid Program Example.................................... 852
30.10 Tips for Writing Setuid Programs.......................... 854
30.11 Identifying Who Logged In................................. 855
30.12 The User Accounting Database............................. 856
30.12.1 Manipulating the User Accounting Database........... 856
30.12.2 XPG User Accounting Database Functions............. 861
30.12.3 Logging In and Out................................... 863
30.13 User Database............................................. 864
30.13.1 The Data Structure that Describes a User............. 864
30.13.2 Looking Up One User................................. 865
30.13.3 Scanning the List of All Users......................... 866
30.13.4 Writing a User Entry.................................. 867
30.14 Group Database........................................... 868
30.14.1 The Data Structure for a Group....................... 868
30.14.2 Looking Up One Group............................... 868
30.14.3 Scanning the List of All Groups....................... 869
30.15 User and Group Database Example......................... 871
30.16 Netgroup Database......................................... 872
30.16.1 Netgroup Data........................................ 872
30.16.2 Looking up one Netgroup.............................. 872
30.16.3 Testing for Netgroup Membership..................... 874
```
31 System Management........................ 875

```
31.1 Host Identification.......................................... 875
31.2 Platform Type Identification................................ 877
31.3 Controlling and Querying Mounts........................... 878
31.3.1 Mount Information..................................... 879
31.3.1.1 Thefstabfile..................................... 879
31.3.1.2 Themtabfile...................................... 882
31.3.1.3 Other (Non-libc) Sources of Mount Information.... 885
31.3.2 Mount, Unmount, Remount............................ 885
```

```
xviii
```
32 System Configuration Parameters.......... 890

```
32.1 General Capacity Limits..................................... 890
32.2 Overall System Options..................................... 891
32.3 Which Version of POSIX is Supported....................... 892
32.4 Usingsysconf.............................................. 893
32.4.1 Definition ofsysconf................................... 893
32.4.2 Constants forsysconfParameters...................... 893
32.4.3 Examples ofsysconf................................... 901
32.5 Minimum Values for General Capacity Limits................ 902
32.6 Limits on File System Capacity............................. 903
32.7 Optional Features in File Support........................... 904
32.8 Minimum Values for File System Limits..................... 905
32.9 Usingpathconf............................................. 906
32.10 Utility Program Capacity Limits........................... 908
32.11 Minimum Values for Utility Limits......................... 909
32.12 String-Valued Parameters.................................. 909
```
33 Cryptographic Functions.................... 912

```
33.1 Passphrase Storage.......................................... 912
33.2 Generating Unpredictable Bytes............................. 916
```
34 Debugging support.......................... 918

```
34.1 Backtraces.................................................. 918
```
35 Threads...................................... 921

```
35.1 ISO C Threads.............................................. 921
35.1.1 Return Values.......................................... 921
35.1.2 Creation and Control................................... 921
35.1.3 Call Once.............................................. 923
35.1.4 Mutexes................................................ 923
35.1.5 Condition Variables.................................... 926
35.1.6 Thread-local Storage................................... 927
35.2 POSIX Threads............................................. 928
35.2.1 Thread-specific Data................................... 928
35.2.2 Non-POSIX Extensions................................. 929
35.2.2.1 Setting Process-wide defaults for thread attributes.. 929
35.2.2.2 Controlling the Initial Signal Mask of a New Thread.. 929
35.2.2.3 Functions for Waiting According to a Specific Clock.. 930
35.2.2.4 Detecting Single-Threaded Execution.............. 931
```
36 Internal probes.............................. 934

```
36.1 Memory Allocation Probes.................................. 934
36.2 Mathematical Function Probes.............................. 937
36.3 Non-local Goto Probes...................................... 939
```

```
xix
```
37 Tunables...................................... 940

```
37.1 Tunable names.............................................. 941
37.2 Memory Allocation Tunables................................ 941
37.3 Dynamic Linking Tunables.................................. 943
37.4 Elision Tunables............................................ 944
37.5 POSIX Thread Tunables.................................... 945
37.6 Hardware Capability Tunables............................... 946
37.7 Memory Related Tunables................................... 947
```
Appendix A C Language

```
Facilities in the Library........................ 949
A.1 Explicitly Checking Internal Consistency..................... 949
A.2 Variadic Functions........................................... 950
A.2.1 Why Variadic Functions are Used....................... 950
A.2.2 How Variadic Functions are Defined and Used........... 951
A.2.2.1 Syntax for Variable Arguments..................... 951
A.2.2.2 Receiving the Argument Values.................... 952
A.2.2.3 How Many Arguments Were Supplied.............. 952
A.2.2.4 Calling Variadic Functions......................... 953
A.2.2.5 Argument Access Macros........................... 953
A.2.3 Example of a Variadic Function......................... 955
A.3 Null Pointer Constant....................................... 955
A.4 Important Data Types....................................... 956
A.5 Data Type Measurements.................................... 956
A.5.1 Width of an Integer Type............................... 957
A.5.2 Range of an Integer Type............................... 958
A.5.3 Floating Type Macros................................... 959
A.5.3.1 Floating Point Representation Concepts............ 959
A.5.3.2 Floating Point Parameters......................... 961
A.5.3.3 IEEE Floating Point............................... 963
A.5.4 Structure Field Offset Measurement..................... 964
```
Appendix B Summary of Library Facilities... 965

Appendix C Installing the GNU C Library.. 1088

```
C.1 Configuring and compiling the GNU C Library.............. 1088
C.2 Installing the C Library..................................... 1094
C.3 Recommended Tools for Compilation........................ 1095
C.4 Specific advice for GNU/Linux systems..................... 1097
C.5 Reporting Bugs............................................. 1098
```

```
xx
```
Appendix D Library Maintenance............ 1099

```
D.1 Adding New Functions...................................... 1099
D.1.1 Platform-specific types, macros and functions.......... 1100
D.2 Symbol handling in the GNU C Library..................... 1101
D.2.1 64-bit time symbol handling in the GNU C Library..... 1101
D.3 Porting the GNU C Library................................. 1102
D.3.1 Layout of thesysdepsDirectory Hierarchy............. 1105
D.3.2 Porting the GNU C Library to Unix Systems........... 1107
```
Appendix E Platform-specific facilities...... 1108

```
E.1 PowerPC-specific Facilities.................................. 1108
E.2 RISC-V-specific Facilities................................... 1110
E.3 X86-specific Facilities....................................... 1110
```
Appendix F Contributors to the

GNU C Library............................... 1116

Appendix G Free Software Needs

Free Documentation.......................... 1122

Appendix H GNU Lesser General

Public License................................. 1124

Appendix I GNU Free

Documentation License....................... 1133

Concept Index................................... 1141

Type Index...................................... 1154

Function and Macro Index..................... 1157

Variable and Constant Macro Index........... 1173

Program and File Index........................ 1186


### 1

## 1 Introduction

The C language provides no built-in facilities for performing such common operations as
input/output, memory management, string manipulation, and the like. Instead, these fa-
cilities are defined in a standardlibrary, which you compile and link with your programs.

The GNU C Library, described in this document, defines all of the library functions that
are specified by the ISO C standard, as well as additional features specific to POSIX and
other derivatives of the Unix operating system, and extensions specific to GNU systems.

The purpose of this manual is to tell you how to use the facilities of the GNU C Library.
We have mentioned which features belong to which standards to help you identify things
that are potentially non-portable to other systems. But the emphasis in this manual is not
on strict portability.

## 1.1 Getting Started.................................................

This manual is written with the assumption that you are at least somewhat familiar with
the C programming language and basic programming concepts. Specifically, familiarity
with ISO standard C (seeSection 1.2.1 [ISO C], page 2), rather than ¡°traditional¡± pre-ISO
C dialects, is assumed.

The GNU C Library includes severalheader files, each of which provides definitions and
declarations for a group of related facilities; this information is used by the C compiler
when processing your program. For example, the header filestdio.hdeclares facilities
for performing input and output, and the header filestring.hdeclares string processing
utilities. The organization of this manual generally follows the same division as the header
files.

If you are reading this manual for the first time, you should read all of the introductory
material and skim the remaining chapters. There are alot of functions in the GNU C
Library and it¡¯s not realistic to expect that you will be able to remember exactlyhowto
use each and every one of them. It¡¯s more important to become generally familiar with the
kinds of facilities that the library provides, so that when you are writing your programs you
can recognizewhento make use of library functions, andwherein this manual you can find
more specific information about them.

## 1.2 Standards and Portability......................................

This section discusses the various standards and other sources that the GNU C Library is
based upon. These sources include the ISO C and POSIX standards, and the System V
and Berkeley Unix implementations.

The primary focus of this manual is to tell you how to make effective use of the GNU C
Library facilities. But if you are concerned about making your programs compatible with
these standards, or portable to operating systems other than GNU, this can affect how you
use the library. This section gives you an overview of these standards, so that you will know
what they are when they are mentioned in other parts of the manual.

SeeAppendix B [Summary of Library Facilities], page 965, for an alphabetical list of the
functions and other symbols provided by the library. This list also states which standards
each function or symbol comes from.


Chapter 1: Introduction 2

## 1.2.1 ISO C.....................................................

The GNU C Library is compatible with the C standard adopted by the American Na-
tional Standards Institute (ANSI):American National Standard X3.159-1989¡ª¡°ANSI C¡±
and later by the International Standardization Organization (ISO):ISO/IEC 9899:1990,
¡°Programming languages¡ªC¡±. We here refer to the standard as ISO C since this is the
more general standard in respect of ratification. The header files and library facilities that
make up the GNU C Library are a superset of those specified by the ISO C standard.

If you are concerned about strict adherence to the ISO C standard, you should use the
¡®-ansi¡¯ option when you compile your programs with the GNU C compiler. This tells
the compiler to defineonlyISO standard features from the library header files, unless you
explicitly ask for additional features. SeeSection 1.3.4 [Feature Test Macros], page 15, for
information on how to do this.

Being able to restrict the library to include only ISO C features is important because
ISO C puts limitations on what names can be defined by the library implementation, and
the GNU extensions don¡¯t fit these limitations. SeeSection 1.3.3 [Reserved Names], page 14,
for more information about these restrictions.

This manual does not attempt to give you complete details on the differences between
ISO C and older dialects. It gives advice on how to write programs to work portably under
multiple C dialects, but does not aim for completeness.

## 1.2.2 POSIX (The Portable Operating System Interface).........

The GNU C Library is also compatible with the ISOPOSIX family of standards, known
more formally as thePortable Operating System Interface for Computer Environments
(ISO/IEC 9945). They were also published as ANSI/IEEE Std 1003. POSIX is derived
mostly from various versions of the Unix operating system.

The library facilities specified by the POSIX standards are a superset of those required
by ISO C; POSIX specifies additional features for ISO C functions, as well as specifying
new additional functions. In general, the additional requirements and functionality defined
by the POSIX standards are aimed at providing lower-level support for a particular kind of
operating system environment, rather than general programming language support which
can run in many diverse operating system environments.

The GNU C Library implements all of the functions specified inISO/IEC 9945-1:1996,
the POSIX System Application Program Interface, commonly referred to as POSIX.1. The
primary extensions to the ISO C facilities specified by this standard include file system
interface primitives (seeChapter 14 [File System Interface], page 402), device-specific ter-
minal control functions (seeChapter 17 [Low-Level Terminal Interface], page 503), and
process control functions (seeChapter 26 [Processes], page 803).

Some facilities from ISO/IEC 9945-2:1993, the POSIX Shell and Utilities standard
(POSIX.2) are also implemented in the GNU C Library. These include utilities for deal-
ing with regular expressions and other pattern matching facilities (seeChapter 10 [Pattern
Matching], page 239).

## 1.2.2.1 POSIX Safety Concepts...............................

This manual documents various safety properties of GNU C Library functions, in lines that
follow their prototypes and look like:


Chapter 1: Introduction 3

Preliminary:|MT-Safe |AS-Safe |AC-Safe |

The properties are assessed according to the criteria set forth in the POSIX standard for
such safety contexts as Thread-, Async-Signal- and Async-Cancel- -Safety. Intuitive defi-
nitions of these properties, attempting to capture the meaning of the standard definitions,
follow.

- MT-Safeor Thread-Safe functions are safe to call in the presence of other threads. MT,
    in MT-Safe, stands for Multi Thread.
    Being MT-Safe does not imply a function is atomic, nor that it uses any of the memory
    synchronization mechanisms POSIX exposes to users. It is even possible that calling
    MT-Safe functions in sequence does not yield an MT-Safe combination. For example,
    having a thread call two MT-Safe functions one right after the other does not guaran-
    tee behavior equivalent to atomic execution of a combination of both functions, since
    concurrent calls in other threads may interfere in a destructive way.
    Whole-program optimizations that could inline functions across library interfaces may
    expose unsafe reordering, and so performing inlining across the GNU C Library inter-
    face is not recommended. The documented MT-Safety status is not guaranteed under
    whole-program optimization. However, functions defined in user-visible headers are
    designed to be safe for inlining.
- AS-Safeor Async-Signal-Safe functions are safe to call from asynchronous signal han-
    dlers. AS, in AS-Safe, stands for Asynchronous Signal.
    Many functions that are AS-Safe may seterrno, or modify the floating-point environ-
    ment, because their doing so does not make them unsuitable for use in signal handlers.
    However, programs could misbehave should asynchronous signal handlers modify this
    thread-local state, and the signal handling machinery cannot be counted on to pre-
    serve it. Therefore, signal handlers that call functions that may seterrnoor modify
    the floating-point environmentmustsave their original values, and restore them before
    returning.
- AC-Safeor Async-Cancel-Safe functions are safe to call when asynchronous cancellation
    is enabled. AC in AC-Safe stands for Asynchronous Cancellation.
    The POSIX standard defines only three functions to be AC-Safe, namelypthread_
    cancel, pthread_setcancelstate, and pthread_setcanceltype. At present the
    GNU C Library provides no guarantees beyond these three functions, but does docu-
    ment which functions are presently AC-Safe. This documentation is provided for use
    by the GNU C Library developers.
    Just like signal handlers, cancellation cleanup routines must configure the floating point
    environment they require. The routines cannot assume a floating point environment,
    particularly when asynchronous cancellation is enabled. If the configuration of the
    floating point environment cannot be performed atomically then it is also possible that
    the environment encountered is internally inconsistent.
- MT-Unsafe,AS-Unsafe,AC-Unsafefunctions are not safe to call within the safety con-
    texts described above. Calling them within such contexts invokes undefined behavior.
    Functions not explicitly documented as safe in a safety context should be regarded as
    Unsafe.
- Preliminarysafety properties are documented, indicating these properties maynotbe
    counted on in future releases of the GNU C Library.


Chapter 1: Introduction 4

```
Such preliminary properties are the result of an assessment of the properties of our
current implementation, rather than of what is mandated and permitted by current
and future standards.
Although we strive to abide by the standards, in some cases our implementation is safe
even when the standard does not demand safety, and in other cases our implementation
does not meet the standard safety requirements. The latter are most likely bugs; the
former, when marked asPreliminary, should not be counted on: future standards may
require changes that are not compatible with the additional safety properties afforded
by the current implementation.
Furthermore, the POSIX standard does not offer a detailed definition of safety. We
assume that, by ¡°safe to call¡±, POSIX means that, as long as the program does not
invoke undefined behavior, the ¡°safe to call¡± function behaves as specified, and does
not cause other functions to deviate from their specified behavior. We have chosen to
use its loose definitions of safety, not because they are the best definitions to use, but
because choosing them harmonizes this manual with POSIX.
Please keep in mind that these are preliminary definitions and annotations, and certain
aspects of the definitions are still under discussion and might be subject to clarification
or change.
Over time, we envision evolving the preliminary safety notes into stable commitments,
as stable as those of our interfaces. As we do, we will remove thePreliminarykeyword
from safety notes. As long as the keyword remains, however, they are not to be regarded
as a promise of future behavior.
Other keywords that appear in safety notes are defined in subsequent sections.
```
## 1.2.2.2 Unsafe Features.......................................

Functions that are unsafe to call in certain contexts are annotated with keywords that
document their features that make them unsafe to call. AS-Unsafe features in this sec-
tion indicate the functions are never safe to call when asynchronous signals are enabled.
AC-Unsafe features indicate they are never safe to call when asynchronous cancellation is
enabled. There are no MT-Unsafe marks in this section.

- lock
    Functions marked withlockas an AS-Unsafe feature may be interrupted by a signal
    while holding a non-recursive lock. If the signal handler calls another such function
    that takes the same lock, the result is a deadlock.
    Functions annotated with lock as an AC-Unsafe feature may, if cancelled
    asynchronously, fail to release a lock that would have been released if their execution
    had not been interrupted by asynchronous thread cancellation. Once a lock is left
    taken, attempts to take that lock will block indefinitely.
- corrupt
    Functions marked withcorruptas an AS-Unsafe feature may corrupt data structures
    and misbehave when they interrupt, or are interrupted by, another such function.
    Unlike functions marked withlock, these take recursive locks to avoid MT-Safety
    problems, but this is not enough to stop a signal handler from observing a partially-
    updated data structure. Further corruption may arise from the interrupted function¡¯s
    failure to notice updates made by signal handlers.


Chapter 1: Introduction 5

```
Functions marked withcorruptas an AC-Unsafe feature may leave data structures in a
corrupt, partially updated state. Subsequent uses of the data structure may misbehave.
```
- heap
    Functions marked withheapmay call heap memory management functions from the
    malloc/freefamily of functions and are only as safe as those functions. This note is
    thus equivalent to:
    |AS-Unsafe lock|AC-Unsafe lock fd mem|
- dlopen
    Functions marked withdlopenuse the dynamic loader to load shared libraries into
    the current execution image. This involves opening files, mapping them into memory,
    allocating additional memory, resolving symbols, applying relocations and more, all of
    this while holding internal dynamic loader locks.
    The locks are enough for these functions to be AS- and AC-Unsafe, but other issues
    may arise. At present this is a placeholder for all potential safety issues raised by
    dlopen.
- plugin
    Functions annotated withpluginmay run code from plugins that may be external to
    the GNU C Library. Such plugin functions are assumed to be MT-Safe, AS-Unsafe
    and AC-Unsafe. Examples of such plugins are stack unwinding libraries, name service
    switch (NSS) and character set conversion (iconv) back-ends.
    Although the plugins mentioned as examples are all brought in by means of dlopen,
    thepluginkeyword does not imply any direct involvement of the dynamic loader or
    thelibdlinterfaces, those are covered bydlopen. For example, if one function loads a
    module and finds the addresses of some of its functions, while another just calls those
    already-resolved functions, the former will be marked withdlopen, whereas the latter
    will get theplugin. When a single function takes all of these actions, then it gets both
    marks.
- i18n
    Functions marked withi18nmay call internationalization functions of thegettext
    family and will be only as safe as those functions. This note is thus equivalent to:
    |MT-Safe env|AS-Unsafe corrupt heap dlopen|AC-Unsafe corrupt|
- timer
    Functions marked withtimeruse thealarmfunction or similar to set a time-out for a
    system call or a long-running operation. In a multi-threaded program, there is a risk
    that the time-out signal will be delivered to a different thread, thus failing to interrupt
    the intended thread. Besides being MT-Unsafe, such functions are always AS-Unsafe,
    because calling them in signal handlers may interfere with timers set in the interrupted
    code, and AC-Unsafe, because there is no safe way to guarantee an earlier timer will
    be reset in case of asynchronous cancellation.

## 1.2.2.3 Conditionally Safe Features...........................

For some features that make functions unsafe to call in certain contexts, there are known
ways to avoid the safety problem other than refraining from calling the function altogether.
The keywords that follow refer to such features, and each of their definitions indicate how


Chapter 1: Introduction 6

the whole program needs to be constrained in order to remove the safety problem indicated
by the keyword. Only when all the reasons that make a function unsafe are observed and
addressed, by applying the documented constraints, does the function become safe to call
in a context.

- init
    Functions marked withinitas an MT-Unsafe feature perform MT-Unsafe initialization
    when they are first called.
    Calling such a function at least once in single-threaded mode removes this specific cause
    for the function to be regarded as MT-Unsafe. If no other cause for that remains, the
    function can then be safely called after other threads are started.
    Functions marked withinitas an AS- or AC-Unsafe feature use the internallibc_
    oncemachinery or similar to initialize internal data structures.
    If a signal handler interrupts such an initializer, and calls any function that also per-
    formslibc_onceinitialization, it will deadlock if the thread library has been loaded.
    Furthermore, if an initializer is partially complete before it is canceled or interrupted
    by a signal whose handler requires the same initialization, some or all of the initializa-
    tion may be performed more than once, leaking resources or even resulting in corrupt
    internal data.
    Applications that need to call functions marked withinitas an AS- or AC-Unsafe
    feature should ensure the initialization is performed before configuring signal handlers
    or enabling cancellation, so that the AS- and AC-Safety issues related withlibc_once
    do not arise.
- race
    Functions annotated withraceas an MT-Safety issue operate on objects in ways that
    may cause data races or similar forms of destructive interference out of concurrent
    execution. In some cases, the objects are passed to the functions by users; in others,
    they are used by the functions to return values to users; in others, they are not even
    exposed to users.
    We consider access to objects passed as (indirect) arguments to functions to be data
    race free. The assurance of data race free objects is the caller¡¯s responsibility. We
    will not mark a function as MT-Unsafe or AS-Unsafe if it misbehaves when users fail
    to take the measures required by POSIX to avoid data races when dealing with such
    objects. As a general rule, if a function is documented as reading from an object
    passed (by reference) to it, or modifying it, users ought to use memory synchronization
    primitives to avoid data races just as they would should they perform the accesses
    themselves rather than by calling the library function.FILEstreams are the exception
    to the general rule, in that POSIX mandates the library to guard against data races
    in many functions that manipulate objects of this specific opaque type. We regard
    this as a convenience provided to users, rather than as a general requirement whose
    expectations should extend to other types.
    In order to remind users that guarding certain arguments is their responsibility, we will
    annotate functions that take objects of certain types as arguments. We draw the line
    for objects passed by users as follows: objects whose types are exposed to users, and
    that users are expected to access directly, such as memory buffers, strings, and various


Chapter 1: Introduction 7

```
user-visiblestructtypes, donotgive reason for functions to be annotated withrace.
It would be noisy and redundant with the general requirement, and not many would
be surprised by the library¡¯s lack of internal guards when accessing objects that can be
accessed directly by users.
As for objects that are opaque or opaque-like, in that they are to be manipulated only
by passing them to library functions (e.g.,FILE,DIR,obstack,iconv_t), there might
be additional expectations as to internal coordination of access by the library. We will
annotate, withracefollowed by a colon and the argument name, functions that take
such objects but that do not take care of synchronizing access to them by default. For
example,FILEstreamunlockedfunctions will be annotated, but those that perform
implicit locking onFILEstreams by default will not, even though the implicit locking
may be disabled on a per-stream basis.
In either case, we will not regard as MT-Unsafe functions that may access user-supplied
objects in unsafe ways should users fail to ensure the accesses are well defined. The
notion prevails that users are expected to safeguard against data races any user-supplied
objects that the library accesses on their behalf.
This user responsibility does not apply, however, to objects controlled by the library
itself, such as internal objects and static buffers used to return values from certain
calls. When the library doesn¡¯t guard them against concurrent uses, these cases are
regarded as MT-Unsafe and AS-Unsafe (although theracemark under AS-Unsafe will
be omitted as redundant with the one under MT-Unsafe). As in the case of user-
exposed objects, the mark may be followed by a colon and an identifier. The identifier
groups all functions that operate on a certain unguarded object; users may avoid the
MT-Safety issues related with unguarded concurrent access to such internal objects
by creating a non-recursive mutex related with the identifier, and always holding the
mutex when calling any function marked as racy on that identifier, as they would have
to should the identifier be an object under user control. The non-recursive mutex
avoids the MT-Safety issue, but it trades one AS-Safety issue for another, so use in
asynchronous signals remains undefined.
When the identifier relates to a static buffer used to hold return values, the mutex
must be held for as long as the buffer remains in use by the caller. Many functions
that return pointers to static buffers offer reentrant variants that store return values in
caller-supplied buffers instead. In some cases, such astmpname, the variant is chosen
not by calling an alternate entry point, but by passing a non-NULLpointer to the buffer
in which the returned values are to be stored. These variants are generally preferable
in multi-threaded programs, although some of them are not MT-Safe because of other
internal buffers, also documented withracenotes.
```
- const
    Functions marked withconstas an MT-Safety issue non-atomically modify internal
    objects that are better regarded as constant, because a substantial portion of the
    GNU C Library accesses them without synchronization. Unlikerace, that causes both
    readers and writers of internal objects to be regarded as MT-Unsafe and AS-Unsafe, this
    mark is applied to writers only. Writers remain equally MT- and AS-Unsafe to call, but
    the then-mandatory constness of objects they modify enables readers to be regarded as
    MT-Safe and AS-Safe (as long as no other reasons for them to be unsafe remain), since
    the lack of synchronization is not a problem when the objects are effectively constant.


Chapter 1: Introduction 8

```
The identifier that follows theconstmark will appear by itself as a safety note in
readers. Programs that wish to work around this safety issue, so as to call writers,
may use a non-recursverwlockassociated with the identifier, and guardallcalls to
functions marked withconstfollowed by the identifier with a write lock, andallcalls to
functions marked with the identifier by itself with a read lock. The non-recursive locking
removes the MT-Safety problem, but it trades one AS-Safety problem for another, so
use in asynchronous signals remains undefined.
```
- sig

```
Functions marked withsigas a MT-Safety issue (that implies an identical AS-Safety is-
sue, omitted for brevity) may temporarily install a signal handler for internal purposes,
which may interfere with other uses of the signal, identified after a colon.
This safety problem can be worked around by ensuring that no other uses of the signal
will take place for the duration of the call. Holding a non-recursive mutex while calling
all functions that use the same temporary signal; blocking that signal before the call
and resetting its handler afterwards is recommended.
There is no safe way to guarantee the original signal handler is restored in case of
asynchronous cancellation, therefore so-marked functions are also AC-Unsafe.
Besides the measures recommended to work around the MT- and AS-Safety problem,
in order to avert the cancellation problem, disabling asynchronous cancellationand
installing a cleanup handler to restore the signal to the desired state and to release the
mutex are recommended.
```
- term

```
Functions marked withtermas an MT-Safety issue may change the terminal settings
in the recommended way, namely: calltcgetattr, modify some flags, and then call
tcsetattr; this creates a window in which changes made by other threads are lost.
Thus, functions marked withtermare MT-Unsafe. The same window enables changes
made by asynchronous signals to be lost. These functions are also AS-Unsafe, but the
corresponding mark is omitted as redundant.
```
```
It is thus advisable for applications using the terminal to avoid concurrent and reen-
trant interactions with it, by not using it in signal handlers or blocking signals that
might use it, and holding a lock while calling these functions and interacting with the
terminal. This lock should also be used for mutual exclusion with functions marked
withrace:tcattr(fd), wherefdis a file descriptor for the controlling terminal. The
caller may use a single mutex for simplicity, or use one mutex per terminal, even if
referenced by different file descriptors.
Functions marked withtermas an AC-Safety issue are supposed to restore terminal
settings to their original state, after temporarily changing them, but they may fail to
do so if cancelled.
Besides the measures recommended to work around the MT- and AS-Safety problem,
in order to avert the cancellation problem, disabling asynchronous cancellationand
installing a cleanup handler to restore the terminal settings to the original state and
to release the mutex are recommended.
```

Chapter 1: Introduction 9

## 1.2.2.4 Other Safety Remarks................................

Additional keywords may be attached to functions, indicating features that do not make
a function unsafe to call, but that may need to be taken into account in certain classes of
programs:

- locale
    Functions annotated withlocaleas an MT-Safety issue read from the locale object
    without any form of synchronization. Functions annotated withlocalecalled concur-
    rently with locale changes may behave in ways that do not correspond to any of the
    locales active during their execution, but an unpredictable mix thereof.
    We do not mark these functions as MT- or AS-Unsafe, however, because functions
    that modify the locale object are marked withconst:localeand regarded as unsafe.
    Being unsafe, the latter are not to be called when multiple threads are running or asyn-
    chronous signals are enabled, and so the locale can be considered effectively constant
    in these contexts, which makes the former safe.
- env
    Functions marked withenvas an MT-Safety issue access the environment withgetenv
    or similar, without any guards to ensure safety in the presence of concurrent modifica-
    tions.
    We do not mark these functions as MT- or AS-Unsafe, however, because functions
    that modify the environment are all marked withconst:envand regarded as unsafe.
    Being unsafe, the latter are not to be called when multiple threads are running or
    asynchronous signals are enabled, and so the environment can be considered effectively
    constant in these contexts, which makes the former safe.
- hostid
    The function marked withhostidas an MT-Safety issue reads from the system-wide
    data structures that hold the ¡°host ID¡± of the machine. These data structures cannot
    generally be modified atomically. Since it is expected that the ¡°host ID¡± will not nor-
    mally change, the function that reads from it (gethostid) is regarded as safe, whereas
    the function that modifies it (sethostid) is marked withconst:hostid, indicating
    it may require special care if it is to be called. In this specific case, the special care
    amounts to system-wide (not merely intra-process) coordination.
- sigintr
    Functions marked withsigintras an MT-Safety issue access the_sigintrinternal
    data structure without any guards to ensure safety in the presence of concurrent mod-
    ifications.
    We do not mark these functions as MT- or AS-Unsafe, however, because functions that
    modify the this data structure are all marked withconst:sigintrand regarded as
    unsafe. Being unsafe, the latter are not to be called when multiple threads are run-
    ning or asynchronous signals are enabled, and so the data structure can be considered
    effectively constant in these contexts, which makes the former safe.
- fd
    Functions annotated withfdas an AC-Safety issue may leak file descriptors if asyn-
    chronous thread cancellation interrupts their execution.


Chapter 1: Introduction 10

```
Functions that allocate or deallocate file descriptors will generally be marked as such.
Even if they attempted to protect the file descriptor allocation and deallocation with
cleanup regions, allocating a new descriptor and storing its number where the cleanup
region could release it cannot be performed as a single atomic operation. Similarly,
releasing the descriptor and taking it out of the data structure normally responsible for
releasing it cannot be performed atomically. There will always be a window in which
the descriptor cannot be released because it was not stored in the cleanup handler
argument yet, or it was already taken out before releasing it. It cannot be taken out
after release: an open descriptor could mean either that the descriptor still has to be
closed, or that it already did so but the descriptor was reallocated by another thread
or signal handler.
Such leaks could be internally avoided, with some performance penalty, by temporarily
disabling asynchronous thread cancellation. However, since callers of allocation or
deallocation functions would have to do this themselves, to avoid the same sort of leak
in their own layer, it makes more sense for the library to assume they are taking care of
it than to impose a performance penalty that is redundant when the problem is solved
in upper layers, and insufficient when it is not.
This remark by itself does not cause a function to be regarded as AC-Unsafe. However,
cumulative effects of such leaks may pose a problem for some programs. If this is the
case, suspending asynchronous cancellation for the duration of calls to such functions
is recommended.
```
- mem
    Functions annotated withmemas an AC-Safety issue may leak memory if asynchronous
    thread cancellation interrupts their execution.
    The problem is similar to that of file descriptors: there is no atomic interface to allocate
    memory and store its address in the argument to a cleanup handler, or to release it
    and remove its address from that argument, without at least temporarily disabling
    asynchronous cancellation, which these functions do not do.
    This remark does not by itself cause a function to be regarded as generally AC-Unsafe.
    However, cumulative effects of such leaks may be severe enough for some programs that
    disabling asynchronous cancellation for the duration of calls to such functions may be
    required.
- cwd
    Functions marked withcwdas an MT-Safety issue may temporarily change the cur-
    rent working directory during their execution, which may cause relative pathnames
    to be resolved in unexpected ways in other threads or within asynchronous signal or
    cancellation handlers.
    This is not enough of a reason to mark so-marked functions as MT- or AS-Unsafe, but
    when this behavior is optional (e.g.,nftwwithFTW_CHDIR), avoiding the option may
    be a good alternative to using full pathnames or file descriptor-relative (e.g.openat)
    system calls.
- !posix
    This remark, as an MT-, AS- or AC-Safety note to a function, indicates the safety status
    of the function is known to differ from the specified status in the POSIX standard. For


Chapter 1: Introduction 11

```
example, POSIX does not require a function to be Safe, but our implementation is, or
vice-versa.
For the time being, the absence of this remark does not imply the safety properties we
documented are identical to those mandated by POSIX for the corresponding functions.
```
- :identifier
    Annotations may sometimes be followed by identifiers, intended to group several func-
    tions that e.g. access the data structures in an unsafe way, as inraceandconst, or to
    provide more specific information, such as naming a signal in a function marked with
    sig. It is envisioned that it may be applied tolockandcorruptas well in the future.
    In most cases, the identifier will name a set of functions, but it may name global objects
    or function arguments, or identifiable properties or logical components associated with
    them, with a notation such as e.g. :buf(arg)to denote a buffer associated with the
    argumentarg, or:tcattr(fd)to denote the terminal attributes of a file descriptorfd.
    The most common use for identifiers is to provide logical groups of functions and
    arguments that need to be protected by the same synchronization primitive in order
    to ensure safe operation in a given context.
- /condition
    Some safety annotations may be conditional, in that they only apply if a boolean
    expression involving arguments, global variables or even the underlying kernel evaluates
    to true. Such conditions as/hurdor/!linux!bsdindicate the preceding marker only
    applies when the underlying kernel is the HURD, or when it is neither Linux nor a
    BSD kernel, respectively. /!psand/one_per_line indicate the preceding marker
    only applies when argumentpsis NULL, or global variableoneperlineis nonzero.
    When all marks that render a function unsafe are adorned with such conditions, and
    none of the named conditions hold, then the function can be regarded as safe.

## 1.2.3 Berkeley Unix............................................

The GNU C Library defines facilities from some versions of Unix which are not formally
standardized, specifically from the 4.2 BSD, 4.3 BSD, and 4.4 BSD Unix systems (also
known asBerkeley Unix) and fromSunOS(a popular 4.2 BSD derivative that includes
some Unix System V functionality). These systems support most of the ISO C and POSIX
facilities, and 4.4 BSD and newer releases of SunOS in fact support them all.

The BSD facilities include symbolic links (seeSection 14.5 [Symbolic Links], page 419),
theselectfunction (seeSection 13.9 [Waiting for Input or Output], page 366), the BSD
signal functions (seeSection 24.10 [BSD Signal Handling], page 757), and sockets (see
Chapter 16 [Sockets], page 455).

## 1.2.4 SVID (The System V Interface Description)...............

TheSystem V Interface Description(SVID) is a document describing the AT&T Unix
System V operating system. It is to some extent a superset of the POSIX standard (see
Section 1.2.2 [POSIX (The Portable Operating System Interface)], page 2).

The GNU C Library defines most of the facilities required by the SVID that are not
also required by the ISO C or POSIX standards, for compatibility with System V Unix and
other Unix systems (such as SunOS) which include these facilities. However, many of the


Chapter 1: Introduction 12

more obscure and less generally useful facilities required by the SVID are not included. (In
fact, Unix System V itself does not provide them all.)

The supported facilities from System V include the methods for inter-process commu-
nication and shared memory, thehsearchanddrand48families of functions,fmtmsgand
several of the mathematical functions.

## 1.2.5 XPG (The X/Open Portability Guide)....................

The X/Open Portability Guide, published by the X/Open Company, Ltd., is a more gen-
eral standard than POSIX. X/Open owns the Unix copyright and the XPG specifies the
requirements for systems which are intended to be a Unix system.

The GNU C Library complies to the X/Open Portability Guide, Issue 4.2, with all exten-
sions common to XSI (X/Open System Interface) compliant systems and also all X/Open
UNIX extensions.

The additions on top of POSIX are mainly derived from functionality available in
System V and BSD systems. Some of the really bad mistakes in System V systems were
corrected, though. Since fulfilling the XPG standard with the Unix extensions is a precon-
dition for getting the Unix brand chances are good that the functionality is available on
commercial systems.

## 1.3 Using the Library.............................................

This section describes some of the practical issues involved in using the GNU C Library.

## 1.3.1 Header Files..............................................

Libraries for use by C programs really consist of two parts:header filesthat define types and
macros and declare variables and functions; and the actual library orarchivethat contains
the definitions of the variables and functions.

(Recall that in C, adeclarationmerely provides information that a function or variable
exists and gives its type. For a function declaration, information about the types of its
arguments might be provided as well. The purpose of declarations is to allow the compiler
to correctly process references to the declared variables and functions. Adefinition, on the
other hand, actually allocates storage for a variable or says what a function does.)

In order to use the facilities in the GNU C Library, you should be sure that your program
source files include the appropriate header files. This is so that the compiler has declarations
of these facilities available and can correctly process references to them. Once your program
has been compiled, the linker resolves these references to the actual definitions provided in
the archive file.

Header files are included into a program source file by the ¡®#include¡¯ preprocessor
directive. The C language supports two forms of this directive; the first,

```
#include "header"
```
is typically used to include a header fileheaderthat you write yourself; this would contain
definitions and declarations describing the interfaces between the different parts of your
particular application. By contrast,

```
#include <file.h>
```

Chapter 1: Introduction 13

is typically used to include a header filefile.hthat contains definitions and declarations
for a standard library. This file would normally be installed in a standard place by your
system administrator. You should use this second form for the C library header files.

Typically, ¡®#include¡¯ directives are placed at the top of the C source file, before any
other code. If you begin your source files with some comments explaining what the code in
the file does (a good idea), put the ¡®#include¡¯ directives immediately afterwards, following
the feature test macro definition (seeSection 1.3.4 [Feature Test Macros], page 15).

For more information about the use of header files and ¡®#include¡¯ directives, seeSection
¡°Header Files¡± inThe GNU C Preprocessor Manual.

The GNU C Library provides several header files, each of which contains the type and
macro definitions and variable and function declarations for a group of related facilities.
This means that your programs may need to include several header files, depending on
exactly which facilities you are using.

Some library header files include other library header files automatically. However, as a
matter of programming style, you should not rely on this; it is better to explicitly include all
the header files required for the library facilities you are using. The GNU C Library header
files have been written in such a way that it doesn¡¯t matter if a header file is accidentally
included more than once; including a header file a second time has no effect. Likewise, if
your program needs to include multiple header files, the order in which they are included
doesn¡¯t matter.

Compatibility Note:Inclusion of standard header files in any order and any number of
times works in any ISO C implementation. However, this has traditionally not been the
case in many older C implementations.

Strictly speaking, you don¡¯thave toinclude a header file to use a function it declares;
you could declare the function explicitly yourself, according to the specifications in this
manual. But it is usually better to include the header file because it may define types and
macros that are not otherwise available and because it may define more efficient macro
replacements for some functions. It is also a sure way to have the correct declaration.

## 1.3.2 Macro Definitions of Functions............................

If we describe something as a function in this manual, it may have a macro definition as
well. This normally has no effect on how your program runs¡ªthe macro definition does
the same thing as the function would. In particular, macro equivalents for library functions
evaluate arguments exactly once, in the same way that a function call would. The main
reason for these macro definitions is that sometimes they can produce an inline expansion
that is considerably faster than an actual function call.

Taking the address of a library function works even if it is also defined as a macro. This
is because, in this context, the name of the function isn¡¯t followed by the left parenthesis
that is syntactically necessary to recognize a macro call.

You might occasionally want to avoid using the macro definition of a function¡ªperhaps
to make your program easier to debug. There are two ways you can do this:

- You can avoid a macro definition in a specific use by enclosing the name of the function
    in parentheses. This works because the name of the function doesn¡¯t appear in a
    syntactic context where it is recognizable as a macro call.


Chapter 1: Introduction 14

- You can suppress any macro definition for a whole source file by using the ¡®#undef¡¯
    preprocessor directive, unless otherwise stated explicitly in the description of that fa-
    cility.
For example, suppose the header filestdlib.hdeclares a function namedabswith
extern int abs (int);

and also provides a macro definition forabs. Then, in:
#include <stdlib.h>
int f (int *i) { return abs (++*i); }

the reference toabsmight refer to either a macro or a function. On the other hand, in each
of the following examples the reference is to a function and not a macro.
#include <stdlib.h>
int g (int *i) { return (abs) (++*i); }

#undef abs
int h (int *i) { return abs (++*i); }
Since macro definitions that double for a function behave in exactly the same way as the
actual function version, there is usually no need for any of these methods. In fact, removing
macro definitions usually just makes your program slower.

## 1.3.3 Reserved Names..........................................

The names of all library types, macros, variables and functions that come from the ISO C
standard are reserved unconditionally; your programmay notredefine these names. All
other library names are reserved if your program explicitly includes the header file that
defines or declares them. There are several reasons for these restrictions:

- Other people reading your code could get very confused if you were using a function
    namedexitto do something completely different from what the standardexitfunction
    does, for example. Preventing this situation helps to make your programs easier to
    understand and contributes to modularity and maintainability.
- It avoids the possibility of a user accidentally redefining a library function that is called
    by other library functions. If redefinition were allowed, those other functions would not
    work properly.
- It allows the compiler to do whatever special optimizations it pleases on calls to these
    functions, without the possibility that they may have been redefined by the user. Some
    library facilities, such as those for dealing with variadic arguments (seeSection A.2
    [Variadic Functions], page 950) and non-local exits (seeChapter 23 [Non-Local Exits],
    page 705), actually require a considerable amount of cooperation on the part of the C
    compiler, and with respect to the implementation, it might be easier for the compiler
    to treat these as built-in parts of the language.
In addition to the names documented in this manual, reserved names include all external
identifiers (global functions and variables) that begin with an underscore (¡®_¡¯) and all iden-
tifiers regardless of use that begin with either two underscores or an underscore followed by
a capital letter are reserved names. This is so that the library and header files can define
functions, variables, and macros for internal purposes without risk of conflict with names
in user programs.

Some additional classes of identifier names are reserved for future extensions to the C
language or the POSIX.1 environment. While using these names for your own purposes


Chapter 1: Introduction 15

right now might not cause a problem, they do raise the possibility of conflict with future
versions of the C or POSIX standards, so you should avoid these names.

- Names beginning with a capital ¡®E¡¯ followed a digit or uppercase letter may be used for
    additional error code names. SeeChapter 2 [Error Reporting], page 23.
- Names that begin with either ¡®is¡¯ or ¡®to¡¯ followed by a lowercase letter may be used
    for additional character testing and conversion functions. SeeChapter 4 [Character
    Handling], page 87.
- Names that begin with ¡®LC_¡¯ followed by an uppercase letter may be used for additional
    macros specifying locale attributes. SeeChapter 7 [Locales and Internationalization],
    page 183.
- Names of all existing mathematics functions (seeChapter 19 [Mathematics], page 539)
    suffixed with ¡®f¡¯ or ¡®l¡¯ are reserved for corresponding functions that operate onfloat
    andlong doublearguments, respectively.
- Names that begin with ¡®SIG¡¯ followed by an uppercase letter are reserved for additional
    signal names. SeeSection 24.2 [Standard Signals], page 716.
- Names that begin with ¡®SIG_¡¯ followed by an uppercase letter are reserved for additional
    signal actions. SeeSection 24.3.1 [Basic Signal Handling], page 725.
- Names beginning with ¡®str¡¯, ¡®mem¡¯, or ¡®wcs¡¯ followed by a lowercase letter are reserved
    for additional string and array functions. SeeChapter 5 [String and Array Utilities],
    page 97.
- Names that end with ¡®_t¡¯ are reserved for additional type names.

In addition, some individual header files reserve names beyond those that they actually
define. You only need to worry about these restrictions if your program includes that
particular header file.

- The header filedirent.hreserves names prefixed with ¡®d_¡¯.
- The header filefcntl.hreserves names prefixed with ¡®l_¡¯, ¡®F_¡¯, ¡®O_¡¯, and ¡®S_¡¯.
- The header filegrp.hreserves names prefixed with ¡®gr_¡¯.
- The header filelimits.hreserves names suffixed with ¡®_MAX¡¯.
- The header filepwd.hreserves names prefixed with ¡®pw_¡¯.
- The header filesignal.hreserves names prefixed with ¡®sa_¡¯ and ¡®SA_¡¯.
- The header filesys/stat.hreserves names prefixed with ¡®st_¡¯ and ¡®S_¡¯.
- The header filesys/times.hreserves names prefixed with ¡®tms_¡¯.
- The header filetermios.hreserves names prefixed with ¡®c_¡¯, ¡®V¡¯, ¡®I¡¯, ¡®O¡¯, and ¡®TC¡¯; and
    names prefixed with ¡®B¡¯ followed by a digit.

## 1.3.4 Feature Test Macros......................................

The exact set of features available when you compile a source file is controlled by which
feature test macrosyou define.

If you compile your programs using ¡®gcc -ansi¡¯, you get only the ISO C library features,
unless you explicitly request additional features by defining one or more of the feature
macros. SeeSection ¡°GNU CC Command Options¡± inThe GNU CC Manual, for more
information about GCC options.


Chapter 1: Introduction 16

You should define these macros by using ¡®#define¡¯ preprocessor directives at the top of
your source code files. These directivesmustcome before any#includeof a system header
file. It is best to make them the very first thing in the file, preceded only by comments. You
could also use the ¡®-D¡¯ option to GCC, but it¡¯s better if you make the source files indicate
their own meaning in a self-contained way.

This system exists to allow the library to conform to multiple standards. Although the
different standards are often described as supersets of each other, they are usually incom-
patible because larger standards require functions with names that smaller ones reserve to
the user program. This is not mere pedantry ¡ª it has been a problem in practice. For
instance, some non-GNU programs define functions namedgetlinethat have nothing to
do with this library¡¯sgetline. They would not be compilable if all features were enabled
indiscriminately.

This should not be used to verify that a program conforms to a limited standard. It is
insufficient for this purpose, as it will not protect you from including header files outside
the standard, or relying on semantics undefined within the standard.

_POSIX_SOURCE [Macro]
If you define this macro, then the functionality from the POSIX.1 standard (IEEE
Standard 1003.1) is available, as well as all of the ISO C facilities.
The state of_POSIX_SOURCEis irrelevant if you define the macro_POSIX_C_SOURCE
to a positive integer.

_POSIX_C_SOURCE [Macro]
Define this macro to a positive integer to control which POSIX functionality is made
available. The greater the value of this macro, the more functionality is made avail-
able.
If you define this macro to a value greater than or equal to 1 , then the functionality
from the 1990 edition of the POSIX.1 standard (IEEE Standard 1003.1-1990) is made
available.
If you define this macro to a value greater than or equal to 2 , then the functionality
from the 1992 edition of the POSIX.2 standard (IEEE Standard 1003.2-1992) is made
available.
If you define this macro to a value greater than or equal to199309L, then the function-
ality from the 1993 edition of the POSIX.1b standard (IEEE Standard 1003.1b-1993)
is made available.
If you define this macro to a value greater than or equal to199506L, then the function-
ality from the 1995 edition of the POSIX.1c standard (IEEE Standard 1003.1c-1995)
is made available.
If you define this macro to a value greater than or equal to200112L, then the func-
tionality from the 2001 edition of the POSIX standard (IEEE Standard 1003.1-2001)
is made available.
If you define this macro to a value greater than or equal to200809L, then the func-
tionality from the 2008 edition of the POSIX standard (IEEE Standard 1003.1-2008)
is made available.


Chapter 1: Introduction 17

```
Greater values for_POSIX_C_SOURCEwill enable future extensions. The POSIX stan-
dards process will define these values as necessary, and the GNU C Library should sup-
port them some time after they become standardized. The 1996 edition of POSIX.1
(ISO/IEC 9945-1: 1996) states that if you define_POSIX_C_SOURCEto a value greater
than or equal to199506L, then the functionality from the 1996 edition is made avail-
able. In general, in the GNU C Library, bugfixes to the standards are included when
specifying the base version; e.g., POSIX.1-2004 will always be included with a value
of200112L.
```
_XOPEN_SOURCE [Macro]
_XOPEN_SOURCE_EXTENDED [Macro]
If you define this macro, functionality described in the X/Open Portability Guide is
included. This is a superset of the POSIX.1 and POSIX.2 functionality and in fact
_POSIX_SOURCEand_POSIX_C_SOURCEare automatically defined.
As the unification of all Unices, functionality only available in BSD and SVID is also
included.
If the macro_XOPEN_SOURCE_EXTENDEDis also defined, even more functionality is
available. The extra functions will make all functions available which are necessary
for the X/Open Unix brand.
If the macro_XOPEN_SOURCEhas the value 500 this includes all functionality described
so far plus some new definitions from the Single Unix Specification, version 2. The
value 600 (corresponding to the sixth revision) includes definitions from SUSv3, and
using 700 (the seventh revision) includes definitions from SUSv4.

_LARGEFILE_SOURCE [Macro]
If this macro is defined some extra functions are available which rectify a few short-
comings in all previous standards. Specifically, the functionsfseekoandftelloare
available. Without these functions the difference between the ISO C interface (fseek,
ftell) and the low-level POSIX interface (lseek) would lead to problems.
This macro was introduced as part of the Large File Support extension (LFS).

_LARGEFILE64_SOURCE [Macro]
If you define this macro an additional set of functions is made available which enables
32 bit systems to use files of sizes beyond the usual limit of 2GB. This interface is
not available if the system does not support files that large. On systems where the
natural file size limit is greater than 2GB (i.e., on 64 bit systems) the new functions
are identical to the replaced functions.
The new functionality is made available by a new set of types and functions which
replace the existing ones. The names of these new objects contain 64 to indicate the
intention, e.g.,off_tvs.off64_tandfseekovs.fseeko64.
This macro was introduced as part of the Large File Support extension (LFS). It is
a transition interface for the period when 64 bit offsets are not generally used (see
_FILE_OFFSET_BITS).

_FILE_OFFSET_BITS [Macro]
This macro determines which file system interface shall be used, one replacing the
other. Whereas_LARGEFILE64_SOURCEmakes the 64 bit interface available as an


Chapter 1: Introduction 18

```
additional interface,_FILE_OFFSET_BITSallows the 64 bit interface to replace the
old interface.
If_FILE_OFFSET_BITSis undefined, or if it is defined to the value 32 , nothing changes.
The 32 bit interface is used and types likeoff_thave a size of 32 bits on 32 bit
systems.
If the macro is defined to the value 64 , the large file interface replaces the old inter-
face. I.e., the functions are not made available under different names (as they are
with_LARGEFILE64_SOURCE). Instead the old function names now reference the new
functions, e.g., a call tofseekonow indeed callsfseeko64.
This macro should only be selected if the system provides mechanisms for handling
large files. On 64 bit systems this macro has no effect since the*64functions are
identical to the normal functions.
This macro was introduced as part of the Large File Support extension (LFS).
```
_ISOC99_SOURCE [Macro]
If this macro is defined, features from ISO C99 are included. Since these features are
included by default, this macro is mostly relevant when the compiler uses an earlier
language version.

_ISOC11_SOURCE [Macro]
If this macro is defined, ISO C11 extensions to ISO C99 are included.

_ISOC2X_SOURCE [Macro]
If this macro is defined, ISO C2X extensions to ISO C11 are included. Only some
features from this draft standard are supported by the GNU C Library.

__STDC_WANT_LIB_EXT2__ [Macro]
If you define this macro to the value 1 , features from ISO/IEC TR 24731-2:2010
(Dynamic Allocation Functions) are enabled. Only some of the features from this TR
are supported by the GNU C Library.

__STDC_WANT_IEC_60559_BFP_EXT__ [Macro]
If you define this macro, features from ISO/IEC TS 18661-1:2014 (Floating-point
extensions for C: Binary floating-point arithmetic) are enabled. Only some of the
features from this TS are supported by the GNU C Library.

__STDC_WANT_IEC_60559_FUNCS_EXT__ [Macro]
If you define this macro, features from ISO/IEC TS 18661-4:2015 (Floating-point
extensions for C: Supplementary functions) are enabled. Only some of the features
from this TS are supported by the GNU C Library.

__STDC_WANT_IEC_60559_TYPES_EXT__ [Macro]
If you define this macro, features from ISO/IEC TS 18661-3:2015 (Floating-point
extensions for C: Interchange and extended types) are enabled. Only some of the
features from this TS are supported by the GNU C Library.

_GNU_SOURCE [Macro]
If you define this macro, everything is included: ISO C89, ISO C99, POSIX.1,
POSIX.2, BSD, SVID, X/Open, LFS, and GNU extensions. In the cases where
POSIX.1 conflicts with BSD, the POSIX definitions take precedence.


Chapter 1: Introduction 19

_DEFAULT_SOURCE [Macro]
If you define this macro, most features are included apart from X/Open, LFS and
GNU extensions: the effect is to enable features from the 2008 edition of POSIX,
as well as certain BSD and SVID features without a separate feature test macro to
control them.
Be aware that compiler options also affect included features:

- If you use a strict conformance option, features beyond those from the compiler¡¯s
    language version will be disabled, though feature test macros may be used to
    enable them.
- Features enabled by compiler options are not overridden by feature test macros.

_ATFILE_SOURCE [Macro]
If this macro is defined, additional*atinterfaces are included.

_FORTIFY_SOURCE [Macro]
If this macro is defined to 1, security hardening is added to various library functions.
If defined to 2, even stricter checks are applied. If defined to 3, the GNU C Library
may also use checks that may have an additional performance overhead.

_REENTRANT [Macro]
_THREAD_SAFE [Macro]
These macros are obsolete. They have the same effect as defining_POSIX_C_SOURCE
with the value199506L.
Some very old C libraries required one of these macros to be defined for basic func-
tionality (e.g.getchar) to be thread-safe.

We recommend you use_GNU_SOURCEin new programs. If you don¡¯t specify the ¡®-ansi¡¯
option to GCC, or other conformance options such as-std=c99, and don¡¯t define any of
these macros explicitly, the effect is the same as defining_DEFAULT_SOURCEto 1.

When you define a feature test macro to request a larger class of features, it is harmless
to define in addition a feature test macro for a subset of those features. For example, if you
define_POSIX_C_SOURCE, then defining_POSIX_SOURCEas well has no effect. Likewise, if
you define_GNU_SOURCE, then defining either_POSIX_SOURCEor_POSIX_C_SOURCEas well
has no effect.

## 1.4 Roadmap to the Manual.......................................

Here is an overview of the contents of the remaining chapters of this manual.

- Chapter 2 [Error Reporting], page 23, describes how errors detected by the library are
    reported.
- Chapter 3 [Virtual Memory Allocation And Paging], page 42, describes the GNU C
    Library¡¯s facilities for managing and using virtual and real memory, including dynamic
    allocation of virtual memory. If you do not know in advance how much memory your
    program needs, you can allocate it dynamically instead, and manipulate it via pointers.
- Chapter 4 [Character Handling], page 87, contains information about character classi-
    fication functions (such asisspace) and functions for performing case conversion.


Chapter 1: Introduction 20

- Chapter 5 [String and Array Utilities], page 97, has descriptions of functions for ma-
    nipulating strings (null-terminated character arrays) and general byte arrays, including
    operations such as copying and comparison.
- Chapter 6 [Character Set Handling], page 140, contains information about manipulating
    characters and strings using character sets larger than will fit in the usualchardata
    type.
- Chapter 7 [Locales and Internationalization], page 183, describes how selecting a par-
    ticular country or language affects the behavior of the library. For example, the locale
    affects collation sequences for strings and how monetary values are formatted.
- Chapter 9 [Searching and Sorting], page 228, contains information about functions for
    searching and sorting arrays. You can use these functions on any kind of array by
    providing an appropriate comparison function.
- Chapter 10 [Pattern Matching], page 239, presents functions for matching regular ex-
    pressions and shell file name patterns, and for expanding words as the shell does.
- Chapter 11 [Input/Output Overview], page 261, gives an overall look at the input and
    output facilities in the library, and contains information about basic concepts such as
    file names.
- Chapter 12 [Input/Output on Streams], page 266, describes I/O operations involving
    streams (orFILE *objects). These are the normal C library functions fromstdio.h.
- Chapter 13 [Low-Level Input/Output], page 342, contains information about I/O op-
    erations on file descriptors. File descriptors are a lower-level mechanism specific to the
    Unix family of operating systems.
- Chapter 14 [File System Interface], page 402, has descriptions of operations on entire
    files, such as functions for deleting and renaming them and for creating new directories.
    This chapter also contains information about how you can access the attributes of a
    file, such as its owner and file protection modes.
- Chapter 15 [Pipes and FIFOs], page 450, contains information about simple inter-
    process communication mechanisms. Pipes allow communication between two related
    processes (such as between a parent and child), while FIFOs allow communication
    between processes sharing a common file system on the same machine.
- Chapter 16 [Sockets], page 455, describes a more complicated interprocess communi-
    cation mechanism that allows processes running on different machines to communicate
    over a network. This chapter also contains information about Internet host addressing
    and how to use the system network databases.
- Chapter 17 [Low-Level Terminal Interface], page 503, describes how you can change
    the attributes of a terminal device. If you want to disable echo of characters typed by
    the user, for example, read this chapter.
- Chapter 19 [Mathematics], page 539, contains information about the math library func-
    tions. These include things like random-number generators and remainder functions on
    integers as well as the usual trigonometric and exponential functions on floating-point
    numbers.
- Chapter 20 [Low-Level Arithmetic Functions], page 601, describes functions for simple
    arithmetic, analysis of floating-point values, and reading numbers from strings.


Chapter 1: Introduction 21

- Chapter 21 [Date and Time], page 646, describes functions for measuring both calendar
    time and CPU time, as well as functions for setting alarms and timers.
- Chapter 23 [Non-Local Exits], page 705, contains descriptions of the setjmp and
    longjmpfunctions. These functions provide a facility forgoto-like jumps which can
    jump from one function to another.
- Chapter 24 [Signal Handling], page 714, tells you all about signals¡ªwhat they are, how
    to establish a handler that is called when a particular kind of signal is delivered, and
    how to prevent signals from arriving during critical sections of your program.
- Chapter 25 [The Basic Program/System Interface], page 759, tells how your programs
    can access their command-line arguments and environment variables.
- Chapter 26 [Processes], page 803, contains information about how to start new processes
    and run programs.
- Chapter 28 [Job Control], page 817, describes functions for manipulating process groups
    and the controlling terminal. This material is probably only of interest if you are writing
    a shell or other program which handles job control specially.
- Chapter 29 [System Databases and Name Service Switch], page 835, describes the ser-
    vices which are available for looking up names in the system databases, how to deter-
    mine which service is used for which database, and how these services are implemented
    so that contributors can design their own services.
- Section 30.13 [User Database], page 864, andSection 30.14 [Group Database], page 868,
    tell you how to access the system user and group databases.
- Chapter 31 [System Management], page 875, describes functions for controlling and
    getting information about the hardware and software configuration your program is
    executing under.
- Chapter 32 [System Configuration Parameters], page 890, tells you how you can get
    information about various operating system limits. Most of these parameters are pro-
    vided for compatibility with POSIX.
- Appendix A [C Language Facilities in the Library], page 949, contains information
    about library support for standard parts of the C language, including things like the
    sizeofoperator and the symbolic constantNULL, how to write functions accepting
    variable numbers of arguments, and constants describing the ranges and other proper-
    ties of the numerical types. There is also a simple debugging mechanism which allows
    you to put assertions in your code, and have diagnostic messages printed if the tests
    fail.
- Appendix B [Summary of Library Facilities], page 965, gives a summary of all the
    functions, variables, and macros in the library, with complete data types and function
    prototypes, and says what standard or system each is derived from.
- Appendix C [Installing the GNU C Library], page 1088, explains how to build and
    install the GNU C Library on your system, and how to report any bugs you might find.
- Appendix D [Library Maintenance], page 1099, explains how to add new functions or
    port the library to a new system.
If you already know the name of the facility you are interested in, you can look it up
inAppendix B [Summary of Library Facilities], page 965. This gives you a summary of its
syntax and a pointer to where you can find a more detailed description. This appendix is


Chapter 1: Introduction 22

particularly useful if you just want to verify the order and type of arguments to a function,
for example. It also tells you what standard or system each function, variable, or macro is
derived from.


### 23

## 2 Error Reporting................................

## 2 Error Reporting......................................

Many functions in the GNU C Library detect and report error conditions, and sometimes
your programs need to check for these error conditions. For example, when you open an
input file, you should verify that the file was actually opened correctly, and print an error
message or take other appropriate action if the call to the library function failed.

This chapter describes how the error reporting facility works. Your program should
include the header fileerrno.hto use this facility.

## 2.1 Checking for Errors............................................

Most library functions return a special value to indicate that they have failed. The special
value is typically-1, a null pointer, or a constant such asEOFthat is defined for that
purpose. But this return value tells you only that an error has occurred. To find out what
kind of error it was, you need to look at the error code stored in the variableerrno. This
variable is declared in the header fileerrno.h.

volatile int errno [Variable]
The variableerrnocontains the system error number. You can change the value of
errno.
Sinceerrnois declaredvolatile, it might be changed asynchronously by a signal
handler; seeSection 24.4 [Defining Signal Handlers], page 731. However, a properly
written signal handler saves and restores the value oferrno, so you generally do not
need to worry about this possibility except when writing signal handlers.
The initial value oferrnoat program startup is zero. In many cases, when a library
function encounters an error, it will seterrnoto a non-zero value to indicate what
specific error condition occurred. The documentation for each function lists the error
conditions that are possible for that function. Not all library functions use this
mechanism; some return an error code directly, instead.
Warning:Many library functions may seterrnoto some meaningless non-zero value
even if they did not encounter any errors, and even if they return error codes directly.
Therefore, it is usually incorrect to checkwhetheran error occurred by inspecting the
value oferrno. The proper way to check for error is documented for each function.
Portability Note: ISO C specifieserrnoas a ¡°modifiable lvalue¡± rather than as a
variable, permitting it to be implemented as a macro. For example, its expansion
might involve a function call, like*__errno_location (). In fact, that is what it is
on GNU/Linux and GNU/Hurd systems. The GNU C Library, on each system, does
whatever is right for the particular system.
There are a few library functions, likesqrtandatan, that return a perfectly legiti-
mate value in case of an error, but also seterrno. For these functions, if you want
to check to see whether an error occurred, the recommended method is to seterrno
to zero before calling the function, and then check its value afterward.

All the error codes have symbolic names; they are macros defined inerrno.h. The
names start with ¡®E¡¯ and an upper-case letter or digit; you should consider names of this
form to be reserved names. SeeSection 1.3.3 [Reserved Names], page 14.


Chapter 2: Error Reporting 24

The error code values are all positive integers and are all distinct, with one exception:
EWOULDBLOCKandEAGAINare the same. Since the values are distinct, you can use them
as labels in a switchstatement; just don¡¯t use both EWOULDBLOCK andEAGAIN. Your
program should not make any other assumptions about the specific values of these symbolic
constants.

The value oferrnodoesn¡¯t necessarily have to correspond to any of these macros, since
some library functions might return other error codes of their own for other situations. The
only values that are guaranteed to be meaningful for a particular library function are the
ones that this manual lists for that function.

Except on GNU/Hurd systems, almost any system call can returnEFAULTif it is given
an invalid pointer as an argument. Since this could only happen as a result of a bug in your
program, and since it will not happen on GNU/Hurd systems, we have saved space by not
mentioningEFAULTin the descriptions of individual functions.

In some Unix systems, many system calls can also returnEFAULTif given as an argument a
pointer into the stack, and the kernel for some obscure reason fails in its attempt to extend
the stack. If this ever happens, you should probably try using statically or dynamically
allocated memory instead of stack memory on that system.

## 2.2 Error Codes...................................................

The error code macros are defined in the header fileerrno.h. All of them expand into
integer constant values. Some of these error codes can¡¯t occur on GNU systems, but they
can occur using the GNU C Library on other systems.

int EPERM [Macro]
¡°Operation not permitted.¡± Only the owner of the file (or other resource) or processes
with special privileges can perform the operation.

int ENOENT [Macro]
¡°No such file or directory.¡± This is a ¡°file doesn¡¯t exist¡± error for ordinary files that
are referenced in contexts where they are expected to already exist.

int ESRCH [Macro]
¡°No such process.¡± No process matches the specified process ID.

int EINTR [Macro]
¡°Interrupted system call.¡± An asynchronous signal occurred and prevented comple-
tion of the call. When this happens, you should try the call again.
You can choose to have functions resume after a signal that is handled, rather than
failing withEINTR; seeSection 24.5 [Primitives Interrupted by Signals], page 741.

int EIO [Macro]
¡°Input/output error.¡± Usually used for physical read or write errors.

int ENXIO [Macro]
¡°No such device or address.¡± The system tried to use the device represented by a file
you specified, and it couldn¡¯t find the device. This can mean that the device file was
installed incorrectly, or that the physical device is missing or not correctly attached
to the computer.


Chapter 2: Error Reporting 25

int E2BIG [Macro]
¡°Argument list too long.¡± Used when the arguments passed to a new program being
executed with one of theexecfunctions (seeSection 26.5 [Executing a File], page 806)
occupy too much memory space. This condition never arises on GNU/Hurd systems.

int ENOEXEC [Macro]
¡°Exec format error.¡± Invalid executable file format. This condition is detected by the
execfunctions; seeSection 26.5 [Executing a File], page 806.

int EBADF [Macro]
¡°Bad file descriptor.¡± For example, I/O on a descriptor that has been closed or
reading from a descriptor open only for writing (or vice versa).

int ECHILD [Macro]
¡°No child processes.¡± This error happens on operations that are supposed to manip-
ulate child processes, when there aren¡¯t any processes to manipulate.

int EDEADLK [Macro]
¡°Resource deadlock avoided.¡± Allocating a system resource would have resulted in
a deadlock situation. The system does not guarantee that it will notice all such
situations. This error means you got lucky and the system noticed; it might just
hang. SeeSection 13.16 [File Locks], page 393, for an example.

int ENOMEM [Macro]
¡°Cannot allocate memory.¡± The system cannot allocate more virtual memory because
its capacity is full.

int EACCES [Macro]
¡°Permission denied.¡± The file permissions do not allow the attempted operation.

int EFAULT [Macro]
¡°Bad address.¡± An invalid pointer was detected. On GNU/Hurd systems, this error
never happens; you get a signal instead.

int ENOTBLK [Macro]
¡°Block device required.¡± A file that isn¡¯t a block special file was given in a situation
that requires one. For example, trying to mount an ordinary file as a file system in
Unix gives this error.

int EBUSY [Macro]
¡°Device or resource busy.¡± A system resource that can¡¯t be shared is already in
use. For example, if you try to delete a file that is the root of a currently mounted
filesystem, you get this error.

int EEXIST [Macro]
¡°File exists.¡± An existing file was specified in a context where it only makes sense to
specify a new file.

int EXDEV [Macro]
¡°Invalid cross-device link.¡± An attempt to make an improper link across file systems
was detected. This happens not only when you uselink(seeSection 14.4 [Hard
Links], page 418) but also when you rename a file withrename (seeSection 14.7
[Renaming Files], page 423).


Chapter 2: Error Reporting 26

int ENODEV [Macro]
¡°No such device.¡± The wrong type of device was given to a function that expects a
particular sort of device.

int ENOTDIR [Macro]
¡°Not a directory.¡± A file that isn¡¯t a directory was specified when a directory is
required.

int EISDIR [Macro]
¡°Is a directory.¡± You cannot open a directory for writing, or create or remove hard
links to it.

int EINVAL [Macro]
¡°Invalid argument.¡± This is used to indicate various kinds of problems with passing
the wrong argument to a library function.

int EMFILE [Macro]
¡°Too many open files.¡± The current process has too many files open and can¡¯t open
any more. Duplicate descriptors do count toward this limit.
In BSD and GNU, the number of open files is controlled by a resource limit that
can usually be increased. If you get this error, you might want to increase the
RLIMIT_NOFILElimit or make it unlimited; seeSection 22.2 [Limiting Resource Us-
age], page 685.

int ENFILE [Macro]
¡°Too many open files in system.¡± There are too many distinct file openings in the
entire system. Note that any number of linked channels count as just one file opening;
seeSection 13.5.1 [Linked Channels], page 354. This error never occurs on GNU/Hurd
systems.

int ENOTTY [Macro]
¡°Inappropriate ioctl for device.¡± Inappropriate I/O control operation, such as trying
to set terminal modes on an ordinary file.

int ETXTBSY [Macro]
¡°Text file busy.¡± An attempt to execute a file that is currently open for writing,
or write to a file that is currently being executed. Often using a debugger to run a
program is considered having it open for writing and will cause this error. (The name
stands for ¡°text file busy¡±.) This is not an error on GNU/Hurd systems; the text is
copied as necessary.

int EFBIG [Macro]
¡°File too large.¡± The size of a file would be larger than allowed by the system.

int ENOSPC [Macro]
¡°No space left on device.¡± Write operation on a file failed because the disk is full.

int ESPIPE [Macro]
¡°Illegal seek.¡± Invalid seek operation (such as on a pipe).


Chapter 2: Error Reporting 27

int EROFS [Macro]
¡°Read-only file system.¡± An attempt was made to modify something on a read-only
file system.

int EMLINK [Macro]
¡°Too many links.¡± The link count of a single file would become too large. rename
can cause this error if the file being renamed already has as many links as it can take
(seeSection 14.7 [Renaming Files], page 423).

int EPIPE [Macro]
¡°Broken pipe.¡± There is no process reading from the other end of a pipe. Every
library function that returns this error code also generates aSIGPIPEsignal; this
signal terminates the program if not handled or blocked. Thus, your program will
never actually seeEPIPEunless it has handled or blockedSIGPIPE.

int EDOM [Macro]
¡°Numerical argument out of domain.¡± Used by mathematical functions when an
argument value does not fall into the domain over which the function is defined.

int ERANGE [Macro]
¡°Numerical result out of range.¡± Used by mathematical functions when the result
value is not representable because of overflow or underflow.

int EAGAIN [Macro]
¡°Resource temporarily unavailable.¡± The call might work if you try again later. The
macroEWOULDBLOCKis another name forEAGAIN; they are always the same in the
GNU C Library.
This error can happen in a few different situations:

- An operation that would block was attempted on an object that has non-blocking
    mode selected. Trying the same operation again will block until some exter-
    nal condition makes it possible to read, write, or connect (whatever the opera-
    tion). You can useselectto find out when the operation will be possible; see
    Section 13.9 [Waiting for Input or Output], page 366.
    Portability Note: In many older Unix systems, this condition was indicated by
    EWOULDBLOCK, which was a distinct error code different fromEAGAIN. To make
    your program portable, you should check for both codes and treat them the same.
- A temporary resource shortage made an operation impossible. forkcan return
    this error. It indicates that the shortage is expected to pass, so your program
    can try the call again later and it may succeed. It is probably a good idea to
    delay for a few seconds before trying it again, to allow time for other processes
    to release scarce resources. Such shortages are usually fairly serious and affect
    the whole system, so usually an interactive program should report the error to
    the user and return to its command loop.

int EWOULDBLOCK [Macro]
¡°Operation would block.¡± In the GNU C Library, this is another name forEAGAIN
(above). The values are always the same, on every operating system.
C libraries in many older Unix systems haveEWOULDBLOCKas a separate error code.


Chapter 2: Error Reporting 28

int EINPROGRESS [Macro]
¡°Operation now in progress.¡± An operation that cannot complete immediately was
initiated on an object that has non-blocking mode selected. Some functions that must
always block (such asconnect; seeSection 16.9.1 [Making a Connection], page 482)
never returnEAGAIN. Instead, they returnEINPROGRESSto indicate that the operation
has begun and will take some time. Attempts to manipulate the object before the
call completes returnEALREADY. You can use theselectfunction to find out when
the pending operation has completed; seeSection 13.9 [Waiting for Input or Output],
page 366.

int EALREADY [Macro]
¡°Operation already in progress.¡± An operation is already in progress on an object
that has non-blocking mode selected.

int ENOTSOCK [Macro]
¡°Socket operation on non-socket.¡± A file that isn¡¯t a socket was specified when a
socket is required.

int EMSGSIZE [Macro]
¡°Message too long.¡± The size of a message sent on a socket was larger than the
supported maximum size.

int EPROTOTYPE [Macro]
¡°Protocol wrong type for socket.¡± The socket type does not support the requested
communications protocol.

int ENOPROTOOPT [Macro]
¡°Protocol not available.¡± You specified a socket option that doesn¡¯t make sense for
the particular protocol being used by the socket. SeeSection 16.12 [Socket Options],
page 499.

int EPROTONOSUPPORT [Macro]
¡°Protocol not supported.¡± The socket domain does not support the requested com-
munications protocol (perhaps because the requested protocol is completely invalid).
SeeSection 16.8.1 [Creating a Socket], page 480.

int ESOCKTNOSUPPORT [Macro]
¡°Socket type not supported.¡± The socket type is not supported.

int EOPNOTSUPP [Macro]
¡°Operation not supported.¡± The operation you requested is not supported. Some
socket functions don¡¯t make sense for all types of sockets, and others may not be
implemented for all communications protocols. On GNU/Hurd systems, this error
can happen for many calls when the object does not support the particular operation;
it is a generic indication that the server knows nothing to do for that call.

int EPFNOSUPPORT [Macro]
¡°Protocol family not supported.¡± The socket communications protocol family you
requested is not supported.


Chapter 2: Error Reporting 29

int EAFNOSUPPORT [Macro]
¡°Address family not supported by protocol.¡± The address family specified for a socket
is not supported; it is inconsistent with the protocol being used on the socket. See
Chapter 16 [Sockets], page 455.

int EADDRINUSE [Macro]
¡°Address already in use.¡± The requested socket address is already in use. See
Section 16.3 [Socket Addresses], page 457.

int EADDRNOTAVAIL [Macro]
¡°Cannot assign requested address.¡± The requested socket address is not available; for
example, you tried to give a socket a name that doesn¡¯t match the local host name.
SeeSection 16.3 [Socket Addresses], page 457.

int ENETDOWN [Macro]
¡°Network is down.¡± A socket operation failed because the network was down.

int ENETUNREACH [Macro]
¡°Network is unreachable.¡± A socket operation failed because the subnet containing
the remote host was unreachable.

int ENETRESET [Macro]
¡°Network dropped connection on reset.¡± A network connection was reset because the
remote host crashed.

int ECONNABORTED [Macro]
¡°Software caused connection abort.¡± A network connection was aborted locally.

int ECONNRESET [Macro]
¡°Connection reset by peer.¡± A network connection was closed for reasons outside the
control of the local host, such as by the remote machine rebooting or an unrecoverable
protocol violation.

int ENOBUFS [Macro]
¡°No buffer space available.¡± The kernel¡¯s buffers for I/O operations are all in use. In
GNU, this error is always synonymous withENOMEM; you may get one or the other
from network operations.

int EISCONN [Macro]
¡°Transport endpoint is already connected.¡± You tried to connect a socket that is
already connected. SeeSection 16.9.1 [Making a Connection], page 482.

int ENOTCONN [Macro]
¡°Transport endpoint is not connected.¡± The socket is not connected to anything. You
get this error when you try to transmit data over a socket, without first specifying a
destination for the data. For a connectionless socket (for datagram protocols, such as
UDP), you getEDESTADDRREQinstead.

int EDESTADDRREQ [Macro]
¡°Destination address required.¡± No default destination address was set for the socket.
You get this error when you try to transmit data over a connectionless socket, without
first specifying a destination for the data withconnect.


Chapter 2: Error Reporting 30

int ESHUTDOWN [Macro]
¡°Cannot send after transport endpoint shutdown.¡± The socket has already been shut
down.

int ETOOMANYREFS [Macro]
¡°Too many references: cannot splice.¡±

int ETIMEDOUT [Macro]
¡°Connection timed out.¡± A socket operation with a specified timeout received no
response during the timeout period.

int ECONNREFUSED [Macro]
¡°Connection refused.¡± A remote host refused to allow the network connection (typi-
cally because it is not running the requested service).

int ELOOP [Macro]
¡°Too many levels of symbolic links.¡± Too many levels of symbolic links were encoun-
tered in looking up a file name. This often indicates a cycle of symbolic links.

int ENAMETOOLONG [Macro]
¡°File name too long.¡± Filename too long (longer thanPATH_MAX; seeSection 32.6
[Limits on File System Capacity], page 903) or host name too long (ingethostname
orsethostname; seeSection 31.1 [Host Identification], page 875).

int EHOSTDOWN [Macro]
¡°Host is down.¡± The remote host for a requested network connection is down.

int EHOSTUNREACH [Macro]
¡°No route to host.¡± The remote host for a requested network connection is not
reachable.

int ENOTEMPTY [Macro]
¡°Directory not empty.¡± Directory not empty, where an empty directory was expected.
Typically, this error occurs when you are trying to delete a directory.

int EPROCLIM [Macro]
¡°Too many processes.¡± This means that the per-user limit on new process would
be exceeded by an attemptedfork. See Section 22.2 [Limiting Resource Usage],
page 685, for details on theRLIMIT_NPROClimit.

int EUSERS [Macro]
¡°Too many users.¡± The file quota system is confused because there are too many
users.

int EDQUOT [Macro]
¡°Disk quota exceeded.¡± The user¡¯s disk quota was exceeded.

int ESTALE [Macro]
¡°Stale file handle.¡± This indicates an internal confusion in the file system which is due
to file system rearrangements on the server host for NFS file systems or corruption
in other file systems. Repairing this condition usually requires unmounting, possibly
repairing and remounting the file system.


Chapter 2: Error Reporting 31

int EREMOTE [Macro]
¡°Object is remote.¡± An attempt was made to NFS-mount a remote file system with
a file name that already specifies an NFS-mounted file. (This is an error on some
operating systems, but we expect it to work properly on GNU/Hurd systems, making
this error code impossible.)

int EBADRPC [Macro]
¡°RPC struct is bad.¡±

int ERPCMISMATCH [Macro]
¡°RPC version wrong.¡±

int EPROGUNAVAIL [Macro]
¡°RPC program not available.¡±

int EPROGMISMATCH [Macro]
¡°RPC program version wrong.¡±

int EPROCUNAVAIL [Macro]
¡°RPC bad procedure for program.¡±

int ENOLCK [Macro]
¡°No locks available.¡± This is used by the file locking facilities; seeSection 13.16 [File
Locks], page 393. This error is never generated by GNU/Hurd systems, but it can
result from an operation to an NFS server running another operating system.

int EFTYPE [Macro]
¡°Inappropriate file type or format.¡± The file was the wrong type for the operation,
or a data file had the wrong format.
On some systemschmodreturns this error if you try to set the sticky bit on a non-
directory file; seeSection 14.9.7 [Assigning File Permissions], page 436.

int EAUTH [Macro]
¡°Authentication error.¡±

int ENEEDAUTH [Macro]
¡°Need authenticator.¡±

int ENOSYS [Macro]
¡°Function not implemented.¡± This indicates that the function called is not imple-
mented at all, either in the C library itself or in the operating system. When you get
this error, you can be sure that this particular function will always fail withENOSYS
unless you install a new version of the C library or the operating system.

int ENOTSUP [Macro]
¡°Not supported.¡± A function returns this error when certain parameter values are
valid, but the functionality they request is not available. This can mean that the
function does not implement a particular command or option value or flag bit at all.
For functions that operate on some object given in a parameter, such as a file de-
scriptor or a port, it might instead mean that onlythat specific object(file descriptor,


Chapter 2: Error Reporting 32

```
port, etc.) is unable to support the other parameters given; different file descriptors
might support different ranges of parameter values.
If the entire function is not available at all in the implementation, it returnsENOSYS
instead.
```
int EILSEQ [Macro]
¡°Invalid or incomplete multibyte or wide character.¡± While decoding a multibyte
character the function came along an invalid or an incomplete sequence of bytes or
the given wide character is invalid.

int EBACKGROUND [Macro]
¡°Inappropriate operation for background process.¡± On GNU/Hurd systems, servers
supporting thetermprotocol return this error for certain operations when the caller
is not in the foreground process group of the terminal. Users do not usually see
this error because functions such asreadandwritetranslate it into aSIGTTINor
SIGTTOUsignal. SeeChapter 28 [Job Control], page 817, for information on process
groups and these signals.

int EDIED [Macro]
¡°Translator died.¡± On GNU/Hurd systems, opening a file returns this error when
the file is translated by a program and the translator program dies while starting up,
before it has connected to the file.

int ED [Macro]
¡°?.¡± The experienced user will know what is wrong.

int EGREGIOUS [Macro]
¡°You really blew it this time.¡± You didwhat?

int EIEIO [Macro]
¡°Computer bought the farm.¡± Go home and have a glass of warm, dairy-fresh milk.

int EGRATUITOUS [Macro]
¡°Gratuitous error.¡± This error code has no purpose.

int EBADMSG [Macro]
¡°Bad message.¡±

int EIDRM [Macro]
¡°Identifier removed.¡±

int EMULTIHOP [Macro]
¡°Multihop attempted.¡±

int ENODATA [Macro]
¡°No data available.¡±

int ENOLINK [Macro]
¡°Link has been severed.¡±

int ENOMSG [Macro]
¡°No message of desired type.¡±


Chapter 2: Error Reporting 33

int ENOSR [Macro]
¡°Out of streams resources.¡±

int ENOSTR [Macro]
¡°Device not a stream.¡±

int EOVERFLOW [Macro]
¡°Value too large for defined data type.¡±

int EPROTO [Macro]
¡°Protocol error.¡±

int ETIME [Macro]
¡°Timer expired.¡±

int ECANCELED [Macro]
¡°Operation canceled.¡± An asynchronous operation was canceled before it completed.
SeeSection 13.11 [Perform I/O Operations in Parallel], page 371. When you call
aio_cancel, the normal result is for the operations affected to complete with this
error; seeSection 13.11.4 [Cancellation of AIO Operations], page 381.

int EOWNERDEAD [Macro]
¡°Owner died.¡±

int ENOTRECOVERABLE [Macro]
¡°State not recoverable.¡±

The following error codes are defined by the Linux/i386 kernel. They are not yet docu-
mented.

int ERESTART [Macro]
¡°Interrupted system call should be restarted.¡±

int ECHRNG [Macro]
¡°Channel number out of range.¡±

int EL2NSYNC [Macro]
¡°Level 2 not synchronized.¡±

int EL3HLT [Macro]
¡°Level 3 halted.¡±

int EL3RST [Macro]
¡°Level 3 reset.¡±

int ELNRNG [Macro]
¡°Link number out of range.¡±

int EUNATCH [Macro]
¡°Protocol driver not attached.¡±

int ENOCSI [Macro]
¡°No CSI structure available.¡±


Chapter 2: Error Reporting 34

int EL2HLT [Macro]
¡°Level 2 halted.¡±

int EBADE [Macro]
¡°Invalid exchange.¡±

int EBADR [Macro]
¡°Invalid request descriptor.¡±

int EXFULL [Macro]
¡°Exchange full.¡±

int ENOANO [Macro]
¡°No anode.¡±

int EBADRQC [Macro]
¡°Invalid request code.¡±

int EBADSLT [Macro]
¡°Invalid slot.¡±

int EDEADLOCK [Macro]
¡°File locking deadlock error.¡±

int EBFONT [Macro]
¡°Bad font file format.¡±

int ENONET [Macro]
¡°Machine is not on the network.¡±

int ENOPKG [Macro]
¡°Package not installed.¡±

int EADV [Macro]
¡°Advertise error.¡±

int ESRMNT [Macro]
¡°Srmount error.¡±

int ECOMM [Macro]
¡°Communication error on send.¡±

int EDOTDOT [Macro]
¡°RFS specific error.¡±

int ENOTUNIQ [Macro]
¡°Name not unique on network.¡±

int EBADFD [Macro]
¡°File descriptor in bad state.¡±

int EREMCHG [Macro]
¡°Remote address changed.¡±


Chapter 2: Error Reporting 35

int ELIBACC [Macro]
¡°Can not access a needed shared library.¡±

int ELIBBAD [Macro]
¡°Accessing a corrupted shared library.¡±

int ELIBSCN [Macro]
¡°.lib section in a.out corrupted.¡±

int ELIBMAX [Macro]
¡°Attempting to link in too many shared libraries.¡±

int ELIBEXEC [Macro]
¡°Cannot exec a shared library directly.¡±

int ESTRPIPE [Macro]
¡°Streams pipe error.¡±

int EUCLEAN [Macro]
¡°Structure needs cleaning.¡±

int ENOTNAM [Macro]
¡°Not a XENIX named type file.¡±

int ENAVAIL [Macro]
¡°No XENIX semaphores available.¡±

int EISNAM [Macro]
¡°Is a named type file.¡±

int EREMOTEIO [Macro]
¡°Remote I/O error.¡±

int ENOMEDIUM [Macro]
¡°No medium found.¡±

int EMEDIUMTYPE [Macro]
¡°Wrong medium type.¡±

int ENOKEY [Macro]
¡°Required key not available.¡±

int EKEYEXPIRED [Macro]
¡°Key has expired.¡±

int EKEYREVOKED [Macro]
¡°Key has been revoked.¡±

int EKEYREJECTED [Macro]
¡°Key was rejected by service.¡±

int ERFKILL [Macro]
¡°Operation not possible due to RF-kill.¡±

int EHWPOISON [Macro]
¡°Memory page has hardware error.¡±


Chapter 2: Error Reporting 36

## 2.3 Error Messages................................................

The library has functions and variables designed to make it easy for your program to report
informative error messages in the customary format about the failure of a library call. The
functionsstrerrorandperrorgive you the standard error message for a given error code;
the variableprogram_invocation_short_namegives you convenient access to the name of
the program that encountered the error.

char * strerror (interrnum) [Function]
Preliminary:|MT-Unsafe race:strerror|AS-Unsafe heap i18n|AC-Unsafe mem|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thestrerrorfunction maps the error code (seeSection 2.1 [Checking for Errors],
page 23) specified by theerrnumargument to a descriptive error message string. The
return value is a pointer to this string.
The valueerrnumnormally comes from the variableerrno.
You should not modify the string returned bystrerror. Also, if you make subsequent
calls tostrerror, the string might be overwritten. (But it¡¯s guaranteed that no
library function ever callsstrerrorbehind your back.)
The functionstrerroris declared instring.h.

char * strerror_r(interrnum, char *buf, sizetn) [Function]
Preliminary:|MT-Safe |AS-Unsafe i18n|AC-Unsafe|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrerror_rfunction works likestrerrorbut instead of returning the error
message in a statically allocated buffer shared by all threads in the process, it returns
a private copy for the thread. This might be either some permanent global data or a
message string in the user supplied buffer starting atbuf with the length ofnbytes.
At mostncharacters are written (including the NUL byte) so it is up to the user to
select a buffer large enough.
This function should always be used in multi-threaded programs since there is no way
to guarantee the string returned bystrerrorreally belongs to the last call of the
current thread.
The functionstrerror_ris a GNU extension and it is declared instring.h.

void perror(const char *message) [Function]
Preliminary:|MT-Safe race:stderr|AS-Unsafe corrupt i18n heap lock|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function prints an error message to the streamstderr; seeSection 12.2 [Standard
Streams], page 266. The orientation ofstderris not changed.
If you callperrorwith amessage that is either a null pointer or an empty string,
perrorjust prints the error message corresponding toerrno, adding a trailing new-
line.
If you supply a non-nullmessageargument, thenperrorprefixes its output with this
string. It adds a colon and a space character to separate themessagefrom the error
string corresponding toerrno.
The functionperroris declared instdio.h.


Chapter 2: Error Reporting 37

const char * strerrorname_np(interrnum) [Function]
|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns the name describing the errorerrnumorNULLif there is no
known constant with this value (e.g"EINVAL"forEINVAL).
This function is a GNU extension, declared in the header filestring.h.

const char * strerrordesc_np(interrnum) [Function]
|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns the message describing the errorerrnumorNULLif there is no
known constant with this value (e.g"Invalid argument"forEINVAL). Different than
strerrorthe returned description is not translated.
This function is a GNU extension, declared in the header filestring.h.

strerrorandperrorproduce the exact same message for any given error code; the
precise text varies from system to system. With the GNU C Library, the messages are
fairly short; there are no multi-line messages or embedded newlines. Each error message
begins with a capital letter and does not include any terminating punctuation.

Many programs that don¡¯t read input from the terminal are designed to exit if any
system call fails. By convention, the error message from such a program should start with
the program¡¯s name, sans directories. You can find that name in the variableprogram_
invocation_short_name; the full file name is stored the variableprogram_invocation_
name.

char * program_invocation_name [Variable]
This variable¡¯s value is the name that was used to invoke the program running in
the current process. It is the same asargv[0]. Note that this is not necessarily a
useful file name; often it contains no directory names. SeeSection 25.1 [Program
Arguments], page 759.
This variable is a GNU extension and is declared inerrno.h.

char * program_invocation_short_name [Variable]
This variable¡¯s value is the name that was used to invoke the program running in
the current process, with directory names removed. (That is to say, it is the same as
program_invocation_nameminus everything up to the last slash, if any.)
This variable is a GNU extension and is declared inerrno.h.

The library initialization code sets up both of these variables before callingmain.
Portability Note:If you want your program to work with non-GNU libraries, you must
save the value ofargv[0]inmain, and then strip off the directory names yourself. We added
these extensions to make it possible to write self-contained error-reporting subroutines that
require no explicit cooperation frommain.

Here is an example showing how to handle failure to open a file correctly. The function
open_sesametries to open the named file for reading and returns a stream if successful. The
fopenlibrary function returns a null pointer if it couldn¡¯t open the file for some reason. In


Chapter 2: Error Reporting 38

that situation,open_sesameconstructs an appropriate error message using thestrerror
function, and terminates the program. If we were going to make some other library calls
before passing the error code tostrerror, we¡¯d have to save it in a local variable instead,
because those other library functions might overwriteerrnoin the meantime.
#define _GNU_SOURCE

```
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
```
```
FILE *
open_sesame (char *name)
{
FILE *stream;
```
errno = 0;
stream = fopen (name, "r");
if (stream == NULL)
{
fprintf (stderr, "%s: Couldn't open file %s; %s\n",
program_invocation_short_name, name, strerror (errno));
exit (EXIT_FAILURE);
}
else
return stream;
}
Usingperrorhas the advantage that the function is portable and available on all systems
implementing ISO C. But often the textperrorgenerates is not what is wanted and there
is no way to extend or change whatperrordoes. The GNU coding standard, for instance,
requires error messages to be preceded by the program name and programs which read some
input files should provide information about the input file name and the line number in case
an error is encountered while reading the file. For these occasions there are two functions
available which are widely used throughout the GNU project. These functions are declared
inerror.h.

void error(intstatus, interrnum, const char *format,.. .) [Function]
Preliminary: |MT-Safe locale |AS-Unsafe corrupt heap i18n |AC-Safe |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theerrorfunction can be used to report general problems during program execution.
Theformatargument is a format string just like those given to theprintffamily of
functions. The arguments required for the format can follow theformatparameter.
Just likeperror,erroralso can report an error code in textual form. But unlike
perrorthe error value is explicitly passed to the function in theerrnumparameter.
This eliminates the problem mentioned above that the error reporting function must
be called immediately after the function causing the error since otherwiseerrnomight
have a different value.
errorprints first the program name. If the application defined a global variable
error_print_prognameand points it to a function this function will be called to
print the program name. Otherwise the string from the global variableprogram_
nameis used. The program name is followed by a colon and a space which in turn


Chapter 2: Error Reporting 39

```
is followed by the output produced by the format string. If theerrnumparameter is
non-zero the format string output is followed by a colon and a space, followed by the
error message for the error codeerrnum. In any case is the output terminated with a
newline.
The output is directed to thestderrstream. If thestderrwasn¡¯t oriented before
the call it will be narrow-oriented afterwards.
The function will return unless thestatusparameter has a non-zero value. In this case
the function will callexitwith thestatusvalue for its parameter and therefore never
return. Iferrorreturns, the global variableerror_message_countis incremented
by one to keep track of the number of errors reported.
```
void error_at_line(intstatus, interrnum, const char *fname, [Function]
unsigned intlineno, const char *format,.. .)
Preliminary: |MT-Unsafe race:erroratline/erroroneperline locale|AS-Unsafe
corrupt heap i18n |AC-Unsafe corrupt/error oneperline | See Section 1.2.2.1
[POSIX Safety Concepts], page 2.
Theerror_at_line function is very similar to theerrorfunction. The only dif-
ferences are the additional parametersfnameandlineno. The handling of the other
parameters is identical to that oferrorexcept that between the program name and
the string generated by the format string additional text is inserted.
Directly following the program name a colon, followed by the file name pointed to by
fname, another colon, and the value oflinenois printed.
This additional output of course is meant to be used to locate an error in an input
file (like a programming language source code file etc).
If the global variableerror_one_per_lineis set to a non-zero valueerror_at_line
will avoid printing consecutive messages for the same file and line. Repetition which
are not directly following each other are not caught.
Just likeerrorthis function only returns ifstatusis zero. Otherwiseexitis called
with the non-zero value. Iferrorreturns, the global variableerror_message_count
is incremented by one to keep track of the number of errors reported.

As mentioned above, theerroranderror_at_linefunctions can be customized by
defining a variable namederror_print_progname.

void (*error_print_progname) (void) [Variable]
If theerror_print_prognamevariable is defined to a non-zero value the function
pointed to is called byerrororerror_at_line. It is expected to print the program
name or do something similarly useful.
The function is expected to print to thestderrstream and must be able to handle
whatever orientation the stream has.
The variable is global and shared by all threads.

unsigned int error_message_count [Variable]
Theerror_message_countvariable is incremented whenever one of the functions
errororerror_at_linereturns. The variable is global and shared by all threads.


Chapter 2: Error Reporting 40

int error_one_per_line [Variable]
Theerror_one_per_linevariable influences onlyerror_at_line. Normally the
error_at_line function creates output for every invocation. Iferror_one_per_
lineis set to a non-zero valueerror_at_linekeeps track of the last file name and
line number for which an error was reported and avoids directly following messages
for the same file and line. This variable is global and shared by all threads.

A program which read some input file and reports errors in it could look like this:
{
char *line = NULL;
size_t len = 0;
unsigned int lineno = 0;

```
error_message_count = 0;
while (! feof_unlocked (fp))
{
ssize_t n = getline (&line, &len, fp);
if (n <= 0)
/* End of file or error. */
break;
++lineno;
```
```
/*Process the line. */
...
```
```
if (Detect error in line)
error_at_line (0, errval, filename, lineno,
"some error text %s", some_variable);
}
```
if (error_message_count != 0)
error (EXIT_FAILURE, 0, "%u errors found", error_message_count);
}
erroranderror_at_lineare clearly the functions of choice and enable the programmer
to write applications which follow the GNU coding standard. The GNU C Library addi-
tionally contains functions which are used in BSD for the same purpose. These functions
are declared inerr.h. It is generally advised to not use these functions. They are included
only for compatibility.

void warn (const char *format,.. .) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe corrupt heap i18n|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewarnfunction is roughly equivalent to a call like
error (0, errno, format,the parameters)
except that the global variableserrorrespects and modifies are not used.

void vwarn(const char *format, valistap) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe corrupt heap i18n|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thevwarnfunction is just likewarnexcept that the parameters for the handling of
the format stringformatare passed in as a value of typeva_list.


Chapter 2: Error Reporting 41

void warnx(const char *format,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe corrupt lock
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewarnxfunction is roughly equivalent to a call like
error (0, 0, format,the parameters)
except that the global variableserrorrespects and modifies are not used. The dif-
ference towarnis that no error number string is printed.

void vwarnx(const char *format, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe corrupt lock
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thevwarnxfunction is just likewarnxexcept that the parameters for the handling
of the format stringformatare passed in as a value of typeva_list.

void err (intstatus, const char *format,.. .) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe corrupt heap i18n|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theerrfunction is roughly equivalent to a call like
error (status, errno, format,the parameters)
except that the global variableserrorrespects and modifies are not used and that
the program is exited even ifstatusis zero.

void verr (intstatus, const char *format, valistap) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe corrupt heap i18n|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theverrfunction is just likeerrexcept that the parameters for the handling of the
format stringformatare passed in as a value of typeva_list.

void errx (intstatus, const char *format,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe corrupt lock
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theerrxfunction is roughly equivalent to a call like
error (status, 0, format,the parameters)
except that the global variableserrorrespects and modifies are not used and that
the program is exited even ifstatusis zero. The difference toerris that no error
number string is printed.

void verrx(intstatus, const char *format, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe corrupt lock
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theverrxfunction is just likeerrxexcept that the parameters for the handling of
the format stringformatare passed in as a value of typeva_list.


### 42

## 3 Virtual Memory Allocation And Paging.....

## 3 Virtual Memory Allocation And Paging..................

This chapter describes how processes manage and use memory in a system that uses the
GNU C Library.

The GNU C Library has several functions for dynamically allocating virtual memory in
various ways. They vary in generality and in efficiency. The library also provides functions
for controlling paging and allocation of real memory.

Memory mapped I/O is not discussed in this chapter. SeeSection 13.8 [Memory-mapped
I/O], page 360.

## 3.1 Process Memory Concepts.....................................

One of the most basic resources a process has available to it is memory. There are a lot of
different ways systems organize memory, but in a typical one, each process has one linear
virtual address space, with addresses running from zero to some huge maximum. It need
not be contiguous; i.e., not all of these addresses actually can be used to store data.

The virtual memory is divided into pages (4 kilobytes is typical). Backing each page
of virtual memory is a page of real memory (called aframe) or some secondary storage,
usually disk space. The disk space might be swap space or just some ordinary disk file.
Actually, a page of all zeroes sometimes has nothing at all backing it ¨C there¡¯s just a flag
saying it is all zeroes.

The same frame of real memory or backing store can back multiple virtual pages be-
longing to multiple processes. This is normally the case, for example, with virtual memory
occupied by GNU C Library code. The same real memory frame containing theprintf
function backs a virtual memory page in each of the existing processes that has aprintf
call in its program.

In order for a program to access any part of a virtual page, the page must at that moment
be backed by (¡°connected to¡±) a real frame. But because there is usually a lot more virtual
memory than real memory, the pages must move back and forth between real memory and
backing store regularly, coming into real memory when a process needs to access them and
then retreating to backing store when not needed anymore. This movement is calledpaging.

When a program attempts to access a page which is not at that moment backed by
real memory, this is known as apage fault. When a page fault occurs, the kernel suspends
the process, places the page into a real page frame (this is called ¡°paging in¡± or ¡°faulting
in¡±), then resumes the process so that from the process¡¯ point of view, the page was in
real memory all along. In fact, to the process, all pages always seem to be in real memory.
Except for one thing: the elapsed execution time of an instruction that would normally be
a few nanoseconds is suddenly much, much, longer (because the kernel normally has to do
I/O to complete the page-in). For programs sensitive to that, the functions described in
Section 3.5 [Locking Pages], page 82,can control it.

Within each virtual address space, a process has to keep track of what is at which
addresses, and that process is called memory allocation. Allocation usually brings to mind
meting out scarce resources, but in the case of virtual memory, that¡¯s not a major goal,
because there is generally much more of it than anyone needs. Memory allocation within a
process is mainly just a matter of making sure that the same byte of memory isn¡¯t used to
store two different things.


Chapter 3: Virtual Memory Allocation And Paging 43

Processes allocate memory in two major ways: by exec and programmatically. Actually,
forking is a third way, but it¡¯s not very interesting. SeeSection 26.4 [Creating a Process],
page 805.

Exec is the operation of creating a virtual address space for a process, loading its basic
program into it, and executing the program. It is done by the ¡°exec¡± family of functions
(e.g. execl). The operation takes a program file (an executable), it allocates space to
load all the data in the executable, loads it, and transfers control to it. That data is most
notably the instructions of the program (thetext), but also literals and constants in the
program and even some variables: C variables with the static storage class (seeSection 3.2.1
[Memory Allocation in C Programs], page 44).

Once that program begins to execute, it uses programmatic allocation to gain additional
memory. In a C program with the GNU C Library, there are two kinds of programmatic
allocation: automatic and dynamic. SeeSection 3.2.1 [Memory Allocation in C Programs],
page 44.

Memory-mapped I/O is another form of dynamic virtual memory allocation. Mapping
memory to a file means declaring that the contents of certain range of a process¡¯ addresses
shall be identical to the contents of a specified regular file. The system makes the virtual
memory initially contain the contents of the file, and if you modify the memory, the system
writes the same modification to the file. Note that due to the magic of virtual memory and
page faults, there is no reason for the system to do I/O to read the file, or allocate real
memory for its contents, until the program accesses the virtual memory. SeeSection 13.8
[Memory-mapped I/O], page 360.

Just as it programmatically allocates memory, the program can programmatically deal-
locate (free) it. You can¡¯t free the memory that was allocated by exec. When the program
exits or execs, you might say that all its memory gets freed, but since in both cases the ad-
dress space ceases to exist, the point is really moot. SeeSection 25.7 [Program Termination],
page 798.

A process¡¯ virtual address space is divided into segments. A segment is a contiguous
range of virtual addresses. Three important segments are:

-
    Thetext segmentcontains a program¡¯s instructions and literals and static constants.
    It is allocated by exec and stays the same size for the life of the virtual address space.
- Thedata segment is working storage for the program. It can be preallocated and
    preloaded by exec and the process can extend or shrink it by calling functions as
    described in SeeSection 3.3 [Resizing the Data Segment], page 77. Its lower end is
    fixed.
- Thestack segmentcontains a program stack. It grows as the stack grows, but doesn¡¯t
    shrink when the stack shrinks.

## 3.2 Allocating Storage For Program Data..........................

This section covers how ordinary programs manage storage for their data, including the
famousmallocfunction and some fancier facilities special to the GNU C Library and GNU
Compiler.


Chapter 3: Virtual Memory Allocation And Paging 44

## 3.2.1 Memory Allocation in C Programs........................

The C language supports two kinds of memory allocation through the variables in C pro-
grams:

- Static allocationis what happens when you declare a static or global variable. Each
    static or global variable defines one block of space, of a fixed size. The space is allocated
    once, when your program is started (part of the exec operation), and is never freed.
- Automatic allocationhappens when you declare an automatic variable, such as a func-
    tion argument or a local variable. The space for an automatic variable is allocated
    when the compound statement containing the declaration is entered, and is freed when
    that compound statement is exited.
    In GNU C, the size of the automatic storage can be an expression that varies. In other
    C implementations, it must be a constant.

A third important kind of memory allocation,dynamic allocation, is not supported by
C variables but is available via GNU C Library functions.

## 3.2.1.1 Dynamic Memory Allocation.........................

Dynamic memory allocationis a technique in which programs determine as they are running
where to store some information. You need dynamic allocation when the amount of memory
you need, or how long you continue to need it, depends on factors that are not known before
the program runs.

For example, you may need a block to store a line read from an input file; since there is
no limit to how long a line can be, you must allocate the memory dynamically and make it
dynamically larger as you read more of the line.

Or, you may need a block for each record or each definition in the input data; since
you can¡¯t know in advance how many there will be, you must allocate a new block for each
record or definition as you read it.

When you use dynamic allocation, the allocation of a block of memory is an action that
the program requests explicitly. You call a function or macro when you want to allocate
space, and specify the size with an argument. If you want to free the space, you do so by
calling another function or macro. You can do these things whenever you want, as often as
you want.

Dynamic allocation is not supported by C variables; there is no storage class ¡°dynamic¡±,
and there can never be a C variable whose value is stored in dynamically allocated space.
The only way to get dynamically allocated memory is via a system call (which is generally
via a GNU C Library function call), and the only way to refer to dynamically allocated
space is through a pointer. Because it is less convenient, and because the actual process of
dynamic allocation requires more computation time, programmers generally use dynamic
allocation only when neither static nor automatic allocation will serve.

For example, if you want to allocate dynamically some space to hold astruct foobar,
you cannot declare a variable of typestruct foobarwhose contents are the dynamically
allocated space. But you can declare a variable of pointer typestruct foobar *and assign
it the address of the space. Then you can use the operators ¡®*¡¯ and ¡®->¡¯ on this pointer
variable to refer to the contents of the space:
{


Chapter 3: Virtual Memory Allocation And Paging 45

```
struct foobar *ptr
= (struct foobar *) malloc (sizeof (struct foobar));
ptr->name = x;
ptr->next = current_foobar;
current_foobar = ptr;
}
```
## 3.2.2 The GNU Allocator......................................

Themallocimplementation in the GNU C Library is derived from ptmalloc (pthreads
malloc), which in turn is derived from dlmalloc (Doug Lea malloc). This malloc may
allocate memory in two different ways depending on their size and certain parameters that
may be controlled by users. The most common way is to allocate portions of memory (called
chunks) from a large contiguous area of memory and manage these areas to optimize their
use and reduce wastage in the form of unusable chunks. Traditionally the system heap was
set up to be the one large memory area but the GNU C Librarymallocimplementation
maintains multiple such areas to optimize their use in multi-threaded applications. Each
such area is internally referred to as anarena.

As opposed to other versions, themallocin the GNU C Library does not round up
chunk sizes to powers of two, neither for large nor for small sizes. Neighboring chunks
can be coalesced on afreeno matter what their size is. This makes the implementation
suitable for all kinds of allocation patterns without generally incurring high memory waste
through fragmentation. The presence of multiple arenas allows multiple threads to allocate
memory simultaneously in separate arenas, thus improving performance.

The other way of memory allocation is for very large blocks, i.e. much larger than a page.
These requests are allocated withmmap(anonymous or via/dev/zero; seeSection 13.8
[Memory-mapped I/O], page 360)). This has the great advantage that these chunks are
returned to the system immediately when they are freed. Therefore, it cannot happen that
a large chunk becomes ¡°locked¡± in between smaller ones and even after callingfreewastes
memory. The size threshold formmapto be used is dynamic and gets adjusted according to
allocation patterns of the program.malloptcan be used to statically adjust the threshold
usingM_MMAP_THRESHOLDand the use ofmmapcan be disabled completely withM_MMAP_MAX;
seeSection 3.2.3.7 [Malloc Tunable Parameters], page 51.

A more detailed technical description of the GNU Allocator is maintained in the GNU
C Library wiki. Seehttps://sourceware.org/glibc/wiki/MallocInternals.

It is possible to use your own custommallocinstead of the built-in allocator provided
by the GNU C Library. SeeSection 3.2.5 [Replacingmalloc], page 62.

## 3.2.3 Unconstrained Allocation.................................

The most general dynamic allocation facility ismalloc. It allows you to allocate blocks of
memory of any size at any time, make them bigger or smaller at any time, and free the
blocks individually at any time (or never).

## 3.2.3.1 Basic Memory Allocation............................

To allocate a block of memory, callmalloc. The prototype for this function is instdlib.h.


Chapter 3: Virtual Memory Allocation And Paging 46

void * malloc(sizetsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns a pointer to a newly allocated blocksizebytes long, or a null
pointer if the block could not be allocated.

The contents of the block are undefined; you must initialize it yourself (or usecalloc
instead; seeSection 3.2.3.5 [Allocating Cleared Space], page 49). Normally you would cast
the value as a pointer to the kind of object that you want to store in the block. Here
we show an example of doing so, and of initializing the space with zeros using the library
functionmemset(seeSection 5.4 [Copying Strings and Arrays], page 101):
struct foo *ptr;

ptr = (struct foo *) malloc (sizeof (struct foo));
if (ptr == 0) abort ();
memset (ptr, 0, sizeof (struct foo));
You can store the result ofmallocinto any pointer variable without a cast, because
ISO C automatically converts the typevoid *to another type of pointer when necessary.
But the cast is necessary in contexts other than assignment operators or if you might want
your code to run in traditional C.

Remember that when allocating space for a string, the argument tomallocmust be one
plus the length of the string. This is because a string is terminated with a null character
that doesn¡¯t count in the ¡°length¡± of the string but does need space. For example:
char *ptr;

```
ptr = (char *) malloc (length + 1);
```
SeeSection 5.1 [Representation of Strings], page 97, for more information about this.

## 3.2.3.2 Examples ofmalloc.................................

If no more space is available,mallocreturns a null pointer. You should check the value of
everycall tomalloc. It is useful to write a subroutine that callsmallocand reports an
error if the value is a null pointer, returning only if the value is nonzero. This function is
conventionally calledxmalloc. Here it is:
void *
xmalloc (size_t size)
{
void *value = malloc (size);
if (value == 0)
fatal ("virtual memory exhausted");
return value;
}
Here is a real example of usingmalloc(by way ofxmalloc). The functionsavestring
will copy a sequence of characters into a newly allocated null-terminated string:
char *
savestring (const char *ptr, size_t len)
{
char *value = (char *) xmalloc (len + 1);
value[len] = '\0';
return (char *) memcpy (value, ptr, len);
}


Chapter 3: Virtual Memory Allocation And Paging 47

The block thatmallocgives you is guaranteed to be aligned so that it can hold any
type of data. On GNU systems, the address is always a multiple of eight on 32-bit systems,
and a multiple of 16 on 64-bit systems. Only rarely is any higher boundary (such as a
page boundary) necessary; for those cases, usealigned_allocorposix_memalign(see
Section 3.2.3.6 [Allocating Aligned Memory Blocks], page 49).

Note that the memory located after the end of the block is likely to be in use for something
else; perhaps a block already allocated by another call tomalloc. If you attempt to treat
the block as longer than you asked for it to be, you are liable to destroy the data that
mallocuses to keep track of its blocks, or you may destroy the contents of another block.
If you have already allocated a block and discover you want it to be bigger, userealloc
(seeSection 3.2.3.4 [Changing the Size of a Block], page 48).

## 3.2.3.3 Freeing Memory Allocated withmalloc..............

When you no longer need a block that you got withmalloc, use the functionfreeto make
the block available to be allocated again. The prototype for this function is instdlib.h.

void free (void *ptr) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefreefunction deallocates the block of memory pointed at byptr.

Freeing a block alters the contents of the block.Do not expect to find any data (such as
a pointer to the next block in a chain of blocks) in the block after freeing it.Copy whatever
you need out of the block before freeing it! Here is an example of the proper way to free all
the blocks in a chain, and the strings that they point to:
struct chain
{
struct chain *next;
char *name;
}

void
free_chain (struct chain *chain)
{
while (chain != 0)
{
struct chain *next = chain->next;
free (chain->name);
free (chain);
chain = next;
}
}
Occasionally,freecan actually return memory to the operating system and make the
process smaller. Usually, all it can do is allow a later call tomallocto reuse the space. In
the meantime, the space remains in your program as part of a free-list used internally by
malloc.

Thefreefunction preserves the value oferrno, so that cleanup code need not worry
about saving and restoring errnoaround a call tofree. Although neither ISO C nor
POSIX.1-2017 requiresfreeto preserveerrno, a future version of POSIX is planned to
require it.


Chapter 3: Virtual Memory Allocation And Paging 48

There is no point in freeing blocks at the end of a program, because all of the program¡¯s
space is given back to the system when the process terminates.

## 3.2.3.4 Changing the Size of a Block.........................

Often you do not know for certain how big a block you will ultimately need at the time you
must begin to use the block. For example, the block might be a buffer that you use to hold
a line being read from a file; no matter how long you make the buffer initially, you may
encounter a line that is longer.

You can make the block longer by callingreallocorreallocarray. These functions
are declared instdlib.h.

void * realloc(void *ptr, size tnewsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thereallocfunction changes the size of the block whose address isptrto benewsize.
Since the space after the end of the block may be in use,reallocmay find it necessary
to copy the block to a new address where more free space is available. The value of
reallocis the new address of the block. If the block needs to be moved,realloc
copies the old contents.
If you pass a null pointer forptr,reallocbehaves just like ¡®malloc (newsize)¡¯. This
can be convenient, but beware that older implementations (before ISO C) may not
support this behavior, and will probably crash whenreallocis passed a null pointer.

void * reallocarray (void *ptr, sizetnmemb, sizetsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thereallocarrayfunction changes the size of the block whose address isptrto be
long enough to contain a vector ofnmembelements, each of sizesize. It is equiva-
lent to ¡®realloc (ptr,nmemb*size)¡¯, except thatreallocarrayfails safely if the
multiplication overflows, by settingerrnotoENOMEM, returning a null pointer, and
leaving the original block unchanged.
reallocarrayshould be used instead ofreallocwhen the new size of the allocated
block is the result of a multiplication that might overflow.
Portability Note:This function is not part of any standard. It was first introduced
in OpenBSD 5.6.

Likemalloc,reallocandreallocarraymay return a null pointer if no memory space
is available to make the block bigger. When this happens, the original block is untouched;
it has not been modified or relocated.

In most cases it makes no difference what happens to the original block whenrealloc
fails, because the application program cannot continue when it is out of memory, and the
only thing to do is to give a fatal error message. Often it is convenient to write and use a
subroutine, conventionally calledxrealloc, that takes care of the error message asxmalloc
does formalloc:
void *
xrealloc (void *ptr, size_t size)


Chapter 3: Virtual Memory Allocation And Paging 49

{
void *value = realloc (ptr, size);
if (value == 0)
fatal ("Virtual memory exhausted");
return value;
}
You can also usereallocorreallocarrayto make a block smaller. The reason you
would do this is to avoid tying up a lot of memory space when only a little is needed. In
several allocation implementations, making a block smaller sometimes necessitates copying
it, so it can fail if no other space is available.

If the new size you specify is the same as the old size,reallocandreallocarrayare
guaranteed to change nothing and return the same address that you gave.

## 3.2.3.5 Allocating Cleared Space.............................

The functioncallocallocates memory and clears it to zero. It is declared instdlib.h.

void * calloc(sizetcount, sizeteltsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function allocates a block long enough to contain a vector ofcountelements,
each of sizeeltsize. Its contents are cleared to zero beforecallocreturns.

You could definecallocas follows:
void *
calloc (size_t count, size_t eltsize)
{
size_t size = count * eltsize;
void *value = malloc (size);
if (value != 0)
memset (value, 0, size);
return value;
}
But in general, it is not guaranteed thatcalloccallsmallocinternally. Therefore, if an
application provides its ownmalloc/realloc/freeoutside the C library, it should always
definecalloc, too.

## 3.2.3.6 Allocating Aligned Memory Blocks...................

The address of a block returned bymallocorreallocin GNU systems is always a multiple
of eight (or sixteen on 64-bit systems). If you need a block whose address is a multiple of
a higher power of two than that, usealigned_allocorposix_memalign.aligned_alloc
andposix_memalignare declared instdlib.h.

void * aligned_alloc(sizetalignment, size tsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thealigned_allocfunction allocates a block ofsizebytes whose address is a multiple
ofalignment. Thealignmentmust be a power of two andsizemust be a multiple of
alignment.


Chapter 3: Virtual Memory Allocation And Paging 50

```
Thealigned_allocfunction returns a null pointer on error and setserrnoto one of
the following values:
ENOMEM There was insufficient memory available to satisfy the request.
EINVAL alignmentis not a power of two.
This function was introduced in ISO C11 and hence may have better
portability to modern non-POSIX systems thanposix_memalign.
```
void * memalign (sizetboundary, sizetsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thememalignfunction allocates a block ofsizebytes whose address is a multiple of
boundary. Theboundarymust be a power of two! The functionmemalignworks by
allocating a somewhat larger block, and then returning an address within the block
that is on the specified boundary.
Thememalignfunction returns a null pointer on error and setserrnoto one of the
following values:
ENOMEM There was insufficient memory available to satisfy the request.
EINVAL boundaryis not a power of two.
Thememalignfunction is obsolete andaligned_allocorposix_memalignshould
be used instead.

int posix_memalign(void **memptr, sizetalignment, sizetsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock fd mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theposix_memalignfunction is similar to thememalignfunction in that it returns
a buffer ofsizebytes aligned to a multiple ofalignment. But it adds one requirement
to the parameteralignment: the value must be a power of two multiple ofsizeof
(void *).
If the function succeeds in allocation memory a pointer to the allocated memory is
returned in*memptrand the return value is zero. Otherwise the function returns an
error value indicating the problem. The possible error values returned are:
ENOMEM There was insufficient memory available to satisfy the request.
EINVAL alignmentis not a power of two multiple ofsizeof (void *).
This function was introduced in POSIX 1003.1d. Although this function is superseded
byaligned_alloc, it is more portable to older POSIX systems that do not support
ISO C11.

void * valloc(sizetsize) [Function]
Preliminary:|MT-Unsafe init|AS-Unsafe init lock|AC-Unsafe init lock fd mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Usingvallocis like usingmemalignand passing the page size as the value of the first
argument. It is implemented like this:
void *


Chapter 3: Virtual Memory Allocation And Paging 51

```
valloc (size_t size)
{
return memalign (getpagesize (), size);
}
Section 22.4.2 [How to get information about the memory subsystem?], page 702,for
more information about the memory subsystem.
Thevallocfunction is obsolete andaligned_allocorposix_memalignshould be
used instead.
```
## 3.2.3.7 Malloc Tunable Parameters..........................

You can adjust some parameters for dynamic memory allocation with themalloptfunction.
This function is the general SVID/XPG interface, defined inmalloc.h.

int mallopt(intparam, intvalue) [Function]
Preliminary:|MT-Unsafe init const:mallopt|AS-Unsafe init lock|AC-Unsafe init
lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
When callingmallopt, theparamargument specifies the parameter to be set, and
valuethe new value to be set. Possible choices forparam, as defined inmalloc.h,
are:

```
M_MMAP_MAX
The maximum number of chunks to allocate withmmap. Setting this to
zero disables all use ofmmap.
The default value of this parameter is 65536.
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_MMAP_MAX_to the desired value.
```
```
M_MMAP_THRESHOLD
All chunks larger than this value are allocated outside the normal heap,
using themmapsystem call. This way it is guaranteed that the memory for
these chunks can be returned to the system onfree. Note that requests
smaller than this threshold might still be allocated viammap.
If this parameter is not set, the default value is set as 128 KiB and the
threshold is adjusted dynamically to suit the allocation patterns of the
program. If the parameter is set, the dynamic adjustment is disabled and
the value is set statically to the input value.
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_MMAP_THRESHOLD_to the desired value.
M_PERTURB
If non-zero, memory blocks are filled with values depending on some low
order bits of this parameter when they are allocated (except when al-
located bycalloc) and freed. This can be used to debug the use of
uninitialized or freed heap memory. Note that this option does not guar-
antee that the freed block will have any specific values. It only guarantees
that the content the block had before it was freed will be overwritten.
The default value of this parameter is 0.
```

Chapter 3: Virtual Memory Allocation And Paging 52

```
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_PERTURB_to the desired value.
M_TOP_PAD
This parameter determines the amount of extra memory to obtain from
the system when an arena needs to be extended. It also specifies the
number of bytes to retain when shrinking an arena. This provides the
necessary hysteresis in heap size such that excessive amounts of system
calls can be avoided.
The default value of this parameter is 0.
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_TOP_PAD_to the desired value.
M_TRIM_THRESHOLD
This is the minimum size (in bytes) of the top-most, releasable chunk
that will trigger a system call in order to return memory to the system.
If this parameter is not set, the default value is set as 128 KiB and the
threshold is adjusted dynamically to suit the allocation patterns of the
program. If the parameter is set, the dynamic adjustment is disabled and
the value is set statically to the provided input.
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_TRIM_THRESHOLD_to the desired value.
M_ARENA_TEST
This parameter specifies the number of arenas that can be created before
the test on the limit to the number of arenas is conducted. The value is
ignored ifM_ARENA_MAXis set.
The default value of this parameter is 2 on 32-bit systems and 8 on 64-bit
systems.
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_ARENA_TESTto the desired value.
M_ARENA_MAX
This parameter sets the number of arenas to use regardless of the number
of cores in the system.
The default value of this tunable is 0 , meaning that the limit on the
number of arenas is determined by the number of CPU cores online. For
32-bit systems the limit is twice the number of cores online and on 64-
bit systems, it is eight times the number of cores online. Note that the
default value is not derived from the default value of MARENATEST
and is computed independently.
This parameter can also be set for the process at startup by setting the
environment variableMALLOC_ARENA_MAXto the desired value.
```
## 3.2.3.8 Heap Consistency Checking..........................

You can askmalloc to check the consistency of dynamic memory by using themcheck
function. This function is a GNU extension, declared inmcheck.h.


Chapter 3: Virtual Memory Allocation And Paging 53

int mcheck(void(*abortfn)(enum mcheck statusstatus)) [Function]
Preliminary: |MT-Unsafe race:mcheck const:mallochooks|AS-Unsafe corrupt|
AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Callingmchecktells mallocto perform occasional consistency checks. These will
catch things such as writing past the end of a block that was allocated withmalloc.
Theabortfnargument is the function to call when an inconsistency is found. If you
supply a null pointer, thenmcheckuses a default function which prints a message
and callsabort(seeSection 25.7.4 [Aborting a Program], page 801). The function
you supply is called with one argument, which says what sort of inconsistency was
detected; its type is described below.
It is too late to begin allocation checking once you have allocated anything with
malloc. Somcheckdoes nothing in that case. The function returns-1if you call it
too late, and 0 otherwise (when it is successful).
The easiest way to arrange to callmcheckearly enough is to use the option ¡®-lmcheck¡¯
when you link your program; then you don¡¯t need to modify your program source at
all. Alternatively you might use a debugger to insert a call tomcheckwhenever the
program is started, for example these gdb commands will automatically callmcheck
whenever the program starts:
(gdb) break main
Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10
(gdb) command 1
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
>call mcheck(0)
>continue
>end
(gdb) ...
This will however only work if no initialization function of any object involved calls
any of themallocfunctions sincemcheckmust be called before the first such function.

enum mcheck_status mprobe(void *pointer) [Function]
Preliminary: |MT-Unsafe race:mcheck const:mallochooks|AS-Unsafe corrupt|
AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Themprobefunction lets you explicitly check for inconsistencies in a particular allo-
cated block. You must have already calledmcheckat the beginning of the program,
to do its occasional checks; callingmproberequests an additional consistency check
to be done at the time of the call.
The argumentpointermust be a pointer returned bymallocorrealloc. mprobe
returns a value that says what inconsistency, if any, was found. The values are
described below.

enum mcheck_status [Data Type]
This enumerated type describes what kind of inconsistency was detected in an allo-
cated block, if any. Here are the possible values:
MCHECK_DISABLED
mcheckwas not called before the first allocation. No consistency checking
can be done.


Chapter 3: Virtual Memory Allocation And Paging 54

### MCHECK_OK

```
No inconsistency detected.
MCHECK_HEAD
The data immediately before the block was modified. This commonly
happens when an array index or pointer is decremented too far.
MCHECK_TAIL
The data immediately after the block was modified. This commonly
happens when an array index or pointer is incremented too far.
```
```
MCHECK_FREE
The block was already freed.
```
Another possibility to check for and guard against bugs in the use ofmalloc,realloc
andfreeis to set the environment variableMALLOC_CHECK_. WhenMALLOC_CHECK_is set
to a non-zero value, a special (less efficient) implementation is used which is designed to
be tolerant against simple errors, such as double calls offreewith the same argument, or
overruns of a single byte (off-by-one bugs). Not all such errors can be protected against,
however, and memory leaks can result.

Any detected heap corruption results in immediate termination of the process.
There is one problem withMALLOC_CHECK_: in SUID or SGID binaries it could possibly
be exploited since diverging from the normal programs behavior it now writes something to
the standard error descriptor. Therefore the use ofMALLOC_CHECK_is disabled by default for
SUID and SGID binaries. It can be enabled again by the system administrator by adding
a file/etc/suid-debug(the content is not important it could be empty).

So, what¡¯s the difference between usingMALLOC_CHECK_and linking with ¡®-lmcheck¡¯?
MALLOC_CHECK_is orthogonal with respect to ¡®-lmcheck¡¯. ¡®-lmcheck¡¯ has been added for
backward compatibility. BothMALLOC_CHECK_ and ¡®-lmcheck¡¯ should uncover the same
bugs - but usingMALLOC_CHECK_you don¡¯t need to recompile your application.

## 3.2.3.9 Memory Allocation Hooks...........................

The GNU C Library lets you modify the behavior ofmalloc,realloc, andfreeby spec-
ifying appropriate hook functions. You can use these hooks to help you debug programs
that use dynamic memory allocation, for example.

```
The hook variables are declared inmalloc.h.
```
__malloc_hook [Variable]
The value of this variable is a pointer to the function thatmallocuses whenever it
is called. You should define this function to look likemalloc; that is, like:
void *function(size_tsize, const void *caller)
The value ofcalleris the return address found on the stack when themallocfunction
was called. This value allows you to trace the memory consumption of the program.

__realloc_hook [Variable]
The value of this variable is a pointer to function thatreallocuses whenever it is
called. You should define this function to look likerealloc; that is, like:
void *function(void *ptr, size_tsize, const void *caller)


Chapter 3: Virtual Memory Allocation And Paging 55

```
The value ofcalleris the return address found on the stack when thereallocfunction
was called. This value allows you to trace the memory consumption of the program.
```
__free_hook [Variable]
The value of this variable is a pointer to function thatfreeuses whenever it is called.
You should define this function to look likefree; that is, like:
voidfunction(void *ptr, const void *caller)
The value ofcalleris the return address found on the stack when thefreefunction
was called. This value allows you to trace the memory consumption of the program.

__memalign_hook [Variable]
The value of this variable is a pointer to function thataligned_alloc,memalign,
posix_memalignandvallocuse whenever they are called. You should define this
function to look likealigned_alloc; that is, like:
void *function(size_talignment, size_tsize, const void *caller)
The value ofcalleris the return address found on the stack when thealigned_alloc,
memalign,posix_memalignorvallocfunctions are called. This value allows you to
trace the memory consumption of the program.

You must make sure that the function you install as a hook for one of these functions
does not call that function recursively without restoring the old value of the hook first!
Otherwise, your program will get stuck in an infinite recursion. Before calling the function
recursively, one should make sure to restore all the hooks to their previous value. When
coming back from the recursive call, all the hooks should be resaved since a hook might
modify itself.

An issue to look out for is the time at which the malloc hook functions can be safely
installed. If the hook functions call the malloc-related functions recursively, it is necessary
that malloc has already properly initialized itself at the time when__malloc_hooketc. is
assigned to. On the other hand, if the hook functions provide a complete malloc implemen-
tation of their own, it is vital that the hooks are assigned tobeforethe very firstmalloccall
has completed, because otherwise a chunk obtained from the ordinary, un-hooked malloc
may later be handed to__free_hook, for example.

Here is an example showing how to use__malloc_hookand__free_hookproperly. It
installs a function that prints out information every timemallocorfreeis called. We just
assume here thatreallocandmemalignare not used in our program.
/* Prototypes for __malloc_hook, __free_hook */
#include <malloc.h>

```
/* Prototypes for our hooks. */
static void my_init_hook (void);
static void *my_malloc_hook (size_t, const void *);
static void my_free_hook (void*, const void *);
```
```
static void
my_init (void)
{
old_malloc_hook = __malloc_hook;
old_free_hook = __free_hook;
__malloc_hook = my_malloc_hook;
__free_hook = my_free_hook;
```

Chapter 3: Virtual Memory Allocation And Paging 56

```
}
```
```
static void *
my_malloc_hook (size_t size, const void *caller)
{
void *result;
/* Restore all old hooks */
__malloc_hook = old_malloc_hook;
__free_hook = old_free_hook;
/* Call recursively */
result = malloc (size);
/* Save underlying hooks */
old_malloc_hook = __malloc_hook;
old_free_hook = __free_hook;
/* printfmight callmalloc, so protect it too.*/
printf ("malloc (%u) returns %p\n", (unsigned int) size, result);
/* Restore our own hooks */
__malloc_hook = my_malloc_hook;
__free_hook = my_free_hook;
return result;
}
```
```
static void
my_free_hook (void *ptr, const void *caller)
{
/* Restore all old hooks */
__malloc_hook = old_malloc_hook;
__free_hook = old_free_hook;
/* Call recursively */
free (ptr);
/* Save underlying hooks */
old_malloc_hook = __malloc_hook;
old_free_hook = __free_hook;
/* printfmight callfree, so protect it too.*/
printf ("freed pointer %p\n", ptr);
/* Restore our own hooks */
__malloc_hook = my_malloc_hook;
__free_hook = my_free_hook;
}
```
```
main ()
{
my_init ();
```
}
Themcheckfunction (seeSection 3.2.3.8 [Heap Consistency Checking], page 52) works
by installing such hooks.

## 3.2.3.10 Statistics for Memory Allocation withmalloc.......

You can get information about dynamic memory allocation by calling themallinfo2func-
tion. This function and its associated data type are declared inmalloc.h; they are an
extension of the standard SVID/XPG version.

struct mallinfo2 [Data Type]
This structure type is used to return information about the dynamic memory alloca-
tor. It contains the following members:


Chapter 3: Virtual Memory Allocation And Paging 57

```
size_t arena
This is the total size of memory allocated withsbrkbymalloc, in bytes.
```
```
size_t ordblks
This is the number of chunks not in use. (The memory allocator
sizeternally gets chunks of memory from the operating system, and then
carves them up to satisfy individualmallocrequests; seeSection 3.2.2
[The GNU Allocator], page 45.)
size_t smblks
This field is unused.
```
```
size_t hblks
This is the total number of chunks allocated withmmap.
```
```
size_t hblkhd
This is the total size of memory allocated withmmap, in bytes.
```
```
size_t usmblks
This field is unused and always 0.
```
```
size_t fsmblks
This field is unused.
```
```
size_t uordblks
This is the total size of memory occupied by chunks handed out by
malloc.
```
```
size_t fordblks
This is the total size of memory occupied by free (not in use) chunks.
```
```
size_t keepcost
This is the size of the top-most releasable chunk that normally borders
the end of the heap (i.e., the high end of the virtual address space¡¯s data
segment).
```
struct mallinfo2 mallinfo2 (void) [Function]
Preliminary:|MT-Unsafe init const:mallopt|AS-Unsafe init lock|AC-Unsafe init
lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns information about the current dynamic memory usage in a
structure of typestruct mallinfo2.

## 3.2.3.11 Summary ofmalloc-Related Functions..............

Here is a summary of the functions that work withmalloc:

void *malloc (size_tsize)
Allocate a block ofsizebytes. SeeSection 3.2.3.1 [Basic Memory Allocation],
page 45.

void free (void *addr)
Free a block previously allocated bymalloc. SeeSection 3.2.3.3 [Freeing Mem-
ory Allocated withmalloc], page 47.


Chapter 3: Virtual Memory Allocation And Paging 58

void *realloc (void *addr, size_tsize)
Make a block previously allocated bymalloclarger or smaller, possibly by
copying it to a new location. SeeSection 3.2.3.4 [Changing the Size of a Block],
page 48.

void *reallocarray (void *ptr, size_tnmemb, size_tsize)
Change the size of a block previously allocated bymalloctonmemb*sizebytes
as withrealloc. SeeSection 3.2.3.4 [Changing the Size of a Block], page 48.

void *calloc (size_tcount, size_teltsize)
Allocate a block ofcount*eltsizebytes usingmalloc, and set its contents to
zero. SeeSection 3.2.3.5 [Allocating Cleared Space], page 49.

void *valloc (size_tsize)
Allocate a block ofsizebytes, starting on a page boundary. SeeSection 3.2.3.6
[Allocating Aligned Memory Blocks], page 49.

void *aligned_alloc (size_tsize, size_talignment)
Allocate a block ofsize bytes, starting on an address that is a multiple of
alignment. SeeSection 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

int posix_memalign (void **memptr, size_talignment, size_tsize)
Allocate a block ofsize bytes, starting on an address that is a multiple of
alignment. SeeSection 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

void *memalign (size_tsize, size_tboundary)
Allocate a block ofsize bytes, starting on an address that is a multiple of
boundary. SeeSection 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

int mallopt (intparam, intvalue)
Adjust a tunable parameter. SeeSection 3.2.3.7 [Malloc Tunable Parameters],
page 51.

int mcheck (void (*abortfn) (void))
Tellmallocto perform occasional consistency checks on dynamically allocated
memory, and to callabortfnwhen an inconsistency is found. SeeSection 3.2.3.8
[Heap Consistency Checking], page 52.

void *(*__malloc_hook) (size_tsize, const void *caller)
A pointer to a function thatmallocuses whenever it is called.

void *(*__realloc_hook) (void *ptr, size_tsize, const void *caller)
A pointer to a function thatreallocuses whenever it is called.

void (*__free_hook) (void *ptr, const void *caller)
A pointer to a function thatfreeuses whenever it is called.

void (*__memalign_hook) (size_tsize, size_talignment, const void *caller)
A pointer to a function thataligned_alloc,memalign,posix_memalignand
vallocuse whenever they are called.

struct mallinfo2 mallinfo2 (void)
Return information about the current dynamic memory usage. See
Section 3.2.3.10 [Statistics for Memory Allocation withmalloc], page 56.


Chapter 3: Virtual Memory Allocation And Paging 59

3.2.4 Allocation Debugging

A complicated task when programming with languages which do not use garbage collected
dynamic memory allocation is to find memory leaks. Long running programs must ensure
that dynamically allocated objects are freed at the end of their lifetime. If this does not
happen the system runs out of memory, sooner or later.

Themallocimplementation in the GNU C Library provides some simple means to detect
such leaks and obtain some information to find the location. To do this the application must
be started in a special mode which is enabled by an environment variable. There are no
speed penalties for the program if the debugging mode is not enabled.

## 3.2.4.1 How to install the tracing functionality...............

void mtrace(void) [Function]
Preliminary:|MT-Unsafe env race:mtrace const:mallochooks init|AS-Unsafe init
heap corrupt lock|AC-Unsafe init corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
When themtrace function is called it looks for an environment variable named
MALLOC_TRACE. This variable is supposed to contain a valid file name. The user
must have write access. If the file already exists it is truncated. If the environment
variable is not set or it does not name a valid file which can be opened for writing
nothing is done. The behavior ofmallocetc. is not changed. For obvious reasons
this also happens if the application is installed with the SUID or SGID bit set.
If the named file is successfully opened,mtraceinstalls special handlers for the func-
tionsmalloc,realloc, andfree(seeSection 3.2.3.9 [Memory Allocation Hooks],
page 54). From then on, all uses of these functions are traced and protocolled into
the file. There is now of course a speed penalty for all calls to the traced functions so
tracing should not be enabled during normal use.
This function is a GNU extension and generally not available on other systems. The
prototype can be found inmcheck.h.

void muntrace(void) [Function]
Preliminary: |MT-Unsafe race:mtrace const:mallochooks locale|AS-Unsafe cor-
rupt heap|AC-Unsafe corrupt mem lock fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themuntracefunction can be called aftermtracewas used to enable tracing the
malloccalls. If no (successful) call ofmtracewas mademuntracedoes nothing.
Otherwise it deinstalls the handlers formalloc,realloc, andfreeand then closes
the protocol file. No calls are protocolled anymore and the program runs again at full
speed.
This function is a GNU extension and generally not available on other systems. The
prototype can be found inmcheck.h.

## 3.2.4.2 Example program excerpts...........................

Even though the tracing functionality does not influence the runtime behavior of the pro-
gram it is not a good idea to callmtracein all programs. Just imagine that you debug
a program usingmtraceand all other programs used in the debugging session also trace


Chapter 3: Virtual Memory Allocation And Paging 60

theirmalloccalls. The output file would be the same for all programs and thus is unusable.
Therefore one should callmtraceonly if compiled for debugging. A program could therefore
start like this:

```
#include <mcheck.h>
```
```
int
main (int argc, char *argv[])
{
#ifdef DEBUGGING
mtrace ();
#endif
```
}
This is all that is needed if you want to trace the calls during the whole runtime of the
program. Alternatively you can stop the tracing at any time with a call tomuntrace. It
is even possible to restart the tracing again with a new call tomtrace. But this can cause
unreliable results since there may be calls of the functions which are not called. Please
note that not only the application uses the traced functions, also libraries (including the C
library itself) use these functions.

This last point is also why it is not a good idea to callmuntracebefore the program
terminates. The libraries are informed about the termination of the program only after the
program returns frommainor callsexitand so cannot free the memory they use before
this time.

So the best thing one can do is to callmtraceas the very first function in the program
and never callmuntrace. So the program traces almost all uses of themallocfunctions
(except those calls which are executed by constructors of the program or used libraries).

## 3.2.4.3 Some more or less clever ideas.......................

You know the situation. The program is prepared for debugging and in all debugging
sessions it runs well. But once it is started without debugging the error shows up. A typical
example is a memory leak that becomes visible only when we turn off the debugging. If you
foresee such situations you can still win. Simply use something equivalent to the following
little program:

```
#include <mcheck.h>
#include <signal.h>
```
```
static void
enable (int sig)
{
mtrace ();
signal (SIGUSR1, enable);
}
```
```
static void
disable (int sig)
{
```

Chapter 3: Virtual Memory Allocation And Paging 61

```
muntrace ();
signal (SIGUSR2, disable);
}
```
```
int
main (int argc, char *argv[])
{
```
```
signal (SIGUSR1, enable);
signal (SIGUSR2, disable);
```
### }

I.e., the user can start the memory debugger any time s/he wants if the program was
started withMALLOC_TRACEset in the environment. The output will of course not show the
allocations which happened before the first signal but if there is a memory leak this will
show up nevertheless.

## 3.2.4.4 Interpreting the traces...............................

If you take a look at the output it will look similar to this:

= Start
[0x8048209] - 0x8064cc8
[0x8048209] - 0x8064ce0
[0x8048209] - 0x8064cf8
[0x80481eb] + 0x8064c48 0x14
[0x80481eb] + 0x8064c60 0x14
[0x80481eb] + 0x8064c78 0x14
[0x80481eb] + 0x8064c90 0x14
= End
What this all means is not really important since the trace file is not meant to be read
by a human. Therefore no attention is given to readability. Instead there is a program
which comes with the GNU C Library which interprets the traces and outputs a summary
in an user-friendly way. The program is calledmtrace(it is in fact a Perl script) and it
takes one or two arguments. In any case the name of the file with the trace output must
be specified. If an optional argument precedes the name of the trace file this must be the
name of the program which generated the trace.

drepper$ mtrace tst-mtrace log
No memory leaks.
In this case the programtst-mtracewas run and it produced a trace filelog. The
message printed bymtraceshows there are no problems with the code, all allocated memory
was freed afterwards.

```
If we callmtraceon the example trace given above we would get a different outout:
drepper$ mtrace errlog
```
- 0x08064cc8 Free 2 was never alloc'd 0x8048209


Chapter 3: Virtual Memory Allocation And Paging 62

- 0x08064ce0 Free 3 was never alloc'd 0x8048209
- 0x08064cf8 Free 4 was never alloc'd 0x8048209

Memory not freed:
-----------------
Address Size Caller
0x08064c48 0x14 at 0x80481eb
0x08064c60 0x14 at 0x80481eb
0x08064c78 0x14 at 0x80481eb
0x08064c90 0x14 at 0x80481eb
We have calledmtracewith only one argument and so the script has no chance to find
out what is meant with the addresses given in the trace. We can do better:

```
drepper$ mtrace tst errlog
```
- 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39
- 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39
- 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39

Memory not freed:
-----------------
Address Size Caller
0x08064c48 0x14 at /home/drepper/tst.c:33
0x08064c60 0x14 at /home/drepper/tst.c:33
0x08064c78 0x14 at /home/drepper/tst.c:33
0x08064c90 0x14 at /home/drepper/tst.c:33
Suddenly the output makes much more sense and the user can see immediately where
the function calls causing the trouble can be found.

Interpreting this output is not complicated. There are at most two different situations
being detected. First,freewas called for pointers which were never returned by one of the
allocation functions. This is usually a very bad problem and what this looks like is shown
in the first three lines of the output. Situations like this are quite rare and if they appear
they show up very drastically: the program normally crashes.

The other situation which is much harder to detect are memory leaks. As you can see in
the output themtracefunction collects all this information and so can say that the program
calls an allocation function from line 33 in the source file/home/drepper/tst-mtrace.c
four times without freeing this memory before the program terminates. Whether this is a
real problem remains to be investigated.

## 3.2.5 Replacingmalloc.........................................

The GNU C Library supports replacing the built-inmallocimplementation with a different
allocator with the same interface. For dynamically linked programs, this happens through
ELF symbol interposition, either using shared object dependencies orLD_PRELOAD. For
static linking, themalloc replacement library must be linked in before linking against
libc.a(explicitly or implicitly).

Note:Failure to provide a complete set of replacement functions (that is, all the functions
used by the application, the GNU C Library, and other linked-in libraries) can lead to static


Chapter 3: Virtual Memory Allocation And Paging 63

linking failures, and, at run time, to heap corruption and application crashes. Replacement
functions should implement the behavior documented for their counterparts in the GNU C
Library; for example, the replacementfreeshould also preserveerrno.

The minimum set of functions which has to be provided by a custommallocis given in
the table below.

malloc

free

calloc

realloc

Thesemalloc-related functions are required for the GNU C Library to work.^1
Themallocimplementation in the GNU C Library provides additional functionality not
used by the library itself, but which is often used by other system libraries and applications.
A general-purpose replacementmallocimplementation should provide definitions of these
functions, too. Their names are listed in the following table.

aligned_alloc
malloc_usable_size
memalign

posix_memalign
pvalloc

valloc

In addition, very old applications may use the obsoletecfreefunction.
Furthermalloc-related functions such asmalloptormallinfo2will not have any effect
or return incorrect statistics when a replacementmallocis in use. However, failure to
replace these functions typically does not result in crashes or other incorrect application
behavior, but may result in static linking failures.

## 3.2.6 Obstacks.................................................

Anobstackis a pool of memory containing a stack of objects. You can create any number of
separate obstacks, and then allocate objects in specified obstacks. Within each obstack, the
last object allocated must always be the first one freed, but distinct obstacks are independent
of each other.

Aside from this one constraint of order of freeing, obstacks are totally general: an obstack
can contain any number of objects of any size. They are implemented with macros, so
allocation is usually very fast as long as the objects are usually small. And the only space
overhead per object is the padding needed to start each object on a suitable boundary.

(^1) Versions of the GNU C Library before 2.25 required that a custommallocdefines__libc_memalign
(with the same interface as thememalignfunction).


Chapter 3: Virtual Memory Allocation And Paging 64

## 3.2.6.1 Creating Obstacks...................................

The utilities for manipulating obstacks are declared in the header fileobstack.h.

struct obstack [Data Type]
An obstack is represented by a data structure of typestruct obstack. This structure
has a small fixed size; it records the status of the obstack and how to find the space in
which objects are allocated. It does not contain any of the objects themselves. You
should not try to access the contents of the structure directly; use only the functions
described in this chapter.

You can declare variables of typestruct obstackand use them as obstacks, or you can
allocate obstacks dynamically like any other kind of object. Dynamic allocation of obstacks
allows your program to have a variable number of different stacks. (You can even allocate
an obstack structure in another obstack, but this is rarely useful.)

All the functions that work with obstacks require you to specify which obstack to use.
You do this with a pointer of typestruct obstack *. In the following, we often say ¡°an
obstack¡± when strictly speaking the object at hand is such a pointer.

The objects in the obstack are packed into large blocks calledchunks. The struct
obstackstructure points to a chain of the chunks currently in use.

The obstack library obtains a new chunk whenever you allocate an object that won¡¯t
fit in the previous chunk. Since the obstack library manages chunks automatically, you
don¡¯t need to pay much attention to them, but you do need to supply a function which the
obstack library should use to get a chunk. Usually you supply a function which usesmalloc
directly or indirectly. You must also supply a function to free a chunk. These matters are
described in the following section.

## 3.2.6.2 Preparing for Using Obstacks........................

Each source file in which you plan to use the obstack functions must include the header file
obstack.h, like this:
#include <obstack.h>
Also, if the source file uses the macroobstack_init, it must declare or define two
functions or macros that will be called by the obstack library. One,obstack_chunk_alloc,
is used to allocate the chunks of memory into which objects are packed. The other,obstack_
chunk_free, is used to return chunks when the objects in them are freed. These macros
should appear before any use of obstacks in the source file.

Usually these are defined to usemallocvia the intermediaryxmalloc(seeSection 3.2.3
[Unconstrained Allocation], page 45). This is done with the following pair of macro defini-
tions:
#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free

Though the memory you get using obstacks really comes frommalloc, using obstacks is
faster becausemallocis called less often, for larger blocks of memory. SeeSection 3.2.6.10
[Obstack Chunks], page 72, for full details.

At run time, before the program can use astruct obstackobject as an obstack, it must
initialize the obstack by callingobstack_init.


Chapter 3: Virtual Memory Allocation And Paging 65

int obstack_init (struct obstack *obstack-ptr) [Function]
Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Initialize obstackobstack-ptr for allocation of objects. This function calls the ob-
stack¡¯sobstack_chunk_allocfunction. If allocation of memory fails, the function
pointed to byobstack_alloc_failed_handleris called. Theobstack_initfunc-
tion always returns 1 (Compatibility notice: Former versions of obstack returned 0 if
allocation failed).

Here are two examples of how to allocate the space for an obstack and initialize it. First,
an obstack that is a static variable:
static struct obstack myobstack;

```
obstack_init (&myobstack);
```
Second, an obstack that is itself dynamically allocated:
struct obstack *myobstack_ptr
= (struct obstack *) xmalloc (sizeof (struct obstack));

```
obstack_init (myobstack_ptr);
```
obstack_alloc_failed_handler [Variable]
The value of this variable is a pointer to a function thatobstackuses whenobstack_
chunk_allocfails to allocate memory. The default action is to print a message and
abort. You should supply a function that either callsexit(seeSection 25.7 [Program
Termination], page 798) orlongjmp(seeChapter 23 [Non-Local Exits], page 705) and
doesn¡¯t return.
void my_obstack_alloc_failed (void)

```
obstack_alloc_failed_handler = &my_obstack_alloc_failed;
```
## 3.2.6.3 Allocation in an Obstack.............................

The most direct way to allocate an object in an obstack is withobstack_alloc, which is
invoked almost likemalloc.

void * obstack_alloc(struct obstack *obstack-ptr, intsize) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This allocates an uninitialized block ofsizebytes in an obstack and returns its address.
Hereobstack-ptrspecifies which obstack to allocate the block in; it is the address of
thestruct obstackobject which represents the obstack. Each obstack function or
macro requires you to specify anobstack-ptras the first argument.
This function calls the obstack¡¯sobstack_chunk_allocfunction if it needs to allocate
a new chunk of memory; it callsobstack_alloc_failed_handlerif allocation of
memory byobstack_chunk_allocfailed.

For example, here is a function that allocates a copy of a stringstrin a specific obstack,
which is in the variablestring_obstack:
struct obstack string_obstack;


Chapter 3: Virtual Memory Allocation And Paging 66

char *
copystring (char *string)
{
size_t len = strlen (string) + 1;
char *s = (char *) obstack_alloc (&string_obstack, len);
memcpy (s, string, len);
return s;
}
To allocate a block with specified contents, use the functionobstack_copy, declared like
this:

void * obstack_copy (struct obstack *obstack-ptr, void [Function]
*address, intsize)
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This allocates a block and initializes it by copying size bytes of data starting
ataddress. It calls obstack_alloc_failed_handlerif allocation of memory by
obstack_chunk_allocfailed.

void * obstack_copy0(struct obstack *obstack-ptr, void [Function]
*address, intsize)
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Likeobstack_copy, but appends an extra byte containing a null character. This
extra byte is not counted in the argumentsize.

Theobstack_copy0function is convenient for copying a sequence of characters into an
obstack as a null-terminated string. Here is an example of its use:

```
char *
obstack_savestring (char *addr, int size)
{
return obstack_copy0 (&myobstack, addr, size);
}
```
Contrast this with the previous example ofsavestringusingmalloc(seeSection 3.2.3.1
[Basic Memory Allocation], page 45).

## 3.2.6.4 Freeing Objects in an Obstack.......................

To free an object allocated in an obstack, use the functionobstack_free. Since the obstack
is a stack of objects, freeing one object automatically frees all other objects allocated more
recently in the same obstack.

void obstack_free(struct obstack *obstack-ptr, void *object) [Function]
Preliminary: |MT-Safe race:obstack-ptr| AS-Safe |AC-Unsafe corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Ifobjectis a null pointer, everything allocated in the obstack is freed. Otherwise,
objectmust be the address of an object allocated in the obstack. Thenobjectis freed,
along with everything allocated inobstack-ptrsinceobject.


Chapter 3: Virtual Memory Allocation And Paging 67

Note that ifobjectis a null pointer, the result is an uninitialized obstack. To free all
memory in an obstack but leave it valid for further allocation, callobstack_freewith the
address of the first object allocated on the obstack:
obstack_free (obstack_ptr, first_object_allocated_ptr);
Recall that the objects in an obstack are grouped into chunks. When all the objects in
a chunk become free, the obstack library automatically frees the chunk (seeSection 3.2.6.2
[Preparing for Using Obstacks], page 64). Then other obstacks, or non-obstack allocation,
can reuse the space of the chunk.

## 3.2.6.5 Obstack Functions and Macros.......................

The interfaces for using obstacks may be defined either as functions or as macros, depending
on the compiler. The obstack facility works with all C compilers, including both ISO C and
traditional C, but there are precautions you must take if you plan to use compilers other
than GNU C.

If you are using an old-fashioned non-ISO C compiler, all the obstack ¡°functions¡± are
actually defined only as macros. You can call these macros like functions, but you cannot
use them in any other way (for example, you cannot take their address).

Calling the macros requires a special precaution: namely, the first operand (the obstack
pointer) may not contain any side effects, because it may be computed more than once. For
example, if you write this:
obstack_alloc (get_obstack (), 4);

you will find thatget_obstackmay be called several times. If you use*obstack_list_
ptr++as the obstack pointer argument, you will get very strange results since the incre-
mentation may occur several times.

In ISO C, each function has both a macro definition and a function definition. The
function definition is used if you take the address of the function without calling it. An
ordinary call uses the macro definition by default, but you can request the function definition
instead by writing the function name in parentheses, as shown here:
char *x;
void *(*funcp) ();
/*Use the macro. */
x = (char *) obstack_alloc (obptr, size);
/*Call the function. */
x = (char *) (obstack_alloc) (obptr, size);
/*Take the address of the function. */
funcp = obstack_alloc;

This is the same situation that exists in ISO C for the standard library functions. See
Section 1.3.2 [Macro Definitions of Functions], page 13.

Warning: When you do use the macros, you must observe the precaution of avoiding
side effects in the first operand, even in ISO C.

If you use the GNU C compiler, this precaution is not necessary, because various language
extensions in GNU C permit defining the macros so as to compute each argument only once.

## 3.2.6.6 Growing Objects.....................................

Because memory in obstack chunks is used sequentially, it is possible to build up an object
step by step, adding one or more bytes at a time to the end of the object. With this


Chapter 3: Virtual Memory Allocation And Paging 68

technique, you do not need to know how much data you will put in the object until you
come to the end of it. We call this the technique ofgrowing objects. The special functions
for adding data to the growing object are described in this section.

You don¡¯t need to do anything special when you start to grow an object. Using one of
the functions to add data to the object automatically starts it. However, it is necessary to
say explicitly when the object is finished. This is done with the functionobstack_finish.

The actual address of the object thus built up is not known until the object is finished.
Until then, it always remains possible that you will add so much data that the object must
be copied into a new chunk.

While the obstack is in use for a growing object, you cannot use it for ordinary allocation
of another object. If you try to do so, the space already added to the growing object will
become part of the other object.

void obstack_blank(struct obstack *obstack-ptr, intsize) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The most basic function for adding to a growing object isobstack_blank, which adds
space without initializing it.

void obstack_grow(struct obstack *obstack-ptr, void *data, int [Function]
size)
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
To add a block of initialized space, useobstack_grow, which is the growing-object
analogue ofobstack_copy. It addssizebytes of data to the growing object, copying
the contents fromdata.

void obstack_grow0(struct obstack *obstack-ptr, void *data, int [Function]
size)
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the growing-object analogue ofobstack_copy0. It addssizebytes copied from
data, followed by an additional null character.

void obstack_1grow(struct obstack *obstack-ptr, charc) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
To add one character at a time, use the functionobstack_1grow. It adds a single
byte containingcto the growing object.

void obstack_ptr_grow(struct obstack *obstack-ptr, void *data) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Adding the value of a pointer one can use the functionobstack_ptr_grow. It adds
sizeof (void *)bytes containing the value ofdata.


Chapter 3: Virtual Memory Allocation And Paging 69

void obstack_int_grow(struct obstack *obstack-ptr, intdata) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
A single value of typeintcan be added by using theobstack_int_growfunction. It
addssizeof (int)bytes to the growing object and initializes them with the value
ofdata.

void * obstack_finish(struct obstack *obstack-ptr) [Function]
Preliminary: |MT-Safe race:obstack-ptr| AS-Safe |AC-Unsafe corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
When you are finished growing the object, use the functionobstack_finishto close
it off and return its final address.
Once you have finished the object, the obstack is available for ordinary allocation or
for growing another object.
This function can return a null pointer under the same conditions asobstack_alloc
(seeSection 3.2.6.3 [Allocation in an Obstack], page 65).

When you build an object by growing it, you will probably need to know afterward
how long it became. You need not keep track of this as you grow the object, because you
can find out the length from the obstack just before finishing the object with the function
obstack_object_size, declared as follows:

int obstack_object_size (struct obstack *obstack-ptr) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function returns the current size of the growing object, in bytes. Remember to
call this functionbeforefinishing the object. After it is finished,obstack_object_
sizewill return zero.

If you have started growing an object and wish to cancel it, you should finish it and then
free it, like this:
obstack_free (obstack_ptr, obstack_finish (obstack_ptr));

This has no effect if no object was growing.

You can useobstack_blankwith a negative size argument to make the current object
smaller. Just don¡¯t try to shrink it beyond zero length¡ªthere¡¯s no telling what will happen
if you do that.

## 3.2.6.7 Extra Fast Growing Objects.........................

The usual functions for growing objects incur overhead for checking whether there is room
for the new growth in the current chunk. If you are frequently constructing objects in small
steps of growth, this overhead can be significant.

You can reduce the overhead by using special ¡°fast growth¡± functions that grow the
object without checking. In order to have a robust program, you must do the checking
yourself. If you do this checking in the simplest way each time you are about to add data to
the object, you have not saved anything, because that is what the ordinary growth functions
do. But if you can arrange to check less often, or check more efficiently, then you make the
program faster.


Chapter 3: Virtual Memory Allocation And Paging 70

The functionobstack_roomreturns the amount of room available in the current chunk.
It is declared as follows:

int obstack_room (struct obstack *obstack-ptr) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This returns the number of bytes that can be added safely to the current growing
object (or to an object about to be started) in obstackobstack-ptrusing the fast
growth functions.

While you know there is room, you can use these fast growth functions for adding data
to a growing object:

void obstack_1grow_fast (struct obstack *obstack-ptr, charc) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionobstack_1grow_fastadds one byte containing the charactercto the
growing object in obstackobstack-ptr.

void obstack_ptr_grow_fast (struct obstack *obstack-ptr, void [Function]
*data)
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The functionobstack_ptr_grow_fastaddssizeof (void *)bytes containing the
value ofdatato the growing object in obstackobstack-ptr.

void obstack_int_grow_fast (struct obstack *obstack-ptr, int [Function]
data)
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The functionobstack_int_grow_fastaddssizeof (int)bytes containing the value
ofdatato the growing object in obstackobstack-ptr.

void obstack_blank_fast (struct obstack *obstack-ptr, intsize) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The functionobstack_blank_fastaddssizebytes to the growing object in obstack
obstack-ptrwithout initializing them.

When you check for space usingobstack_roomand there is not enough room for what
you want to add, the fast growth functions are not safe. In this case, simply use the
corresponding ordinary growth function instead. Very soon this will copy the object to a
new chunk; then there will be lots of room available again.

So, each time you use an ordinary growth function, check afterward for sufficient space
usingobstack_room. Once the object is copied to a new chunk, there will be plenty of
space again, so the program will start using the fast growth functions again.


Chapter 3: Virtual Memory Allocation And Paging 71

```
Here is an example:
void
add_string (struct obstack *obstack, const char *ptr, int len)
{
while (len > 0)
{
int room = obstack_room (obstack);
if (room == 0)
{
/*Not enough room. Add one character slowly,
which may copy to a new chunk and make room. */
obstack_1grow (obstack, *ptr++);
len--;
}
else
{
if (room > len)
room = len;
/*Add fast as much as we have room for.*/
len -= room;
while (room-- > 0)
obstack_1grow_fast (obstack, *ptr++);
}
}
}
```
## 3.2.6.8 Status of an Obstack.................................

Here are functions that provide information on the current status of allocation in an obstack.
You can use them to learn about an object while still growing it.

void * obstack_base (struct obstack *obstack-ptr) [Function]
Preliminary:|MT-Safe|AS-Unsafe corrupt|AC-Safe|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns the tentative address of the beginning of the currently growing
object inobstack-ptr. If you finish the object immediately, it will have that address.
If you make it larger first, it may outgrow the current chunk¡ªthen its address will
change!
If no object is growing, this value says where the next object you allocate will start
(once again assuming it fits in the current chunk).

void * obstack_next_free(struct obstack *obstack-ptr) [Function]
Preliminary:|MT-Safe|AS-Unsafe corrupt|AC-Safe|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns the address of the first free byte in the current chunk of obstack
obstack-ptr. This is the end of the currently growing object. If no object is growing,
obstack_next_freereturns the same value asobstack_base.

int obstack_object_size (struct obstack *obstack-ptr) [Function]
Preliminary:|MT-Safe race:obstack-ptr|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function returns the size in bytes of the currently growing object. This is equiv-
alent to


Chapter 3: Virtual Memory Allocation And Paging 72

```
obstack_next_free (obstack-ptr) - obstack_base (obstack-ptr)
```
## 3.2.6.9 Alignment of Data in Obstacks.......................

Each obstack has analignment boundary; each object allocated in the obstack automatically
starts on an address that is a multiple of the specified boundary. By default, this boundary
is aligned so that the object can hold any type of data.

To access an obstack¡¯s alignment boundary, use the macroobstack_alignment_mask,
whose function prototype looks like this:

int obstack_alignment_mask (struct obstack *obstack-ptr) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The value is a bit mask; a bit that is 1 indicates that the corresponding bit in the
address of an object should be 0. The mask value should be one less than a power of
2; the effect is that all object addresses are multiples of that power of 2. The default
value of the mask is a value that allows aligned objects to hold any type of data: for
example, if its value is 3, any type of data can be stored at locations whose addresses
are multiples of 4. A mask value of 0 means an object can start on any multiple of 1
(that is, no alignment is required).
The expansion of the macroobstack_alignment_maskis an lvalue, so you can alter
the mask by assignment. For example, this statement:
obstack_alignment_mask (obstack_ptr) = 0;
has the effect of turning off alignment processing in the specified obstack.
Note that a change in alignment mask does not take effect untilafterthe next time an
object is allocated or finished in the obstack. If you are not growing an object, you can
make the new alignment mask take effect immediately by callingobstack_finish. This
will finish a zero-length object and then do proper alignment for the next object.

## 3.2.6.10 Obstack Chunks....................................

Obstacks work by allocating space for themselves in large chunks, and then parceling out
space in the chunks to satisfy your requests. Chunks are normally 4096 bytes long unless
you specify a different chunk size. The chunk size includes 8 bytes of overhead that are
not actually used for storing objects. Regardless of the specified size, longer chunks will be
allocated when necessary for long objects.

The obstack library allocates chunks by calling the functionobstack_chunk_alloc,
which you must define. When a chunk is no longer needed because you have freed all the
objects in it, the obstack library frees the chunk by callingobstack_chunk_free, which
you must also define.

These two must be defined (as macros) or declared (as functions) in each source file that
usesobstack_init(seeSection 3.2.6.1 [Creating Obstacks], page 64). Most often they are
defined as macros like this:
#define obstack_chunk_alloc malloc
#define obstack_chunk_free free
Note that these are simple macros (no arguments). Macro definitions with arguments
will not work! It is necessary thatobstack_chunk_allocorobstack_chunk_free, alone,
expand into a function name if it is not itself a function name.


Chapter 3: Virtual Memory Allocation And Paging 73

If you allocate chunks withmalloc, the chunk size should be a power of 2. The default
chunk size, 4096, was chosen because it is long enough to satisfy many typical requests on
the obstack yet short enough not to waste too much memory in the portion of the last chunk
not yet used.

int obstack_chunk_size (struct obstack *obstack-ptr) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This returns the chunk size of the given obstack.

Since this macro expands to an lvalue, you can specify a new chunk size by assigning
it a new value. Doing so does not affect the chunks already allocated, but will change the
size of chunks allocated for that particular obstack in the future. It is unlikely to be useful
to make the chunk size smaller, but making it larger might improve efficiency if you are
allocating many objects whose size is comparable to the chunk size. Here is how to do so
cleanly:

```
if (obstack_chunk_size (obstack_ptr) <new-chunk-size)
obstack_chunk_size (obstack_ptr) =new-chunk-size;
```
## 3.2.6.11 Summary of Obstack Functions.....................

Here is a summary of all the functions associated with obstacks. Each takes the address of
an obstack (struct obstack *) as its first argument.

void obstack_init (struct obstack *obstack-ptr)
Initialize use of an obstack. SeeSection 3.2.6.1 [Creating Obstacks], page 64.

void *obstack_alloc (struct obstack *obstack-ptr, intsize)
Allocate an object ofsizeuninitialized bytes. SeeSection 3.2.6.3 [Allocation in
an Obstack], page 65.

void *obstack_copy (struct obstack *obstack-ptr, void *address, intsize)
Allocate an object of size bytes, with contents copied from address. See
Section 3.2.6.3 [Allocation in an Obstack], page 65.

void *obstack_copy0 (struct obstack *obstack-ptr, void *address, intsize)
Allocate an object ofsize+1 bytes, withsize of them copied from address,
followed by a null character at the end. SeeSection 3.2.6.3 [Allocation in an
Obstack], page 65.

void obstack_free (struct obstack *obstack-ptr, void *object)
Freeobject(and everything allocated in the specified obstack more recently
thanobject). SeeSection 3.2.6.4 [Freeing Objects in an Obstack], page 66.

void obstack_blank (struct obstack *obstack-ptr, intsize)
Addsizeuninitialized bytes to a growing object. SeeSection 3.2.6.6 [Growing
Objects], page 67.

void obstack_grow (struct obstack *obstack-ptr, void *address, intsize)
Addsizebytes, copied fromaddress, to a growing object. SeeSection 3.2.6.6
[Growing Objects], page 67.


Chapter 3: Virtual Memory Allocation And Paging 74

void obstack_grow0 (struct obstack *obstack-ptr, void *address, intsize)
Addsizebytes, copied fromaddress, to a growing object, and then add another
byte containing a null character. SeeSection 3.2.6.6 [Growing Objects], page 67.

void obstack_1grow (struct obstack *obstack-ptr, chardata-char)
Add one byte containingdata-char to a growing object. SeeSection 3.2.6.6
[Growing Objects], page 67.

void *obstack_finish (struct obstack *obstack-ptr)
Finalize the object that is growing and return its permanent address. See
Section 3.2.6.6 [Growing Objects], page 67.

int obstack_object_size (struct obstack *obstack-ptr)
Get the current size of the currently growing object. SeeSection 3.2.6.6 [Grow-
ing Objects], page 67.

void obstack_blank_fast (struct obstack *obstack-ptr, intsize)
Addsizeuninitialized bytes to a growing object without checking that there is
enough room. SeeSection 3.2.6.7 [Extra Fast Growing Objects], page 69.

void obstack_1grow_fast (struct obstack *obstack-ptr, chardata-char)
Add one byte containing data-char to a growing object without checking
that there is enough room. SeeSection 3.2.6.7 [Extra Fast Growing Objects],
page 69.

int obstack_room (struct obstack *obstack-ptr)
Get the amount of room now available for growing the current object. See
Section 3.2.6.7 [Extra Fast Growing Objects], page 69.

int obstack_alignment_mask (struct obstack *obstack-ptr)
The mask used for aligning the beginning of an object. This is an lvalue. See
Section 3.2.6.9 [Alignment of Data in Obstacks], page 72.

int obstack_chunk_size (struct obstack *obstack-ptr)
The size for allocating chunks. This is an lvalue. SeeSection 3.2.6.10 [Obstack
Chunks], page 72.

void *obstack_base (struct obstack *obstack-ptr)
Tentative starting address of the currently growing object. SeeSection 3.2.6.8
[Status of an Obstack], page 71.

void *obstack_next_free (struct obstack *obstack-ptr)
Address just after the end of the currently growing object. SeeSection 3.2.6.8
[Status of an Obstack], page 71.

## 3.2.7 Automatic Storage with Variable Size.....................

The functionallocasupports a kind of half-dynamic allocation in which blocks are allocated
dynamically but freed automatically.

Allocating a block withallocais an explicit action; you can allocate as many blocks as
you wish, and compute the size at run time. But all the blocks are freed when you exit the
function thatallocawas called from, just as if they were automatic variables declared in
that function. There is no way to free the space explicitly.

```
The prototype forallocais instdlib.h. This function is a BSD extension.
```

Chapter 3: Virtual Memory Allocation And Paging 75

void * alloca(sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The return value ofallocais the address of a block ofsizebytes of memory, allocated
in the stack frame of the calling function.

Do not useallocainside the arguments of a function call¡ªyou will get unpredictable
results, because the stack space for theallocawould appear on the stack in the middle
of the space for the function arguments. An example of what to avoid isfoo (x, alloca
(4), y).

## 3.2.7.1 allocaExample.....................................

As an example of the use ofalloca, here is a function that opens a file name made from
concatenating two argument strings, and returns a file descriptor or minus one signifying
failure:

```
int
open2 (char *str1, char *str2, int flags, int mode)
{
char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
stpcpy (stpcpy (name, str1), str2);
return open (name, flags, mode);
}
```
Here is how you would get the same results withmallocandfree:

int
open2 (char *str1, char *str2, int flags, int mode)
{
char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
int desc;
if (name == 0)
fatal ("virtual memory exceeded");
stpcpy (stpcpy (name, str1), str2);
desc = open (name, flags, mode);
free (name);
return desc;
}
As you can see, it is simpler with alloca. Butalloca has other, more important
advantages, and some disadvantages.

## 3.2.7.2 Advantages ofalloca................................

Here are the reasons whyallocamay be preferable tomalloc:

- Usingallocawastes very little space and is very fast. (It is open-coded by the GNU
    C compiler.)
- Sinceallocadoes not have separate pools for different sizes of blocks, space used
    for any size block can be reused for any other size. allocadoes not cause memory
    fragmentation.
- Nonlocal exits done withlongjmp(seeChapter 23 [Non-Local Exits], page 705) au-
    tomatically free the space allocated withallocawhen they exit through the function
    that calledalloca. This is the most important reason to usealloca.


Chapter 3: Virtual Memory Allocation And Paging 76

```
To illustrate this, suppose you have a functionopen_or_report_errorwhich returns
a descriptor, likeopen, if it succeeds, but does not return to its caller if it fails. If
the file cannot be opened, it prints an error message and jumps out to the command
level of your program usinglongjmp. Let¡¯s changeopen2(seeSection 3.2.7.1 [alloca
Example], page 75) to use this subroutine:
int
open2 (char *str1, char *str2, int flags, int mode)
{
char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
stpcpy (stpcpy (name, str1), str2);
return open_or_report_error (name, flags, mode);
}
Because of the wayallocaworks, the memory it allocates is freed even when an error
occurs, with no special effort required.
By contrast, the previous definition ofopen2(which usesmallocandfree) would
develop a memory leak if it were changed in this way. Even if you are willing to make
more changes to fix it, there is no easy way to do so.
```
## 3.2.7.3 Disadvantages ofalloca.............................

These are the disadvantages ofallocain comparison withmalloc:

- If you try to allocate more memory than the machine can provide, you don¡¯t get a
    clean error message. Instead you get a fatal signal like the one you would get from
    an infinite recursion; probably a segmentation violation (seeSection 24.2.1 [Program
    Error Signals], page 716).
- Some non-GNU systems fail to supportalloca, so it is less portable. However, a slower
    emulation ofallocawritten in C is available for use on systems with this deficiency.

## 3.2.7.4 GNU C Variable-Size Arrays.........................

In GNU C, you can replace most uses ofallocawith an array of variable size. Here is how
open2would look then:

```
int open2 (char *str1, char *str2, int flags, int mode)
{
char name[strlen (str1) + strlen (str2) + 1];
stpcpy (stpcpy (name, str1), str2);
return open (name, flags, mode);
}
```
```
Butallocais not always equivalent to a variable-sized array, for several reasons:
```
- A variable size array¡¯s space is freed at the end of the scope of the name of the array.
    The space allocated withallocaremains until the end of the function.
- It is possible to usealloca within a loop, allocating an additional block on each
    iteration. This is impossible with variable-sized arrays.

NB:If you mix use ofallocaand variable-sized arrays within one function, exiting a
scope in which a variable-sized array was declared frees all blocks allocated withalloca
during the execution of that scope.


Chapter 3: Virtual Memory Allocation And Paging 77

## 3.3 Resizing the Data Segment....................................

The symbols in this section are declared inunistd.h.

You will not normally use the functions in this section, because the functions described
inSection 3.2 [Allocating Storage For Program Data], page 43,are easier to use. Those are
interfaces to a GNU C Library memory allocator that uses the functions below itself. The
functions below are simple interfaces to system calls.

int brk(void *addr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
brksets the high end of the calling process¡¯ data segment toaddr.
The address of the end of a segment is defined to be the address of the last byte in
the segment plus 1.
The function has no effect ifaddris lower than the low end of the data segment.
(This is considered success, by the way.)
The function fails if it would cause the data segment to overlap another segment or
exceed the process¡¯ data storage limit (seeSection 22.2 [Limiting Resource Usage],
page 685).
The function is named for a common historical case where data storage and the stack
are in the same segment. Data storage allocation grows upward from the bottom of
the segment while the stack grows downward toward it from the top of the segment
and the curtain between them is called thebreak.
The return value is zero on success. On failure, the return value is-1anderrnois
set accordingly. The followingerrnovalues are specific to this function:

```
ENOMEM The request would cause the data segment to overlap another segment or
exceed the process¡¯ data storage limit.
```
void *sbrk(ptrdiff tdelta) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is the same asbrkexcept that you specify the new end of the data
segment as an offsetdeltafrom the current end and on success the return value is the
address of the resulting end of the data segment instead of zero.
This means you can use ¡®sbrk(0)¡¯ to find out what the current end of the data
segment is.

## 3.4 Memory Protection............................................

When a page is mapped usingmmap, page protection flags can be specified using the pro-
tection flags argument. SeeSection 13.8 [Memory-mapped I/O], page 360.

```
The following flags are available:
```
PROT_WRITE
The memory can be written to.


Chapter 3: Virtual Memory Allocation And Paging 78

### PROT_READ

```
The memory can be read. On some architectures, this flag implies that the
memory can be executed as well (as ifPROT_EXEChad been specified at the
same time).
```
PROT_EXEC
The memory can be used to store instructions which can then be executed.
On most architectures, this flag implies that the memory can be read (as if
PROT_READhad been specified).

PROT_NONE
This flag must be specified on its own.
The memory is reserved, but cannot be read, written, or executed. If this flag
is specified in a call tommap, a virtual memory area will be set aside for future
use in the process, andmmapcalls without theMAP_FIXEDflag will not use it for
subsequent allocations. For anonymous mappings, the kernel will not reserve
any physical memory for the allocation at the time the mapping is created.

The operating system may keep track of these flags separately even if the underlying
hardware treats them the same for the purposes of access checking (as happens withPROT_
READandPROT_EXECon some platforms). On GNU systems,PROT_EXECalways implies
PROT_READ, so that users can view the machine code which is executing on their system.

Inappropriate access will cause a segfault (seeSection 24.2.1 [Program Error Signals],
page 716).

```
After allocation, protection flags can be changed using themprotectfunction.
```
int mprotect (void *address, sizetlength, intprotection) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
A successful call to themprotectfunction changes the protection flags of at least
lengthbytes of memory, starting ataddress.
addressmust be aligned to the page size for the mapping. The system page size can
be obtained by callingsysconfwith the_SC_PAGESIZEparameter (seeSection 32.4.1
[Definition ofsysconf], page 893). The system page size is the granularity in which
the page protection of anonymous memory mappings and most file mappings can be
changed. Memory which is mapped from special files or devices may have larger page
granularity than the system page size and may require larger alignment.
lengthis the number of bytes whose protection flags must be changed. It is automat-
ically rounded up to the next multiple of the system page size.
protectionis a combination of thePROT_*flags described above.
Themprotectfunction returns 0 on success and?1 on failure.
The followingerrnoerror conditions are defined for this function:
ENOMEM The system was not able to allocate resources to fulfill the request. This
can happen if there is not enough physical memory in the system for the
allocation of backing storage. The error can also occur if the new protec-
tion flags would cause the memory region to be split from its neighbors,


Chapter 3: Virtual Memory Allocation And Paging 79

and the process limit for the number of such distinct memory regions
would be exceeded.
EINVAL addressis not properly aligned to a page boundary for the mapping, or
length(after rounding up to the system page size) is not a multiple of
the applicable page size for the mapping, or the combination of flags in
protectionis not valid.
EACCES The file for a file-based mapping was not opened with open flags which
are compatible withprotection.
EPERM The system security policy does not allow a mapping with the specified
flags. For example, mappings which are bothPROT_EXECandPROT_WRITE
at the same time might not be allowed.
If themprotectfunction is used to make a region of memory inaccessible by specifying
thePROT_NONEprotection flag and access is later restored, the memory retains its previous
contents.

On some systems, it may not be possible to specify additional flags which were not
present when the mapping was first created. For example, an attempt to make a region of
memory executable could fail if the initial protection flags were ¡®PROT_READ | PROT_WRITE¡¯.

In general, themprotectfunction can be used to change any process memory, no matter
how it was allocated. However, portable use of the function requires that it is only used
with memory regions returned bymmapormmap64.

## 3.4.1 Memory Protection Keys.................................

On some systems, further restrictions can be added to specific pages usingmemory protec-
tion keys. These restrictions work as follows:

- All memory pages are associated with a protection key. The default protection key
    does not cause any additional protections to be applied during memory accesses. New
    keys can be allocated with thepkey_allocfunction, and applied to pages usingpkey_
    mprotect.
- Each thread has a set of separate access right restriction for each protection key. These
    access rights can be manipulated using thepkey_setandpkey_getfunctions.
- During a memory access, the system obtains the protection key for the accessed page
    and uses that to determine the applicable access rights, as configured for the current
    thread. If the access is restricted, a segmentation fault is the result ((seeSection 24.2.1
    [Program Error Signals], page 716). These checks happen in addition to thePROT_*
    protection flags set bymprotectorpkey_mprotect.
New threads and subprocesses inherit the access rights of the current thread. If a pro-
tection key is allocated subsequently, existing threads (except the current) will use an
unspecified system default for the access rights associated with newly allocated keys.

Upon entering a signal handler, the system resets the access rights of the current thread
so that pages with the default key can be accessed, but the access rights for other protection
keys are unspecified.

Applications are expected to allocate a key once usingpkey_alloc, and apply the key
to memory regions which need special protection withpkey_mprotect:
int key = pkey_alloc (0, PKEY_DISABLE_ACCESS);


Chapter 3: Virtual Memory Allocation And Paging 80

```
if (key < 0)
/* Perform error checking, including fallback for lack of support. */
...;
```
/* Apply the key to a special memory region used to store critical
data. */
if (pkey_mprotect (region, region_length,
PROT_READ | PROT_WRITE, key) < 0)
...; /* Perform error checking (generally fatal). */
If the key allocation fails due to lack of support for memory protection keys, thepkey_
mprotectcall can usually be skipped. In this case, the region will not be protected by
default. It is also possible to callpkey_mprotectwith a key value of?1, in which case it
will behave in the same way asmprotect.

After key allocation assignment to memory pages,pkey_setcan be used to temporarily
acquire access to the memory region and relinquish it again:
if (key >= 0 && pkey_set (key, 0) < 0)
...; /* Perform error checking (generally fatal). */
/* At this point, the current thread has read-write access to the
memory region. */
...
/* Revoke access again. */
if (key >= 0 && pkey_set (key, PKEY_DISABLE_ACCESS) < 0)
...; /* Perform error checking (generally fatal). */
In this example, a negative key value indicates that no key had been allocated, which
means that the system lacks support for memory protection keys and it is not necessary to
change the the access rights of the current thread (because it always has access).

Compared to usingmprotectto change the page protection flags, this approach has
two advantages: It is thread-safe in the sense that the access rights are only changed for
the current thread, so another thread which changes its own access rights concurrently to
gain access to the mapping will not suddenly see its access rights revoked. Andpkey_set
typically does not involve a call into the kernel and a context switch, so it is more efficient.

int pkey_alloc(unsigned intflags, unsigned intrestrictions) [Function]
Preliminary:|MT-Safe|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Allocate a new protection key. Theflagsargument is reserved and must be zero. The
restrictionsargument specifies access rights which are applied to the current thread
(as if withpkey_setbelow). Access rights of other threads are not changed.
The function returns the new protection key, a non-negative number, or?1 on error.
The followingerrnoerror conditions are defined for this function:
ENOSYS The system does not implement memory protection keys.
EINVAL Theflagsargument is not zero.
Therestrictionsargument is invalid.
The system does not implement memory protection keys or runs in a
mode in which memory protection keys are disabled.
ENOSPC All available protection keys already have been allocated.
The system does not implement memory protection keys or runs in a
mode in which memory protection keys are disabled.


Chapter 3: Virtual Memory Allocation And Paging 81

int pkey_free(intkey) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Deallocate the protection key, so that it can be reused bypkey_alloc.
Calling this function does not change the access rights of the freed protection key.
The calling thread and other threads may retain access to it, even if it is subsequently
allocated again. For this reason, it is not recommended to call thepkey_freefunction.

```
ENOSYS The system does not implement memory protection keys.
```
```
EINVAL Thekeyargument is not a valid protection key.
```
int pkey_mprotect(void *address, sizetlength, intprotection, [Function]
intkey)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Similar tomprotect, but also set the memory protection key for the memory region
tokey.
Some systems use memory protection keys to emulate certain combinations ofpro-
tectionflags. Under such circumstances, specifying an explicit protection key may
behave as if additional flags have been specified inprotection, even though this does
not happen with the default protection key. For example, some systems can support
PROT_EXEC-only mappings only with a default protection key, and memory with a key
which was allocated usingpkey_allocwill still be readable ifPROT_EXECis specified
withoutPROT_READ.
Ifkeyis?1, the default protection key is applied to the mapping, just as ifmprotect
had been called.
Thepkey_mprotectfunction returns 0 on success and?1 on failure. The sameerrno
error conditions as formprotectare defined for this function, with the following
addition:

```
EINVAL Thekeyargument is not?1 or a valid memory protection key allocated
usingpkey_alloc.
```
```
ENOSYS The system does not implement memory protection keys, andkeyis not
?1.
```
int pkey_set (intkey, unsigned intrights) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Change the access rights of the current thread for memory pages with the protection
keykeytorights. Ifrightsis zero, no additional access restrictions on top of the page
protection flags are applied. Otherwise,rightsis a combination of the following flags:

```
PKEY_DISABLE_WRITE
Subsequent attempts to write to memory with the specified protection
key will fault.
```

Chapter 3: Virtual Memory Allocation And Paging 82

### PKEY_DISABLE_ACCESS

```
Subsequent attempts to write to or read from memory with the specified
protection key will fault.
Operations not specified as flags are not restricted. In particular, this means that the
memory region will remain executable if it was mapped with thePROT_EXECprotection
flag andPKEY_DISABLE_ACCESShas been specified.
Calling thepkey_setfunction with a protection key which was not allocated by
pkey_allocresults in undefined behavior. This means that calling this function on
systems which do not support memory protection keys is undefined.
Thepkey_setfunction returns 0 on success and?1 on failure.
The followingerrnoerror conditions are defined for this function:
EINVAL The system does not support the access rights restrictions expressed in
therightsargument.
```
int pkey_get (intkey) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Return the access rights of the current thread for memory pages with protection key
key. The return value is zero or a combination of thePKEY_DISABLE_* flags; see the
pkey_setfunction.
Calling thepkey_getfunction with a protection key which was not allocated by
pkey_allocresults in undefined behavior. This means that calling this function on
systems which do not support memory protection keys is undefined.

## 3.5 Locking Pages.................................................

You can tell the system to associate a particular virtual memory page with a real page
frame and keep it that way ¡ª i.e., cause the page to be paged in if it isn¡¯t already and
mark it so it will never be paged out and consequently will never cause a page fault. This
is calledlockinga page.

```
The functions in this chapter lock and unlock the calling process¡¯ pages.
```
## 3.5.1 Why Lock Pages..........................................

Because page faults cause paged out pages to be paged in transparently, a process rarely
needs to be concerned about locking pages. However, there are two reasons people some-
times are:

- Speed. A page fault is transparent only insofar as the process is not sensitive to how
    long it takes to do a simple memory access. Time-critical processes, especially realtime
    processes, may not be able to wait or may not be able to tolerate variance in execution
    speed.
    A process that needs to lock pages for this reason probably also needs priority among
    other processes for use of the CPU. SeeSection 22.3 [Process CPU Priority And
    Scheduling], page 689.
    In some cases, the programmer knows better than the system¡¯s demand paging allocator
    which pages should remain in real memory to optimize system performance. In this
    case, locking pages can help.


Chapter 3: Virtual Memory Allocation And Paging 83

- Privacy. If you keep secrets in virtual memory and that virtual memory gets paged
    out, that increases the chance that the secrets will get out. If a passphrase gets written
    out to disk swap space, for example, it might still be there long after virtual and real
    memory have been wiped clean.
Be aware that when you lock a page, that¡¯s one fewer page frame that can be used to
back other virtual memory (by the same or other processes), which can mean more page
faults, which means the system runs more slowly. In fact, if you lock enough memory, some
programs may not be able to run at all for lack of real memory.

## 3.5.2 Locked Memory Details...................................

A memory lock is associated with a virtual page, not a real frame. The paging rule is: If a
frame backs at least one locked page, don¡¯t page it out.

Memory locks do not stack. I.e., you can¡¯t lock a particular page twice so that it has to
be unlocked twice before it is truly unlocked. It is either locked or it isn¡¯t.

A memory lock persists until the process that owns the memory explicitly unlocks it.
(But process termination and exec cause the virtual memory to cease to exist, which you
might say means it isn¡¯t locked any more).

Memory locks are not inherited by child processes. (But note that on a modern Unix
system, immediately after a fork, the parent¡¯s and the child¡¯s virtual address space are
backed by the same real page frames, so the child enjoys the parent¡¯s locks). SeeSection 26.4
[Creating a Process], page 805.

Because of its ability to impact other processes, only the superuser can lock a page. Any
process can unlock its own page.

The system sets limits on the amount of memory a process can have locked and the
amount of real memory it can have dedicated to it. SeeSection 22.2 [Limiting Resource
Usage], page 685.

In Linux, locked pages aren¡¯t as locked as you might think. Two virtual pages that are
not shared memory can nonetheless be backed by the same real frame. The kernel does this
in the name of efficiency when it knows both virtual pages contain identical data, and does
it even if one or both of the virtual pages are locked.

But when a process modifies one of those pages, the kernel must get it a separate frame
and fill it with the page¡¯s data. This is known as acopy-on-write page fault. It takes a
small amount of time and in a pathological case, getting that frame may require I/O.

To make sure this doesn¡¯t happen to your program, don¡¯t just lock the pages. Write
to them as well, unless you know you won¡¯t write to them ever. And to make sure you
have pre-allocated frames for your stack, enter a scope that declares a C automatic variable
larger than the maximum stack size you will need, set it to something, then return from its
scope.

## 3.5.3 Functions To Lock And Unlock Pages.....................

The symbols in this section are declared insys/mman.h. These functions are defined by
POSIX.1b, but their availability depends on your kernel. If your kernel doesn¡¯t allow these
functions, they exist but always fail. Theyareavailable with a Linux kernel.

Portability Note: POSIX.1b requires that when themlockandmunlockfunctions are
available, the fileunistd.hdefine the macro_POSIX_MEMLOCK_RANGEand the filelimits.h


Chapter 3: Virtual Memory Allocation And Paging 84

define the macroPAGESIZEto be the size of a memory page in bytes. It requires that when
themlockallandmunlockallfunctions are available, theunistd.hfile define the macro
_POSIX_MEMLOCK. The GNU C Library conforms to this requirement.

int mlock (const void *addr, size tlen) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
mlocklocks a range of the calling process¡¯ virtual pages.
The range of memory starts at addressaddrand islenbytes long. Actually, since you
must lock whole pages, it is the range of pages that include any part of the specified
range.
When the function returns successfully, each of those pages is backed by (connected
to) a real frame (is resident) and is marked to stay that way. This means the function
may cause page-ins and have to wait for them.
When the function fails, it does not affect the lock status of any pages.
The return value is zero if the function succeeds. Otherwise, it is-1anderrnois set
accordingly.errnovalues specific to this function are:
ENOMEM

- At least some of the specified address range does not exist in the
    calling process¡¯ virtual address space.
- The locking would cause the process to exceed its locked page limit.
EPERM The calling process is not superuser.
EINVAL lenis not positive.
ENOSYS The kernel does not providemlockcapability.

int mlock2(const void *addr, sizetlen, unsigned intflags) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tomlock. Ifflagsis zero, a call tomlock2behaves exactly as
the equivalent call tomlock.
Theflagsargument must be a combination of zero or more of the following flags:
MLOCK_ONFAULT
Only those pages in the specified address range which are already in
memory are locked immediately. Additional pages in the range are auto-
matically locked in case of a page fault and allocation of memory.
Likemlock,mlock2returns zero on success and-1on failure, settingerrnoaccord-
ingly. Additionalerrnovalues defined formlock2are:
EINVAL The specified (non-zero)flagsargument is not supported by this system.

You can lockalla process¡¯ memory withmlockall. You unlock memory withmunlock
ormunlockall.

To avoid all page faults in a C program, you have to usemlockall, because some of the
memory a program uses is hidden from the C code, e.g. the stack and automatic variables,
and you wouldn¡¯t know what address to tellmlock.


Chapter 3: Virtual Memory Allocation And Paging 85

int munlock(const void *addr, sizetlen) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
munlockunlocks a range of the calling process¡¯ virtual pages.
munlockis the inverse ofmlockand functions completely analogously tomlock, except
that there is noEPERMfailure.

int mlockall (intflags) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
mlockalllocks all the pages in a process¡¯ virtual memory address space, and/or any
that are added to it in the future. This includes the pages of the code, data and
stack segment, as well as shared libraries, user space kernel data, shared memory, and
memory mapped files.
flagsis a string of single bit flags represented by the following macros. They tell
mlockallwhich of its functions you want. All other bits must be zero.

```
MCL_CURRENT
Lock all pages which currently exist in the calling process¡¯ virtual address
space.
```
```
MCL_FUTURE
Set a mode such that any pages added to the process¡¯ virtual address
space in the future will be locked from birth. This mode does not affect
future address spaces owned by the same process so exec, which replaces
a process¡¯ address space, wipes outMCL_FUTURE. SeeSection 26.5 [Exe-
cuting a File], page 806.
```
```
When the function returns successfully, and you specifiedMCL_CURRENT, all of the
process¡¯ pages are backed by (connected to) real frames (they are resident) and are
marked to stay that way. This means the function may cause page-ins and have to
wait for them.
When the process is inMCL_FUTUREmode because it successfully executed this func-
tion and specifiedMCL_CURRENT, any system call by the process that requires space
be added to its virtual address space fails witherrno=ENOMEMif locking the addi-
tional space would cause the process to exceed its locked page limit. In the case that
the address space addition that can¡¯t be accommodated is stack expansion, the stack
expansion fails and the kernel sends aSIGSEGVsignal to the process.
When the function fails, it does not affect the lock status of any pages or the future
locking mode.
The return value is zero if the function succeeds. Otherwise, it is-1anderrnois set
accordingly.errnovalues specific to this function are:
```
```
ENOMEM
```
- At least some of the specified address range does not exist in the
    calling process¡¯ virtual address space.
- The locking would cause the process to exceed its locked page limit.


Chapter 3: Virtual Memory Allocation And Paging 86

```
EPERM The calling process is not superuser.
EINVAL Undefined bits inflagsare not zero.
ENOSYS The kernel does not providemlockallcapability.
You can lock just specific pages withmlock. You unlock pages withmunlockalland
munlock.
```
int munlockall(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
munlockallunlocks every page in the calling process¡¯ virtual address space and turns
offMCL_FUTUREfuture locking mode.
The return value is zero if the function succeeds. Otherwise, it is-1anderrnois
set accordingly. The only way this function can fail is for generic reasons that all
functions and system calls can fail, so there are no specificerrnovalues.


### 87

## 4 Character Handling............................

## 4 Character Handling...................................

Programs that work with characters and strings often need to classify a character¡ªis it
alphabetic, is it a digit, is it whitespace, and so on¡ªand perform case conversion operations
on characters. The functions in the header filectype.hare provided for this purpose.

Since the choice of locale and character set can alter the classifications of particular
character codes, all of these functions are affected by the current locale. (More precisely,
they are affected by the locale currently selected for character classification¡ªtheLC_CTYPE
category; seeSection 7.3 [Locale Categories], page 184.)

The ISO C standard specifies two different sets of functions. The one set works onchar
type characters, the other one onwchar_twide characters (seeSection 6.1 [Introduction to
Extended Characters], page 140).

## 4.1 Classification of Characters....................................

This section explains the library functions for classifying characters. For example,isalpha
is the function to test for an alphabetic character. It takes one argument, the character to
test, and returns a nonzero integer if the character is alphabetic, and zero otherwise. You
would use it like this:
if (isalpha (c))
printf ("The character `%c' is alphabetic.\n", c);
Each of the functions in this section tests for membership in a particular class of char-
acters; each has a name starting with ¡®is¡¯. Each of them takes one argument, which is
a character to test, and returns anintwhich is treated as a boolean value. The charac-
ter argument is passed as anint, and it may be the constant valueEOFinstead of a real
character.

The attributes of any given character can vary between locales. SeeChapter 7 [Locales
and Internationalization], page 183, for more information on locales.

```
These functions are declared in the header filectype.h.
```
int islower(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a lower-case letter. The letter need not be from the Latin alphabet,
any alphabet representable is valid.

int isupper(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis an upper-case letter. The letter need not be from the Latin
alphabet, any alphabet representable is valid.

int isalpha(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis an alphabetic character (a letter). Ifislowerorisupperis true
of a character, thenisalphais also true.


Chapter 4: Character Handling 88

```
In some locales, there may be additional characters for whichisalphais true¡ªletters
which are neither upper case nor lower case. But in the standard"C"locale, there
are no such additional characters.
```
int isdigit(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a decimal digit (¡® 0 ¡¯ through ¡® 9 ¡¯).

int isalnum(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis an alphanumeric character (a letter or number); in other words,
if eitherisalphaorisdigitis true of a character, thenisalnumis also true.

int isxdigit (intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifc is a hexadecimal digit. Hexadecimal digits include the normal
decimal digits ¡® 0 ¡¯ through ¡® 9 ¡¯ and the letters ¡®A¡¯ through ¡®F¡¯ and ¡®a¡¯ through ¡®f¡¯.

int ispunct(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a punctuation character. This means any printing character that
is not alphanumeric or a space character.

int isspace(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifc is awhitespacecharacter. In the standard"C"locale,isspace
returns true for only the standard whitespace characters:

```
' ' space
```
```
'\f' formfeed
'\n' newline
```
```
'\r' carriage return
'\t' horizontal tab
```
```
'\v' vertical tab
```
int isblank(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a blank character; that is, a space or a tab. This function was
originally a GNU extension, but was added in ISO C99.


Chapter 4: Character Handling 89

int isgraph(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a graphic character; that is, a character that has a glyph associated
with it. The whitespace characters are not considered graphic.

int isprint(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a printing character. Printing characters include all the graphic
characters, plus the space (¡® ¡¯) character.

int iscntrl(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a control character (that is, a character that is not a printing
character).

int isascii(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns true ifcis a 7-bitunsigned charvalue that fits into the US/UK ASCII
character set. This function is a BSD extension and is also an SVID extension.

## 4.2 Case Conversion...............................................

This section explains the library functions for performing conversions such as case mappings
on characters. For example,toupperconverts any character to upper case if possible. If
the character can¡¯t be converted,toupperreturns it unchanged.

These functions take one argument of typeint, which is the character to convert, and
return the converted character as anint. If the conversion is not applicable to the argument
given, the argument is returned unchanged.

Compatibility Note: In pre-ISO C dialects, instead of returning the argument
unchanged, these functions may fail when the argument is not suitable for the conversion.
Thus for portability, you may need to writeislower(c)? toupper(c) : c rather than
justtoupper(c).

```
These functions are declared in the header filectype.h.
```
int tolower(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Ifcis an upper-case letter,tolowerreturns the corresponding lower-case letter. Ifc
is not an upper-case letter,cis returned unchanged.

int toupper(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 4: Character Handling 90

```
Ifcis a lower-case letter,toupperreturns the corresponding upper-case letter. Oth-
erwisecis returned unchanged.
```
int toascii(intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function convertscto a 7-bitunsigned charvalue that fits into the US/UK
ASCII character set, by clearing the high-order bits. This function is a BSD extension
and is also an SVID extension.

int _tolower (intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is identical totolower, and is provided for compatibility with the SVID. See
Section 1.2.4 [SVID (The System V Interface Description)], page 11.

int _toupper (intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is identical totoupper, and is provided for compatibility with the SVID.

## 4.3 Character class determination for wide characters..............

Amendment 1 to ISO C90 defines functions to classify wide characters. Although the orig-
inal ISO C90 standard already defined the typewchar_t, no functions operating on them
were defined.

The general design of the classification functions for wide characters is more general.
It allows extensions to the set of available classifications, beyond those which are always
available. The POSIX standard specifies how extensions can be made, and this is already
implemented in the GNU C Library implementation of thelocaledefprogram.

The character class functions are normally implemented with bitsets, with a bitset per
character. For a given character, the appropriate bitset is read from a table and a test is
performed as to whether a certain bit is set. Which bit is tested for is determined by the
class.

For the wide character classification functions this is made visible. There is a type
classification type defined, a function to retrieve this value for a given class, and a function
to test whether a given character is in this class, using the classification value. On top of
this the normal character classification functions as used forcharobjects can be defined.

wctype_t [Data type]
Thewctype_tcan hold a value which represents a character class. The only defined
way to generate such a value is by using thewctypefunction.
This type is defined inwctype.h.

wctype_t wctype (const char *property) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.


Chapter 4: Character Handling 91

```
wctypereturns a value representing a class of wide characters which is identified by
the stringproperty. Besides some standard properties each locale can define its own
ones. In case no property with the given name is known for the current locale selected
for theLC_CTYPEcategory, the function returns zero.
The properties known in every locale are:
"alnum" "alpha" "cntrl" "digit"
"graph" "lower" "print" "punct"
"space" "upper" "xdigit"
This function is declared inwctype.h.
```
To test the membership of a character to one of the non-standard classes the ISO C
standard defines a completely new function.

int iswctype (winttwc, wctypetdesc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns a nonzero value ifwcis in the character class specified bydesc.
descmust previously be returned by a successful call towctype.
This function is declared inwctype.h.

To make it easier to use the commonly-used classification functions, they are defined in
the C library. There is no need to usewctypeif the property string is one of the known
character classes. In some situations it is desirable to construct the property strings, and
then it is important thatwctypecan also handle the standard classes.

int iswalnum (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns a nonzero value ifwcis an alphanumeric character (a letter or
number); in other words, if eitheriswalphaoriswdigitis true of a character, then
iswalnumis also true.
This function can be implemented using
iswctype (wc, wctype ("alnum"))
It is declared inwctype.h.

int iswalpha (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwcis an alphabetic character (a letter). Ifiswloweroriswupperis
true of a character, theniswalphais also true.
In some locales, there may be additional characters for whichiswalphais true¡ª
letters which are neither upper case nor lower case. But in the standard"C"locale,
there are no such additional characters.
This function can be implemented using
iswctype (wc, wctype ("alpha"))
It is declared inwctype.h.


Chapter 4: Character Handling 92

int iswcntrl (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwcis a control character (that is, a character that is not a printing
character).
This function can be implemented using
iswctype (wc, wctype ("cntrl"))
It is declared inwctype.h.

int iswdigit (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwc is a digit (e.g., ¡® 0 ¡¯ through ¡® 9 ¡¯). Please note that this function
does not only return a nonzero value fordecimaldigits, but for all kinds of digits.
A consequence is that code like the following willnotwork unconditionally for wide
characters:
n = 0;
while (iswdigit (*wc))
{
n *= 10;
n += *wc++ - L'0';
}
This function can be implemented using
iswctype (wc, wctype ("digit"))
It is declared inwctype.h.

int iswgraph (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwcis a graphic character; that is, a character that has a glyph asso-
ciated with it. The whitespace characters are not considered graphic.
This function can be implemented using
iswctype (wc, wctype ("graph"))
It is declared inwctype.h.

int iswlower (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwc is a lower-case letter. The letter need not be from the Latin
alphabet, any alphabet representable is valid.
This function can be implemented using
iswctype (wc, wctype ("lower"))
It is declared inwctype.h.


Chapter 4: Character Handling 93

int iswprint (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwcis a printing character. Printing characters include all the graphic
characters, plus the space (¡® ¡¯) character.
This function can be implemented using
iswctype (wc, wctype ("print"))
It is declared inwctype.h.

int iswpunct (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwc is a punctuation character. This means any printing character
that is not alphanumeric or a space character.
This function can be implemented using
iswctype (wc, wctype ("punct"))
It is declared inwctype.h.

int iswspace (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwc is awhitespacecharacter. In the standard"C"locale,iswspace
returns true for only the standard whitespace characters:

```
L' ' space
```
```
L'\f' formfeed
```
```
L'\n' newline
L'\r' carriage return
```
```
L'\t' horizontal tab
```
```
L'\v' vertical tab
This function can be implemented using
iswctype (wc, wctype ("space"))
It is declared inwctype.h.
```
int iswupper (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwc is an upper-case letter. The letter need not be from the Latin
alphabet, any alphabet representable is valid.
This function can be implemented using
iswctype (wc, wctype ("upper"))
It is declared inwctype.h.


Chapter 4: Character Handling 94

int iswxdigit(winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwc is a hexadecimal digit. Hexadecimal digits include the normal
decimal digits ¡® 0 ¡¯ through ¡® 9 ¡¯ and the letters ¡®A¡¯ through ¡®F¡¯ and ¡®a¡¯ through ¡®f¡¯.
This function can be implemented using
iswctype (wc, wctype ("xdigit"))
It is declared inwctype.h.
The GNU C Library also provides a function which is not defined in the ISO C standard
but which is available as a version for single byte characters as well.

int iswblank (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Returns true ifwcis a blank character; that is, a space or a tab. This function was
originally a GNU extension, but was added in ISO C99. It is declared inwchar.h.

## 4.4 Notes on using the wide character classes......................

The first note is probably not astonishing but still occasionally a cause of problems. The
iswXXXfunctions can be implemented using macros and in fact, the GNU C Library does
this. They are still available as real functions but when thewctype.hheader is included
the macros will be used. This is the same as thechartype versions of these functions.

The second note covers something new. It can be best illustrated by a (real-world)
example. The first piece of code is an excerpt from the original code. It is truncated a bit
but the intention should be clear.
int
is_in_class (int c, const char *class)
{
if (strcmp (class, "alnum") == 0)
return isalnum (c);
if (strcmp (class, "alpha") == 0)
return isalpha (c);
if (strcmp (class, "cntrl") == 0)
return iscntrl (c);
...
return 0;
}
Now, with thewctypeandiswctypeyou can avoid theifcascades, but rewriting the
code as follows is wrong:
int
is_in_class (int c, const char *class)
{
wctype_t desc = wctype (class);
return desc? iswctype ((wint_t) c, desc) : 0;
}
The problem is that it is not guaranteed that the wide character representation of a
single-byte character can be found using casting. In fact, usually this fails miserably. The
correct solution to this problem is to write the code as follows:
int


Chapter 4: Character Handling 95

is_in_class (int c, const char *class)
{
wctype_t desc = wctype (class);
return desc? iswctype (btowc (c), desc) : 0;
}
SeeSection 6.3.3 [Converting Single Characters], page 146, for more information on
btowc. Note that this change probably does not improve the performance of the program
a lot since thewctypefunction still has to make the string comparisons. It gets really
interesting if theis_in_classfunction is called more than once for the same class name.
In this case the variabledesccould be computed once and reused for all the calls. Therefore
the above form of the function is probably not the final one.

## 4.5 Mapping of wide characters....................................

The classification functions are also generalized by the ISO C standard. Instead of just
allowing the two standard mappings, a locale can contain others. Again, thelocaledef
program already supports generating such locale data files.

wctrans_t [Data Type]
This data type is defined as a scalar type which can hold a value representing the
locale-dependent character mapping. There is no way to construct such a value apart
from using the return value of thewctransfunction.
This type is defined inwctype.h.

wctrans_t wctrans(const char *property) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewctransfunction has to be used to find out whether a named mapping is defined
in the current locale selected for theLC_CTYPEcategory. If the returned value is non-
zero, you can use it afterwards in calls totowctrans. If the return value is zero no
such mapping is known in the current locale.
Beside locale-specific mappings there are two mappings which are guaranteed to be
available in every locale:
"tolower" "toupper"
These functions are declared inwctype.h.

wint_t towctrans (winttwc, wctranstdesc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
towctransmaps the input characterwc according to the rules of the mapping for
whichdescis a descriptor, and returns the value it finds. descmust be obtained by
a successful call towctrans.
This function is declared inwctype.h.

For the generally available mappings, the ISO C standard defines convenient shortcuts
so that it is not necessary to callwctransfor them.


Chapter 4: Character Handling 96

wint_t towlower (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Ifwc is an upper-case letter,towlowerreturns the corresponding lower-case letter.
Ifwcis not an upper-case letter,wcis returned unchanged.
towlowercan be implemented using
towctrans (wc, wctrans ("tolower"))
This function is declared inwctype.h.

wint_t towupper (winttwc) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Ifwc is a lower-case letter,towupperreturns the corresponding upper-case letter.
Otherwisewcis returned unchanged.
towuppercan be implemented using
towctrans (wc, wctrans ("toupper"))
This function is declared inwctype.h.

The same warnings given in the last section for the use of the wide character classification
functions apply here. It is not possible to simply cast achartype value to awint_tand
use it as an argument totowctranscalls.


### 97

## 5 String and Array Utilities.....................

## 5 String and Array Utilities..............................

Operations on strings (null-terminated byte sequences) are an important part of many
programs. The GNU C Library provides an extensive set of string utility functions, including
functions for copying, concatenating, comparing, and searching strings. Many of these
functions can also operate on arbitrary regions of storage; for example, thememcpyfunction
can be used to copy the contents of any kind of array.

It¡¯s fairly common for beginning C programmers to ¡°reinvent the wheel¡± by duplicating
this functionality in their own code, but it pays to become familiar with the library functions
and to make use of them, since this offers benefits in maintenance, efficiency, and portability.

For instance, you could easily compare one string to another in two lines of C code, but
if you use the built-instrcmpfunction, you¡¯re less likely to make a mistake. And, since
these library functions are typically highly optimized, your program may run faster too.

## 5.1 Representation of Strings......................................

This section is a quick summary of string concepts for beginning C programmers. It de-
scribes how strings are represented in C and some common pitfalls. If you are already
familiar with this material, you can skip this section.

Astring is a null-terminated array of bytes of typechar, including the terminating
null byte. String-valued variables are usually declared to be pointers of typechar *. Such
variables do not include space for the text of a string; that has to be stored somewhere else¡ª
in an array variable, a string constant, or dynamically allocated memory (seeSection 3.2
[Allocating Storage For Program Data], page 43). It¡¯s up to you to store the address of the
chosen memory space into the pointer variable. Alternatively you can store anull pointerin
the pointer variable. The null pointer does not point anywhere, so attempting to reference
the string it points to gets an error.

Amultibyte characteris a sequence of one or more bytes that represents a single character
using the locale¡¯s encoding scheme; a null byte always represents the null character. A
multibyte stringis a string that consists entirely of multibyte characters. In contrast, a
wide string is a null-terminated sequence ofwchar_tobjects. A wide-string variable is
usually declared to be a pointer of typewchar_t *, by analogy with string variables and
char *. SeeSection 6.1 [Introduction to Extended Characters], page 140.

By convention, thenull byte,'\0', marks the end of a string and thenull wide character,
L'\0', marks the end of a wide string. For example, in testing to see whether thechar *
variableppoints to a null byte marking the end of a string, you can write!*por*p==
'\0'.

A null byte is quite different conceptually from a null pointer, although both are repre-
sented by the integer constant 0.

Astring literalappears in C program source as a multibyte string between double-quote
characters (¡®"¡¯). If the initial double-quote character is immediately preceded by a capital ¡®L¡¯
(ell) character (as inL"foo"), it is a wide string literal. String literals can also contribute to
string concatenation:"a" "b"is the same as"ab". For wide strings one can use eitherL"a"
L"b"orL"a" "b". Modification of string literals is not allowed by the GNU C compiler,
because literals are placed in read-only storage.


Chapter 5: String and Array Utilities 98

Arrays that are declaredconstcannot be modified either. It¡¯s generally good style to
declare non-modifiable string pointers to be of typeconst char *, since this often allows
the C compiler to detect accidental modifications as well as providing some amount of
documentation about what your program intends to do with the string.

The amount of memory allocated for a byte array may extend past the null byte that
marks the end of the string that the array contains. In this document, the termallocated
sizeis always used to refer to the total amount of memory allocated for an array, while the
termlengthrefers to the number of bytes up to (but not including) the terminating null
byte. Wide strings are similar, except their sizes and lengths count wide characters, not
bytes.

A notorious source of program bugs is trying to put more bytes into a string than fit
in its allocated size. When writing code that extends strings or moves bytes into a pre-
allocated array, you should be very careful to keep track of the length of the text and make
explicit checks for overflowing the array. Many of the library functionsdo notdo this for
you! Remember also that you need to allocate an extra byte to hold the null byte that
marks the end of the string.

Originally strings were sequences of bytes where each byte represented a single character.
This is still true today if the strings are encoded using a single-byte character encoding.
Things are different if the strings are encoded using a multibyte encoding (for more informa-
tion on encodings seeSection 6.1 [Introduction to Extended Characters], page 140). There
is no difference in the programming interface for these two kind of strings; the programmer
has to be aware of this and interpret the byte sequences accordingly.

But since there is no separate interface taking care of these differences the byte-based
string functions are sometimes hard to use. Since the count parameters of these functions
specify bytes a call tomemcpycould cut a multibyte character in the middle and put an
incomplete (and therefore unusable) byte sequence in the target buffer.

To avoid these problems later versions of the ISO C standard introduce a second set of
functions which are operating onwide characters(seeSection 6.1 [Introduction to Extended
Characters], page 140). These functions don¡¯t have the problems the single-byte versions
have since every wide character is a legal, interpretable value. This does not mean that
cutting wide strings at arbitrary points is without problems. It normally is for alphabet-
based languages (except for non-normalized text) but languages based on syllables still have
the problem that more than one wide character is necessary to complete a logical unit. This
is a higher level problem which the C library functions are not designed to solve. But it is
at least good that no invalid byte sequences can be created. Also, the higher level functions
can also much more easily operate on wide characters than on multibyte characters so that
a common strategy is to use wide characters internally whenever text is more than simply
copied.

The remaining of this chapter will discuss the functions for handling wide strings in
parallel with the discussion of strings since there is almost always an exact equivalent
available.

## 5.2 String and Array Conventions.................................

This chapter describes both functions that work on arbitrary arrays or blocks of memory,
and functions that are specific to strings and wide strings.


Chapter 5: String and Array Utilities 99

Functions that operate on arbitrary blocks of memory have names beginning with ¡®mem¡¯
and ¡®wmem¡¯ (such asmemcpyandwmemcpy) and invariably take an argument which specifies
the size (in bytes and wide characters respectively) of the block of memory to operate on.
The array arguments and return values for these functions have typevoid *orwchar_t.
As a matter of style, the elements of the arrays used with the ¡®mem¡¯ functions are referred to
as ¡°bytes¡±. You can pass any kind of pointer to these functions, and thesizeofoperator
is useful in computing the value for the size argument. Parameters to the ¡®wmem¡¯ functions
must be of typewchar_t *. These functions are not really usable with anything but arrays
of this type.

In contrast, functions that operate specifically on strings and wide strings have names
beginning with ¡®str¡¯ and ¡®wcs¡¯ respectively (such asstrcpyandwcscpy) and look for a
terminating null byte or null wide character instead of requiring an explicit size argument to
be passed. (Some of these functions accept a specified maximum length, but they also check
for premature termination.) The array arguments and return values for these functions have
typechar *andwchar_t *respectively, and the array elements are referred to as ¡°bytes¡±
and ¡°wide characters¡±.

In many cases, there are both ¡®mem¡¯ and ¡®str¡¯/¡®wcs¡¯ versions of a function. The one that
is more appropriate to use depends on the exact situation. When your program is manipu-
lating arbitrary arrays or blocks of storage, then you should always use the ¡®mem¡¯ functions.
On the other hand, when you are manipulating strings it is usually more convenient to use
the ¡®str¡¯/¡®wcs¡¯ functions, unless you already know the length of the string in advance. The
¡®wmem¡¯ functions should be used for wide character arrays with known size.

Some of the memory and string functions take single characters as arguments. Since
a value of typecharis automatically promoted into a value of typeintwhen used as a
parameter, the functions are declared withintas the type of the parameter in question. In
case of the wide character functions the situation is similar: the parameter type for a single
wide character iswint_tand notwchar_t. This would for many implementations not be
necessary sincewchar_tis large enough to not be automatically promoted, but since the
ISO C standard does not require such a choice of types thewint_ttype is used.

## 5.3 String Length.................................................

You can get the length of a string using thestrlenfunction. This function is declared in
the header filestring.h.

size_t strlen(const char *s) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrlenfunction returns the length of the stringsin bytes. (In other words, it
returns the offset of the terminating null byte within the array.)
For example,
strlen ("hello, world")
? 12
When applied to an array, thestrlenfunction returns the length of the string stored
there, not its allocated size. You can get the allocated size of the array that holds a
string using thesizeofoperator:
char string[32] = "hello, world";


Chapter 5: String and Array Utilities 100

```
sizeof (string)
? 32
strlen (string)
? 12
But beware, this will not work unlessstring is the array itself, not a pointer to it.
For example:
char string[32] = "hello, world";
char *ptr = string;
sizeof (string)
? 32
sizeof (ptr)
?4 /*(on a machine with 4 byte pointers)*/
This is an easy mistake to make when you are working with functions that take string
arguments; those arguments are always pointers, not arrays.
It must also be noted that for multibyte encoded strings the return value does not
have to correspond to the number of characters in the string. To get this value the
string can be converted to wide characters andwcslencan be used or something like
the following code can be used:
/*The input is instring.
The length is expected inn. */
{
mbstate_t t;
char *scopy = string;
/* In initial state. */
memset (&t, '\0', sizeof (t));
/* Determine number of characters. */
n = mbsrtowcs (NULL, &scopy, strlen (scopy), &t);
}
This is cumbersome to do so if the number of characters (as opposed to bytes) is
needed often it is better to work with wide characters.
```
```
The wide character equivalent is declared inwchar.h.
```
size_t wcslen(const wchart *ws) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcslenfunction is the wide character equivalent tostrlen. The return value is
the number of wide characters in the wide string pointed to byws(this is also the
offset of the terminating null wide character ofws).
Since there are no multi wide character sequences making up one wide character the
return value is not only the offset in the array, it is also the number of wide characters.
This function was introduced in Amendment 1 to ISO C90.

size_t strnlen(const char *s, size tmaxlen) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If the arraysof sizemaxlencontains a null byte, thestrnlenfunction returns the
length of the stringsin bytes. Otherwise it returnsmaxlen. Therefore this function is
equivalent to(strlen (s) <maxlen? strlen (s) :maxlen)but it is more efficient


Chapter 5: String and Array Utilities 101

```
and works even ifsis not null-terminated so long asmaxlendoes not exceed the size
ofs¡¯s array.
char string[32] = "hello, world";
strnlen (string, 32)
? 12
strnlen (string, 5)
? 5
This function is a GNU extension and is declared instring.h.
```
size_t wcsnlen(const wchart *ws, sizetmaxlen) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
wcsnlenis the wide character equivalent tostrnlen. Themaxlenparameter specifies
the maximum number of wide characters.
This function is a GNU extension and is declared inwchar.h.

## 5.4 Copying Strings and Arrays..................................

You can use the functions described in this section to copy the contents of strings, wide
strings, and arrays. The ¡®str¡¯ and ¡®mem¡¯ functions are declared instring.hwhile the ¡®w¡¯
functions are declared inwchar.h.

A helpful way to remember the ordering of the arguments to the functions in this section
is that it corresponds to an assignment expression, with the destination array specified to
the left of the source array. Most of these functions return the address of the destination
array; a few return the address of the destination¡¯s terminating null, or of just past the
destination.

Most of these functions do not work properly if the source and destination arrays overlap.
For example, if the beginning of the destination array overlaps the end of the source array,
the original contents of that part of the source array may get overwritten before it is copied.
Even worse, in the case of the string functions, the null byte marking the end of the string
may be lost, and the copy function might get stuck in a loop trashing all the memory
allocated to your program.

All functions that have problems copying between overlapping arrays are explicitly iden-
tified in this manual. In addition to functions in this section, there are a few others like
sprintf(see Section 12.12.7 [Formatted Output Functions], page 296) and scanf(see
Section 12.14.8 [Formatted Input Functions], page 318).

void * memcpy(void *restrictto, const void *restrictfrom, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thememcpyfunction copiessize bytes from the object beginning atfrominto the
object beginning atto. The behavior of this function is undefined if the two arrays
toandfromoverlap; usememmoveinstead if overlapping is possible.
The value returned bymemcpyis the value ofto.
Here is an example of how you might usememcpyto copy the contents of an array:
struct foo *oldarray, *newarray;


Chapter 5: String and Array Utilities 102

```
int arraysize;
...
memcpy (new, old, arraysize * sizeof (struct foo));
```
wchar_t * wmemcpy(wchart *restrictwto, const wchart *restrict [Function]
wfrom, sizetsize)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewmemcpyfunction copiessizewide characters from the object beginning atwfrom
into the object beginning atwto. The behavior of this function is undefined if the
two arrayswtoandwfromoverlap; usewmemmoveinstead if overlapping is possible.
The following is a possible implementation ofwmemcpybut there are more optimiza-
tions possible.
wchar_t *
wmemcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
size_t size)
{
return (wchar_t *) memcpy (wto, wfrom, size * sizeof (wchar_t));
}
The value returned bywmemcpyis the value ofwto.
This function was introduced in Amendment 1 to ISO C90.

void * mempcpy(void *restrictto, const void *restrictfrom, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themempcpyfunction is nearly identical to thememcpyfunction. It copiessizebytes
from the object beginning atfrominto the object pointed to byto. But instead of
returning the value oftoit returns a pointer to the byte following the last written byte
in the object beginning atto. I.e., the value is((void *) ((char *)to+size)).
This function is useful in situations where a number of objects shall be copied to
consecutive memory positions.
void *
combine (void *o1, size_t s1, void *o2, size_t s2)
{
void *result = malloc (s1 + s2);
if (result != NULL)
mempcpy (mempcpy (result, o1, s1), o2, s2);
return result;
}
This function is a GNU extension.

wchar_t * wmempcpy(wchart *restrictwto, const wchar t *restrict [Function]
wfrom, sizetsize)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewmempcpyfunction is nearly identical to thewmemcpyfunction. It copiessize
wide characters from the object beginning atwfrominto the object pointed to by
wto. But instead of returning the value of wtoit returns a pointer to the wide


Chapter 5: String and Array Utilities 103

```
character following the last written wide character in the object beginning atwto.
I.e., the value iswto+size.
This function is useful in situations where a number of objects shall be copied to
consecutive memory positions.
The following is a possible implementation ofwmemcpybut there are more optimiza-
tions possible.
wchar_t *
wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
size_t size)
{
return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
}
This function is a GNU extension.
```
void * memmove(void *to, const void *from, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
memmovecopies thesizebytes at frominto thesizebytes atto, even if those two
blocks of space overlap. In the case of overlap,memmoveis careful to copy the original
values of the bytes in the block atfrom, including those bytes which also belong to
the block atto.
The value returned bymemmoveis the value ofto.

wchar_t * wmemmove(wchart *wto, const wchart *wfrom, size t [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
wmemmovecopies thesizewide characters atwfrominto thesizewide characters at
wto, even if those two blocks of space overlap. In the case of overlap, wmemmove
is careful to copy the original values of the wide characters in the block atwfrom,
including those wide characters which also belong to the block atwto.
The following is a possible implementation ofwmemcpybut there are more optimiza-
tions possible.
wchar_t *
wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
size_t size)
{
return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
}
The value returned bywmemmoveis the value ofwto.
This function is a GNU extension.

void * memccpy(void *restrictto, const void *restrictfrom, intc, [Function]
sizetsize)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function copies no more thansizebytes fromfromtoto, stopping if a byte
matchingcis found. The return value is a pointer intotoone byte past wherecwas
copied, or a null pointer if no byte matchingcappeared in the firstsizebytes offrom.


Chapter 5: String and Array Utilities 104

void * memset(void *block, intc, size tsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function copies the value ofc(converted to anunsigned char) into each of the
firstsizebytes of the object beginning atblock. It returns the value ofblock.

wchar_t * wmemset(wchart *block, wchartwc, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function copies the value ofwcinto each of the firstsizewide characters of the
object beginning atblock. It returns the value ofblock.

char * strcpy(char *restrictto, const char *restrictfrom) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This copies bytes from the stringfrom (up to and including the terminating null
byte) into the stringto. Likememcpy, this function has undefined results if the strings
overlap. The return value is the value ofto.

wchar_t * wcscpy (wchart *restrictwto, const wchart *restrict [Function]
wfrom)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This copies wide characters from the wide stringwfrom(up to and including the
terminating null wide character) into the stringwto. Likewmemcpy, this function has
undefined results if the strings overlap. The return value is the value ofwto.

char * strdup(const char *s) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function copies the stringsinto a newly allocated string. The string is allocated
usingmalloc; seeSection 3.2.3 [Unconstrained Allocation], page 45. Ifmalloccannot
allocate space for the new string,strdupreturns a null pointer. Otherwise it returns
a pointer to the new string.

wchar_t * wcsdup (const wchart *ws) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function copies the wide stringwsinto a newly allocated string. The string is al-
located usingmalloc; seeSection 3.2.3 [Unconstrained Allocation], page 45. Ifmalloc
cannot allocate space for the new string,wcsdupreturns a null pointer. Otherwise it
returns a pointer to the new wide string.
This function is a GNU extension.

char * stpcpy(char *restrictto, const char *restrictfrom) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 5: String and Array Utilities 105

```
This function is likestrcpy, except that it returns a pointer to the end of the string
to(that is, the address of the terminating null byteto + strlen (from)) rather than
the beginning.
For example, this program usesstpcpyto concatenate ¡®foo¡¯ and ¡®bar¡¯ to produce
¡®foobar¡¯, which it then prints.
```
```
#include <string.h>
#include <stdio.h>
```
```
int
main (void)
{
char buffer[10];
char *to = buffer;
to = stpcpy (to, "foo");
to = stpcpy (to, "bar");
puts (buffer);
return 0;
}
This function is part of POSIX.1-2008 and later editions, but was available in the
GNU C Library and other systems as an extension long before it was standardized.
Its behavior is undefined if the strings overlap. The function is declared instring.h.
```
wchar_t * wcpcpy (wchart *restrictwto, const wchart *restrict [Function]
wfrom)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is likewcscpy, except that it returns a pointer to the end of the
stringwto(that is, the address of the terminating null wide characterwto + wcslen
(wfrom)) rather than the beginning.
This function is not part of ISO or POSIX but was found useful while developing the
GNU C Library itself.
The behavior ofwcpcpyis undefined if the strings overlap.
wcpcpyis a GNU extension and is declared inwchar.h.

char * strdupa(const char *s) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro is similar tostrdupbut allocates the new string usingallocainstead
ofmalloc(seeSection 3.2.7 [Automatic Storage with Variable Size], page 74). This
means of course the returned string has the same limitations as any block of memory
allocated usingalloca.
For obvious reasonsstrdupais implemented only as a macro; you cannot get the
address of this function. Despite this limitation it is a useful function. The following
code shows a situation where usingmallocwould be a lot more expensive.

```
#include <paths.h>
#include <string.h>
#include <stdio.h>
```

Chapter 5: String and Array Utilities 106

```
const char path[] = _PATH_STDPATH;
```
```
int
main (void)
{
char *wr_path = strdupa (path);
char *cp = strtok (wr_path, ":");
```
```
while (cp != NULL)
{
puts (cp);
cp = strtok (NULL, ":");
}
return 0;
}
Please note that callingstrtok usingpathdirectly is invalid. It is also not al-
lowed to callstrdupain the argument list ofstrtoksincestrdupausesalloca(see
Section 3.2.7 [Automatic Storage with Variable Size], page 74) can interfere with the
parameter passing.
This function is only available if GNU CC is used.
```
void bcopy(const void *from, void *to, size tsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is a partially obsolete alternative formemmove, derived from BSD. Note that it
is not quite equivalent tomemmove, because the arguments are not in the same order
and there is no return value.

void bzero(void *block, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is a partially obsolete alternative formemset, derived from BSD. Note that it is
not as general asmemset, because the only value it can store is zero.

## 5.5 Concatenating Strings........................................

The functions described in this section concatenate the contents of a string or wide string
to another. They follow the string-copying functions in their conventions. SeeSection 5.4
[Copying Strings and Arrays], page 101. ¡®strcat¡¯ is declared in the header filestring.h
while ¡®wcscat¡¯ is declared inwchar.h.

char * strcat(char *restrictto, const char *restrictfrom) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrcatfunction is similar tostrcpy, except that the bytes fromfromare con-
catenated or appended to the end ofto, instead of overwriting it. That is, the first
byte fromfromoverwrites the null byte marking the end ofto.
An equivalent definition forstrcatwould be:
char *


Chapter 5: String and Array Utilities 107

```
strcat (char *restrict to, const char *restrict from)
{
strcpy (to + strlen (to), from);
return to;
}
This function has undefined results if the strings overlap.
As noted below, this function has significant performance issues.
```
wchar_t * wcscat (wchart *restrictwto, const wchart *restrict [Function]
wfrom)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcscatfunction is similar towcscpy, except that the wide characters fromwfrom
are concatenated or appended to the end ofwto, instead of overwriting it. That is,
the first wide character fromwfromoverwrites the null wide character marking the
end ofwto.
An equivalent definition forwcscatwould be:
wchar_t *
wcscat (wchar_t *wto, const wchar_t *wfrom)
{
wcscpy (wto + wcslen (wto), wfrom);
return wto;
}
This function has undefined results if the strings overlap.
As noted below, this function has significant performance issues.

Programmers using thestrcatorwcscatfunction (or thestrncatorwcsncatfunctions
defined in a later section, for that matter) can easily be recognized as lazy and reckless.
In almost all situations the lengths of the participating strings are known (it better should
be since how can one otherwise ensure the allocated size of the buffer is sufficient?) Or at
least, one could know them if one keeps track of the results of the various function calls.
But then it is very inefficient to usestrcat/wcscat. A lot of time is wasted finding the end
of the destination string so that the actual copying can start. This is a common example:
/*This function concatenates arbitrarily many strings. The last
parameter must beNULL. */
char *
concat (const char *str, ...)
{
va_list ap, ap2;
size_t total = 1;
const char *s;
char *result;

```
va_start (ap, str);
va_copy (ap2, ap);
```
```
/*Determine how much space we need. */
for (s = str; s != NULL; s = va_arg (ap, const char *))
total += strlen (s);
```
```
va_end (ap);
```

Chapter 5: String and Array Utilities 108

```
result = (char *) malloc (total);
if (result != NULL)
{
result[0] = '\0';
```
```
/*Copy the strings. */
for (s = str; s != NULL; s = va_arg (ap2, const char *))
strcat (result, s);
}
```
```
va_end (ap2);
```
return result;
}
This looks quite simple, especially the second loop where the strings are actually copied.
But these innocent lines hide a major performance penalty. Just imagine that ten strings
of 100 bytes each have to be concatenated. For the second string we search the already
stored 100 bytes for the end of the string so that we can append the next string. For all
strings in total the comparisons necessary to find the end of the intermediate results sums
up to 5500! If we combine the copying with the search for the allocation we can write this
function more efficiently:

```
char *
concat (const char *str, ...)
{
va_list ap;
size_t allocated = 100;
char *result = (char *) malloc (allocated);
```
```
if (result != NULL)
{
char *newp;
char *wp;
const char *s;
```
```
va_start (ap, str);
```
```
wp = result;
for (s = str; s != NULL; s = va_arg (ap, const char *))
{
size_t len = strlen (s);
```
```
/*Resize the allocated memory if necessary. */
if (wp + len + 1 > result + allocated)
{
allocated = (allocated + len) * 2;
newp = (char *) realloc (result, allocated);
if (newp == NULL)
{
free (result);
return NULL;
}
wp = newp + (wp - result);
result = newp;
}
```
```
wp = mempcpy (wp, s, len);
```

Chapter 5: String and Array Utilities 109

```
}
```
```
/*Terminate the result string. */
*wp++ = '\0';
```
```
/*Resize memory to the optimal size. */
newp = realloc (result, wp - result);
if (newp != NULL)
result = newp;
```
```
va_end (ap);
}
```
return result;
}
With a bit more knowledge about the input strings one could fine-tune the memory
allocation. The difference we are pointing to here is that we don¡¯t usestrcatanymore. We
always keep track of the length of the current intermediate result so we can save ourselves
the search for the end of the string and usemempcpy. Please note that we also don¡¯t use
stpcpy which might seem more natural since we are handling strings. But this is not
necessary since we already know the length of the string and therefore can use the faster
memory copying function. The example would work for wide characters the same way.

Whenever a programmer feels the need to usestrcatshe or he should think twice and
look through the program to see whether the code cannot be rewritten to take advantage
of already calculated results. Again: it is almost always unnecessary to usestrcat.

## 5.6 Truncating Strings while Copying.............................

The functions described in this section copy or concatenate the possibly-truncated contents
of a string or array to another, and similarly for wide strings. They follow the string-
copying functions in their header conventions. SeeSection 5.4 [Copying Strings and Arrays],
page 101. The ¡®str¡¯ functions are declared in the header filestring.hand the ¡®wc¡¯ functions
are declared in the filewchar.h.

char * strncpy(char *restrictto, const char *restrictfrom, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tostrcpybut always copies exactlysizebytes intoto.
Iffromdoes not contain a null byte in its firstsizebytes,strncpycopies just the first
sizebytes. In this case no null terminator is written intoto.
Otherwisefrommust be a string with length less thansize. In this casestrncpy
copies all offrom, followed by enough null bytes to add up tosizebytes in all.
The behavior ofstrncpyis undefined if the strings overlap.
This function was designed for now-rarely-used arrays consisting of non-null bytes
followed by zero or more null bytes. It needs to set allsizebytes of the destination,
even whensizeis much greater than the length offrom. As noted below, this function
is generally a poor choice for processing text.


Chapter 5: String and Array Utilities 110

wchar_t * wcsncpy(wchart *restrictwto, const wchart *restrict [Function]
wfrom, sizetsize)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar towcscpybut always copies exactlysizewide characters into
wto.
Ifwfromdoes not contain a null wide character in its firstsizewide characters, then
wcsncpycopies just the firstsizewide characters. In this case no null terminator is
written intowto.
Otherwisewfrommust be a wide string with length less thansize. In this casewcsncpy
copies all ofwfrom, followed by enough null wide characters to add up tosizewide
characters in all.
The behavior ofwcsncpyis undefined if the strings overlap.
This function is the wide-character counterpart ofstrncpyand suffers from most
of the problems thatstrncpydoes. For example, as noted below, this function is
generally a poor choice for processing text.

char * strndup(const char *s, size tsize) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function is similar tostrdupbut always copies at mostsizebytes into the newly
allocated string.
If the length ofsis more thansize, thenstrndupcopies just the firstsizebytes and
adds a closing null byte. Otherwise all bytes are copied and the string is terminated.
This function differs fromstrncpyin that it always terminates the destination string.
As noted below, this function is generally a poor choice for processing text.
strndupis a GNU extension.

char * strndupa (const char *s, sizetsize) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tostrndupbut likestrdupait allocates the new string using
allocaseeSection 3.2.7 [Automatic Storage with Variable Size], page 74. The same
advantages and limitations ofstrdupaare valid forstrndupa, too.
This function is implemented only as a macro, just likestrdupa. Just asstrdupa
this macro also must not be used inside the parameter list in a function call.
As noted below, this function is generally a poor choice for processing text.
strndupais only available if GNU CC is used.

char * stpncpy(char *restrictto, const char *restrictfrom, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tostpcpybut copies always exactlysizebytes intoto.


Chapter 5: String and Array Utilities 111

```
If the length offromis more thansize, thenstpncpycopies just the firstsizebytes
and returns a pointer to the byte directly following the one which was copied last.
Note that in this case there is no null terminator written intoto.
If the length offromis less thansize, thenstpncpycopies all offrom, followed by
enough null bytes to add up tosizebytes in all. This behavior is rarely useful, but it
is implemented to be useful in contexts where this behavior of thestrncpyis used.
stpncpyreturns a pointer to thefirstwritten null byte.
This function is not part of ISO or POSIX but was found useful while developing the
GNU C Library itself.
Its behavior is undefined if the strings overlap. The function is declared instring.h.
As noted below, this function is generally a poor choice for processing text.
```
wchar_t * wcpncpy(wchart *restrictwto, const wchart *restrict [Function]
wfrom, sizetsize)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar towcpcpybut copies always exactlywsizewide characters
intowto.
If the length ofwfromis more thansize, thenwcpncpycopies just the firstsizewide
characters and returns a pointer to the wide character directly following the last non-
null wide character which was copied last. Note that in this case there is no null
terminator written intowto.
If the length ofwfromis less thansize, thenwcpncpycopies all ofwfrom, followed by
enough null wide characters to add up tosizewide characters in all. This behavior is
rarely useful, but it is implemented to be useful in contexts where this behavior of the
wcsncpyis used.wcpncpyreturns a pointer to thefirstwritten null wide character.
This function is not part of ISO or POSIX but was found useful while developing the
GNU C Library itself.
Its behavior is undefined if the strings overlap.
As noted below, this function is generally a poor choice for processing text.
wcpncpyis a GNU extension.

char * strncat(char *restrictto, const char *restrictfrom, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is likestrcat except that not more thansize bytes fromfromare
appended to the end ofto, andfromneed not be null-terminated. A single null byte
is also always appended toto, so the total allocated size oftomust be at leastsize
+ 1bytes longer than its initial length.
Thestrncatfunction could be implemented like this:


Chapter 5: String and Array Utilities 112

```
char *
strncat (char *to, const char *from, size_t size)
{
size_t len = strlen (to);
memcpy (to + len, from, strnlen (from, size));
to[len + strnlen (from, size)] = '\0';
return to;
}
The behavior ofstrncatis undefined if the strings overlap.
As a companion tostrncpy,strncatwas designed for now-rarely-used arrays con-
sisting of non-null bytes followed by zero or more null bytes. As noted below, this
function is generally a poor choice for processing text. Also, this function has signif-
icant performance issues. SeeSection 5.5 [Concatenating Strings], page 106.
```
wchar_t * wcsncat(wchart *restrictwto, const wchart *restrict [Function]
wfrom, sizetsize)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is likewcscatexcept that not more thansizewide characters fromfrom
are appended to the end ofto, andfromneed not be null-terminated. A single null
wide character is also always appended toto, so the total allocated size oftomust be
at leastwcsnlen (wfrom,size) + 1wide characters longer than its initial length.
Thewcsncatfunction could be implemented like this:
wchar_t *
wcsncat (wchar_t *restrict wto, const wchar_t *restrict wfrom,
size_t size)
{
size_t len = wcslen (wto);
memcpy (wto + len, wfrom, wcsnlen (wfrom, size) * sizeof (wchar_t));
wto[len + wcsnlen (wfrom, size)] = L'\0';
return wto;
}
The behavior ofwcsncatis undefined if the strings overlap.
As noted below, this function is generally a poor choice for processing text. Also, this
function has significant performance issues. SeeSection 5.5 [Concatenating Strings],
page 106.

Because these functions can abruptly truncate strings or wide strings, they are generally
poor choices for processing text. When coping or concatening multibyte strings, they can
truncate within a multibyte character so that the result is not a valid multibyte string.
When combining or concatenating multibyte or wide strings, they may truncate the output
after a combining character, resulting in a corrupted grapheme. They can cause bugs even
when processing single-byte strings: for example, when calculating an ASCII-only user
name, a truncated name can identify the wrong user.

Although some buffer overruns can be prevented by manually replacing calls to copying
functions with calls to truncation functions, there are often easier and safer automatic tech-
niques that cause buffer overruns to reliably terminate a program, such as GCC¡¯s-fcheck-
pointer-boundsand-fsanitize=addressoptions. SeeSection ¡°Options for Debugging
Your Program or GCC¡± inUsing GCC. Because truncation functions can mask application


Chapter 5: String and Array Utilities 113

bugs that would otherwise be caught by the automatic techniques, these functions should
be used only when the application¡¯s underlying logic requires truncation.

Note: GNU programs should not truncate strings or wide strings to fit arbitrary size
limits. SeeSection ¡°Writing Robust Programs¡± inThe GNU Coding Standards. Instead
of string-truncation functions, it is usually better to use dynamic memory allocation (see
Section 3.2.3 [Unconstrained Allocation], page 45) and functions such asstrduporasprintf
to construct strings.

## 5.7 String/Array Comparison....................................

You can use the functions in this section to perform comparisons on the contents of strings
and arrays. As well as checking for equality, these functions can also be used as the ordering
functions for sorting operations. SeeChapter 9 [Searching and Sorting], page 228, for an
example of this.

Unlike most comparison operations in C, the string comparison functions return a
nonzero value if the strings arenot equivalent rather than if they are. The sign of the
value indicates the relative ordering of the first part of the strings that are not equivalent:
a negative value indicates that the first string is ¡°less¡± than the second, while a positive
value indicates that the first string is ¡°greater¡±.

The most common use of these functions is to check only for equality. This is canonically
done with an expression like ¡®! strcmp (s1, s2)¡¯.

```
All of these functions are declared in the header filestring.h.
```
int memcmp(const void *a1, const void *a2, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionmemcmpcompares thesize bytes of memory beginning ata1 against
thesizebytes of memory beginning ata2. The value returned has the same sign as
the difference between the first differing pair of bytes (interpreted asunsigned char
objects, then promoted toint).
If the contents of the two blocks are equal,memcmpreturns 0.

int wmemcmp(const wchart *a1, const wchart *a2, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionwmemcmpcompares thesizewide characters beginning ata1against the
sizewide characters beginning ata2. The value returned is smaller than or larger
than zero depending on whether the first differing wide character isa1is smaller or
larger than the corresponding wide character ina2.
If the contents of the two blocks are equal,wmemcmpreturns 0.

On arbitrary arrays, thememcmpfunction is mostly useful for testing equality. It usually
isn¡¯t meaningful to do byte-wise ordering comparisons on arrays of things other than bytes.
For example, a byte-wise comparison on the bytes that make up floating-point numbers isn¡¯t
likely to tell you anything about the relationship between the values of the floating-point
numbers.


Chapter 5: String and Array Utilities 114

wmemcmpis really only useful to compare arrays of typewchar_tsince the function looks
atsizeof (wchar_t)bytes at a time and this number of bytes is system dependent.

You should also be careful about usingmemcmp to compare objects that can contain
¡°holes¡±, such as the padding inserted into structure objects to enforce alignment require-
ments, extra space at the end of unions, and extra bytes at the ends of strings whose
length is less than their allocated size. The contents of these ¡°holes¡± are indeterminate and
may cause strange behavior when performing byte-wise comparisons. For more predictable
results, perform an explicit component-wise comparison.

```
For example, given a structure type definition like:
struct foo
{
unsigned char tag;
union
{
double f;
long i;
char *p;
} value;
};
```
you are better off writing a specialized comparison function to comparestruct fooobjects
instead of comparing them withmemcmp.

int strcmp(const char *s1, const char *s2) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrcmpfunction compares the strings1againsts2, returning a value that has
the same sign as the difference between the first differing pair of bytes (interpreted
asunsigned charobjects, then promoted toint).
If the two strings are equal,strcmpreturns 0.
A consequence of the ordering used bystrcmpis that ifs1is an initial substring of
s2, thens1is considered to be ¡°less than¡±s2.
strcmpdoes not take sorting conventions of the language the strings are written in
into account. To get that one has to usestrcoll.

int wcscmp(const wchar t *ws1, const wchart *ws2) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcscmpfunction compares the wide stringws1againstws2. The value returned
is smaller than or larger than zero depending on whether the first differing wide
character isws1is smaller or larger than the corresponding wide character inws2.
If the two strings are equal,wcscmpreturns 0.
A consequence of the ordering used bywcscmpis that ifws1is an initial substring of
ws2, thenws1is considered to be ¡°less than¡±ws2.
wcscmpdoes not take sorting conventions of the language the strings are written in
into account. To get that one has to usewcscoll.


Chapter 5: String and Array Utilities 115

int strcasecmp(const char *s1, const char *s2) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is likestrcmp, except that differences in case are ignored, and its
arguments must be multibyte strings. How uppercase and lowercase characters are
related is determined by the currently selected locale. In the standard"C"locale the
charactersA and ?a do not match but in a locale which regards these characters as ?
parts of the alphabet they do match.
strcasecmpis derived from BSD.

int wcscasecmp(const wchart *ws1, const wchar t *ws2) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is likewcscmp, except that differences in case are ignored. How up-
percase and lowercase characters are related is determined by the currently selected
locale. In the standard"C"locale the charactersA and ?a do not match but in a locale ?
which regards these characters as parts of the alphabet they do match.
wcscasecmpis a GNU extension.

int strncmp(const char *s1, const char *s2, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is the similar tostrcmp, except that no more than size bytes are
compared. In other words, if the two strings are the same in their firstsizebytes, the
return value is zero.

int wcsncmp(const wchart *ws1, const wchar t *ws2, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar towcscmp, except that no more thansizewide characters
are compared. In other words, if the two strings are the same in their firstsizewide
characters, the return value is zero.

int strncasecmp (const char *s1, const char *s2, size tn) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is likestrncmp, except that differences in case are ignored, and the
compared parts of the arguments should consist of valid multibyte characters. Like
strcasecmp, it is locale dependent how uppercase and lowercase characters are re-
lated.
strncasecmpis a GNU extension.

int wcsncasecmp (const wchart *ws1, const wchar t *s2, sizetn) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.


Chapter 5: String and Array Utilities 116

```
This function is like wcsncmp, except that differences in case are ignored. Like
wcscasecmp, it is locale dependent how uppercase and lowercase characters are re-
lated.
wcsncasecmpis a GNU extension.
```
Here are some examples showing the use ofstrcmpandstrncmp(equivalent examples
can be constructed for the wide character functions). These examples assume the use of
the ASCII character set. (If some other character set¡ªsay, EBCDIC¡ªis used instead, then
the glyphs are associated with different numeric codes, and the return values and ordering
may differ.)
strcmp ("hello", "hello")
?0 /*These two strings are the same.*/
strcmp ("hello", "Hello")
?32 /*Comparisons are case-sensitive.*/
strcmp ("hello", "world")
?-15 /*The byte'h'comes before'w'.*/
strcmp ("hello", "hello, world")
?-44 /*Comparing a null byte against a comma.*/
strncmp ("hello", "hello, world", 5)
?0 /*The initial 5 bytes are the same.*/
strncmp ("hello, world", "hello, stupid world!!!", 5)
?0 /*The initial 5 bytes are the same.*/

int strverscmp(const char *s1, const char *s2) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrverscmpfunction compares the strings1 againsts2, considering them as
holding indices/version numbers. The return value follows the same conventions as
found in thestrcmpfunction. In fact, ifs1ands2contain no digits,strverscmp
behaves likestrcmp(in the sense that the sign of the result is the same).
The comparison algorithm which thestrverscmpfunction implements differs slightly
from other version-comparison algorithms. The implementation is based on a finite-
state machine, whose behavior is approximated below.

- The input strings are each split into sequences of non-digits and digits. These
    sequences can be empty at the beginning and end of the string. Digits are
    determined by theisdigitfunction and are thus subject to the current locale.
- Comparison starts with a (possibly empty) non-digit sequence. The first non-
    equal sequences of non-digits or digits determines the outcome of the comparison.
- Corresponding non-digit sequences in both strings are compared lexicographically
    if their lengths are equal. If the lengths differ, the shorter non-digit sequence is
    extended with the input string character immediately following it (which may be
    the null terminator), the other sequence is truncated to be of the same (extended)
    length, and these two sequences are compared lexicographically. In the last
    case, the sequence comparison determines the result of the function because the
    extension character (or some character before it) is necessarily different from the
    character at the same offset in the other input string.
- For two sequences of digits, the number of leading zeros is counted (which can
    be zero). If the count differs, the string with more leading zeros in the digit
    sequence is considered smaller than the other string.


Chapter 5: String and Array Utilities 117

- If the two sequences of digits have no leading zeros, they are compared as integers,
    that is, the string with the longer digit sequence is deemed larger, and if both
    sequences are of equal length, they are compared lexicographically.
- If both digit sequences start with a zero and have an equal number of leading
    zeros, they are compared lexicographically if their lengths are the same. If the
    lengths differ, the shorter sequence is extended with the following character in its
    input string, and the other sequence is truncated to the same length, and both
    sequences are compared lexicographically (similar to the non-digit sequence case
    above).

```
The treatment of leading zeros and the tie-breaking extension characters (which in ef-
fect propagate across non-digit/digit sequence boundaries) differs from other version-
comparison algorithms.
strverscmp ("no digit", "no digit")
?0 /*same behavior as strcmp.*/
strverscmp ("item#99", "item#100")
?<0 /*same prefix, but 99<100.*/
strverscmp ("alpha1", "alpha001")
?>0 /*different number of leading zeros (0 and 2).*/
strverscmp ("part1_f012", "part1_f01")
?>0 /*lexicographical comparison with leading zeros.*/
strverscmp ("foo.009", "foo.0")
?<0 /*different number of leading zeros (2 and 1).*/
strverscmpis a GNU extension.
```
int bcmp (const void *a1, const void *a2, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is an obsolete alias formemcmp, derived from BSD.

## 5.8 Collation Functions...........................................

In some locales, the conventions for lexicographic ordering differ from the strict numeric
ordering of character codes. For example, in Spanish most glyphs with diacritical marks
such as accents are not considered distinct letters for the purposes of collation. On the
other hand, in Czech the two-character sequence ¡®ch¡¯ is treated as a single letter that is
collated between ¡®h¡¯ and ¡®i¡¯.

You can use the functionsstrcollandstrxfrm(declared in the headers filestring.h)
andwcscollandwcsxfrm(declared in the headers filewchar) to compare strings using a
collation ordering appropriate for the current locale. The locale used by these functions in
particular can be specified by setting the locale for theLC_COLLATEcategory; seeChapter 7
[Locales and Internationalization], page 183.

In the standard C locale, the collation sequence forstrcollis the same as that for
strcmp. Similarly,wcscollandwcscmpare the same in this situation.

Effectively, the way these functions work is by applying a mapping to transform the
characters in a multibyte string to a byte sequence that represents the string¡¯s position in
the collating sequence of the current locale. Comparing two such byte sequences in a simple
fashion is equivalent to comparing the strings with the locale¡¯s collating sequence.


Chapter 5: String and Array Utilities 118

The functionsstrcollandwcscollperform this translation implicitly, in order to do
one comparison. By contrast,strxfrmandwcsxfrmperform the mapping explicitly. If
you are making multiple comparisons using the same string or set of strings, it is likely
to be more efficient to usestrxfrmorwcsxfrmto transform all the strings just once, and
subsequently compare the transformed strings withstrcmporwcscmp.

int strcoll(const char *s1, const char *s2) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thestrcollfunction is similar tostrcmpbut uses the collating sequence of the
current locale for collation (theLC_COLLATElocale). The arguments are multibyte
strings.

int wcscoll(const wchart *ws1, const wchar t *ws2) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewcscollfunction is similar towcscmpbut uses the collating sequence of the
current locale for collation (theLC_COLLATElocale).

Here is an example of sorting an array of strings, usingstrcollto compare them. The
actual sort algorithm is not written here; it comes fromqsort(seeSection 9.3 [Array Sort
Function], page 229). The job of the code shown here is to say how to compare the strings
while sorting them. (Later on in this section, we will show a way to do this more efficiently
usingstrxfrm.)
/*This is the comparison function used withqsort.*/

```
int
compare_elements (const void *v1, const void *v2)
{
char * const *p1 = v1;
char * const *p2 = v2;
```
```
return strcoll (*p1, *p2);
}
```
```
/*This is the entry point¡ªthe function to sort
strings using the locale¡¯s collating sequence.*/
```
```
void
sort_strings (char **array, int nstrings)
{
/*Sorttemp_arrayby comparing the strings.*/
qsort (array, nstrings,
sizeof (char *), compare_elements);
}
```
size_t strxfrm(char *restrictto, const char *restrictfrom, sizet [Function]
size)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionstrxfrmtransforms the multibyte stringfromusing the collation trans-
formation determined by the locale currently selected for collation, and stores the


Chapter 5: String and Array Utilities 119

```
transformed string in the arrayto. Up tosize bytes (including a terminating null
byte) are stored.
The behavior is undefined if the stringstoandfromoverlap; seeSection 5.4 [Copying
Strings and Arrays], page 101.
The return value is the length of the entire transformed string. This value is not
affected by the value ofsize, but if it is greater or equal thansize, it means that the
transformed string did not entirely fit in the arrayto. In this case, only as much
of the string as actually fits was stored. To get the whole transformed string, call
strxfrmagain with a bigger output array.
The transformed string may be longer than the original string, and it may also be
shorter.
Ifsizeis zero, no bytes are stored into. In this case,strxfrmsimply returns the
number of bytes that would be the length of the transformed string. This is useful
for determining what size the allocated array should be. It does not matter whatto
is ifsizeis zero;tomay even be a null pointer.
```
size_t wcsxfrm(wchart *restrictwto, const wchar t *wfrom, sizet [Function]
size)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionwcsxfrmtransforms wide stringwfromusing the collation transforma-
tion determined by the locale currently selected for collation, and stores the trans-
formed string in the arraywto. Up tosizewide characters (including a terminating
null wide character) are stored.
The behavior is undefined if the stringswto andwfromoverlap; seeSection 5.4
[Copying Strings and Arrays], page 101.
The return value is the length of the entire transformed wide string. This value is
not affected by the value ofsize, but if it is greater or equal thansize, it means that
the transformed wide string did not entirely fit in the arraywto. In this case, only
as much of the wide string as actually fits was stored. To get the whole transformed
wide string, callwcsxfrmagain with a bigger output array.
The transformed wide string may be longer than the original wide string, and it may
also be shorter.
Ifsize is zero, no wide characters are stored into. In this case, wcsxfrmsimply
returns the number of wide characters that would be the length of the transformed
wide string. This is useful for determining what size the allocated array should be
(remember to multiply withsizeof (wchar_t)). It does not matter whatwtois if
sizeis zero;wtomay even be a null pointer.

Here is an example of how you can usestrxfrmwhen you plan to do many comparisons.
It does the same thing as the previous example, but much faster, because it has to transform
each string only once, no matter how many times it is compared with other strings. Even
the time needed to allocate and free storage is much less than the time we save, when there
are many strings.
struct sorter { char *input; char *transformed; };


Chapter 5: String and Array Utilities 120

```
/*This is the comparison function used withqsort
to sort an array ofstruct sorter.*/
```
```
int
compare_elements (const void *v1, const void *v2)
{
const struct sorter *p1 = v1;
const struct sorter *p2 = v2;
```
```
return strcmp (p1->transformed, p2->transformed);
}
```
```
/*This is the entry point¡ªthe function to sort
strings using the locale¡¯s collating sequence.*/
```
```
void
sort_strings_fast (char **array, int nstrings)
{
struct sorter temp_array[nstrings];
int i;
```
```
/*Set uptemp_array. Each element contains
one input string and its transformed string.*/
for (i = 0; i < nstrings; i++)
{
size_t length = strlen (array[i]) * 2;
char *transformed;
size_t transformed_length;
```
```
temp_array[i].input = array[i];
```
```
/*First try a buffer perhaps big enough. */
transformed = (char *) xmalloc (length);
```
```
/*Transformarray[i]. */
transformed_length = strxfrm (transformed, array[i], length);
```
```
/*If the buffer was not large enough, resize it
and try again. */
if (transformed_length >= length)
{
/*Allocate the needed space.+1 for terminating
'\0'byte. */
transformed = (char *) xrealloc (transformed,
transformed_length + 1);
```
```
/*The return value is not interesting because we know
how long the transformed string is. */
(void) strxfrm (transformed, array[i],
transformed_length + 1);
}
```
```
temp_array[i].transformed = transformed;
}
```
```
/*Sorttemp_arrayby comparing transformed strings.*/
qsort (temp_array, nstrings,
sizeof (struct sorter), compare_elements);
```

Chapter 5: String and Array Utilities 121

```
/*Put the elements back in the permanent array
in their sorted order.*/
for (i = 0; i < nstrings; i++)
array[i] = temp_array[i].input;
```
```
/*Free the strings we allocated.*/
for (i = 0; i < nstrings; i++)
free (temp_array[i].transformed);
}
The interesting part of this code for the wide character version would look like this:
void
sort_strings_fast (wchar_t **array, int nstrings)
{
...
/*Transformarray[i]. */
transformed_length = wcsxfrm (transformed, array[i], length);
```
```
/*If the buffer was not large enough, resize it
and try again. */
if (transformed_length >= length)
{
/*Allocate the needed space.+1 for terminating
L'\0'wide character. */
transformed = (wchar_t *) xrealloc (transformed,
(transformed_length + 1)
* sizeof (wchar_t));
```
```
/*The return value is not interesting because we know
how long the transformed string is. */
(void) wcsxfrm (transformed, array[i],
transformed_length + 1);
}
...
```
Note the additional multiplication withsizeof (wchar_t)in therealloccall.

Compatibility Note:The string collation functions are a new feature of ISO C90. Older
C dialects have no equivalent feature. The wide character versions were introduced in
Amendment 1 to ISO C90.

5.9 Search Functions

This section describes library functions which perform various kinds of searching operations
on strings and arrays. These functions are declared in the header filestring.h.

void * memchr(const void *block, intc, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function finds the first occurrence of the bytec(converted to anunsigned char)
in the initialsizebytes of the object beginning atblock. The return value is a pointer
to the located byte, or a null pointer if no match was found.

wchar_t * wmemchr(const wchar t *block, wchartwc, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 5: String and Array Utilities 122

```
This function finds the first occurrence of the wide characterwc in the initialsize
wide characters of the object beginning atblock. The return value is a pointer to the
located wide character, or a null pointer if no match was found.
```
void * rawmemchr (const void *block, intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Often thememchrfunction is used with the knowledge that the bytecis available in
the memory block specified by the parameters. But this means that thesizeparameter
is not really needed and that the tests performed with it at runtime (to check whether
the end of the block is reached) are not needed.
Therawmemchrfunction exists for just this situation which is surprisingly frequent.
The interface is similar tomemchrexcept that thesizeparameter is missing. The
function will look beyond the end of the block pointed to byblockin case the pro-
grammer made an error in assuming that the bytecis present in the block. In this
case the result is unspecified. Otherwise the return value is a pointer to the located
byte.
This function is of special interest when looking for the end of a string. Since all
strings are terminated by a null byte a call like
rawmemchr (str, '\0')
will never go beyond the end of the string.
This function is a GNU extension.

void * memrchr(const void *block, intc, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionmemrchris likememchr, except that it searches backwards from the end
of the block defined byblockandsize(instead of forwards from the front).
This function is a GNU extension.

char * strchr(const char *string, intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrchrfunction finds the first occurrence of the bytec(converted to achar) in
the string beginning atstring. The return value is a pointer to the located byte, or a
null pointer if no match was found.
For example,
strchr ("hello, world", 'l')
?"llo, world"
strchr ("hello, world", '?')
?NULL
The terminating null byte is considered to be part of the string, so you can use this
function get a pointer to the end of a string by specifying zero as the value of thec
argument.
Whenstrchrreturns a null pointer, it does not let you know the position of the
terminating null byte it has found. If you need that information, it is better (but less
portable) to usestrchrnulthan to search for it a second time.


Chapter 5: String and Array Utilities 123

wchar_t * wcschr (const wchart *wstring, wchartwc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcschrfunction finds the first occurrence of the wide characterwcin the wide
string beginning atwstring. The return value is a pointer to the located wide char-
acter, or a null pointer if no match was found.
The terminating null wide character is considered to be part of the wide string, so
you can use this function get a pointer to the end of a wide string by specifying a
null wide character as the value of thewc argument. It would be better (but less
portable) to usewcschrnulin this case, though.

char * strchrnul (const char *string, intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
strchrnulis the same asstrchrexcept that if it does not find the byte, it returns
a pointer to string¡¯s terminating null byte rather than a null pointer.
This function is a GNU extension.

wchar_t * wcschrnul (const wchart *wstring, wchartwc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
wcschrnulis the same aswcschrexcept that if it does not find the wide character,
it returns a pointer to the wide string¡¯s terminating null wide character rather than
a null pointer.
This function is a GNU extension.

One useful, but unusual, use of thestrchrfunction is when one wants to have a pointer
pointing to the null byte terminating a string. This is often written in this way:
s += strlen (s);

This is almost optimal but the addition operation duplicated a bit of the work already done
in thestrlenfunction. A better solution is this:
s = strchr (s, '\0');
There is no restriction on the second parameter ofstrchrso it could very well also be
zero. Those readers thinking very hard about this might now point out that thestrchr
function is more expensive than thestrlenfunction since we have two abort criteria. This
is right. But in the GNU C Library the implementation ofstrchris optimized in a special
way so thatstrchractually is faster.

char * strrchr(const char *string, intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionstrrchris likestrchr, except that it searches backwards from the end
of the stringstring(instead of forwards from the front).
For example,
strrchr ("hello, world", 'l')
?"ld"


Chapter 5: String and Array Utilities 124

wchar_t * wcsrchr(const wchar t *wstring, wchartwc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionwcsrchris likewcschr, except that it searches backwards from the end
of the stringwstring(instead of forwards from the front).

char * strstr(const char *haystack, const char *needle) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is likestrchr, except that it searcheshaystack for a substringneedlerather
than just a single byte. It returns a pointer into the stringhaystackthat is the first
byte of the substring, or a null pointer if no match was found. Ifneedleis an empty
string, the function returnshaystack.
For example,
strstr ("hello, world", "l")
?"llo, world"
strstr ("hello, world", "wo")
?"world"

wchar_t * wcsstr (const wchart *haystack, const wchar t [Function]
*needle)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is likewcschr, except that it searcheshaystack for a substringneedlerather
than just a single wide character. It returns a pointer into the stringhaystackthat
is the first wide character of the substring, or a null pointer if no match was found.
Ifneedleis an empty string, the function returnshaystack.

wchar_t * wcswcs (const wchart *haystack, const wchar t [Function]
*needle)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
wcswcsis a deprecated alias forwcsstr. This is the name originally used in the
X/Open Portability Guide before the Amendment 1 to ISO C90 was published.

char * strcasestr(const char *haystack, const char *needle) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This is likestrstr, except that it ignores case in searching for the substring. Like
strcasecmp, it is locale dependent how uppercase and lowercase characters are re-
lated, and arguments are multibyte strings.
For example,
strcasestr ("hello, world", "L")
?"llo, world"
strcasestr ("hello, World", "wo")
?"World"


Chapter 5: String and Array Utilities 125

void * memmem(const void *haystack, sizethaystack-len, [Function]
const void *needle, sizetneedle-len)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is likestrstr, butneedleandhaystack are byte arrays rather than strings.
needle-lenis the length ofneedleandhaystack-lenis the length ofhaystack.
This function is a GNU extension.

size_t strspn(const char *string, const char *skipset) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrspn(¡°string span¡±) function returns the length of the initial substring of
string that consists entirely of bytes that are members of the set specified by the
stringskipset. The order of the bytes inskipsetis not important.
For example,
strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
? 5
In a multibyte string, characters consisting of more than one byte are not treated as
single entities. Each byte is treated separately. The function is not locale-dependent.

size_t wcsspn(const wchart *wstring, const wchart *skipset) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcsspn(¡°wide character string span¡±) function returns the length of the initial
substring ofwstringthat consists entirely of wide characters that are members of the
set specified by the stringskipset. The order of the wide characters inskipsetis not
important.

size_t strcspn(const char *string, const char *stopset) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrcspn(¡°string complement span¡±) function returns the length of the initial
substring ofstring that consists entirely of bytes that arenot members of the set
specified by the stringstopset. (In other words, it returns the offset of the first byte
instringthat is a member of the setstopset.)
For example,
strcspn ("hello, world", " \t\n,.;!?")
? 5
In a multibyte string, characters consisting of more than one byte are not treated as a
single entities. Each byte is treated separately. The function is not locale-dependent.

size_t wcscspn(const wchart *wstring, const wchar t *stopset) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcscspn(¡°wide character string complement span¡±) function returns the length
of the initial substring ofwstring that consists entirely of wide characters that are
notmembers of the set specified by the stringstopset. (In other words, it returns the
offset of the first wide character instringthat is a member of the setstopset.)


Chapter 5: String and Array Utilities 126

char * strpbrk(const char *string, const char *stopset) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestrpbrk(¡°string pointer break¡±) function is related tostrcspn, except that it
returns a pointer to the first byte instringthat is a member of the setstopsetinstead
of the length of the initial substring. It returns a null pointer if no such byte from
stopsetis found.
For example,
strpbrk ("hello, world", " \t\n,.;!?")
?", world"
In a multibyte string, characters consisting of more than one byte are not treated as
single entities. Each byte is treated separately. The function is not locale-dependent.

wchar_t * wcspbrk(const wchar t *wstring, const wchar t [Function]
*stopset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcspbrk(¡°wide character string pointer break¡±) function is related towcscspn,
except that it returns a pointer to the first wide character inwstringthat is a member
of the setstopsetinstead of the length of the initial substring. It returns a null pointer
if no such wide character fromstopsetis found.

## 5.9.1 Compatibility String Search Functions...................

char * index (const char *string, intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
indexis another name forstrchr; they are exactly the same. New code should always
usestrchrsince this name is defined in ISO C whileindexis a BSD invention which
never was available on System V derived systems.

char * rindex(const char *string, intc) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
rindexis another name forstrrchr; they are exactly the same. New code should
always usestrrchr since this name is defined in ISO C whilerindex is a BSD
invention which never was available on System V derived systems.

## 5.10 Finding Tokens in a String..................................

It¡¯s fairly common for programs to have a need to do some simple kinds of lexical analysis
and parsing, such as splitting a command string up into tokens. You can do this with the
strtokfunction, declared in the header filestring.h.

char * strtok(char *restrictnewstring, const char *restrict [Function]
delimiters)
Preliminary:|MT-Unsafe race:strtok|AS-Unsafe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 5: String and Array Utilities 127

```
A string can be split into tokens by making a series of calls to the functionstrtok.
The string to be split up is passed as thenewstringargument on the first call only.
Thestrtokfunction uses this to set up some internal state information. Subsequent
calls to get additional tokens from the same string are indicated by passing a null
pointer as thenewstringargument. Callingstrtokwith another non-nullnewstring
argument reinitializes the state information. It is guaranteed that no other library
function ever callsstrtokbehind your back (which would mess up this internal state
information).
Thedelimitersargument is a string that specifies a set of delimiters that may surround
the token being extracted. All the initial bytes that are members of this set are
discarded. The first byte that isnot a member of this set of delimiters marks the
beginning of the next token. The end of the token is found by looking for the next
byte that is a member of the delimiter set. This byte in the original stringnewstringis
overwritten by a null byte, and the pointer to the beginning of the token innewstring
is returned.
On the next call tostrtok, the searching begins at the next byte beyond the one
that marked the end of the previous token. Note that the set of delimitersdelimiters
do not have to be the same on every call in a series of calls tostrtok.
If the end of the stringnewstring is reached, or if the remainder of string consists
only of delimiter bytes,strtokreturns a null pointer.
In a multibyte string, characters consisting of more than one byte are not treated as
single entities. Each byte is treated separately. The function is not locale-dependent.
```
wchar_t * wcstok (wchart *newstring, const wchart [Function]
*delimiters, wchart **save_ptr)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
A string can be split into tokens by making a series of calls to the functionwcstok.
The string to be split up is passed as thenewstringargument on the first call only.
Thewcstokfunction uses this to set up some internal state information. Subsequent
calls to get additional tokens from the same wide string are indicated by passing a
null pointer as thenewstringargument, which causes the pointer previously stored
insaveptrto be used instead.
Thedelimitersargument is a wide string that specifies a set of delimiters that may
surround the token being extracted. All the initial wide characters that are members
of this set are discarded. The first wide character that isnota member of this set of
delimiters marks the beginning of the next token. The end of the token is found by
looking for the next wide character that is a member of the delimiter set. This wide
character in the original wide stringnewstringis overwritten by a null wide character,
the pointer past the overwritten wide character is saved insaveptr, and the pointer
to the beginning of the token innewstringis returned.
On the next call towcstok, the searching begins at the next wide character beyond
the one that marked the end of the previous token. Note that the set of delimiters
delimitersdo not have to be the same on every call in a series of calls towcstok.
If the end of the wide stringnewstringis reached, or if the remainder of string consists
only of delimiter wide characters,wcstokreturns a null pointer.


Chapter 5: String and Array Utilities 128

Warning:Sincestrtokandwcstokalter the string they is parsing, you should always
copy the string to a temporary buffer before parsing it withstrtok/wcstok(seeSection 5.4
[Copying Strings and Arrays], page 101). If you allowstrtokorwcstokto modify a string
that came from another part of your program, you are asking for trouble; that string might
be used for other purposes afterstrtokorwcstokhas modified it, and it would not have
the expected value.

The string that you are operating on might even be a constant. Then whenstrtok
orwcstoktries to modify it, your program will get a fatal signal for writing in read-only
memory. SeeSection 24.2.1 [Program Error Signals], page 716. Even if the operation of
strtokorwcstokwould not require a modification of the string (e.g., if there is exactly
one token) the string can (and in the GNU C Library case will) be modified.

This is a special case of a general principle: if a part of a program does not have as its
purpose the modification of a certain data structure, then it is error-prone to modify the
data structure temporarily.

The functionstrtokis not reentrant, whereaswcstokis. SeeSection 24.4.6 [Signal Han-
dling and Nonreentrant Functions], page 737, for a discussion of where and why reentrancy
is important.

```
Here is a simple example showing the use ofstrtok.
#include <string.h>
#include <stddef.h>
```
```
...
```
```
const char string[] = "words separated by spaces -- and, punctuation!";
const char delimiters[] = " .,;:!-";
char *token, *cp;
```
```
...
```
cp = strdupa (string); /* Make writable copy. */
token = strtok (cp, delimiters); /* token => "words" */
token = strtok (NULL, delimiters); /* token => "separated" */
token = strtok (NULL, delimiters); /* token => "by" */
token = strtok (NULL, delimiters); /* token => "spaces" */
token = strtok (NULL, delimiters); /* token => "and" */
token = strtok (NULL, delimiters); /* token => "punctuation" */
token = strtok (NULL, delimiters); /* token => NULL */
The GNU C Library contains two more functions for tokenizing a string which overcome
the limitation of non-reentrancy. They are not available available for wide strings.

char * strtok_r (char *newstring, const char *delimiters, char [Function]
**save_ptr)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Just likestrtok, this function splits the string into several tokens which can be
accessed by successive calls tostrtok_r. The difference is that, as inwcstok, the
information about the next token is stored in the space pointed to by the third
argument,saveptr, which is a pointer to a string pointer. Callingstrtok_rwith a
null pointer fornewstringand leavingsaveptrbetween the calls unchanged does the
job without hindering reentrancy.


Chapter 5: String and Array Utilities 129

```
This function is defined in POSIX.1 and can be found on many systems which support
multi-threading.
```
char * strsep(char **string_ptr, const char *delimiter) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function has a similar functionality asstrtok_rwith thenewstringargument
replaced by thesaveptrargument. The initialization of the moving pointer has to be
done by the user. Successive calls tostrsepmove the pointer along the tokens sep-
arated bydelimiter, returning the address of the next token and updatingstring ptr
to point to the beginning of the next token.
One difference betweenstrsepandstrtok_ris that if the input string contains more
than one byte fromdelimiterin a rowstrsepreturns an empty string for each pair
of bytes fromdelimiter. This means that a program normally should test forstrsep
returning an empty string before processing it.
This function was introduced in 4.3BSD and therefore is widely available.

```
Here is how the above example looks like whenstrsepis used.
#include <string.h>
#include <stddef.h>
```
```
...
```
```
const char string[] = "words separated by spaces -- and, punctuation!";
const char delimiters[] = " .,;:!-";
char *running;
char *token;
```
```
...
```
```
running = strdupa (string);
token = strsep (&running, delimiters); /* token => "words" */
token = strsep (&running, delimiters); /* token => "separated" */
token = strsep (&running, delimiters); /* token => "by" */
token = strsep (&running, delimiters); /* token => "spaces" */
token = strsep (&running, delimiters); /* token => "" */
token = strsep (&running, delimiters); /* token => "" */
token = strsep (&running, delimiters); /* token => "" */
token = strsep (&running, delimiters); /* token => "and" */
token = strsep (&running, delimiters); /* token => "" */
token = strsep (&running, delimiters); /* token => "punctuation" */
token = strsep (&running, delimiters); /* token => "" */
token = strsep (&running, delimiters); /* token => NULL */
```
char * basename (const char *filename) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The GNU version of thebasenamefunction returns the last component of the path in
filename. This function is the preferred usage, since it does not modify the argument,
filename, and respects trailing slashes. The prototype forbasenamecan be found
instring.h. Note, this function is overridden by the XPG version, iflibgen.his
included.


Chapter 5: String and Array Utilities 130

```
Example of using GNUbasename:
#include <string.h>
```
```
int
main (int argc, char *argv[])
{
char *prog = basename (argv[0]);
```
```
if (argc < 2)
{
fprintf (stderr, "Usage %s <arg>\n", prog);
exit (1);
}
```
```
...
}
Portability Note:This function may produce different results on different systems.
```
char * basename (char *path) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is the standard XPG definedbasename. It is similar in spirit to the GNU
version, but may modify thepathby removing trailing ¡¯/¡¯ bytes. If thepathis made
up entirely of ¡¯/¡¯ bytes, then"/"will be returned. Also, ifpathisNULLor an empty
string, then"."is returned. The prototype for the XPG version can be found in
libgen.h.
Example of using XPGbasename:
#include <libgen.h>

```
int
main (int argc, char *argv[])
{
char *prog;
char *path = strdupa (argv[0]);
```
```
prog = basename (path);
```
```
if (argc < 2)
{
fprintf (stderr, "Usage %s <arg>\n", prog);
exit (1);
}
```
```
...
```
```
}
```
char * dirname(char *path) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thedirnamefunction is the compliment to the XPG version ofbasename. It returns
the parent directory of the file specified bypath. IfpathisNULL, an empty string,
or contains no ¡¯/¡¯ bytes, then"."is returned. The prototype for this function can be
found inlibgen.h.


Chapter 5: String and Array Utilities 131

## 5.11 Erasing Sensitive Data......................................

Sensitive data, such as cryptographic keys, should be erased from memory after use, to
reduce the risk that a bug will expose it to the outside world. However, compiler opti-
mizations may determine that an erasure operation is ¡°unnecessary,¡± and remove it from
the generated code, because nocorrectprogram could access the variable or heap object
containing the sensitive data after it¡¯s deallocated. Since erasure is a precaution against
bugs, this optimization is inappropriate.

The functionexplicit_bzeroerases a block of memory, and guarantees that the com-
piler will not remove the erasure as ¡°unnecessary.¡±

```
#include <string.h>
```
```
extern void encrypt (const char *key, const char *in,
char *out, size_t n);
extern void genkey (const char *phrase, char *key);
```
```
void encrypt_with_phrase (const char *phrase, const char *in,
char *out, size_t n)
{
char key[16];
genkey (phrase, key);
encrypt (key, in, out, n);
explicit_bzero (key, 16);
}
```
In this example, ifmemset, bzero, or a hand-written loop had been used, the compiler
might remove them as ¡°unnecessary.¡±

Warning:explicit_bzerodoes not guarantee that sensitive data iscompletelyerased
from the computer¡¯s memory. There may be copies in temporary storage areas, such as
registers and ¡°scratch¡± stack space; since these are invisible to the source code, a library
function cannot erase them.

Also,explicit_bzeroonly operates on RAM. If a sensitive data object never needs to
have its address taken other than to callexplicit_bzero, it might be stored entirely in
CPU registersuntil the call toexplicit_bzero. Then it will be copied into RAM, the
copy will be erased, and the original will remain intact. Data in RAM is more likely to be
exposed by a bug than data in registers, so this creates a brief window where the data is at
greater risk of exposure than it would have been if the program didn¡¯t try to erase it at all.

Declaring sensitive variables asvolatilewill make both the above problemsworse; a
volatilevariable will be stored in memory for its entire lifetime, and the compiler will
makemorecopies of it than it would otherwise have. Attempting to erase a normal variable
¡°by hand¡± through avolatile-qualified pointer doesn¡¯t work at all¡ªbecause the variable
itself is notvolatile, some compilers will ignore the qualification on the pointer and remove
the erasure anyway.

Having said all that, in most situations, usingexplicit_bzerois better than not using
it. At present, the only way to do a more thorough job is to write the entire sensitive
operation in assembly language. We anticipate that future compilers will recognize calls
toexplicit_bzeroand take appropriate steps to erase all the copies of the affected data,
whereever they may be.


Chapter 5: String and Array Utilities 132

void explicit_bzero (void *block, sizetlen) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
explicit_bzerowrites zero intolenbytes of memory beginning atblock, just as
bzerowould. The zeroes are always written, even if the compiler could determine
that this is ¡°unnecessary¡± because no correct program could read them back.
Note: Theonlyoptimization thatexplicit_bzerodisables is removal of ¡°unneces-
sary¡± writes to memory. The compiler can perform all the other optimizations that it
could for a call tomemset. For instance, it may replace the function call with inline
memory writes, and it may assume thatblockcannot be a null pointer.
Portability Note: This function first appeared in OpenBSD 5.5 and has not been
standardized. Other systems may provide the same functionality under a different
name, such asexplicit_memset,memset_s, orSecureZeroMemory.
The GNU C Library declares this function instring.h, but on other systems it may
be instrings.hinstead.

## 5.12 Shuffling Bytes..............................................

The function below addresses the perennial programming quandary: ¡°How do I take good
data in string form and painlessly turn it into garbage?¡± This is not a difficult thing to
code for oneself, but the authors of the GNU C Library wish to make it as convenient as
possible.

Toerasedata, useexplicit_bzero(seeSection 5.11 [Erasing Sensitive Data], page 131);
to obfuscate it reversibly, usememfrob(seeSection 5.13 [Obfuscating Data], page 132).

char * strfry(char *string) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
strfryperforms an in-place shuffle onstring. Each character is swapped to a position
selected at random, within the portion of the string starting with the character¡¯s
original position. (This is the Fisher-Yates algorithm for unbiased shuffling.)
Callingstrfrywill not disturb any of the random number generators that have global
state (seeSection 19.8 [Pseudo-Random Numbers], page 591).
The return value ofstrfryis alwaysstring.
Portability Note: This function is unique to the GNU C Library. It is declared in
string.h.

## 5.13 Obfuscating Data...........................................

Thememfrob function reversibly obfuscates an array of binary data. This is not true
encryption; the obfuscated data still bears a clear relationship to the original, and no secret
key is required to undo the obfuscation. It is analogous to the ¡°Rot13¡± cipher used on
Usenet for obscuring offensive jokes, spoilers for works of fiction, and so on, but it can be
applied to arbitrary binary data.


Chapter 5: String and Array Utilities 133

Programs that need true encryption¡ªa transformation that completely obscures the
original and cannot be reversed without knowledge of a secret key¡ªshould use a dedicated
cryptography library, such aslibgcrypt.

Programs that need todestroydata should useexplicit_bzero(seeSection 5.11 [Eras-
ing Sensitive Data], page 131), or possibly strfry (see Section 5.12 [Shuffling Bytes],
page 132).

void * memfrob(void *mem, size tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionmemfrobobfuscateslengthbytes of data beginning atmem, in place.
Each byte is bitwise xor-ed with the binary pattern 00101010 (hexadecimal 0x2A).
The return value is alwaysmem.
memfroba second time on the same data returns it to its original state.
Portability Note: This function is unique to the GNU C Library. It is declared in
string.h.

## 5.14 Encode Binary Data........................................

To store or transfer binary data in environments which only support text one has to encode
the binary data by mapping the input bytes to bytes in the range allowed for storing
or transferring. SVID systems (and nowadays XPG compliant systems) provide minimal
support for this task.

char * l64a(long intn) [Function]
Preliminary: |MT-Unsafe race:l64a|AS-Unsafe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function encodes a 32-bit input value using bytes from the basic character set.
It returns a pointer to a 7 byte buffer which contains an encoded version ofn. To
encode a series of bytes the user must copy the returned string to a destination buffer.
It returns the empty string ifnis zero, which is somewhat bizarre but mandated by
the standard.
Warning: Since a static buffer is used this function should not be used in multi-
threaded programs. There is no thread-safe alternative to this function in the C
library.
Compatibility Note: The XPG standard states that the return value ofl64ais un-
defined ifnis negative. In the GNU implementation,l64atreats its argument as
unsigned, so it will return a sensible encoding for any nonzeron; however, portable
programs should not rely on this.
To encode a large bufferl64amust be called in a loop, once for each 32-bit word of
the buffer. For example, one could do something like this:
char *
encode (const void *buf, size_t len)
{
/*We know in advance how long the buffer has to be.*/
unsigned char *in = (unsigned char *) buf;
char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
char *cp = out, *p;


Chapter 5: String and Array Utilities 134

```
/*Encode the length.*/
/*Using ¡®htonl¡¯ is necessary so that the data can be
decoded even on machines with different byte order.
¡®l64a¡¯ can return a string shorter than 6 bytes, so
we pad it with encoding of 0 ('.') at the end by
hand.*/
```
```
p = stpcpy (cp, l64a (htonl (len)));
cp = mempcpy (p, "......", 6 - (p - cp));
```
```
while (len > 3)
{
unsigned long int n = *in++;
n = (n << 8) | *in++;
n = (n << 8) | *in++;
n = (n << 8) | *in++;
len -= 4;
p = stpcpy (cp, l64a (htonl (n)));
cp = mempcpy (p, "......", 6 - (p - cp));
}
if (len > 0)
{
unsigned long int n = *in++;
if (--len > 0)
{
n = (n << 8) | *in++;
if (--len > 0)
n = (n << 8) | *in;
}
cp = stpcpy (cp, l64a (htonl (n)));
}
*cp = '\0';
return out;
}
It is strange that the library does not provide the complete functionality needed but
so be it.
```
```
To decode data produced withl64athe following function should be used.
```
long int a64l(const char *string) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The parameterstringshould contain a string which was produced by a call tol64a.
The function processes at least 6 bytes of this string, and decodes the bytes it finds
according to the table below. It stops decoding when it finds a byte not in the table,
rather likeatoi; if you have a buffer which has been broken into lines, you must be
careful to skip over the end-of-line bytes.
The decoded number is returned as along intvalue.

Thel64aanda64lfunctions use a base 64 encoding, in which each byte of an encoded
string represents six bits of an input word. These symbols are used for the base 64 digits:

0 1 2 3 4 5 6 7
0. / 0 1 2 3 4 5


Chapter 5: String and Array Utilities 135

### 8 6 7 8 9 A B C D

### 16 E F G H I J K L

### 24 M N O P Q R S T

32 U V W X Y Z a b
40 c d e f g h i j
48 k l m n o p q r
56 s t u v w x y z

This encoding scheme is not standard. There are some other encoding methods which
are much more widely used (UU encoding, MIME encoding). Generally, it is better to use
one of these encodings.

## 5.15 Argz and Envz Vectors......................................

argz vectorsare vectors of strings in a contiguous block of memory, each element separated
from its neighbors by null bytes ('\0').

Envz vectorsare an extension of argz vectors where each element is a name-value pair,
separated by a'='byte (as in a Unix environment).

## 5.15.1 Argz Functions.........................................

Each argz vector is represented by a pointer to the first element, of typechar *, and a size,
of typesize_t, both of which can be initialized to 0 to represent an empty argz vector. All
argz functions accept either a pointer and a size argument, or pointers to them, if they will
be modified.

The argz functions usemalloc/reallocto allocate/grow argz vectors, and so any argz
vector created using these functions may be freed by usingfree; conversely, any argz
function that may grow a string expects that string to have been allocated usingmalloc
(those argz functions that only examine their arguments or modify them in place will work
on any sort of memory). SeeSection 3.2.3 [Unconstrained Allocation], page 45.

All argz functions that do memory allocation have a return type oferror_t, and return
0 for success, andENOMEMif an allocation error occurs.

```
These functions are declared in the standard include fileargz.h.
```
error_t argz_create (char *constargv[], char **argz, sizet [Function]
*argz_len)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theargz_createfunction converts the Unix-style argument vectorargv (a vector
of pointers to normal C strings, terminated by(char *)0; seeSection 25.1 [Program
Arguments], page 759) into an argz vector with the same elements, which is returned
inargzandargzlen.

error_t argz_create_sep (const char *string, intsep, char [Function]
**argz, sizet *argz_len)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 5: String and Array Utilities 136

```
Theargz_create_sepfunction converts the stringstring into an argz vector (re-
turned inargzandargzlen) by splitting it into elements at every occurrence of the
bytesep.
```
size_t argz_count(const char *argz, sizetargz_len) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns the number of elements in the argz vectorargzandargzlen.

void argz_extract(const char *argz, sizetargz_len, char [Function]
**argv)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theargz_extractfunction converts the argz vectorargzandargzleninto a Unix-
style argument vector stored inargv, by putting pointers to every element inargzinto
successive positions inargv, followed by a terminator of 0 .Argvmust be pre-allocated
with enough space to hold all the elements inargzplus the terminating(char *)0
((argz_count (argz,argz_len) + 1) * sizeof (char *)bytes should be enough).
Note that the string pointers stored intoargvpoint intoargz¡ªthey are not copies¡ª
and soargz must be copied if it will be changed whileargv is still active. This
function is useful for passing the elements inargzto an exec function (seeSection 26.5
[Executing a File], page 806).

void argz_stringify (char *argz, size tlen, intsep) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theargz_stringifyconvertsargzinto a normal string with the elements separated
by the bytesep, by replacing each'\0' inside argz (except the last one, which
terminates the string) withsep. This is handy for printingargzin a readable manner.

error_t argz_add (char **argz, size t *argz_len, const char *str) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theargz_addfunction adds the stringstrto the end of the argz vector*argz, and
updates*argzand*argz_lenaccordingly.

error_t argz_add_sep(char **argz, sizet *argz_len, const char [Function]
*str, intdelim)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theargz_add_sepfunction is similar toargz_add, butstris split into separate
elements in the result at occurrences of the bytedelim. This is useful, for instance,
for adding the components of a Unix search path to an argz vector, by using a value
of':'fordelim.

error_t argz_append (char **argz, size t *argz_len, const char [Function]
*buf, sizetbuf_len)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 5: String and Array Utilities 137

```
Theargz_appendfunction appendsbuflenbytes starting atbuf to the argz vector
*argz, reallocating*argzto accommodate it, and addingbuflento*argz_len.
```
void argz_delete (char **argz, size t *argz_len, char *entry) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Ifentrypoints to the beginning of one of the elements in the argz vector*argz, the
argz_deletefunction will remove this entry and reallocate*argz, modifying*argz
and*argz_lenaccordingly. Note that as destructive argz functions usually reallocate
their argz argument, pointers into argz vectors such asentrywill then become invalid.

error_t argz_insert (char **argz, size t *argz_len, char [Function]
*before, const char *entry)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theargz_insertfunction inserts the stringentryinto the argz vector*argzat a
point just before the existing element pointed to bybefore, reallocating*argzand
updating*argzand*argz_len. Ifbeforeis 0 ,entryis added to the end instead (as
if byargz_add). Since the first element is in fact the same as*argz, passing in*argz
as the value ofbeforewill result inentrybeing inserted at the beginning.

char * argz_next (const char *argz, sizetargz_len, const char [Function]
*entry)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theargz_nextfunction provides a convenient way of iterating over the elements in
the argz vectorargz. It returns a pointer to the next element inargzafter the element
entry, or 0 if there are no elements followingentry. Ifentryis 0 , the first element of
argzis returned.
This behavior suggests two styles of iteration:
char *entry = 0;
while ((entry = argz_next (argz,argz_len, entry)))
action;
(the double parentheses are necessary to make some C compilers shut up about what
they consider a questionablewhile-test) and:
char *entry;
for (entry = argz;
entry;
entry = argz_next (argz,argz_len, entry))
action;
Note that the latter depends onargzhaving a value of 0 if it is empty (rather than a
pointer to an empty block of memory); this invariant is maintained for argz vectors
created by the functions here.

error_t argz_replace(char **argz, sizet *argz_len, [Function]
const char *str, const char *with, unsigned *replace_count)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 5: String and Array Utilities 138

```
Replace any occurrences of the stringstr in argzwith with, reallocatingargz as
necessary. Ifreplacecountis non-zero,*replace_countwill be incremented by the
number of replacements performed.
```
## 5.15.2 Envz Functions.........................................

Envz vectors are just argz vectors with additional constraints on the form of each element;
as such, argz functions can also be used on them, where it makes sense.

Each element in an envz vector is a name-value pair, separated by a'='byte; if multiple
'='bytes are present in an element, those after the first are considered part of the value,
and treated like all other non-'\0'bytes.

Ifno'='bytes are present in an element, that element is considered the name of a
¡°null¡± entry, as distinct from an entry with an empty value:envz_getwill return 0 if given
the name of null entry, whereas an entry with an empty value would result in a value of
"";envz_entrywill still find such entries, however. Null entries can be removed with the
envz_stripfunction.

As with argz functions, envz functions that may allocate memory (and thus fail) have a
return type oferror_t, and return either 0 orENOMEM.

```
These functions are declared in the standard include fileenvz.h.
```
char * envz_entry(const char *envz, sizetenvz_len, const char [Function]
*name)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theenvz_entryfunction finds the entry inenvzwith the namename, and returns a
pointer to the whole entry¡ªthat is, the argz element which begins withnamefollowed
by a'='byte. If there is no entry with that name, 0 is returned.

char * envz_get (const char *envz, size tenvz_len, const char [Function]
*name)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theenvz_getfunction finds the entry inenvzwith the namename(likeenvz_entry),
and returns a pointer to the value portion of that entry (following the'='). If there
is no entry with that name (or only a null entry), 0 is returned.

error_t envz_add (char **envz, size t *envz_len, const char [Function]
*name, const char *value)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theenvz_addfunction adds an entry to*envz(updating*envzand*envz_len)
with the namename, and valuevalue. If an entry with the same name already exists
inenvz, it is removed first. Ifvalueis 0 , then the new entry will be the special null
type of entry (mentioned above).

error_t envz_merge(char **envz, sizet *envz_len, const char [Function]
*envz2, sizetenvz2_len, intoverride)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 5: String and Array Utilities 139

```
Theenvz_merge function adds each entry inenvz2toenvz, as if withenvz_add,
updating*envzand*envz_len. Ifoverrideis true, then values inenvz2will supersede
those with the same name inenvz, otherwise not.
Null entries are treated just like other entries in this respect, so a null entry inenvz
can prevent an entry of the same name inenvz2from being added toenvz, ifoverride
is false.
```
void envz_strip (char **envz, sizet *envz_len) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theenvz_stripfunction removes any null entries fromenvz, updating*envzand
*envz_len.

void envz_remove (char **envz, size t *envz_len, const char [Function]
*name)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theenvz_removefunction removes an entry namednamefromenvz, updating*envz
and*envz_len.


### 140

## 6 Character Set Handling......................

## 6 Character Set Handling...............................

Character sets used in the early days of computing had only six, seven, or eight bits for
each character: there was never a case where more than eight bits (one byte) were used
to represent a single character. The limitations of this approach became more apparent
as more people grappled with non-Roman character sets, where not all the characters that
make up a language¡¯s character set can be represented by 2^8 choices. This chapter shows
the functionality that was added to the C library to support multiple character sets.

## 6.1 Introduction to Extended Characters.........................

A variety of solutions are available to overcome the differences between character sets with
a 1:1 relation between bytes and characters and character sets with ratios of 2:1 or 4:1.
The remainder of this section gives a few examples to help understand the design decisions
made while developing the functionality of the C library.

A distinction we have to make right away is between internal and external representation.
Internal representationmeans the representation used by a program while keeping the text
in memory. External representations are used when text is stored or transmitted through
some communication channel. Examples of external representations include files waiting in
a directory to be read and parsed.

Traditionally there has been no difference between the two representations. It was equally
comfortable and useful to use the same single-byte representation internally and externally.
This comfort level decreases with more and larger character sets.

One of the problems to overcome with the internal representation is handling text that
is externally encoded using different character sets. Assume a program that reads two texts
and compares them using some metric. The comparison can be usefully done only if the
texts are internally kept in a common format.

For such a common format (= character set) eight bits are certainly no longer enough.
So the smallest entity will have to grow:wide characterswill now be used. Instead of one
byte per character, two or four will be used instead. (Three are not good to address in
memory and more than four bytes seem not to be necessary).

As shown in some other part of this manual, a completely new family has been created
of functions that can handle wide character texts in memory. The most commonly used
character sets for such internal wide character representations are Unicode and ISO 10646
(also known as UCS for Universal Character Set). Unicode was originally planned as a 16-
bit character set; whereas, ISO 10646 was designed to be a 31-bit large code space. The two
standards are practically identical. They have the same character repertoire and code table,
but Unicode specifies added semantics. At the moment, only characters in the first0x10000
code positions (the so-called Basic Multilingual Plane, BMP) have been assigned, but the
assignment of more specialized characters outside this 16-bit space is already in progress.
A number of encodings have been defined for Unicode and ISO 10646 characters: UCS-2
is a 16-bit word that can only represent characters from the BMP, UCS-4 is a 32-bit word
than can represent any Unicode and ISO 10646 character, UTF-8 is an ASCII compatible
encoding where ASCII characters are represented by ASCII bytes and non-ASCII characters
by sequences of 2-6 non-ASCII bytes, and finally UTF-16 is an extension of UCS-2 in which
pairs of certain UCS-2 words can be used to encode non-BMP characters up to0x10ffff.


Chapter 6: Character Set Handling 141

To represent wide characters thechartype is not suitable. For this reason the ISO C
standard introduces a new type that is designed to keep one character of a wide character
string. To maintain the similarity there is also a type corresponding toint for those
functions that take a single wide character.

wchar_t [Data type]
This data type is used as the base type for wide character strings. In other words,
arrays of objects of this type are the equivalent ofchar[]for multibyte character
strings. The type is defined instddef.h.
The ISO C90 standard, wherewchar_twas introduced, does not say anything specific
about the representation. It only requires that this type is capable of storing all
elements of the basic character set. Therefore it would be legitimate to definewchar_
taschar, which might make sense for embedded systems.
But in the GNU C Librarywchar_tis always 32 bits wide and, therefore, capable of
representing all UCS-4 values and, therefore, covering all of ISO 10646. Some Unix
systems definewchar_tas a 16-bit type and thereby follow Unicode very strictly.
This definition is perfectly fine with the standard, but it also means that to repre-
sent all characters from Unicode and ISO 10646 one has to use UTF-16 surrogate
characters, which is in fact a multi-wide-character encoding. But resorting to multi-
wide-character encoding contradicts the purpose of thewchar_ttype.

wint_t [Data type]
wint_tis a data type used for parameters and variables that contain a single wide
character. As the name suggests this type is the equivalent ofintwhen using the
normalcharstrings. The typeswchar_tandwint_toften have the same represen-
tation if their size is 32 bits wide but ifwchar_tis defined ascharthe typewint_t
must be defined asintdue to the parameter promotion.
This type is defined inwchar.hand was introduced in Amendment 1 to ISO C90.

As there are for thechardata type macros are available for specifying the minimum
and maximum value representable in an object of typewchar_t.

wint_t WCHAR_MIN [Macro]
The macroWCHAR_MINevaluates to the minimum value representable by an object of
typewint_t.
This macro was introduced in Amendment 1 to ISO C90.

wint_t WCHAR_MAX [Macro]
The macroWCHAR_MAXevaluates to the maximum value representable by an object of
typewint_t.
This macro was introduced in Amendment 1 to ISO C90.

```
Another special wide character value is the equivalent toEOF.
```
wint_t WEOF [Macro]
The macroWEOFevaluates to a constant expression of typewint_twhose value is
different from any member of the extended character set.


Chapter 6: Character Set Handling 142

```
WEOFneed not be the same value asEOFand unlikeEOFit also neednotbe negative.
In other words, sloppy code like
{
int c;
...
while ((c = getc (fp)) < 0)
...
}
has to be rewritten to useWEOFexplicitly when wide characters are used:
{
wint_t c;
...
while ((c = getwc (fp)) != WEOF)
...
}
This macro was introduced in Amendment 1 to ISO C90 and is defined inwchar.h.
```
These internal representations present problems when it comes to storage and transmit-
tal. Because each single wide character consists of more than one byte, they are affected by
byte-ordering. Thus, machines with different endianesses would see different values when
accessing the same data. This byte ordering concern also applies for communication pro-
tocols that are all byte-based and therefore require that the sender has to decide about
splitting the wide character in bytes. A last (but not least important) point is that wide
characters often require more storage space than a customized byte-oriented character set.

For all the above reasons, an external encoding that is different from the internal encoding
is often used if the latter is UCS-2 or UCS-4. The external encoding is byte-based and can
be chosen appropriately for the environment and for the texts to be handled. A variety of
different character sets can be used for this external encoding (information that will not
be exhaustively presented here¨Cinstead, a description of the major groups will suffice). All
of the ASCII-based character sets fulfill one requirement: they are"filesystem safe."This
means that the character'/'is used in the encodingonlyto represent itself. Things are a
bit different for character sets like EBCDIC (Extended Binary Coded Decimal Interchange
Code, a character set family used by IBM), but if the operating system does not understand
EBCDIC directly the parameters-to-system calls have to be converted first anyhow.

- The simplest character sets are single-byte character sets. There can be only up to
    256 characters (for 8 bit character sets), which is not sufficient to cover all languages
    but might be sufficient to handle a specific text. Handling of a 8 bit character sets is
    simple. This is not true for other kinds presented later, and therefore, the application
    one uses might require the use of 8 bit character sets.
- The ISO 2022 standard defines a mechanism for extended character sets where one
    charactercanbe represented by more than one byte. This is achieved by associating a
    state with the text. Characters that can be used to change the state can be embedded
    in the text. Each byte in the text might have a different interpretation in each state.
    The state might even influence whether a given byte stands for a character on its own
    or whether it has to be combined with some more bytes.
    In most uses of ISO 2022 the defined character sets do not allow state changes that
    cover more than the next character. This has the big advantage that whenever one
    can identify the beginning of the byte sequence of a character one can interpret a text


Chapter 6: Character Set Handling 143

```
correctly. Examples of character sets using this policy are the various EUC character
sets (used by Sun¡¯s operating systems, EUC-JP, EUC-KR, EUC-TW, and EUC-CN)
or ShiftJIS (SJIS, a Japanese encoding).
But there are also character sets using a state that is valid for more than one character
and has to be changed by another byte sequence. Examples for this are ISO-2022-JP,
ISO-2022-KR, and ISO-2022-CN.
```
- Early attempts to fix 8 bit character sets for other languages using the Roman alphabet
    lead to character sets like ISO 6937. Here bytes representing characters like the acute
    accent do not produce output themselves: one has to combine them with other charac-
    ters to get the desired result. For example, the byte sequence0xc2 0x61(non-spacing
    acute accent, followed by lower-case ¡®a¡¯) to get the ¡°small a with acute¡± character. To
    get the acute accent character on its own, one has to write0xc2 0x20(the non-spacing
    acute followed by a space).
    Character sets like ISO 6937 are used in some embedded systems such as teletex.
- Instead of converting the Unicode or ISO 10646 text used internally, it is often also
    sufficient to simply use an encoding different than UCS-2/UCS-4. The Unicode and
    ISO 10646 standards even specify such an encoding: UTF-8. This encoding is able to
    represent all of ISO 10646 31 bits in a byte string of length one to six.
    There were a few other attempts to encode ISO 10646 such as UTF-7, but UTF-8 is
    today the only encoding that should be used. In fact, with any luck UTF-8 will soon be
    the only external encoding that has to be supported. It proves to be universally usable
    and its only disadvantage is that it favors Roman languages by making the byte string
    representation of other scripts (Cyrillic, Greek, Asian scripts) longer than necessary if
    using a specific character set for these scripts. Methods like the Unicode compression
    scheme can alleviate these problems.

The question remaining is: how to select the character set or encoding to use. The
answer: you cannot decide about it yourself, it is decided by the developers of the system
or the majority of the users. Since the goal is interoperability one has to use whatever the
other people one works with use. If there are no constraints, the selection is based on the
requirements the expected circle of users will have. In other words, if a project is expected
to be used in only, say, Russia it is fine to use KOI8-R or a similar character set. But if
at the same time people from, say, Greece are participating one should use a character set
that allows all people to collaborate.

The most widely useful solution seems to be: go with the most general character set,
namely ISO 10646. Use UTF-8 as the external encoding and problems about users not
being able to use their own language adequately are a thing of the past.

One final comment about the choice of the wide character representation is necessary
at this point. We have said above that the natural choice is using Unicode or ISO 10646.
This is not required, but at least encouraged, by the ISO C standard. The standard defines
at least a macro__STDC_ISO_10646__that is only defined on systems where thewchar_t
type encodes ISO 10646 characters. If this symbol is not defined one should avoid making
assumptions about the wide character representation. If the programmer uses only the
functions provided by the C library to handle wide character strings there should be no
compatibility problems with other systems.


Chapter 6: Character Set Handling 144

## 6.2 Overview about Character Handling Functions................

A Unix C library contains three different sets of functions in two families to handle character
set conversion. One of the function families (the most commonly used) is specified in the
ISO C90 standard and, therefore, is portable even beyond the Unix world. Unfortunately
this family is the least useful one. These functions should be avoided whenever possible,
especially when developing libraries (as opposed to applications).

The second family of functions got introduced in the early Unix standards (XPG2) and
is still part of the latest and greatest Unix standard: Unix 98. It is also the most powerful
and useful set of functions. But we will start with the functions defined in Amendment 1
to ISO C90.

## 6.3 Restartable Multibyte Conversion Functions..................

The ISO C standard defines functions to convert strings from a multibyte representation to
wide character strings. There are a number of peculiarities:

- The character set assumed for the multibyte encoding is not specified as an argument
    to the functions. Instead the character set specified by theLC_CTYPEcategory of the
    current locale is used; seeSection 7.3 [Locale Categories], page 184.
- The functions handling more than one character at a time require NUL terminated
    strings as the argument (i.e., converting blocks of text does not work unless one can
    add a NUL byte at an appropriate place). The GNU C Library contains some extensions
    to the standard that allow specifying a size, but basically they also expect terminated
    strings.

Despite these limitations the ISO C functions can be used in many contexts. In graphical
user interfaces, for instance, it is not uncommon to have functions that require text to be
displayed in a wide character string if the text is not simple ASCII. The text itself might
come from a file with translations and the user should decide about the current locale,
which determines the translation and therefore also the external encoding used. In such a
situation (and many others) the functions described here are perfect. If more freedom while
performing the conversion is necessary take a look at theiconvfunctions (seeSection 6.5
[Generic Charset Conversion], page 162).

## 6.3.1 Selecting the conversion and its properties...............

We already said above that the currently selected locale for theLC_CTYPEcategory decides
the conversion that is performed by the functions we are about to describe. Each locale
uses its own character set (given as an argument tolocaledef) and this is the one assumed
as the external multibyte encoding. The wide character set is always UCS-4 in the GNU C
Library.

A characteristic of each multibyte character set is the maximum number of bytes that
can be necessary to represent one character. This information is quite important when
writing code that uses the conversion functions (as shown in the examples below). The
ISO C standard defines two macros that provide this information.


Chapter 6: Character Set Handling 145

int MB_LEN_MAX [Macro]
MB_LEN_MAXspecifies the maximum number of bytes in the multibyte sequence for a
single character in any of the supported locales. It is a compile-time constant and is
defined inlimits.h.

int MB_CUR_MAX [Macro]
MB_CUR_MAXexpands into a positive integer expression that is the maximum number
of bytes in a multibyte character in the current locale. The value is never greater than
MB_LEN_MAX. UnlikeMB_LEN_MAXthis macro need not be a compile-time constant, and
in the GNU C Library it is not.
MB_CUR_MAXis defined instdlib.h.

Two different macros are necessary since strictly ISO C90 compilers do not allow variable
length array definitions, but still it is desirable to avoid dynamic allocation. This incomplete
piece of code shows the problem:

```
{
char buf[MB_LEN_MAX];
ssize_t len = 0;
```
while (! feof (fp))
{
fread (&buf[len], 1, MB_CUR_MAX - len, fp);
/*... processbuf */
len -= used;
}
}
The code in the inner loop is expected to have always enough bytes in the arraybuf
to convert one multibyte character. The arraybuf has to be sized statically since many
compilers do not allow a variable size. Thefreadcall makes sure thatMB_CUR_MAXbytes
are always available inbuf. Note that it isn¡¯t a problem ifMB_CUR_MAXis not a compile-time
constant.

## 6.3.2 Representing the state of the conversion.................

In the introduction of this chapter it was said that certain character sets use astateful
encoding. That is, the encoded values depend in some way on the previous bytes in the
text.

Since the conversion functions allow converting a text in more than one step we must
have a way to pass this information from one call of the functions to another.

mbstate_t [Data type]
A variable of typembstate_tcan contain all the information about theshift state
needed from one call to a conversion function to another.
mbstate_tis defined inwchar.h. It was introduced in Amendment 1 to ISO C90.

To use objects of typembstate_tthe programmer has to define such objects (normally
as local variables on the stack) and pass a pointer to the object to the conversion functions.
This way the conversion function can update the object if the current multibyte character
set is stateful.


Chapter 6: Character Set Handling 146

There is no specific function or initializer to put the state object in any specific state.
The rules are that the object should always represent the initial state before the first use,
and this is achieved by clearing the whole variable with code such as follows:
{
mbstate_t state;
memset (&state, '\0', sizeof (state));
/*from now onstatecan be used. */

}
When using the conversion functions to generate output it is often necessary to test
whether the current state corresponds to the initial state. This is necessary, for example,
to decide whether to emit escape sequences to set the state to the initial state at certain
sequence points. Communication protocols often require this.

int mbsinit(const mbstatet *ps) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thembsinitfunction determines whether the state object pointed to bypsis in the
initial state. Ifpsis a null pointer or the object is in the initial state the return value
is nonzero. Otherwise it is zero.
mbsinitwas introduced in Amendment 1 to ISO C90 and is declared inwchar.h.

```
Code usingmbsinitoften looks similar to this:
{
mbstate_t state;
memset (&state, '\0', sizeof (state));
/*Usestate. */
```
```
if (! mbsinit (&state))
{
/*Emit code to return to initial state. */
const wchar_t empty[] = L"";
const wchar_t *srcp = empty;
wcsrtombs (outbuf, &srcp, outbuflen, &state);
}
```
}
The code to emit the escape sequence to get back to the initial state is interesting. The
wcsrtombsfunction can be used to determine the necessary output code (seeSection 6.3.4
[Converting Multibyte and Wide Character Strings], page 153). Please note that with the
GNU C Library it is not necessary to perform this extra action for the conversion from
multibyte text to wide character text since the wide character encoding is not stateful. But
there is nothing mentioned in any standard that prohibits makingwchar_tuse a stateful
encoding.

## 6.3.3 Converting Single Characters............................

The most fundamental of the conversion functions are those dealing with single characters.
Please note that this does not always mean single bytes. But since there is very often
a subset of the multibyte character set that consists of single byte sequences, there are
functions to help with converting bytes. Frequently, ASCII is a subset of the multibyte


Chapter 6: Character Set Handling 147

character set. In such a scenario, each ASCII character stands for itself, and all other
characters have at least a first byte that is beyond the range 0 to 127.

wint_t btowc (intc) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt heap lock dlopen|AC-Unsafe corrupt
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thebtowcfunction (¡°byte to wide character¡±) converts a valid single byte character
cin the initial shift state into the wide character equivalent using the conversion rules
from the currently selected locale of theLC_CTYPEcategory.
If(unsigned char)cis no valid single byte multibyte character or ifcisEOF, the
function returnsWEOF.
Please note the restriction ofcbeing tested for validity only in the initial shift state.
Nombstate_tobject is used from which the state information is taken, and the
function also does not use any static state.
Thebtowcfunction was introduced in Amendment 1 to ISO C90 and is declared in
wchar.h.

Despite the limitation that the single byte value is always interpreted in the initial state,
this function is actually useful most of the time. Most characters are either entirely single-
byte character sets or they are extensions to ASCII. But then it is possible to write code
like this (not that this specific example is very useful):
wchar_t *
itow (unsigned long int val)
{
static wchar_t buf[30];
wchar_t *wcp = &buf[29];
*wcp = L'\0';
while (val != 0)
{
*--wcp = btowc ('0' + val % 10);
val /= 10;
}
if (wcp == &buf[29])
*--wcp = L'0';
return wcp;
}
Why is it necessary to use such a complicated implementation and not simply cast'0'
+ val % 10to a wide character? The answer is that there is no guarantee that one can
perform this kind of arithmetic on the character of the character set used forwchar_t
representation. In other situations the bytes are not constant at compile time and so the
compiler cannot do the work. In situations like this, usingbtowcis required.

There is also a function for the conversion in the other direction.

int wctob (winttc) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt heap lock dlopen|AC-Unsafe corrupt
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewctobfunction (¡°wide character to byte¡±) takes as the parameter a valid wide
character. If the multibyte representation for this character in the initial state is


Chapter 6: Character Set Handling 148

```
exactly one byte long, the return value of this function is this character. Otherwise
the return value isEOF.
wctobwas introduced in Amendment 1 to ISO C90 and is declared inwchar.h.
```
There are more general functions to convert single characters from multibyte represen-
tation to wide characters and vice versa. These functions pose no limit on the length of the
multibyte representation and they also do not require it to be in the initial state.

size_t mbrtowc(wchart *restrictpwc, const char *restricts, sizet [Function]
n, mbstatet *restrictps)
Preliminary: |MT-Unsafe race:mbrtowc/!ps|AS-Unsafe corrupt heap lock dlopen
|AC-Unsafe corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thembrtowcfunction (¡°multibyte restartable to wide character¡±) converts the next
multibyte character in the string pointed to bysinto a wide character and stores it in
the location pointed to bypwc. The conversion is performed according to the locale
currently selected for theLC_CTYPEcategory. If the conversion for the character set
used in the locale requires a state, the multibyte string is interpreted in the state
represented by the object pointed to byps. Ifpsis a null pointer, a static, internal
state variable used only by thembrtowcfunction is used.
If the next multibyte character corresponds to the null wide character, the return
value of the function is 0 and the state object is afterwards in the initial state. If
the nextnor fewer bytes form a correct multibyte character, the return value is the
number of bytes starting fromsthat form the multibyte character. The conversion
state is updated according to the bytes consumed in the conversion. In both cases
the wide character (either theL'\0'or the one found in the conversion) is stored in
the string pointed to bypwcifpwcis not null.
If the firstnbytes of the multibyte string possibly form a valid multibyte character
but there are more thannbytes needed to complete it, the return value of the function
is(size_t) -2and no value is stored in*pwc. The conversion state is updated and
allninput bytes are consumed and should not be submitted again. Please note that
this can happen even ifnhas a value greater than or equal toMB_CUR_MAXsince the
input might contain redundant shift sequences.
If the firstnbytes of the multibyte string cannot possibly form a valid multibyte
character, no value is stored, the global variableerrnois set to the valueEILSEQ,
and the function returns(size_t) -1. The conversion state is afterwards undefined.
As specified, thembrtowcfunction could deal with multibyte sequences which contain
embedded null bytes (which happens in Unicode encodings such as UTF-16), but the
GNU C Library does not support such multibyte encodings. When encountering a null
input byte, the function will either return zero, or return(size_t) -1)and report
aEILSEQerror. Theiconvfunction can be used for converting between arbitrary
encodings. SeeSection 6.5.1 [Generic Character Set Conversion Interface], page 162.
mbrtowcwas introduced in Amendment 1 to ISO C90 and is declared inwchar.h.

A function that copies a multibyte string into a wide character string while at the same
time converting all lowercase characters into uppercase could look like this:
wchar_t *


Chapter 6: Character Set Handling 149

```
mbstouwcs (const char *s)
{
/*Include the null terminator in the conversion.*/
size_t len = strlen (s) + 1;
wchar_t *result = reallocarray (NULL, len, sizeof (wchar_t));
if (result == NULL)
return NULL;
```
```
wchar_t *wcp = result;
mbstate_t state;
memset (&state, '\0', sizeof (state));
```
```
while (true)
{
wchar_t wc;
size_t nbytes = mbrtowc (&wc, s, len, &state);
if (nbytes == 0)
{
/*Terminate the result string.*/
*wcp = L'\0';
break;
}
else if (nbytes == (size_t) -2)
{
/*Truncated input string.*/
errno = EILSEQ;
free (result);
return NULL;
}
else if (nbytes == (size_t) -1)
{
/*Some other error (including EILSEQ).*/
free (result);
return NULL;
}
else
{
/*A character was converted.*/
*wcp++ = towupper (wc);
len -= nbytes;
s += nbytes;
}
}
return result;
}
```
In the inner loop, a single wide character is stored inwc, and the number of consumed
bytes is stored in the variablenbytes. If the conversion is successful, the uppercase variant
of the wide character is stored in theresultarray and the pointer to the input string and
the number of available bytes is adjusted. If thembrtowcfunction returns zero, the null
input byte has not been converted, so it must be stored explicitly in the result.

The above code uses the fact that there can never be more wide characters in the
converted result than there are bytes in the multibyte input string. This method yields a
pessimistic guess about the size of the result, and if many wide character strings have to be
constructed this way or if the strings are long, the extra memory required to be allocated
because the input string contains multibyte characters might be significant. The allocated


Chapter 6: Character Set Handling 150

memory block can be resized to the correct size before returning it, but a better solution
might be to allocate just the right amount of space for the result right away. Unfortunately
there is no function to compute the length of the wide character string directly from the
multibyte string. There is, however, a function that does part of the work.

size_t mbrlen(const char *restricts, size tn, mbstatet *ps) [Function]
Preliminary: |MT-Unsafe race:mbrlen/!ps|AS-Unsafe corrupt heap lock dlopen
|AC-Unsafe corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thembrlenfunction (¡°multibyte restartable length¡±) computes the number of at most
nbytes starting ats, which form the next valid and complete multibyte character.
If the next multibyte character corresponds to the NUL wide character, the return
value is 0. If the nextnbytes form a valid multibyte character, the number of bytes
belonging to this multibyte character byte sequence is returned.
If the firstnbytes possibly form a valid multibyte character but the character is
incomplete, the return value is(size_t) -2. Otherwise the multibyte character se-
quence is invalid and the return value is(size_t) -1.
The multibyte sequence is interpreted in the state represented by the object pointed
to byps. Ifpsis a null pointer, a state object local tombrlenis used.
mbrlenwas introduced in Amendment 1 to ISO C90 and is declared inwchar.h.

The attentive reader now will note thatmbrlencan be implemented as
mbrtowc (NULL, s, n, ps != NULL? ps : &internal)
This is true and in fact is mentioned in the official specification. How can this function be
used to determine the length of the wide character string created from a multibyte character
string? It is not directly usable, but we can define a functionmbslenusing it:
size_t
mbslen (const char *s)
{
mbstate_t state;
size_t result = 0;
size_t nbytes;
memset (&state, '\0', sizeof (state));
while ((nbytes = mbrlen (s, MB_LEN_MAX, &state)) > 0)
{
if (nbytes >= (size_t) -2)
/* Something is wrong. */
return (size_t) -1;
s += nbytes;
++result;
}
return result;
}
This function simply callsmbrlenfor each multibyte character in the string and counts
the number of function calls. Please note that we here useMB_LEN_MAXas the size argument
in thembrlencall. This is acceptable since a) this value is larger than the length of the
longest multibyte character sequence and b) we know that the stringsends with a NUL byte,
which cannot be part of any other multibyte character sequence but the one representing
the NUL wide character. Therefore, thembrlenfunction will never read invalid memory.


Chapter 6: Character Set Handling 151

Now that this function is available (just to make this clear, this function isnotpart of
the GNU C Library) we can compute the number of wide characters required to store the
converted multibyte character stringsusing
wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);
Please note that the mbslen function is quite inefficient. The implementation of
mbstouwcswithmbslenwould have to perform the conversion of the multibyte character
input string twice, and this conversion might be quite expensive. So it is necessary to
think about the consequences of using the easier but imprecise method before doing the
work twice.

size_t wcrtomb(char *restricts, wchartwc, mbstatet *restrictps) [Function]
Preliminary: |MT-Unsafe race:wcrtomb/!ps|AS-Unsafe corrupt heap lock dlopen
|AC-Unsafe corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thewcrtombfunction (¡°wide character restartable to multibyte¡±) converts a single
wide character into a multibyte string corresponding to that wide character.
Ifsis a null pointer, the function resets the state stored in the object pointed to by
ps(or the internalmbstate_tobject) to the initial state. This can also be achieved
by a call like this:
wcrtombs (temp_buf, L'\0', ps)
since, ifsis a null pointer,wcrtombperforms as if it writes into an internal buffer,
which is guaranteed to be large enough.
Ifwcis the NUL wide character,wcrtombemits, if necessary, a shift sequence to get
the statepsinto the initial state followed by a single NUL byte, which is stored in
the strings.
Otherwise a byte sequence (possibly including shift sequences) is written into the
strings. This only happens ifwcis a valid wide character (i.e., it has a multibyte
representation in the character set selected by locale of theLC_CTYPEcategory). Ifwc
is no valid wide character, nothing is stored in the stringss,errnois set toEILSEQ,
the conversion state inpsis undefined and the return value is(size_t) -1.
If no error occurred the function returns the number of bytes stored in the strings.
This includes all bytes representing shift sequences.
One word about the interface of the function: there is no parameter specifying the
length of the arrays. Instead the function assumes that there are at leastMB_CUR_MAX
bytes available since this is the maximum length of any byte sequence representing a
single character. So the caller has to make sure that there is enough space available,
otherwise buffer overruns can occur.
wcrtombwas introduced in Amendment 1 to ISO C90 and is declared inwchar.h.

Usingwcrtombis as easy as usingmbrtowc. The following example appends a wide
character string to a multibyte character string. Again, the code is not really useful (or
correct), it is simply here to demonstrate the use and some problems.
char *
mbscatwcs (char *s, size_t len, const wchar_t *ws)
{
mbstate_t state;


Chapter 6: Character Set Handling 152

/*Find the end of the existing string. */
char *wp = strchr (s, '\0');
len -= wp - s;
memset (&state, '\0', sizeof (state));
do
{
size_t nbytes;
if (len < MB_CUR_LEN)
{
/*We cannot guarantee that the next
character fits into the buffer, so
return an error. */
errno = E2BIG;
return NULL;
}
nbytes = wcrtomb (wp, *ws, &state);
if (nbytes == (size_t) -1)
/* Error in the conversion. */
return NULL;
len -= nbytes;
wp += nbytes;
}
while (*ws++ != L'\0');
return s;
}
First the function has to find the end of the string currently in the arrays. Thestrchr
call does this very efficiently since a requirement for multibyte character representations is
that the NUL byte is never used except to represent itself (and in this context, the end of
the string).

After initializing the state object the loop is entered where the first task is to make sure
there is enough room in the arrays. We abort if there are not at leastMB_CUR_LENbytes
available. This is not always optimal but we have no other choice. We might have less than
MB_CUR_LENbytes available but the next multibyte character might also be only one byte
long. At the time thewcrtombcall returns it is too late to decide whether the buffer was
large enough. If this solution is unsuitable, there is a very slow but more accurate solution.
...
if (len < MB_CUR_LEN)
{
mbstate_t temp_state;
memcpy (&temp_state, &state, sizeof (state));
if (wcrtomb (NULL, *ws, &temp_state) > len)
{
/*We cannot guarantee that the next
character fits into the buffer, so
return an error. */
errno = E2BIG;
return NULL;
}
}
...
Here we perform the conversion that might overflow the buffer so that we are afterwards
in the position to make an exact decision about the buffer size. Please note theNULL
argument for the destination buffer in the newwcrtombcall; since we are not interested in
the converted text at this point, this is a nice way to express this. The most unusual thing


Chapter 6: Character Set Handling 153

about this piece of code certainly is the duplication of the conversion state object, but if a
change of the state is necessary to emit the next multibyte character, we want to have the
same shift state change performed in the real conversion. Therefore, we have to preserve
the initial shift state information.

There are certainly many more and even better solutions to this problem. This example
is only provided for educational purposes.

## 6.3.4 Converting Multibyte and Wide Character Strings.......

The functions described in the previous section only convert a single character at a time.
Most operations to be performed in real-world programs include strings and therefore the
ISO C standard also defines conversions on entire strings. However, the defined set of
functions is quite limited; therefore, the GNU C Library contains a few extensions that can
help in some important situations.

size_t mbsrtowcs (wchart *restrictdst, const char **restrictsrc, [Function]
sizetlen, mbstatet *restrictps)
Preliminary:|MT-Unsafe race:mbsrtowcs/!ps|AS-Unsafe corrupt heap lock dlopen
|AC-Unsafe corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thembsrtowcsfunction (¡°multibyte string restartable to wide character string¡±)
converts the NUL-terminated multibyte character string at*srcinto an equivalent
wide character string, including the NUL wide character at the end. The conversion
is started using the state information from the object pointed to bypsor from an
internal object ofmbsrtowcsifpsis a null pointer. Before returning, the state object
is updated to match the state after the last converted character. The state is the
initial state if the terminating NUL byte is reached and converted.
Ifdstis not a null pointer, the result is stored in the array pointed to bydst; otherwise,
the conversion result is not available since it is stored in an internal buffer.
Iflenwide characters are stored in the arraydstbefore reaching the end of the input
string, the conversion stops andlenis returned. Ifdstis a null pointer,lenis never
checked.
Another reason for a premature return from the function call is if the input string
contains an invalid multibyte sequence. In this case the global variableerrnois set
toEILSEQand the function returns(size_t) -1.
In all other cases the function returns the number of wide characters converted during
this call. Ifdstis not null,mbsrtowcsstores in the pointer pointed to bysrceither a
null pointer (if the NUL byte in the input string was reached) or the address of the
byte following the last converted multibyte character.
Likembstowcsthedstparameter may be a null pointer and the function can be used
to count the number of wide characters that would be required.
mbsrtowcswas introduced in Amendment 1 to ISO C90 and is declared inwchar.h.

The definition of thembsrtowcsfunction has one important limitation. The requirement
thatdsthas to be a NUL-terminated string provides problems if one wants to convert buffers
with text. A buffer is not normally a collection of NUL-terminated strings but instead a
continuous collection of lines, separated by newline characters. Now assume that a function


Chapter 6: Character Set Handling 154

to convert one line from a buffer is needed. Since the line is not NUL-terminated, the source
pointer cannot directly point into the unmodified text buffer. This means, either one inserts
the NUL byte at the appropriate place for the time of thembsrtowcsfunction call (which is
not doable for a read-only buffer or in a multi-threaded application) or one copies the line
in an extra buffer where it can be terminated by a NUL byte. Note that it is not in general
possible to limit the number of characters to convert by setting the parameterlento any
specific value. Since it is not known how many bytes each multibyte character sequence is
in length, one can only guess.

There is still a problem with the method of NUL-terminating a line right after the
newline character, which could lead to very strange results. As said in the description of
thembsrtowcsfunction above, the conversion state is guaranteed to be in the initial shift
state after processing the NUL byte at the end of the input string. But this NUL byte is
not really part of the text (i.e., the conversion state after the newline in the original text
could be something different than the initial shift state and therefore the first character
of the next line is encoded using this state). But the state in question is never accessible
to the user since the conversion stops after the NUL byte (which resets the state). Most
stateful character sets in use today require that the shift state after a newline be the initial
state¨Cbut this is not a strict guarantee. Therefore, simply NUL-terminating a piece of a
running text is not always an adequate solution and, therefore, should never be used in
generally used code.

The generic conversion interface (seeSection 6.5 [Generic Charset Conversion], page 162)
does not have this limitation (it simply works on buffers, not strings), and the GNU C
Library contains a set of functions that take additional parameters specifying the maxi-
mal number of bytes that are consumed from the input string. This way the problem of
mbsrtowcs¡¯s example above could be solved by determining the line length and passing this
length to the function.

size_t wcsrtombs (char *restrictdst, const wchart **restrictsrc, [Function]
sizetlen, mbstatet *restrictps)
Preliminary:|MT-Unsafe race:wcsrtombs/!ps|AS-Unsafe corrupt heap lock dlopen
|AC-Unsafe corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thewcsrtombsfunction (¡°wide character string restartable to multibyte string¡±) con-
verts the NUL-terminated wide character string at*srcinto an equivalent multibyte
character string and stores the result in the array pointed to bydst. The NUL wide
character is also converted. The conversion starts in the state described in the object
pointed to bypsor by a state object local towcsrtombsin casepsis a null pointer.
Ifdstis a null pointer, the conversion is performed as usual but the result is not
available. If all characters of the input string were successfully converted and ifdst
is not a null pointer, the pointer pointed to bysrcgets assigned a null pointer.
If one of the wide characters in the input string has no valid multibyte character
equivalent, the conversion stops early, sets the global variableerrnotoEILSEQ, and
returns(size_t) -1.
Another reason for a premature stop is ifdstis not a null pointer and the next
converted character would require more thanlenbytes in total to the arraydst. In


Chapter 6: Character Set Handling 155

```
this case (and ifdstis not a null pointer) the pointer pointed to bysrcis assigned a
value pointing to the wide character right after the last one successfully converted.
Except in the case of an encoding error the return value of thewcsrtombsfunction
is the number of bytes in all the multibyte character sequences which were or would
have been (ifdstwas not a null) stored indst. Before returning, the state in the
object pointed to byps(or the internal object in casepsis a null pointer) is updated
to reflect the state after the last conversion. The state is the initial shift state in case
the terminating NUL wide character was converted.
Thewcsrtombsfunction was introduced in Amendment 1 to ISO C90 and is declared
inwchar.h.
```
The restriction mentioned above for thembsrtowcsfunction applies here also. There is
no possibility of directly controlling the number of input characters. One has to place the
NUL wide character at the correct place or control the consumed input indirectly via the
available output array size (thelenparameter).

size_t mbsnrtowcs(wchart *restrictdst, const char **restrictsrc, [Function]
sizetnmc, sizetlen, mbstatet *restrictps)
Preliminary: | MT-Unsafe race:mbsnrtowcs/!ps | AS-Unsafe corrupt heap lock
dlopen | AC-Unsafe corrupt lock mem fd | See Section 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thembsnrtowcsfunction is very similar to thembsrtowcsfunction. All the param-
eters are the same except fornmc, which is new. The return value is the same as for
mbsrtowcs.
This new parameter specifies how many bytes at most can be used from the multibyte
character string. In other words, the multibyte character string*srcneed not be
NUL-terminated. But if a NUL byte is found within thenmcfirst bytes of the string,
the conversion stops there.
Likembstowcsthedstparameter may be a null pointer and the function can be used
to count the number of wide characters that would be required.
This function is a GNU extension. It is meant to work around the problems mentioned
above. Now it is possible to convert a buffer with multibyte character text piece by
piece without having to care about inserting NUL bytes and the effect of NUL bytes
on the conversion state.

A function to convert a multibyte string into a wide character string and display it could
be written like this (this is not a really useful example):
void
showmbs (const char *src, FILE *fp)
{
mbstate_t state;
int cnt = 0;
memset (&state, '\0', sizeof (state));
while (1)
{
wchar_t linebuf[100];
const char *endp = strchr (src, '\n');
size_t n;


Chapter 6: Character Set Handling 156

```
/*Exit if there is no more line. */
if (endp == NULL)
break;
```
n = mbsnrtowcs (linebuf, &src, endp - src, 99, &state);
linebuf[n] = L'\0';
fprintf (fp, "line %d: \"%S\"\n", linebuf);
}
}
There is no problem with the state after a call tombsnrtowcs. Since we don¡¯t insert
characters in the strings that were not in there right from the beginning and we usestate
only for the conversion of the given buffer, there is no problem with altering the state.

size_t wcsnrtombs(char *restrictdst, const wchart **restrictsrc, [Function]
sizetnwc, sizetlen, mbstatet *restrictps)
Preliminary: | MT-Unsafe race:wcsnrtombs/!ps | AS-Unsafe corrupt heap lock
dlopen | AC-Unsafe corrupt lock mem fd | See Section 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewcsnrtombsfunction implements the conversion from wide character strings to
multibyte character strings. It is similar towcsrtombsbut, just likembsnrtowcs, it
takes an extra parameter, which specifies the length of the input string.
No more thannwcwide characters from the input string*srcare converted. If the
input string contains a NUL wide character in the firstnwccharacters, the conversion
stops at this place.
Thewcsnrtombsfunction is a GNU extension and just like mbsnrtowcshelps in
situations where no NUL-terminated input strings are available.

## 6.3.5 A Complete Multibyte Conversion Example..............

The example programs given in the last sections are only brief and do not contain all the
error checking, etc. Presented here is a complete and documented example. It features the
mbrtowcfunction but it should be easy to derive versions using the other functions.
int
file_mbsrtowcs (int input, int output)
{
/*Note the use ofMB_LEN_MAX.
MB_CUR_MAXcannot portably be used here. */
char buffer[BUFSIZ + MB_LEN_MAX];
mbstate_t state;
int filled = 0;
int eof = 0;

```
/*Initialize the state. */
memset (&state, '\0', sizeof (state));
```
```
while (!eof)
{
ssize_t nread;
ssize_t nwrite;
char *inp = buffer;
wchar_t outbuf[BUFSIZ];
wchar_t *outp = outbuf;
```

Chapter 6: Character Set Handling 157

```
/*Fill up the buffer from the input file. */
nread = read (input, buffer + filled, BUFSIZ);
if (nread < 0)
{
perror ("read");
return 0;
}
/*If we reach end of file, make a note to read no more.*/
if (nread == 0)
eof = 1;
```
```
/* filledis now the number of bytes inbuffer.*/
filled += nread;
```
```
/*Convert those bytes to wide characters¨Cas many as we can.*/
while (1)
{
size_t thislen = mbrtowc (outp, inp, filled, &state);
/*Stop converting at invalid character;
this can mean we have read just the first part
of a valid character. */
if (thislen == (size_t) -1)
break;
/*We want to handle embedded NUL bytes
but the return value is 0. Correct this. */
if (thislen == 0)
thislen = 1;
/*Advance past this character.*/
inp += thislen;
filled -= thislen;
++outp;
}
```
```
/*Write the wide characters we just made. */
nwrite = write (output, outbuf,
(outp - outbuf) * sizeof (wchar_t));
if (nwrite < 0)
{
perror ("write");
return 0;
}
```
```
/*See if we have arealinvalid character.*/
if ((eof && filled > 0) || filled >= MB_CUR_MAX)
{
error (0, 0, "invalid multibyte character");
return 0;
}
```
```
/*If any characters must be carried forward,
put them at the beginning ofbuffer.*/
if (filled > 0)
memmove (buffer, inp, filled);
}
```
```
return 1;
}
```

Chapter 6: Character Set Handling 158

## 6.4 Non-reentrant Conversion Function...........................

The functions described in the previous chapter are defined in Amendment 1 to ISO C90,
but the original ISO C90 standard also contained functions for character set conversion.
The reason that these original functions are not described first is that they are almost
entirely useless.

The problem is that all the conversion functions described in the original ISO C90 use a
local state. Using a local state implies that multiple conversions at the same time (not only
when using threads) cannot be done, and that you cannot first convert single characters
and then strings since you cannot tell the conversion functions which state to use.

These original functions are therefore usable only in a very limited set of situations. One
must complete converting the entire string before starting a new one, and each string/text
must be converted with the same function (there is no problem with the library itself; it is
guaranteed that no library function changes the state of any of these functions). For the
above reasons it is highly requested that the functions described in the previous section be
used in place of non-reentrant conversion functions.

## 6.4.1 Non-reentrant Conversion of Single Characters...........

int mbtowc(wchart *restrictresult, const char *restrictstring, [Function]
sizetsize)
Preliminary:|MT-Unsafe race|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thembtowc(¡°multibyte to wide character¡±) function when called with non-nullstring
converts the first multibyte character beginning atstring to its corresponding wide
character code. It stores the result in*result.
mbtowcnever examines more thansize bytes. (The idea is to supply forsize the
number of bytes of data you have in hand.)
mbtowcwith non-nullstring distinguishes three possibilities: the firstsizebytes at
stringstart with valid multibyte characters, they start with an invalid byte sequence
or just part of a character, orstringpoints to an empty string (a null character).
For a valid multibyte character,mbtowcconverts it to a wide character and stores
that in*result, and returns the number of bytes in that character (always at least
1 and never more thansize).
For an invalid byte sequence,mbtowcreturns?1. For an empty string, it returns 0,
also storing'\0'in*result.
If the multibyte character code uses shift characters, thenmbtowc maintains and
updates a shift state as it scans. If you callmbtowcwith a null pointer forstring, that
initializes the shift state to its standard initial value. It also returns nonzero if the
multibyte character code in use actually has a shift state. SeeSection 6.4.3 [States
in Non-reentrant Functions], page 161.

int wctomb(char *string, wchar twchar) [Function]
Preliminary:|MT-Unsafe race|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 6: Character Set Handling 159

```
Thewctomb(¡°wide character to multibyte¡±) function converts the wide character
codewcharto its corresponding multibyte character sequence, and stores the result
in bytes starting atstring. At mostMB_CUR_MAXcharacters are stored.
wctombwith non-nullstring distinguishes three possibilities forwchar: a valid wide
character code (one that can be translated to a multibyte character), an invalid code,
andL'\0'.
Given a valid code,wctombconverts it to a multibyte character, storing the bytes
starting atstring. Then it returns the number of bytes in that character (always at
least 1 and never more thanMB_CUR_MAX).
Ifwcharis an invalid wide character code,wctombreturns?1. IfwcharisL'\0', it
returns 0 , also storing'\0'in*string.
If the multibyte character code uses shift characters, thenwctomb maintains and
updates a shift state as it scans. If you callwctombwith a null pointer forstring, that
initializes the shift state to its standard initial value. It also returns nonzero if the
multibyte character code in use actually has a shift state. SeeSection 6.4.3 [States
in Non-reentrant Functions], page 161.
Calling this function with a wcharargument of zero when string is not null has
the side-effect of reinitializing the stored shift stateas well asstoring the multibyte
character'\0'and returning 0.
```
Similar tombrlenthere is also a non-reentrant function that computes the length of a
multibyte character. It can be defined in terms ofmbtowc.

int mblen (const char *string, size tsize) [Function]
Preliminary:|MT-Unsafe race|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Themblenfunction with a non-nullstringargument returns the number of bytes that
make up the multibyte character beginning atstring, never examining more thansize
bytes. (The idea is to supply forsizethe number of bytes of data you have in hand.)
The return value ofmblendistinguishes three possibilities: the firstsizebytes at
stringstart with valid multibyte characters, they start with an invalid byte sequence
or just part of a character, orstringpoints to an empty string (a null character).
For a valid multibyte character,mblenreturns the number of bytes in that character
(always at least 1 and never more thansize). For an invalid byte sequence,mblen
returns?1. For an empty string, it returns 0.
If the multibyte character code uses shift characters, thenmblenmaintains and up-
dates a shift state as it scans. If you callmblenwith a null pointer forstring, that
initializes the shift state to its standard initial value. It also returns a nonzero value
if the multibyte character code in use actually has a shift state. SeeSection 6.4.3
[States in Non-reentrant Functions], page 161.
The functionmblenis declared instdlib.h.

## 6.4.2 Non-reentrant Conversion of Strings.....................

For convenience the ISO C90 standard also defines functions to convert entire strings instead
of single characters. These functions suffer from the same problems as their reentrant


Chapter 6: Character Set Handling 160

counterparts from Amendment 1 to ISO C90; seeSection 6.3.4 [Converting Multibyte and
Wide Character Strings], page 153.

size_t mbstowcs (wchart *wstring, const char *string, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Unsafe corrupt heap lock dlopen|AC-Unsafe corrupt
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thembstowcs(¡°multibyte string to wide character string¡±) function converts the
null-terminated string of multibyte charactersstringto an array of wide character
codes, storing not more thansizewide characters into the array beginning atwstring.
The terminating null character counts towards the size, so ifsizeis less than the
actual number of wide characters resulting fromstring, no terminating null character
is stored.
The conversion of characters fromstringbegins in the initial shift state.
If an invalid multibyte character sequence is found, thembstowcsfunction returns
a value of?1. Otherwise, it returns the number of wide characters stored in the
arraywstring. This number does not include the terminating null character, which is
present if the number is less thansize.
Here is an example showing how to convert a string of multibyte characters, allocating
enough space for the result.
wchar_t *
mbstowcs_alloc (const char *string)
{
size_t size = strlen (string) + 1;
wchar_t *buf = xmalloc (size * sizeof (wchar_t));

```
size = mbstowcs (buf, string, size);
if (size == (size_t) -1)
return NULL;
buf = xrealloc (buf, (size + 1) * sizeof (wchar_t));
return buf;
}
Ifwstringis a null pointer then no output is written and the conversion proceeds as
above, and the result is returned. In practice such behaviour is useful for calculating
the exact number of wide characters required to convertstring. This behaviour of
accepting a null pointer forwstringis an XPG4.2 extension that is not specified in
ISO C and is optional in POSIX.
```
size_t wcstombs (char *string, const wchart *wstring, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Unsafe corrupt heap lock dlopen|AC-Unsafe corrupt
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewcstombs(¡°wide character string to multibyte string¡±) function converts the null-
terminated wide character arraywstringinto a string containing multibyte characters,
storing not more thansize bytes starting atstring, followed by a terminating null
character if there is room. The conversion of characters begins in the initial shift
state.
The terminating null character counts towards the size, so ifsizeis less than or equal
to the number of bytes needed inwstring, no terminating null character is stored.


Chapter 6: Character Set Handling 161

```
If a code that does not correspond to a valid multibyte character is found, the
wcstombsfunction returns a value of?1. Otherwise, the return value is the number
of bytes stored in the arraystring. This number does not include the terminating
null character, which is present if the number is less thansize.
```
## 6.4.3 States in Non-reentrant Functions.......................

In some multibyte character codes, themeaningof any particular byte sequence is not fixed;
it depends on what other sequences have come earlier in the same string. Typically there are
just a few sequences that can change the meaning of other sequences; these few are called
shift sequencesand we say that they set theshift statefor other sequences that follow.

To illustrate shift state and shift sequences, suppose we decide that the sequence 0200
(just one byte) enters Japanese mode, in which pairs of bytes in the range from 0240 to 0377
are single characters, while 0201 enters Latin-1 mode, in which single bytes in the range
from 0240 to 0377 are characters, and interpreted according to the ISO Latin-1 character
set. This is a multibyte code that has two alternative shift states (¡°Japanese mode¡± and
¡°Latin-1 mode¡±), and two shift sequences that specify particular shift states.

When the multibyte character code in use has shift states, thenmblen,mbtowc, and
wctombmust maintain and update the current shift state as they scan the string. To make
this work properly, you must follow these rules:

- Before starting to scan a string, call the function with a null pointer for the multibyte
    character address¡ªfor example,mblen (NULL, 0). This initializes the shift state to its
    standard initial value.
- Scan the string one character at a time, in order. Do not ¡°back up¡± and rescan
    characters already scanned, and do not intersperse the processing of different strings.

```
Here is an example of usingmblenfollowing these rules:
void
scan_string (char *s)
{
int length = strlen (s);
```
```
/*Initialize shift state. */
mblen (NULL, 0);
```
```
while (1)
{
int thischar = mblen (s, length);
/*Deal with end of string and invalid characters. */
if (thischar == 0)
break;
if (thischar == -1)
{
error ("invalid multibyte character");
break;
}
/*Advance past this character. */
s += thischar;
length -= thischar;
}
}
```

Chapter 6: Character Set Handling 162

The functionsmblen,mbtowcandwctombare not reentrant when using a multibyte code
that uses a shift state. However, no other library functions call these functions, so you don¡¯t
have to worry that the shift state will be changed mysteriously.

## 6.5 Generic Charset Conversion..................................

The conversion functions mentioned so far in this chapter all had in common that they
operate on character sets that are not directly specified by the functions. The multibyte
encoding used is specified by the currently selected locale for theLC_CTYPEcategory. The
wide character set is fixed by the implementation (in the case of the GNU C Library it is
always UCS-4 encoded ISO 10646).

```
This has of course several problems when it comes to general character conversion:
```
- For every conversion where neither the source nor the destination character set is the
    character set of the locale for theLC_CTYPEcategory, one has to change theLC_CTYPE
    locale usingsetlocale.
    Changing theLC_CTYPElocale introduces major problems for the rest of the programs
    since several more functions (e.g., the character classification functions, seeSection 4.1
    [Classification of Characters], page 87) use theLC_CTYPEcategory.
- Parallel conversions to and from different character sets are not possible since theLC_
    CTYPEselection is global and shared by all threads.
- If neither the source nor the destination character set is the character set used for
    wchar_trepresentation, there is at least a two-step process necessary to convert a
    text using the functions above. One would have to select the source character set as
    the multibyte encoding, convert the text into awchar_ttext, select the destination
    character set as the multibyte encoding, and convert the wide character text to the
    multibyte (= destination) character set.
    Even if this is possible (which is not guaranteed) it is a very tiring work. Plus it suffers
    from the other two raised points even more due to the steady changing of the locale.

The XPG2 standard defines a completely new set of functions, which has none of these
limitations. They are not at all coupled to the selected locales, and they have no con-
straints on the character sets selected for source and destination. Only the set of available
conversions limits them. The standard does not specify that any conversion at all must be
available. Such availability is a measure of the quality of the implementation.

In the following text first the interface toiconvand then the conversion function, will
be described. Comparisons with other implementations will show what obstacles stand in
the way of portable applications. Finally, the implementation is described in so far as might
interest the advanced user who wants to extend conversion capabilities.

## 6.5.1 Generic Character Set Conversion Interface..............

This set of functions follows the traditional cycle of using a resource: open¨Cuse¨Cclose. The
interface consists of three functions, each of which implements one step.

Before the interfaces are described it is necessary to introduce a data type. Just like
other open¨Cuse¨Cclose interfaces the functions introduced here work using handles and the
iconv.hheader defines a special type for the handles used.


Chapter 6: Character Set Handling 163

iconv_t [Data Type]
This data type is an abstract type defined iniconv.h. The user must not assume
anything about the definition of this type; it must be completely opaque.
Objects of this type can be assigned handles for the conversions using theiconv
functions. The objects themselves need not be freed, but the conversions for which
the handles stand for have to.

The first step is the function to create a handle.

iconv_t iconv_open(const char *tocode, const char *fromcode) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theiconv_open function has to be used before starting a conversion. The two
parameters this function takes determine the source and destination character set
for the conversion, and if the implementation has the possibility to perform such a
conversion, the function returns a handle.
If the wanted conversion is not available, theiconv_openfunction returns(iconv_t)
-1. In this case the global variableerrnocan have the following values:
EMFILE The process already hasOPEN_MAXfile descriptors open.
ENFILE The system limit of open files is reached.
ENOMEM Not enough memory to carry out the operation.

```
EINVAL The conversion fromfromcodetotocodeis not supported.
It is not possible to use the same descriptor in different threads to perform independent
conversions. The data structures associated with the descriptor include information
about the conversion state. This must not be messed up by using it in different
conversions.
Aniconvdescriptor is like a file descriptor as for every use a new descriptor must
be created. The descriptor does not stand for all of the conversions fromfromsetto
toset.
The GNU C Library implementation oficonv_openhas one significant extension to
other implementations. To ease the extension of the set of available conversions, the
implementation allows storing the necessary files with data and code in an arbitrary
number of directories. How this extension must be written will be explained below
(seeSection 6.5.4 [TheiconvImplementation in the GNU C Library], page 169).
Here it is only important to say that all directories mentioned in theGCONV_PATH
environment variable are considered only if they contain a filegconv-modules. These
directories need not necessarily be created by the system administrator. In fact, this
extension is introduced to help users writing and using their own, new conversions.
Of course, this does not work for security reasons in SUID binaries; in this case
only the system directory is considered and this normally isprefix/lib/gconv. The
GCONV_PATHenvironment variable is examined exactly once at the first call of the
iconv_openfunction. Later modifications of the variable have no effect.
Theiconv_openfunction was introduced early in the X/Open Portability Guide,
version 2. It is supported by all commercial Unices as it is required for the Unix
```

Chapter 6: Character Set Handling 164

```
branding. However, the quality and completeness of the implementation varies widely.
Theiconv_openfunction is declared iniconv.h.
```
Theiconvimplementation can associate large data structure with the handle returned
byiconv_open. Therefore, it is crucial to free all the resources once all conversions are
carried out and the conversion is not needed anymore.

int iconv_close (iconvtcd) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt heap lock dlopen|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theiconv_closefunction frees all resources associated with the handlecd, which
must have been returned by a successful call to theiconv_openfunction.
If the function call was successful the return value is 0. Otherwise it is?1 anderrno
is set appropriately. Defined errors are:

```
EBADF The conversion descriptor is invalid.
Theiconv_closefunction was introduced together with the rest of theiconvfunc-
tions in XPG2 and is declared iniconv.h.
```
The standard defines only one actual conversion function. This has, therefore, the most
general interface: it allows conversion from one buffer to another. Conversion from a file to
a buffer, vice versa, or even file to file can be implemented on top of it.

size_t iconv (iconv tcd, char **inbuf, sizet *inbytesleft, char [Function]
**outbuf, size t *outbytesleft)
Preliminary:|MT-Safe race:cd|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theiconvfunction converts the text in the input buffer according to the rules associ-
ated with the descriptorcdand stores the result in the output buffer. It is possible to
call the function for the same text several times in a row since for stateful character
sets the necessary state information is kept in the data structures associated with the
descriptor.
The input buffer is specified by*inbufand it contains*inbytesleftbytes. The
extra indirection is necessary for communicating the used input back to the caller
(see below). It is important to note that the buffer pointer is of typecharand the
length is measured in bytes even if the input text is encoded in wide characters.
The output buffer is specified in a similar way. *outbufpoints to the beginning of
the buffer with at least*outbytesleftbytes room for the result. The buffer pointer
again is of typecharand the length is measured in bytes. Ifoutbuf or*outbufis a
null pointer, the conversion is performed but no output is available.
Ifinbuf is a null pointer, theiconvfunction performs the necessary action to put the
state of the conversion into the initial state. This is obviously a no-op for non-stateful
encodings, but if the encoding has a state, such a function call might put some byte
sequences in the output buffer, which perform the necessary state changes. The next
call withinbuf not being a null pointer then simply goes on from the initial state.
It is important that the programmer never makes any assumption as to whether the
conversion has to deal with states. Even if the input and output character sets are


Chapter 6: Character Set Handling 165

```
not stateful, the implementation might still have to keep states. This is due to the
implementation chosen for the GNU C Library as it is described below. Therefore
aniconvcall to reset the state should always be performed if some protocol requires
this for the output text.
The conversion stops for one of three reasons. The first is that all characters from
the input buffer are converted. This actually can mean two things: either all bytes
from the input buffer are consumed or there are some bytes at the end of the buffer
that possibly can form a complete character but the input is incomplete. The second
reason for a stop is that the output buffer is full. And the third reason is that the
input contains invalid characters.
In all of these cases the buffer pointers after the last successful conversion, for the
input and output buffers, are stored ininbuf andoutbuf, and the available room in
each buffer is stored ininbytesleftandoutbytesleft.
Since the character sets selected in theiconv_open call can be almost arbitrary,
there can be situations where the input buffer contains valid characters, which have
no identical representation in the output character set. The behavior in this situation
is undefined. Thecurrent behavior of the GNU C Library in this situation is to
return with an error immediately. This certainly is not the most desirable solution;
therefore, future versions will provide better ones, but they are not yet finished.
If all input from the input buffer is successfully converted and stored in the output
buffer, the function returns the number of non-reversible conversions performed. In
all other cases the return value is(size_t) -1anderrnois set appropriately. In
such cases the value pointed to byinbytesleftis nonzero.
EILSEQ The conversion stopped because of an invalid byte sequence in the input.
After the call,*inbufpoints at the first byte of the invalid byte sequence.
E2BIG The conversion stopped because it ran out of space in the output buffer.
EINVAL The conversion stopped because of an incomplete byte sequence at the
end of the input buffer.
EBADF Thecdargument is invalid.
Theiconvfunction was introduced in the XPG2 standard and is declared in the
iconv.hheader.
```
The definition of theiconvfunction is quite good overall. It provides quite flexible
functionality. The only problems lie in the boundary cases, which are incomplete byte
sequences at the end of the input buffer and invalid input. A third problem, which is not
really a design problem, is the way conversions are selected. The standard does not say
anything about the legitimate names, a minimal set of available conversions. We will see
how this negatively impacts other implementations, as demonstrated below.

## 6.5.2 A completeiconvexample..............................

The example below features a solution for a common problem. Given that one knows the
internal encoding used by the system forwchar_tstrings, one often is in the position to read
text from a file and store it in wide character buffers. One can do this usingmbsrtowcs,
but then we run into the problems discussed above.
int


Chapter 6: Character Set Handling 166

```
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
char inbuf[BUFSIZ];
size_t insize = 0;
char *wrptr = (char *) outbuf;
int result = 0;
iconv_t cd;
```
```
cd = iconv_open ("WCHAR_T", charset);
if (cd == (iconv_t) -1)
{
/*Something went wrong. */
if (errno == EINVAL)
error (0, 0, "conversion from '%s' to wchar_t not available",
charset);
else
perror ("iconv_open");
```
```
/*Terminate the output string. */
*outbuf = L'\0';
```
```
return -1;
}
```
```
while (avail > 0)
{
size_t nread;
size_t nconv;
char *inptr = inbuf;
```
```
/*Read more input. */
nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
if (nread == 0)
{
/*When we come here the file is completely read.
This still could mean there are some unused
characters in theinbuf. Put them back. */
if (lseek (fd, -insize, SEEK_CUR) == -1)
result = -1;
```
```
/*Now write out the byte sequence to get into the
initial state if this is necessary. */
iconv (cd, NULL, NULL, &wrptr, &avail);
```
```
break;
}
insize += nread;
```
```
/*Do the conversion. */
nconv = iconv (cd, &inptr, &insize, &wrptr, &avail);
if (nconv == (size_t) -1)
{
/*Not everything went right. It might only be
an unfinished byte sequence at the end of the
buffer. Or it is a real problem. */
if (errno == EINVAL)
/*This is harmless. Simply move the unused
bytes to the beginning of the buffer so that
```

Chapter 6: Character Set Handling 167

```
they can be used in the next round. */
memmove (inbuf, inptr, insize);
else
{
/*It is a real problem. Maybe we ran out of
space in the output buffer or we have invalid
input. In any case back the file pointer to
the position of the last processed byte. */
lseek (fd, -insize, SEEK_CUR);
result = -1;
break;
}
}
}
```
```
/*Terminate the output string. */
if (avail >= sizeof (wchar_t))
*((wchar_t *) wrptr) = L'\0';
```
```
if (iconv_close (cd) != 0)
perror ("iconv_close");
```
```
return (wchar_t *) wrptr - outbuf;
}
```
This example shows the most important aspects of using theiconvfunctions. It shows
how successive calls toiconvcan be used to convert large amounts of text. The user does
not have to care about stateful encodings as the functions take care of everything.

An interesting point is the case whereiconvreturns an error anderrnois set toEINVAL.
This is not really an error in the transformation. It can happen whenever the input character
set contains byte sequences of more than one byte for some character and texts are not
processed in one piece. In this case there is a chance that a multibyte sequence is cut. The
caller can then simply read the remainder of the takes and feed the offending bytes together
with new character from the input toiconvand continue the work. The internal state kept
in the descriptor isnotunspecified after such an event as is the case with the conversion
functions from the ISO C standard.

The example also shows the problem of using wide character strings withiconv. As
explained in the description of theiconvfunction above, the function always takes a pointer
to achararray and the available space is measured in bytes. In the example, the output
buffer is a wide character buffer; therefore, we use a local variablewrptrof typechar *,
which is used in theiconvcalls.

This looks rather innocent but can lead to problems on platforms that have tight restric-
tion on alignment. Therefore the caller oficonvhas to make sure that the pointers passed
are suitable for access of characters from the appropriate character set. Since, in the above
case, the input parameter to the function is awchar_tpointer, this is the case (unless the
user violates alignment when computing the parameter). But in other situations, especially
when writing generic functions where one does not know what type of character set one
uses and, therefore, treats text as a sequence of bytes, it might become tricky.


Chapter 6: Character Set Handling 168

## 6.5.3 Some Details about othericonvImplementations........

This is not really the place to discuss theiconvimplementation of other systems but it
is necessary to know a bit about them to write portable programs. The above mentioned
problems with the specification of theiconvfunctions can lead to portability issues.

The first thing to notice is that, due to the large number of character sets in use, it is
certainly not practical to encode the conversions directly in the C library. Therefore, the
conversion information must come from files outside the C library. This is usually done in
one or both of the following ways:

- The C library contains a set of generic conversion functions that can read the needed
    conversion tables and other information from data files. These files get loaded when
    necessary.
    This solution is problematic as it requires a great deal of effort to apply to all char-
    acter sets (potentially an infinite set). The differences in the structure of the different
    character sets is so large that many different variants of the table-processing functions
    must be developed. In addition, the generic nature of these functions make them slower
    than specifically implemented functions.
- The C library only contains a framework that can dynamically load object files and
    execute the conversion functions contained therein.
    This solution provides much more flexibility. The C library itself contains only very lit-
    tle code and therefore reduces the general memory footprint. Also, with a documented
    interface between the C library and the loadable modules it is possible for third parties
    to extend the set of available conversion modules. A drawback of this solution is that
    dynamic loading must be available.
Some implementations in commercial Unices implement a mixture of these possibilities;
the majority implement only the second solution. Using loadable modules moves the code
out of the library itself and keeps the door open for extensions and improvements, but
this design is also limiting on some platforms since not many platforms support dynamic
loading in statically linked programs. On platforms without this capability it is therefore
not possible to use this interface in statically linked programs. The GNU C Library has, on
ELF platforms, no problems with dynamic loading in these situations; therefore, this point
is moot. The danger is that one gets acquainted with this situation and forgets about the
restrictions on other systems.

A second thing to know about other iconvimplementations is that the number of
available conversions is often very limited. Some implementations provide, in the standard
release (not special international or developer releases), at most 100 to 200 conversion
possibilities. This does not mean 200 different character sets are supported; for example,
conversions from one character set to a set of 10 others might count as 10 conversions.
Together with the other direction this makes 20 conversion possibilities used up by one
character set. One can imagine the thin coverage these platforms provide. Some Unix
vendors even provide only a handful of conversions, which renders them useless for almost
all uses.

This directly leads to a third and probably the most problematic point. The way the
iconvconversion functions are implemented on all known Unix systems and the availability
of the conversion functions from character setAtoBand the conversion fromBtoCdoes
notimply that the conversion fromAtoCis available.


Chapter 6: Character Set Handling 169

This might not seem unreasonable and problematic at first, but it is a quite big problem
as one will notice shortly after hitting it. To show the problem we assume to write a program
that has to convert fromAtoC. A call like
cd = iconv_open ("C", "A");

fails according to the assumption above. But what does the program do now? The conver-
sion is necessary; therefore, simply giving up is not an option.

This is a nuisance. Theiconvfunction should take care of this. But how should the
program proceed from here on? If it tries to convert to character setB, first the two
iconv_opencalls
cd1 = iconv_open ("B", "A");

and
cd2 = iconv_open ("C", "B");

will succeed, but how to findB?

Unfortunately, the answer is: there is no general solution. On some systems guessing
might help. On those systems most character sets can convert to and from UTF-8 encoded
ISO 10646 or Unicode text. Besides this only some very system-specific methods can help.
Since the conversion functions come from loadable modules and these modules must be
stored somewhere in the filesystem, onecould try to find them and determine from the
available file which conversions are available and whether there is an indirect route fromA
toC.

This example shows one of the design errors oficonvmentioned above. It should at
least be possible to determine the list of available conversions programmatically so that
ificonv_opensays there is no such conversion, one could make sure this also is true for
indirect routes.

## 6.5.4 TheiconvImplementation in the GNU C Library.......

After reading about the problems oficonvimplementations in the last section it is certainly
good to note that the implementation in the GNU C Library has none of the problems
mentioned above. What follows is a step-by-step analysis of the points raised above. The
evaluation is based on the current state of the development (as of January 1999). The
development of theiconvfunctions is not complete, but basic functionality has solidified.

The GNU C Library¡¯siconvimplementation uses shared loadable modules to implement
the conversions. A very small number of conversions are built into the library itself but
these are only rather trivial conversions.

All the benefits of loadable modules are available in the GNU C Library implementation.
This is especially appealing since the interface is well documented (see below), and it,
therefore, is easy to write new conversion modules. The drawback of using loadable objects
is not a problem in the GNU C Library, at least on ELF systems. Since the library is able
to load shared objects even in statically linked binaries, static linking need not be forbidden
in case one wants to useiconv.

The second mentioned problem is the number of supported conversions. Currently, the
GNU C Library supports more than 150 character sets. The way the implementation is
designed the number of supported conversions is greater than 22350 (150 times 149). If any
conversion from or to a character set is missing, it can be added easily.


Chapter 6: Character Set Handling 170

Particularly impressive as it may be, this high number is due to the fact that the GNU
C Library implementation oficonvdoes not have the third problem mentioned above (i.e.,
whenever there is a conversion from a character setAtoBand fromBtoCit is always
possible to convert fromAtoCdirectly). If theiconv_openreturns an error and setserrno
toEINVAL, there is no known way, directly or indirectly, to perform the wanted conversion.

Triangulation is achieved by providing for each character set a conversion from and to
UCS-4 encoded ISO 10646. Using ISO 10646 as an intermediate representation it is possible
totriangulate(i.e., convert with an intermediate representation).

There is no inherent requirement to provide a conversion to ISO 10646 for a new char-
acter set, and it is also possible to provide other conversions where neither source nor
destination character set is ISO 10646. The existing set of conversions is simply meant to
cover all conversions that might be of interest.

All currently available conversions use the triangulation method above, making conver-
sion run unnecessarily slow. If, for example, somebody often needs the conversion from
ISO-2022-JP to EUC-JP, a quicker solution would involve direct conversion between the
two character sets, skipping the input to ISO 10646 first. The two character sets of interest
are much more similar to each other than to ISO 10646.

In such a situation one easily can write a new conversion and provide it as a better
alternative. The GNU C Libraryiconvimplementation would automatically use the module
implementing the conversion if it is specified to be more efficient.

## 6.5.4.1 Format ofgconv-modulesfiles......................

All information about the available conversions comes from a file namedgconv-modules,
which can be found in any of the directories along theGCONV_PATH. Thegconv-modules
files are line-oriented text files, where each of the lines has one of the following formats:

- If the first non-whitespace character is a#the line contains only comments and is
    ignored.
- Lines starting withaliasdefine an alias name for a character set. Two more words
    are expected on the line. The first word defines the alias name, and the second defines
    the original name of the character set. The effect is that it is possible to use the alias
    name in thefromsetortosetparameters oficonv_openand achieve the same result as
    when using the real character set name.
    This is quite important as a character set has often many different names. There is
    normally an official name but this need not correspond to the most popular name.
    Besides this many character sets have special names that are somehow constructed.
    For example, all character sets specified by the ISO have an alias of the formISO-IR-
    nnnwherennnis the registration number. This allows programs that know about the
    registration number to construct character set names and use them iniconv_open
    calls. More on the available names and aliases follows below.
- Lines starting withmoduleintroduce an available conversion module. These lines must
    contain three or four more words.
    The first word specifies the source character set, the second word the destination char-
    acter set of conversion implemented in this module, and the third word is the name
    of the loadable module. The filename is constructed by appending the usual shared
    object suffix (normally.so) and this file is then supposed to be found in the same


Chapter 6: Character Set Handling 171

```
directory thegconv-modulesfile is in. The last word on the line, which is optional, is
a numeric value representing the cost of the conversion. If this word is missing, a cost
of 1 is assumed. The numeric value itself does not matter that much; what counts are
the relative values of the sums of costs for all possible conversion paths. Below is a
more precise description of the use of the cost value.
```
Returning to the example above where one has written a module to directly convert
from ISO-2022-JP to EUC-JP and back. All that has to be done is to put the new module,
let its name be ISO2022JP-EUCJP.so, in a directory and add a filegconv-moduleswith
the following content in the same directory:
module ISO-2022-JP// EUC-JP// ISO2022JP-EUCJP 1
module EUC-JP// ISO-2022-JP// ISO2022JP-EUCJP 1
To see why this is sufficient, it is necessary to understand how the conversion used by
iconv(and described in the descriptor) is selected. The approach to this problem is quite
simple.

At the first call of the iconv_open function the program reads all available
gconv-modulesfiles and builds up two tables: one containing all the known aliases and
another that contains the information about the conversions and which shared object
implements them.

## 6.5.4.2 Finding the conversion path iniconv...............

The set of available conversions form a directed graph with weighted edges. The weights
on the edges are the costs specified in thegconv-modulesfiles. Theiconv_openfunction
uses an algorithm suitable for search for the best path in such a graph and so constructs a
list of conversions that must be performed in succession to get the transformation from the
source to the destination character set.

Explaining why the abovegconv-modules files allows the iconvimplementation to
resolve the specific ISO-2022-JP to EUC-JP conversion module instead of the conversion
coming with the library itself is straightforward. Since the latter conversion takes two
steps (from ISO-2022-JP to ISO 10646 and then from ISO 10646 to EUC-JP), the cost
is 1 + 1 = 2. The abovegconv-modulesfile, however, specifies that the new conversion
modules can perform this conversion with only the cost of 1.

A mysterious item about thegconv-modulesfile above (and also the file coming with
the GNU C Library) are the names of the character sets specified in themodulelines. Why
do almost all the names end in//? And this is not all: the names can actually be regular
expressions. At this point in time this mystery should not be revealed, unless you have the
relevant spell-casting materials: ashes from an original DOS 6.2 boot disk burnt in effigy, a
crucifix blessed by St. Emacs, assorted herbal roots from Central America, sand from Cebu,
etc. Sorry!The part of the implementation where this is used is not yet finished. For now
please simply follow the existing examples. It¡¯ll become clearer once it is. ¨Cdrepper

A last remark about thegconv-modules is about the names not ending with//. A
character set namedINTERNALis often mentioned. From the discussion above and the
chosen name it should have become clear that this is the name for the representation used
in the intermediate step of the triangulation. We have said that this is UCS-4 but actually
that is not quite right. The UCS-4 specification also includes the specification of the byte
ordering used. Since a UCS-4 value consists of four bytes, a stored value is affected by byte


Chapter 6: Character Set Handling 172

ordering. The internal representation isnot the same as UCS-4 in case the byte ordering
of the processor (or at least the running process) is not the same as the one required for
UCS-4. This is done for performance reasons as one does not want to perform unnecessary
byte-swapping operations if one is not interested in actually seeing the result in UCS-4. To
avoid trouble with endianness, the internal representation consistently is namedINTERNAL
even on big-endian systems where the representations are identical.

## 6.5.4.3 iconvmodule data structures.......................

So far this section has described how modules are located and considered to be used. What
remains to be described is the interface of the modules so that one can write new ones. This
section describes the interface as it is in use in January 1999. The interface will change a
bit in the future but, with luck, only in an upwardly compatible way.

The definitions necessary to write new modules are publicly available in the non-standard
headergconv.h. The following text, therefore, describes the definitions from this header
file. First, however, it is necessary to get an overview.

From the perspective of the user oficonvthe interface is quite simple: theiconv_open
function returns a handle that can be used in calls toiconv, and finally the handle is freed
with a call toiconv_close. The problem is that the handle has to be able to represent the
possibly long sequences of conversion steps and also the state of each conversion since the
handle is all that is passed to theiconvfunction. Therefore, the data structures are really
the elements necessary to understanding the implementation.

We need two different kinds of data structures. The first describes the conversion and
the second describes the state etc. There are really two type definitions like this ingconv.h.

struct __gconv_step [Data type]
This data structure describes one conversion a module can perform. For each func-
tion in a loaded module with conversion functions there is exactly one object of this
type. This object is shared by all users of the conversion (i.e., this object does not
contain any information corresponding to an actual conversion; it only describes the
conversion itself).

```
struct __gconv_loaded_object *__shlib_handle
const char *__modname
int __counter
All these elements of the structure are used internally in the C library
to coordinate loading and unloading the shared object. One must not
expect any of the other elements to be available or initialized.
```
```
const char *__from_name
const char *__to_name
__from_nameand__to_namecontain the names of the source and desti-
nation character sets. They can be used to identify the actual conversion
to be carried out since one module might implement conversions for more
than one character set and/or direction.
```

Chapter 6: Character Set Handling 173

```
gconv_fct __fct
gconv_init_fct __init_fct
gconv_end_fct __end_fct
These elements contain pointers to the functions in the loadable module.
The interface will be explained below.
int __min_needed_from
int __max_needed_from
int __min_needed_to
int __max_needed_to;
These values have to be supplied in the init function of the module. The
__min_needed_fromvalue specifies how many bytes a character of the
source character set at least needs. The__max_needed_fromspecifies
the maximum value that also includes possible shift sequences.
The__min_needed_toand__max_needed_tovalues serve the same pur-
pose as__min_needed_fromand__max_needed_frombut this time for
the destination character set.
It is crucial that these values be accurate since otherwise the conversion
functions will have problems or not work at all.
int __stateful
This element must also be initialized by the init function. int
__statefulis nonzero if the source character set is stateful. Otherwise
it is zero.
void *__data
This element can be used freely by the conversion functions in the module.
void *__datacan be used to communicate extra information from one
call to another.void *__dataneed not be initialized if not needed at all.
Ifvoid *__dataelement is assigned a pointer to dynamically allocated
memory (presumably in the init function) it has to be made sure that the
end function deallocates the memory. Otherwise the application will leak
memory.
It is important to be aware that this data structure is shared by all users
of this specification conversion and therefore the__dataelement must
not contain data specific to one specific use of the conversion function.
```
struct __gconv_step_data [Data type]
This is the data structure that contains the information specific to each use of the
conversion functions.
char *__outbuf
char *__outbufend
These elements specify the output buffer for the conversion step. The__
outbufelement points to the beginning of the buffer, and__outbufend
points to the byte following the last byte in the buffer. The conversion
function must not assume anything about the size of the buffer but it can
be safely assumed there is room for at least one complete character in the
output buffer.


Chapter 6: Character Set Handling 174

```
Once the conversion is finished, if the conversion is the last step, the__
outbufelement must be modified to point after the last byte written into
the buffer to signal how much output is available. If this conversion step
is not the last one, the element must not be modified. The__outbufend
element must not be modified.
int __is_last
This element is nonzero if this conversion step is the last one. This infor-
mation is necessary for the recursion. See the description of the conversion
function internals below. This element must never be modified.
int __invocation_counter
The conversion function can use this element to see how many calls of
the conversion function already happened. Some character sets require a
certain prolog when generating output, and by comparing this value with
zero, one can find out whether it is the first call and whether, therefore,
the prolog should be emitted. This element must never be modified.
int __internal_use
This element is another one rarely used but needed in certain situations.
It is assigned a nonzero value in case the conversion functions are used to
implementmbsrtowcset.al. (i.e., the function is not used directly through
theiconvinterface).
This sometimes makes a difference as it is expected that theiconvfunc-
tions are used to translate entire texts while thembsrtowcsfunctions are
normally used only to convert single strings and might be used multiple
times to convert entire texts.
But in this situation we would have problem complying with some rules
of the character set specification. Some character sets require a pro-
log, which must appear exactly once for an entire text. If a number of
mbsrtowcscalls are used to convert the text, only the first call must add
the prolog. However, because there is no communication between the
different calls ofmbsrtowcs, the conversion functions have no possibility
to find this out. The situation is different for sequences oficonvcalls
since the handle allows access to the needed information.
The int __internal_use element is mostly used together with
__invocation_counteras follows:
if (!data->__internal_use
&& data->__invocation_counter == 0)
/*Emit prolog. */
...
This element must never be modified.
mbstate_t *__statep
The __statep element points to an object of type mbstate_t (see
Section 6.3.2 [Representing the state of the conversion], page 145). The
conversion of a stateful character set must use the object pointed to
by __statep to store information about the conversion state. The
__statepelement itself must never be modified.
```

Chapter 6: Character Set Handling 175

```
mbstate_t __state
This element mustneverbe used directly. It is only part of this structure
to have the needed space allocated.
```
## 6.5.4.4 iconvmodule interfaces............................

With the knowledge about the data structures we now can describe the conversion function
itself. To understand the interface a bit of knowledge is necessary about the functionality
in the C library that loads the objects with the conversions.

It is often the case that one conversion is used more than once (i.e., there are several
iconv_opencalls for the same set of character sets during one program run). Thembsrtowcs
et.al. functions in the GNU C Library also use theiconvfunctionality, which increases the
number of uses of the same functions even more.

Because of this multiple use of conversions, the modules do not get loaded exclusively
for one conversion. Instead a module once loaded can be used by an arbitrary number
oficonvormbsrtowcscalls at the same time. The splitting of the information between
conversion- function-specific information and conversion data makes this possible. The last
section showed the two data structures used to do this.

This is of course also reflected in the interface and semantics of the functions that the
modules must provide. There are three functions that must have the following names:

gconv_init
Thegconv_initfunction initializes the conversion function specific data struc-
ture. This very same object is shared by all conversions that use this conversion
and, therefore, no state information about the conversion itself must be stored
in here. If a module implements more than one conversion, thegconv_init
function will be called multiple times.

gconv_end
Thegconv_endfunction is responsible for freeing all resources allocated by the
gconv_initfunction. If there is nothing to do, this function can be missing.
Special care must be taken if the module implements more than one conver-
sion and thegconv_initfunction does not allocate the same resources for all
conversions.

gconv This is the actual conversion function. It is called to convert one block of text.
It gets passed the conversion step information initialized bygconv_initand
the conversion data, specific to this use of the conversion functions.

There are three data types defined for the three module interface functions and these
define the interface.

int (*__gconv_init_fct) (struct gconvstep *) [Data type]
This specifies the interface of the initialization function of the module. It is called
exactly once for each conversion the module implements.
As explained in the description of thestruct __gconv_stepdata structure above
the initialization function has to initialize parts of it.


Chapter 6: Character Set Handling 176

```
__min_needed_from
__max_needed_from
__min_needed_to
__max_needed_to
These elements must be initialized to the exact numbers of the minimum
and maximum number of bytes used by one character in the source and
destination character sets, respectively. If the characters all have the
same size, the minimum and maximum values are the same.
__stateful
This element must be initialized to a nonzero value if the source character
set is stateful. Otherwise it must be zero.
If the initialization function needs to communicate some information to the conversion
function, this communication can happen using the__dataelement of the__gconv_
stepstructure. But since this data is shared by all the conversions, it must not be
modified by the conversion function. The example below shows how this can be used.
#define MIN_NEEDED_FROM 1
#define MAX_NEEDED_FROM 4
#define MIN_NEEDED_TO 4
#define MAX_NEEDED_TO 4
```
```
int
gconv_init (struct __gconv_step *step)
{
/*Determine which direction. */
struct iso2022jp_data *new_data;
enum direction dir = illegal_dir;
enum variant var = illegal_var;
int result;
```
```
if (__strcasecmp (step->__from_name, "ISO-2022-JP//") == 0)
{
dir = from_iso2022jp;
var = iso2022jp;
}
else if (__strcasecmp (step->__to_name, "ISO-2022-JP//") == 0)
{
dir = to_iso2022jp;
var = iso2022jp;
}
else if (__strcasecmp (step->__from_name, "ISO-2022-JP-2//") == 0)
{
dir = from_iso2022jp;
var = iso2022jp2;
}
else if (__strcasecmp (step->__to_name, "ISO-2022-JP-2//") == 0)
{
dir = to_iso2022jp;
var = iso2022jp2;
}
```
```
result = __GCONV_NOCONV;
if (dir != illegal_dir)
{
new_data = (struct iso2022jp_data *)
```

Chapter 6: Character Set Handling 177

```
malloc (sizeof (struct iso2022jp_data));
```
```
result = __GCONV_NOMEM;
if (new_data != NULL)
{
new_data->dir = dir;
new_data->var = var;
step->__data = new_data;
```
```
if (dir == from_iso2022jp)
{
step->__min_needed_from = MIN_NEEDED_FROM;
step->__max_needed_from = MAX_NEEDED_FROM;
step->__min_needed_to = MIN_NEEDED_TO;
step->__max_needed_to = MAX_NEEDED_TO;
}
else
{
step->__min_needed_from = MIN_NEEDED_TO;
step->__max_needed_from = MAX_NEEDED_TO;
step->__min_needed_to = MIN_NEEDED_FROM;
step->__max_needed_to = MAX_NEEDED_FROM + 2;
}
```
```
/*Yes, this is a stateful encoding. */
step->__stateful = 1;
```
```
result = __GCONV_OK;
}
}
```
```
return result;
}
The function first checks which conversion is wanted. The module from which this
function is taken implements four different conversions; which one is selected can be
determined by comparing the names. The comparison should always be done without
paying attention to the case.
Next, a data structure, which contains the necessary information about which conver-
sion is selected, is allocated. The data structurestruct iso2022jp_datais locally
defined since, outside the module, this data is not used at all. Please note that if all
four conversions this module supports are requested there are four data blocks.
One interesting thing is the initialization of the__min_and__max_elements of the
step data object. A single ISO-2022-JP character can consist of one to four bytes.
Therefore theMIN_NEEDED_FROMandMAX_NEEDED_FROMmacros are defined this way.
The output is always theINTERNALcharacter set (aka UCS-4) and therefore each
character consists of exactly four bytes. For the conversion fromINTERNALto ISO-
2022-JP we have to take into account that escape sequences might be necessary to
switch the character sets. Therefore the__max_needed_toelement for this direction
gets assignedMAX_NEEDED_FROM + 2. This takes into account the two bytes needed for
the escape sequences to signal the switching. The asymmetry in the maximum values
for the two directions can be explained easily: when reading ISO-2022-JP text, escape
sequences can be handled alone (i.e., it is not necessary to process a real character
since the effect of the escape sequence can be recorded in the state information).
```

Chapter 6: Character Set Handling 178

```
The situation is different for the other direction. Since it is in general not known
which character comes next, one cannot emit escape sequences to change the state in
advance. This means the escape sequences have to be emitted together with the next
character. Therefore one needs more room than only for the character itself.
The possible return values of the initialization function are:
```
```
__GCONV_OK
The initialization succeeded
__GCONV_NOCONV
The requested conversion is not supported in the module. This can hap-
pen if thegconv-modulesfile has errors.
__GCONV_NOMEM
Memory required to store additional information could not be allocated.
```
The function called before the module is unloaded is significantly easier. It often has
nothing at all to do; in which case it can be left out completely.

void (*__gconv_end_fct) (struct gconvstep *) [Data type]
The task of this function is to free all resources allocated in the initialization function.
Therefore only the__dataelement of the object pointed to by the argument is of
interest. Continuing the example from the initialization function, the finalization
function looks like this:
void
gconv_end (struct __gconv_step *data)
{
free (data->__data);
}

The most important function is the conversion function itself, which can get quite com-
plicated for complex character sets. But since this is not of interest here, we will only
describe a possible skeleton for the conversion function.

int (*__gconv_fct)(struct gconvstep *, struct [Data type]
gconv stepdata *, const char **, const char *, sizet *, int)
The conversion function can be called for two basic reasons: to convert text or to reset
the state. From the description of theiconvfunction it can be seen why the flushing
mode is necessary. What mode is selected is determined by the sixth argument, an
integer. This argument being nonzero means that flushing is selected.
Common to both modes is where the output buffer can be found. The information
about this buffer is stored in the conversion step data. A pointer to this information
is passed as the second argument to this function. The description of thestruct
__gconv_step_datastructure has more information on the conversion step data.
What has to be done for flushing depends on the source character set. If the source
character set is not stateful, nothing has to be done. Otherwise the function has to
emit a byte sequence to bring the state object into the initial state. Once this all
happened the other conversion modules in the chain of conversions have to get the
same chance. Whether another step follows can be determined from the__is_last
element of the step data structure to which the first parameter points.


Chapter 6: Character Set Handling 179

```
The more interesting mode is when actual text has to be converted. The first step in
this case is to convert as much text as possible from the input buffer and store the
result in the output buffer. The start of the input buffer is determined by the third
argument, which is a pointer to a pointer variable referencing the beginning of the
buffer. The fourth argument is a pointer to the byte right after the last byte in the
buffer.
The conversion has to be performed according to the current state if the character
set is stateful. The state is stored in an object pointed to by the__statepelement of
the step data (second argument). Once either the input buffer is empty or the output
buffer is full the conversion stops. At this point, the pointer variable referenced by
the third parameter must point to the byte following the last processed byte (i.e., if
all of the input is consumed, this pointer and the fourth parameter have the same
value).
What now happens depends on whether this step is the last one. If it is the last
step, the only thing that has to be done is to update the__outbufelement of the
step data structure to point after the last written byte. This update gives the caller
the information on how much text is available in the output buffer. In addition,
the variable pointed to by the fifth parameter, which is of typesize_t, must be
incremented by the number of characters (not bytes) that were converted in a non-
reversible way. Then, the function can return.
In case the step is not the last one, the later conversion functions have to get a chance
to do their work. Therefore, the appropriate conversion function has to be called. The
information about the functions is stored in the conversion data structures, passed as
the first parameter. This information and the step data are stored in arrays, so the
next element in both cases can be found by simple pointer arithmetic:
int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
const char **inbuf, const char *inbufend, size_t *written,
int do_flush)
{
struct __gconv_step *next_step = step + 1;
struct __gconv_step_data *next_data = data + 1;
...
Thenext_steppointer references the next step information andnext_datathe next
data record. The call of the next function therefore will look similar to this:
next_step->__fct (next_step, next_data, &outerr, outbuf,
written, 0)
But this is not yet all. Once the function call returns the conversion function might
have some more to do. If the return value of the function is__GCONV_EMPTY_INPUT,
more room is available in the output buffer. Unless the input buffer is empty, the
conversion functions start all over again and process the rest of the input buffer. If
the return value is not__GCONV_EMPTY_INPUT, something went wrong and we have
to recover from this.
A requirement for the conversion function is that the input buffer pointer (the third
argument) always point to the last character that was put in converted form into the
output buffer. This is trivially true after the conversion performed in the current step,
but if the conversion functions deeper downstream stop prematurely, not all characters
```

Chapter 6: Character Set Handling 180

```
from the output buffer are consumed and, therefore, the input buffer pointers must
be backed off to the right position.
Correcting the input buffers is easy to do if the input and output character sets
have a fixed width for all characters. In this situation we can compute how many
characters are left in the output buffer and, therefore, can correct the input buffer
pointer appropriately with a similar computation. Things are getting tricky if either
character set has characters represented with variable length byte sequences, and it
gets even more complicated if the conversion has to take care of the state. In these
cases the conversion has to be performed once again, from the known state before
the initial conversion (i.e., if necessary the state of the conversion has to be reset and
the conversion loop has to be executed again). The difference now is that it is known
how much input must be created, and the conversion can stop before converting the
first unused character. Once this is done the input buffer pointers must be updated
again and the function can return.
One final thing should be mentioned. If it is necessary for the conversion to know
whether it is the first invocation (in case a prolog has to be emitted), the conver-
sion function should increment the__invocation_counterelement of the step data
structure just before returning to the caller. See the description of thestruct __
gconv_step_datastructure above for more information on how this can be used.
The return value must be one of the following values:
```
```
__GCONV_EMPTY_INPUT
All input was consumed and there is room left in the output buffer.
```
```
__GCONV_FULL_OUTPUT
No more room in the output buffer. In case this is not the last step this
value is propagated down from the call of the next conversion function in
the chain.
```
```
__GCONV_INCOMPLETE_INPUT
The input buffer is not entirely empty since it contains an incomplete
character sequence.
```
```
The following example provides a framework for a conversion function. In case a new
conversion has to be written the holes in this implementation have to be filled and
that is it.
int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
const char **inbuf, const char *inbufend, size_t *written,
int do_flush)
{
struct __gconv_step *next_step = step + 1;
struct __gconv_step_data *next_data = data + 1;
gconv_fct fct = next_step->__fct;
int status;
```
```
/*If the function is called with no input this means we have
to reset to the initial state. The possibly partly
converted input is dropped. */
if (do_flush)
{
```

Chapter 6: Character Set Handling 181

```
status = __GCONV_OK;
```
```
/*Possible emit a byte sequence which put the state object
into the initial state. */
```
```
/*Call the steps down the chain if there are any but only
if we successfully emitted the escape sequence. */
if (status == __GCONV_OK &&! data->__is_last)
status = fct (next_step, next_data, NULL, NULL,
written, 1);
}
else
{
/*We preserve the initial values of the pointer variables. */
const char *inptr = *inbuf;
char *outbuf = data->__outbuf;
char *outend = data->__outbufend;
char *outptr;
```
```
do
{
/*Remember the start value for this round. */
inptr = *inbuf;
/*The outbuf buffer is empty. */
outptr = outbuf;
```
```
/*For stateful encodings the state must be safe here. */
```
```
/*Run the conversion loop.statusis set
appropriately afterwards. */
```
```
/*If this is the last step, leave the loop. There is
nothing we can do. */
if (data->__is_last)
{
/*Store information about how many bytes are
available. */
data->__outbuf = outbuf;
```
```
/*If any non-reversible conversions were performed,
add the number to*written. */
```
```
break;
}
```
```
/*Write out all output that was produced. */
if (outbuf > outptr)
{
const char *outerr = data->__outbuf;
int result;
```
```
result = fct (next_step, next_data, &outerr,
outbuf, written, 0);
```
```
if (result != __GCONV_EMPTY_INPUT)
{
if (outerr != outbuf)
{
```

Chapter 6: Character Set Handling 182

```
/*Reset the input buffer pointer. We
document here the complex case. */
size_t nstatus;
```
```
/*Reload the pointers. */
*inbuf = inptr;
outbuf = outptr;
```
```
/*Possibly reset the state. */
```
```
/*Redo the conversion, but this time
the end of the output buffer is at
outerr. */
}
```
```
/*Change the status. */
status = result;
}
else
/*All the output is consumed, we can make
another run if everything was ok. */
if (status == __GCONV_FULL_OUTPUT)
status = __GCONV_OK;
}
}
while (status == __GCONV_OK);
```
```
/*We finished one use of this step. */
++data->__invocation_counter;
}
```
```
return status;
}
```
This information should be sufficient to write new modules. Anybody doing so should
also take a look at the available source code in the GNU C Library sources. It contains
many examples of working and optimized modules.


### 183

## 7 Locales and Internationalization.............

## 7 Locales and Internationalization........................

Different countries and cultures have varying conventions for how to communicate. These
conventions range from very simple ones, such as the format for representing dates and
times, to very complex ones, such as the language spoken.

Internationalizationof software means programming it to be able to adapt to the user¡¯s
favorite conventions. In ISO C, internationalization works by means oflocales. Each locale
specifies a collection of conventions, one convention for each purpose. The user chooses a
set of conventions by specifying a locale (via environment variables).

All programs inherit the chosen locale as part of their environment. Provided the pro-
grams are written to obey the choice of locale, they will follow the conventions preferred by
the user.

## 7.1 What Effects a Locale Has...................................

Each locale specifies conventions for several purposes, including the following:

- What multibyte character sequences are valid, and how they are interpreted (see
    Chapter 6 [Character Set Handling], page 140).
- Classification of which characters in the local character set are considered alphabetic,
    and upper- and lower-case conversion conventions (seeChapter 4 [Character Handling],
    page 87).
- The collating sequence for the local language and character set (seeSection 5.8 [Colla-
    tion Functions], page 117).
- Formatting of numbers and currency amounts (seeSection 7.7.1.1 [Generic Numeric
    Formatting Parameters], page 189).
- Formatting of dates and times (see Section 21.5.4 [Formatting Calendar Time],
    page 662).
- What language to use for output, including error messages (seeChapter 8 [Message
    Translation], page 203).
- What language to use for user answers to yes-or-no questions (seeSection 7.9 [Yes-or-No
    Questions], page 201).
- What language to use for more complex user input. (The C library doesn¡¯t yet help
    you implement this.)
Some aspects of adapting to the specified locale are handled automatically by the library
subroutines. For example, all your program needs to do in order to use the collating sequence
of the chosen locale is to usestrcollorstrxfrmto compare strings.

Other aspects of locales are beyond the comprehension of the library. For example, the
library can¡¯t automatically translate your program¡¯s output messages into other languages.
The only way you can support output in the user¡¯s favorite language is to program this
more or less by hand. The C library provides functions to handle translations for multiple
languages easily.

This chapter discusses the mechanism by which you can modify the current locale. The
effects of the current locale on specific library functions are discussed in more detail in the
descriptions of those functions.


Chapter 7: Locales and Internationalization 184

## 7.2 Choosing a Locale............................................

The simplest way for the user to choose a locale is to set the environment variableLANG.
This specifies a single locale to use for all purposes. For example, a user could specify a
hypothetical locale named ¡®espana-castellano¡¯ to use the standard conventions of most
of Spain.

The set of locales supported depends on the operating system you are using, and so
do their names, except that the standard locale called ¡®C¡¯ or ¡®POSIX¡¯ always exist. See
Section 7.6 [Locale Names], page 187.

In order to force the system to always use the default locale, the user can set theLC_ALL
environment variable to ¡®C¡¯.

A user also has the option of specifying different locales for different purposes¡ªin effect,
choosing a mixture of multiple locales. SeeSection 7.3 [Locale Categories], page 184.

For example, the user might specify the locale ¡®espana-castellano¡¯ for most purposes,
but specify the locale ¡®usa-english¡¯ for currency formatting. This might make sense if
the user is a Spanish-speaking American, working in Spanish, but representing monetary
amounts in US dollars.

Note that both locales ¡®espana-castellano¡¯ and ¡®usa-english¡¯, like all locales, would
include conventions for all of the purposes to which locales apply. However, the user can
choose to use each locale for a particular subset of those purposes.

## 7.3 Locale Categories............................................

The purposes that locales serve are grouped intocategories, so that a user or a program
can choose the locale for each category independently. Here is a table of categories; each
name is both an environment variable that a user can set, and a macro name that you can
use as the first argument tosetlocale.

The contents of the environment variable (or the string in the second argument to
setlocale) has to be a valid locale name. SeeSection 7.6 [Locale Names], page 187.

LC_COLLATE
This category applies to collation of strings (functionsstrcollandstrxfrm);
seeSection 5.8 [Collation Functions], page 117.

LC_CTYPE This category applies to classification and conversion of characters, and to
multibyte and wide characters; seeChapter 4 [Character Handling], page 87,
andChapter 6 [Character Set Handling], page 140.

LC_MONETARY
This category applies to formatting monetary values; see Section 7.7.1.1
[Generic Numeric Formatting Parameters], page 189.

LC_NUMERIC
This category applies to formatting numeric values that are not monetary; see
Section 7.7.1.1 [Generic Numeric Formatting Parameters], page 189.

LC_TIME This category applies to formatting date and time values; seeSection 21.5.4
[Formatting Calendar Time], page 662.


Chapter 7: Locales and Internationalization 185

### LC_MESSAGES

```
This category applies to selecting the language used in the user interface for mes-
sage translation (seeSection 8.2 [The Uniforum approach to Message Transla-
tion], page 212; seeSection 8.1 [X/Open Message Catalog Handling], page 203)
and contains regular expressions for affirmative and negative responses.
```
LC_ALL This is not a category; it is only a macro that you can use withsetlocaleto
set a single locale for all purposes. Setting this environment variable overwrites
all selections by the otherLC_*variables orLANG.

LANG If this environment variable is defined, its value specifies the locale to use for
all purposes except as overridden by the variables above.

When developing the message translation functions it was felt that the functionality
provided by the variables above is not sufficient. For example, it should be possible to
specify more than one locale name. Take a Swedish user who better speaks German than
English, and a program whose messages are output in English by default. It should be
possible to specify that the first choice of language is Swedish, the second German, and
if this also fails to use English. This is possible with the variableLANGUAGE. For further
description of this GNU extension seeSection 8.2.1.6 [User influence ongettext], page 224.

## 7.4 How Programs Set the Locale................................

A C program inherits its locale environment variables when it starts up. This happens
automatically. However, these variables do not automatically control the locale used by the
library functions, because ISO C says that all programs start by default in the standard ¡®C¡¯
locale. To use the locales specified by the environment, you must callsetlocale. Call it
as follows:
setlocale (LC_ALL, "");

to select a locale based on the user choice of the appropriate environment variables.

You can also usesetlocaleto specify a particular locale, for general use or for a specific
category.

```
The symbols in this section are defined in the header filelocale.h.
```
char * setlocale (intcategory, const char *locale) [Function]
Preliminary: |MT-Unsafe const:locale env|AS-Unsafe init lock heap corrupt|
AC-Unsafe init corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
The functionsetlocalesets the current locale for categorycategorytolocale.
Ifcategory isLC_ALL, this specifies the locale for all purposes. The other possi-
ble values ofcategory specify a single purpose (seeSection 7.3 [Locale Categories],
page 184).
You can also use this function to find out the current locale by passing a null pointer
as thelocaleargument. In this case,setlocalereturns a string that is the name of
the locale currently selected for categorycategory.
The string returned bysetlocalecan be overwritten by subsequent calls, so you
should make a copy of the string (seeSection 5.4 [Copying Strings and Arrays],


Chapter 7: Locales and Internationalization 186

```
page 101) if you want to save it past any further calls tosetlocale. (The standard
library is guaranteed never to callsetlocaleitself.)
You should not modify the string returned bysetlocale. It might be the same string
that was passed as an argument in a previous call tosetlocale. One requirement is
that thecategorymust be the same in the call the string was returned and the one
when the string is passed in aslocaleparameter.
When you read the current locale for categoryLC_ALL, the value encodes the entire
combination of selected locales for all categories. If you specify the same ¡°locale name¡±
withLC_ALLin a subsequent call tosetlocale, it restores the same combination of
locale selections.
To be sure you can use the returned string encoding the currently selected locale at a
later time, you must make a copy of the string. It is not guaranteed that the returned
pointer remains valid over time.
When thelocaleargument is not a null pointer, the string returned bysetlocale
reflects the newly-modified locale.
If you specify an empty string forlocale, this means to read the appropriate environ-
ment variable and use its value to select the locale forcategory.
If a nonempty string is given forlocale, then the locale of that name is used if possible.
The effective locale name (either the second argument tosetlocale, or if the argu-
ment is an empty string, the name obtained from the process environment) must be
a valid locale name. SeeSection 7.6 [Locale Names], page 187.
If you specify an invalid locale name,setlocalereturns a null pointer and leaves the
current locale unchanged.
```
Here is an example showing how you might usesetlocaleto temporarily switch to a
new locale.
#include <stddef.h>
#include <locale.h>
#include <stdlib.h>
#include <string.h>

```
void
with_other_locale (char *new_locale,
void (*subroutine) (int),
int argument)
{
char *old_locale, *saved_locale;
```
```
/*Get the name of the current locale. */
old_locale = setlocale (LC_ALL, NULL);
```
```
/*Copy the name so it won¡¯t be clobbered bysetlocale.*/
saved_locale = strdup (old_locale);
if (saved_locale == NULL)
fatal ("Out of memory");
```
```
/*Now change the locale and do some stuff with it. */
setlocale (LC_ALL, new_locale);
(*subroutine) (argument);
```

Chapter 7: Locales and Internationalization 187

/*Restore the original locale.*/
setlocale (LC_ALL, saved_locale);
free (saved_locale);
}
Portability Note: Some ISO C systems may define additional locale categories, and
future versions of the library will do so. For portability, assume that any symbol beginning
with ¡®LC_¡¯ might be defined inlocale.h.

## 7.5 Standard Locales.............................................

The only locale names you can count on finding on all operating systems are these three
standard ones:

"C" This is the standard C locale. The attributes and behavior it provides are
specified in the ISO C standard. When your program starts up, it initially uses
this locale by default.

"POSIX" This is the standard POSIX locale. Currently, it is an alias for the standard C
locale.

"" The empty name says to select a locale based on environment variables. See
Section 7.3 [Locale Categories], page 184.

Defining and installing named locales is normally a responsibility of the system admin-
istrator at your site (or the person who installed the GNU C Library). It is also possible
for the user to create private locales. All this will be discussed later when describing the
tool to do so.

If your program needs to use something other than the ¡®C¡¯ locale, it will be more portable
if you use whatever locale the user specifies with the environment, rather than trying to
specify some non-standard locale explicitly by name. Remember, different machines might
have different sets of locales installed.

## 7.6 Locale Names................................................

The following command prints a list of locales supported by the system:
locale -a
Portability Note: With the notable exception of the standard locale names ¡®C¡¯ and
¡®POSIX¡¯, locale names are system-specific.

Most locale names follow XPG syntax and consist of up to four parts:
language[_territory[.codeset]][@modifier]
Beside the first part, all of them are allowed to be missing. If the full specified locale is
not found, less specific ones are looked for. The various parts will be stripped off, in the
following order:

1. codeset
2. normalized codeset
3. territory
4. modifier


Chapter 7: Locales and Internationalization 188

For example, the locale name ¡®de_AT.iso885915@euro¡¯ denotes a German-language lo-
cale for use in Austria, using the ISO-8859-15 (Latin-9) character set, and with the Euro
as the currency symbol.

In addition to locale names which follow XPG syntax, systems may provide aliases such
as ¡®german¡¯. Both categories of names must not contain the slash character ¡®/¡¯.

If the locale name starts with a slash ¡®/¡¯, it is treated as a path relative to the configured
locale directories; seeLOCPATHbelow. The specified path must not contain a component
¡®..¡¯, or the name is invalid, andsetlocalewill fail.

Portability Note: POSIX suggests that if a locale name starts with a slash ¡®/¡¯, it is
resolved as an absolute path. However, the GNU C Library treats it as a relative path
under the directories listed inLOCPATH(or the default locale directory ifLOCPATHis unset).

Locale names which are longer than an implementation-defined limit are invalid and
causesetlocaleto fail.

As a special case, locale names used withLC_ALLcan combine several locales, reflecting
different locale settings for different categories. For example, you might want to use a U.S.
locale with ISO A4 paper format, so you setLANGto ¡®en_US.UTF-8¡¯, andLC_PAPERto
¡®de_DE.UTF-8¡¯. In this case, theLC_ALL-style combined locale name is
LC_CTYPE=en_US.UTF-8;LC_TIME=en_US.UTF-8;LC_PAPER=de_DE.UTF-8;...
followed by other category settings not shown here.
The path used for finding locale data can be set using theLOCPATHenvironment variable.
This variable lists the directories in which to search for locale definitions, separated by a
colon ¡®:¡¯.

The default path for finding locale data is system specific. A typical value for the
LOCPATHdefault is:
/usr/share/locale
The value ofLOCPATHis ignored by privileged programs for security reasons, and only
the default directory is used.

## 7.7 Accessing Locale Information.................................

There are several ways to access locale information. The simplest way is to let the C library
itself do the work. Several of the functions in this library implicitly access the locale data,
and use what information is provided by the currently selected locale. This is how the locale
model is meant to work normally.

As an example take thestrftimefunction, which is meant to nicely format date and
time information (seeSection 21.5.4 [Formatting Calendar Time], page 662). Part of the
standard information contained in theLC_TIMEcategory is the names of the months. Instead
of requiring the programmer to take care of providing the translations thestrftimefunction
does this all by itself.%Ain the format string is replaced by the appropriate weekday name
of the locale currently selected byLC_TIME. This is an easy example, and wherever possible
functions do things automatically in this way.

But there are quite often situations when there is simply no function to perform the task,
or it is simply not possible to do the work automatically. For these cases it is necessary to
access the information in the locale directly. To do this the C library provides two functions:
localeconvandnl_langinfo. The former is part of ISO C and therefore portable, but


Chapter 7: Locales and Internationalization 189

has a brain-damaged interface. The second is part of the Unix interface and is portable in
as far as the system follows the Unix standards.

## 7.7.1 localeconv: It is portable but

Together with thesetlocalefunction the ISO C people invented thelocaleconvfunction.
It is a masterpiece of poor design. It is expensive to use, not extensible, and not generally
usable as it provides access to onlyLC_MONETARYandLC_NUMERICrelated information.
Nevertheless, if it is applicable to a given situation it should be used since it is very portable.
The functionstrfmonformats monetary amounts according to the selected locale using this
information.

struct lconv * localeconv(void) [Function]
Preliminary: |MT-Unsafe race:localeconv locale|AS-Unsafe |AC-Safe |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelocaleconvfunction returns a pointer to a structure whose components contain
information about how numeric and monetary values should be formatted in the
current locale.
You should not modify the structure or its contents. The structure might be over-
written by subsequent calls tolocaleconv, or by calls tosetlocale, but no other
function in the library overwrites this value.

struct lconv [Data Type]
localeconv¡¯s return value is of this data type. Its elements are described in the
following subsections.

If a member of the structurestruct lconvhas typechar, and the value isCHAR_MAX,
it means that the current locale has no value for that parameter.

## 7.7.1.1 Generic Numeric Formatting Parameters............

These are the standard members ofstruct lconv; there may be others.

char *decimal_point
char *mon_decimal_point
These are the decimal-point separators used in formatting non-monetary and
monetary quantities, respectively. In the ¡®C¡¯ locale, the value ofdecimal_point
is".", and the value ofmon_decimal_pointis"".

char *thousands_sep
char *mon_thousands_sep
These are the separators used to delimit groups of digits to the left of the decimal
point in formatting non-monetary and monetary quantities, respectively. In the
¡®C¡¯ locale, both members have a value of""(the empty string).

char *grouping
char *mon_grouping
These are strings that specify how to group the digits to the left of the decimal
point.groupingapplies to non-monetary quantities andmon_groupingapplies
to monetary quantities. Use eitherthousands_sepormon_thousands_septo
separate the digit groups.


Chapter 7: Locales and Internationalization 190

```
Each member of these strings is to be interpreted as an integer value of type
char. Successive numbers (from left to right) give the sizes of successive groups
(from right to left, starting at the decimal point.) The last member is either
0 , in which case the previous member is used over and over again for all the
remaining groups, orCHAR_MAX, in which case there is no more grouping¡ªor,
put another way, any remaining digits form one large group without separators.
For example, ifgroupingis"\04\03\02", the correct grouping for the number
123456787654321 is ¡® 12 ¡¯, ¡® 34 ¡¯, ¡® 56 ¡¯, ¡® 78 ¡¯, ¡® 765 ¡¯, ¡® 4321 ¡¯. This uses a group of 4
digits at the end, preceded by a group of 3 digits, preceded by groups of 2 digits
(as many as needed). With a separator of ¡®,¡¯, the number would be printed as
¡®12,34,56,78,765,4321¡¯.
A value of"\03"indicates repeated groups of three digits, as normally used in
the U.S.
In the standard ¡®C¡¯ locale, bothgroupingandmon_groupinghave a value of
"". This value specifies no grouping at all.
```
char int_frac_digits
char frac_digits
These are small integers indicating how many fractional digits (to the right of
the decimal point) should be displayed in a monetary value in international and
local formats, respectively. (Most often, both members have the same value.)
In the standard ¡®C¡¯ locale, both of these members have the valueCHAR_MAX,
meaning ¡°unspecified¡±. The ISO standard doesn¡¯t say what to do when you
find this value; we recommend printing no fractional digits. (This locale also
specifies the empty string formon_decimal_point, so printing any fractional
digits would be confusing!)

## 7.7.1.2 Printing the Currency Symbol......................

These members of thestruct lconvstructure specify how to print the symbol to identify
a monetary value¡ªthe international analog of ¡®$¡¯ for US dollars.

Each country has two standard currency symbols. Thelocal currency symbolis used
commonly within the country, while theinternational currency symbol is used interna-
tionally to refer to that country¡¯s currency when it is necessary to indicate the country
unambiguously.

For example, many countries use the dollar as their monetary unit, and when dealing with
international currencies it¡¯s important to specify that one is dealing with (say) Canadian
dollars instead of U.S. dollars or Australian dollars. But when the context is known to be
Canada, there is no need to make this explicit¡ªdollar amounts are implicitly assumed to
be in Canadian dollars.

char *currency_symbol
The local currency symbol for the selected locale.
In the standard ¡®C¡¯ locale, this member has a value of""(the empty string),
meaning ¡°unspecified¡±. The ISO standard doesn¡¯t say what to do when you
find this value; we recommend you simply print the empty string as you would
print any other string pointed to by this variable.


Chapter 7: Locales and Internationalization 191

char *int_curr_symbol
The international currency symbol for the selected locale.
The value ofint_curr_symbolshould normally consist of a three-letter ab-
breviation determined by the international standardISO 4217 Codes for the
Representation of Currency and Funds, followed by a one-character separator
(often a space).
In the standard ¡®C¡¯ locale, this member has a value of""(the empty string),
meaning ¡°unspecified¡±. We recommend you simply print the empty string as
you would print any other string pointed to by this variable.

char p_cs_precedes
char n_cs_precedes
char int_p_cs_precedes
char int_n_cs_precedes
These members are 1 if thecurrency_symbol orint_curr_symbolstrings
should precede the value of a monetary amount, or 0 if the strings should
follow the value. Thep_cs_precedesandint_p_cs_precedesmembers apply
to positive amounts (or zero), and then_cs_precedesandint_n_cs_precedes
members apply to negative amounts.
In the standard ¡®C¡¯ locale, all of these members have a value ofCHAR_MAX,
meaning ¡°unspecified¡±. The ISO standard doesn¡¯t say what to do when you
find this value. We recommend printing the currency symbol before the amount,
which is right for most countries. In other words, treat all nonzero values alike
in these members.
The members with theint_prefix apply to theint_curr_symbolwhile the
other two apply tocurrency_symbol.

char p_sep_by_space
char n_sep_by_space
char int_p_sep_by_space
char int_n_sep_by_space
These members are 1 if a space should appear between thecurrency_symbolor
int_curr_symbolstrings and the amount, or 0 if no space should appear. The
p_sep_by_spaceandint_p_sep_by_spacemembers apply to positive amounts
(or zero), and then_sep_by_spaceandint_n_sep_by_spacemembers apply
to negative amounts.
In the standard ¡®C¡¯ locale, all of these members have a value ofCHAR_MAX,
meaning ¡°unspecified¡±. The ISO standard doesn¡¯t say what you should do
when you find this value; we suggest you treat it as 1 (print a space). In other
words, treat all nonzero values alike in these members.
The members with theint_prefix apply to theint_curr_symbolwhile the
other two apply tocurrency_symbol. There is one specialty with theint_
curr_symbol, though. Since all legal values contain a space at the end of
the string one either prints this space (if the currency symbol must appear in
front and must be separated) or one has to avoid printing this character at all
(especially when at the end of the string).


Chapter 7: Locales and Internationalization 192

## 7.7.1.3 Printing the Sign of a Monetary Amount............

These members of thestruct lconvstructure specify how to print the sign (if any) of a
monetary value.

char *positive_sign
char *negative_sign
These are strings used to indicate positive (or zero) and negative monetary
quantities, respectively.
In the standard ¡®C¡¯ locale, both of these members have a value of""(the empty
string), meaning ¡°unspecified¡±.
The ISO standard doesn¡¯t say what to do when you find this value; we recom-
mend printingpositive_signas you find it, even if it is empty. For a negative
value, printnegative_signas you find it unless both it andpositive_sign
are empty, in which case print ¡®-¡¯ instead. (Failing to indicate the sign at all
seems rather unreasonable.)

char p_sign_posn
char n_sign_posn
char int_p_sign_posn
char int_n_sign_posn
These members are small integers that indicate how to position the sign for
nonnegative and negative monetary quantities, respectively. (The string used
for the sign is what was specified withpositive_signornegative_sign.) The
possible values are as follows:

```
0 The currency symbol and quantity should be surrounded by paren-
theses.
```
```
1 Print the sign string before the quantity and currency symbol.
```
```
2 Print the sign string after the quantity and currency symbol.
```
```
3 Print the sign string right before the currency symbol.
```
```
4 Print the sign string right after the currency symbol.
```
```
CHAR_MAX ¡°Unspecified¡±. Both members have this value in the standard ¡®C¡¯
locale.
```
```
The ISO standard doesn¡¯t say what you should do when the value isCHAR_MAX.
We recommend you print the sign after the currency symbol.
The members with theint_prefix apply to theint_curr_symbolwhile the
other two apply tocurrency_symbol.
```
## 7.7.2 Pinpoint Access to Locale Data..........................

When writing the X/Open Portability Guide the authors realized that thelocaleconv
function is not enough to provide reasonable access to locale information. The information
which was meant to be available in the locale (as later specified in the POSIX.1 standard)
requires more ways to access it. Therefore thenl_langinfofunction was introduced.


Chapter 7: Locales and Internationalization 193

char * nl_langinfo(nlitemitem) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thenl_langinfofunction can be used to access individual elements of the locale
categories. Unlike thelocaleconvfunction, which returns all the information,nl_
langinfolets the caller select what information it requires. This is very fast and it
is not a problem to call this function multiple times.
A second advantage is that in addition to the numeric and monetary formatting
information, information from theLC_TIMEandLC_MESSAGEScategories is available.
The typenl_itemis defined innl_types.h. The argumentitemis a numeric value
defined in the headerlanginfo.h. The X/Open standard defines the following values:

```
CODESET nl_langinforeturns a string with the name of the coded character set
used in the selected locale.
```
```
ABDAY_1
ABDAY_2
ABDAY_3
ABDAY_4
ABDAY_5
ABDAY_6
ABDAY_7 nl_langinforeturns the abbreviated weekday name. ABDAY_1 corre-
sponds to Sunday.
```
```
DAY_1
DAY_2
DAY_3
DAY_4
DAY_5
DAY_6
DAY_7 Similar toABDAY_1, etc., but here the return value is the unabbreviated
weekday name.
```
```
ABMON_1
ABMON_2
ABMON_3
ABMON_4
ABMON_5
ABMON_6
ABMON_7
ABMON_8
ABMON_9
ABMON_10
ABMON_11
ABMON_12 The return value is the abbreviated name of the month, in the grammat-
ical form used when the month forms part of a complete date. ABMON_1
corresponds to January.
```

Chapter 7: Locales and Internationalization 194

### MON_1

### MON_2

### MON_3

### MON_4

### MON_5

### MON_6

### MON_7

### MON_8

### MON_9

### MON_10

### MON_11

```
MON_12 Similar toABMON_1, etc., but here the month names are not abbreviated.
Here the first valueMON_1also corresponds to January.
```
```
ALTMON_1
ALTMON_2
ALTMON_3
ALTMON_4
ALTMON_5
ALTMON_6
ALTMON_7
ALTMON_8
ALTMON_9
ALTMON_10
ALTMON_11
ALTMON_12
Similar toMON_1, etc., but here the month names are in the grammatical
form used when the month is named by itself. Thestrftimefunctions
use these month names for the conversion specifier%OB(seeSection 21.5.4
[Formatting Calendar Time], page 662).
Note that not all languages need two different forms of the month names,
so the strings returned forMON_...andALTMON_...may or may not be
the same, depending on the locale.
NB:ABALTMON_...constants corresponding to the%Obconversion speci-
fier are not currently provided, but are expected to be in a future release.
In the meantime, it is possible to use_NL_ABALTMON_....
```
```
AM_STR
PM_STR The return values are strings which can be used in the representation of
time as an hour from 1 to 12 plus an am/pm specifier.
Note that in locales which do not use this time representation these strings
might be empty, in which case the am/pm format cannot be used at all.
```
```
D_T_FMT The return value can be used as a format string forstrftimeto represent
time and date in a locale-specific way.
```
```
D_FMT The return value can be used as a format string forstrftimeto represent
a date in a locale-specific way.
```

Chapter 7: Locales and Internationalization 195

```
T_FMT The return value can be used as a format string forstrftimeto represent
time in a locale-specific way.
```
```
T_FMT_AMPM
The return value can be used as a format string forstrftimeto represent
time in the am/pm format.
Note that if the am/pm format does not make any sense for the selected
locale, the return value might be the same as the one forT_FMT.
```
```
ERA The return value represents the era used in the current locale.
Most locales do not define this value. An example of a locale which
does define this value is the Japanese one. In Japan, the traditional
representation of dates includes the name of the era corresponding to the
then-emperor¡¯s reign.
Normally it should not be necessary to use this value directly. Specifying
theEmodifier in their format strings causes thestrftimefunctions to
use this information. The format of the returned string is not specified,
and therefore you should not assume knowledge of it on different systems.
```
```
ERA_YEAR The return value gives the year in the relevant era of the locale. As for
ERAit should not be necessary to use this value directly.
```
```
ERA_D_T_FMT
This return value can be used as a format string forstrftimeto represent
dates and times in a locale-specific era-based way.
```
```
ERA_D_FMT
This return value can be used as a format string forstrftimeto represent
a date in a locale-specific era-based way.
```
```
ERA_T_FMT
This return value can be used as a format string forstrftimeto represent
time in a locale-specific era-based way.
```
```
ALT_DIGITS
The return value is a representation of up to 100 values used to represent
the values 0 to 99. As forERA this value is not intended to be used
directly, but instead indirectly through thestrftimefunction. When
the modifierOis used in a format which would otherwise use numerals
to represent hours, minutes, seconds, weekdays, months, or weeks, the
appropriate value for the locale is used instead.
```
```
INT_CURR_SYMBOL
The same as the value returned bylocaleconvin theint_curr_symbol
element of thestruct lconv.
```
```
CURRENCY_SYMBOL
CRNCYSTR The same as the value returned bylocaleconvin thecurrency_symbol
element of thestruct lconv.
CRNCYSTRis a deprecated alias still required by Unix98.
```

Chapter 7: Locales and Internationalization 196

### MON_DECIMAL_POINT

```
The same as the value returned bylocaleconv in themon_decimal_
pointelement of thestruct lconv.
MON_THOUSANDS_SEP
The same as the value returned bylocaleconvin themon_thousands_
sepelement of thestruct lconv.
MON_GROUPING
The same as the value returned bylocaleconv in themon_grouping
element of thestruct lconv.
POSITIVE_SIGN
The same as the value returned bylocaleconvin thepositive_sign
element of thestruct lconv.
NEGATIVE_SIGN
The same as the value returned bylocaleconvin thenegative_sign
element of thestruct lconv.
INT_FRAC_DIGITS
The same as the value returned bylocaleconvin theint_frac_digits
element of thestruct lconv.
FRAC_DIGITS
The same as the value returned bylocaleconvin thefrac_digitsele-
ment of thestruct lconv.
P_CS_PRECEDES
The same as the value returned bylocaleconvin thep_cs_precedes
element of thestruct lconv.
P_SEP_BY_SPACE
The same as the value returned bylocaleconvin thep_sep_by_space
element of thestruct lconv.
N_CS_PRECEDES
The same as the value returned bylocaleconvin then_cs_precedes
element of thestruct lconv.
N_SEP_BY_SPACE
The same as the value returned bylocaleconvin then_sep_by_space
element of thestruct lconv.
P_SIGN_POSN
The same as the value returned bylocaleconvin thep_sign_posnele-
ment of thestruct lconv.
N_SIGN_POSN
The same as the value returned bylocaleconvin then_sign_posnele-
ment of thestruct lconv.
INT_P_CS_PRECEDES
The same as the value returned by localeconv in the int_p_cs_
precedeselement of thestruct lconv.
```

Chapter 7: Locales and Internationalization 197

### INT_P_SEP_BY_SPACE

```
The same as the value returned bylocaleconvin theint_p_sep_by_
spaceelement of thestruct lconv.
INT_N_CS_PRECEDES
The same as the value returned by localeconv in the int_n_cs_
precedeselement of thestruct lconv.
INT_N_SEP_BY_SPACE
The same as the value returned bylocaleconvin theint_n_sep_by_
spaceelement of thestruct lconv.
INT_P_SIGN_POSN
The same as the value returned bylocaleconvin theint_p_sign_posn
element of thestruct lconv.
INT_N_SIGN_POSN
The same as the value returned bylocaleconvin theint_n_sign_posn
element of thestruct lconv.
DECIMAL_POINT
RADIXCHAR
The same as the value returned bylocaleconvin thedecimal_point
element of thestruct lconv.
The nameRADIXCHARis a deprecated alias still used in Unix98.
THOUSANDS_SEP
THOUSEP The same as the value returned bylocaleconvin thethousands_sep
element of thestruct lconv.
The nameTHOUSEPis a deprecated alias still used in Unix98.
GROUPING The same as the value returned bylocaleconvin thegroupingelement
of thestruct lconv.
YESEXPR The return value is a regular expression which can be used with the
regexfunction to recognize a positive response to a yes/no question.
The GNU C Library provides therpmatchfunction for easier handling
in applications.
NOEXPR The return value is a regular expression which can be used with theregex
function to recognize a negative response to a yes/no question.
YESSTR The return value is a locale-specific translation of the positive response
to a yes/no question.
Using this value is deprecated since it is a very special case of message
translation, and is better handled by the message translation functions
(seeChapter 8 [Message Translation], page 203).
The use of this symbol is deprecated. Instead message translation should
be used.
```
```
NOSTR The return value is a locale-specific translation of the negative response
to a yes/no question. What is said forYESSTRis also true here.
```

Chapter 7: Locales and Internationalization 198

```
The use of this symbol is deprecated. Instead message translation should
be used.
```
```
The filelanginfo.hdefines a lot more symbols but none of them are official. Using
them is not portable, and the format of the return values might change. Therefore
we recommended you not use them.
Note that the return value for any valid argument can be used in all situations (with
the possible exception of the am/pm time formatting codes). If the user has not
selected any locale for the appropriate category,nl_langinforeturns the information
from the"C"locale. It is therefore possible to use this function as shown in the
example below.
If the argumentitemis not valid, a pointer to an empty string is returned.
```
An example ofnl_langinfousage is a function which has to print a given date and
time in a locale-specific way. At first one might think that, sincestrftimeinternally uses
the locale information, writing something like the following is enough:

size_t
i18n_time_n_data (char *s, size_t len, const struct tm *tp)
{
return strftime (s, len, "%X %D", tp);
}
The format contains no weekday or month names and therefore is internationally usable.
Wrong! The output produced is something like"hh:mm:ss MM/DD/YY". This format is only
recognizable in the USA. Other countries use different formats. Therefore the function
should be rewritten like this:
size_t
i18n_time_n_data (char *s, size_t len, const struct tm *tp)
{
return strftime (s, len, nl_langinfo (D_T_FMT), tp);
}
Now it uses the date and time format of the locale selected when the program runs. If
the user selects the locale correctly there should never be a misunderstanding over the time
and date format.

7.8 A dedicated function to format numbers

We have seen that the structure returned bylocaleconvas well as the values given tonl_
langinfoallow you to retrieve the various pieces of locale-specific information to format
numbers and monetary amounts. We have also seen that the underlying rules are quite
complex.

Therefore the X/Open standards introduce a function which uses such locale information,
making it easier for the user to format numbers according to these rules.

ssize_t strfmon (char *s, size tmaxsize, const char *format,.. .) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thestrfmonfunction is similar to thestrftimefunction in that it takes a buffer,
its size, a format string, and values to write into the buffer as text in a form specified


Chapter 7: Locales and Internationalization 199

```
by the format string. Likestrftime, the function also returns the number of bytes
written into the buffer.
There are two differences:strfmoncan take more than one argument, and, of course,
the format specification is different. Likestrftime, the format string consists of
normal text, which is output as is, and format specifiers, which are indicated by a
¡®%¡¯. Immediately after the ¡®%¡¯, you can optionally specify various flags and formatting
information before the main formatting character, in a similar way toprintf:
```
- Immediately following the ¡®%¡¯ there can be one or more of the following flags:
    ¡®=f¡¯ The single byte characterf is used for this field as the numeric fill
       character. By default this character is a space character. Filling with
       this character is only performed if a left precision is specified. It is
       not just to fill to the given field width.
    ¡®^¡¯ The number is printed without grouping the digits according to the
       rules of the current locale. By default grouping is enabled.
    ¡®+¡¯, ¡®(¡¯ At most one of these flags can be used. They select which format
       to represent the sign of a currency amount. By default, and if ¡®+¡¯ is
       given, the locale equivalent of +/?is used. If ¡®(¡¯ is given, negative
       amounts are enclosed in parentheses. The exact format is determined
       by the values of theLC_MONETARYcategory of the locale selected at
       program runtime.
    ¡®!¡¯ The output will not contain the currency symbol.

```
¡®-¡¯ The output will be formatted left-justified instead of right-justified
if it does not fill the entire field width.
```
```
The next part of the specification is an optional field width. If no width is specified 0
is taken. During output, the function first determines how much space is required. If
it requires at least as many characters as given by the field width, it is output using
as much space as necessary. Otherwise, it is extended to use the full width by filling
with the space character. The presence or absence of the ¡®-¡¯ flag determines the side
at which such padding occurs. If present, the spaces are added at the right making
the output left-justified, and vice versa.
So far the format looks familiar, being similar to theprintfandstrftimeformats.
However, the next two optional fields introduce something new. The first one is a ¡®#¡¯
character followed by a decimal digit string. The value of the digit string specifies
the number ofdigitpositions to the left of the decimal point (or equivalent). This
doesnotinclude the grouping character when the ¡®^¡¯ flag is not given. If the space
needed to print the number does not fill the whole width, the field is padded at the
left side with the fill character, which can be selected using the ¡®=¡¯ flag and by default
is a space. For example, if the field width is selected as 6 and the number is 123, the
fill character is ¡®*¡¯ the result will be ¡®***123¡¯.
The second optional field starts with a ¡®.¡¯ (period) and consists of another decimal
digit string. Its value describes the number of characters printed after the decimal
point. The default is selected from the current locale (frac_digits,int_frac_
digits, see seeSection 7.7.1.1 [Generic Numeric Formatting Parameters], page 189).
```

Chapter 7: Locales and Internationalization 200

```
If the exact representation needs more digits than given by the field width, the dis-
played value is rounded. If the number of fractional digits is selected to be zero, no
decimal point is printed.
As a GNU extension, thestrfmonimplementation in the GNU C Library allows an
optional ¡®L¡¯ next as a format modifier. If this modifier is given, the argument is
expected to be along doubleinstead of adoublevalue.
Finally, the last component is a format specifier. There are three specifiers defined:
¡®i¡¯ Use the locale¡¯s rules for formatting an international currency value.
¡®n¡¯ Use the locale¡¯s rules for formatting a national currency value.
¡®%¡¯ Place a ¡®%¡¯ in the output. There must be no flag, width specifier or
modifier given, only ¡®%%¡¯ is allowed.
As forprintf, the function reads the format string from left to right and uses the
values passed to the function following the format string. The values are expected to
be either of typedoubleorlong double, depending on the presence of the modifier
¡®L¡¯. The result is stored in the buffer pointed to bys. At mostmaxsize characters
are stored.
The return value of the function is the number of characters stored ins, including the
terminatingNULLbyte. If the number of characters stored would exceedmaxsize, the
function returns?1 and the content of the buffersis unspecified. In this caseerrno
is set toE2BIG.
```
A few examples should make clear how the function works. It is assumed that all the
following pieces of code are executed in a program which uses the USA locale (en_US). The
simplest form of the format is this:
strfmon (buf, 100, "@%n@%n@%n@", 123.45, -567.89, 12345.678);

The output produced is
"@$123.45@-$567.89@$12,345.68@"
We can notice several things here. First, the widths of the output numbers are different.
We have not specified a width in the format string, and so this is no wonder. Second, the
third number is printed using thousands separators. The thousands separator for theen_US
locale is a comma. The number is also rounded. .678 is rounded to.68 since the format
does not specify a precision and the default value in the locale is 2. Finally, note that the
national currency symbol is printed since ¡®%n¡¯ was used, not ¡®i¡¯. The next example shows
how we can align the output.
strfmon (buf, 100, "@%=*11n@%=*11n@%=*11n@", 123.45, -567.89, 12345.678);

The output this time is:
"@ $123.45@ -$567.89@ $12,345.68@"
Two things stand out. Firstly, all fields have the same width (eleven characters) since
this is the width given in the format and since no number required more characters to be
printed. The second important point is that the fill character is not used. This is correct
since the white space was not used to achieve a precision given by a ¡®#¡¯ modifier, but
instead to fill to the given width. The difference becomes obvious if we now add a width
specification.
strfmon (buf, 100, "@%=*11#5n@%=*11#5n@%=*11#5n@",


Chapter 7: Locales and Internationalization 201

```
123.45, -567.89, 12345.678);
```
The output is
"@ $***123.45@-$***567.89@ $12,456.68@"
Here we can see that all the currency symbols are now aligned, and that the space
between the currency sign and the number is filled with the selected fill character. Note
that although the width is selected to be 5 and 123.45 has three digits left of the decimal
point, the space is filled with three asterisks. This is correct since, as explained above, the
width does not include the positions used to store thousands separators. One last example
should explain the remaining functionality.
strfmon (buf, 100, "@%=0(16#5.3i@%=0(16#5.3i@%=0(16#5.3i@",
123.45, -567.89, 12345.678);

This rather complex format string produces the following output:
"@ USD 000123,450 @(USD 000567.890)@ USD 12,345.678 @"
The most noticeable change is the alternative way of representing negative numbers. In
financial circles this is often done using parentheses, and this is what the ¡®(¡¯ flag selected.
The fill character is now ¡® 0 ¡¯. Note that this ¡® 0 ¡¯ character is not regarded as a numeric zero,
and therefore the first and second numbers are not printed using a thousands separator.
Since we used the format specifier ¡®i¡¯ instead of ¡®n¡¯, the international form of the currency
symbol is used. This is a four letter string, in this case"USD ". The last point is that since
the precision right of the decimal point is selected to be three, the first and second numbers
are printed with an extra zero at the end and the third number is printed without rounding.

## 7.9 Yes-or-No Questions..........................................

Some non GUI programs ask a yes-or-no question. If the messages (especially the questions)
are translated into foreign languages, be sure that you localize the answers too. It would be
very bad habit to ask a question in one language and request the answer in another, often
English.

The GNU C Library containsrpmatchto give applications easy access to the corre-
sponding locale definitions.

int rpmatch(const char *response) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionrpmatchchecks the string inresponsefor whether or not it is a correct
yes-or-no answer and if yes, which one. The check uses theYESEXPRandNOEXPRdata
in theLC_MESSAGEScategory of the currently selected locale. The return value is as
follows:
1 The user entered an affirmative answer.

```
0 The user entered a negative answer.
```
```
-1 The answer matched neither theYESEXPRnor theNOEXPRregular expres-
sion.
```
```
This function is not standardized but available beside in the GNU C Library at least
also in the IBM AIX library.
```

Chapter 7: Locales and Internationalization 202

This function would normally be used like this:
...
/*Use a safe default. */
_Bool doit = false;

fputs (gettext ("Do you really want to do this? "), stdout);
fflush (stdout);
/*Prepare thegetlinecall. */
line = NULL;
len = 0;
while (getline (&line, &len, stdin) >= 0)
{
/*Check the response. */
int res = rpmatch (line);
if (res >= 0)
{
/*We got a definitive answer. */
if (res > 0)
doit = true;
break;
}
}
/*Free whatgetlineallocated. */
free (line);
Note that the loop continues until a read error is detected or until a definitive (positive
or negative) answer is read.


### 203

## 8 Message Translation..........................

## 8 Message Translation.................................

The program¡¯s interface with the user should be designed to ease the user¡¯s task. One way
to ease the user¡¯s task is to use messages in whatever language the user prefers.

Printing messages in different languages can be implemented in different ways. One could
add all the different languages in the source code and choose among the variants every time
a message has to be printed. This is certainly not a good solution since extending the set of
languages is cumbersome (the code must be changed) and the code itself can become really
big with dozens of message sets.

A better solution is to keep the message sets for each language in separate files which
are loaded at runtime depending on the language selection of the user.

The GNU C Library provides two different sets of functions to support message trans-
lation. The problem is that neither of the interfaces is officially defined by the POSIX
standard. Thecatgetsfamily of functions is defined in the X/Open standard but this is
derived from industry decisions and therefore not necessarily based on reasonable decisions.

As mentioned above, the message catalog handling provides easy extendability by using
external data files which contain the message translations. I.e., these files contain for each
of the messages used in the program a translation for the appropriate language. So the
tasks of the message handling functions are

- locate the external data file with the appropriate translations
- load the data and make it possible to address the messages
- map a given key to the translated message

The two approaches mainly differ in the implementation of this last step. Decisions made
in the last step influence the rest of the design.

## 8.1 X/Open Message Catalog Handling...........................

Thecatgetsfunctions are based on the simple scheme:

Associate every message to translate in the source code with a unique identifier.
To retrieve a message from a catalog file solely the identifier is used.
This means for the author of the program that s/he will have to make sure the meaning
of the identifier in the program code and in the message catalogs is always the same.

Before a message can be translated the catalog file must be located. The user of the
program must be able to guide the responsible function to find whatever catalog the user
wants. This is separated from what the programmer had in mind.

All the types, constants and functions for thecatgetsfunctions are defined/declared in
thenl_types.hheader file.

## 8.1.1 Thecatgetsfunction family............................

nl_catd catopen (const char *cat_name, intflag) [Function]
Preliminary:|MT-Safe env|AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 8: Message Translation 204

```
Thecatopenfunction tries to locate the message data file namedcatnameand loads
it when found. The return value is of an opaque type and can be used in calls to the
other functions to refer to this loaded catalog.
The return value is(nl_catd) -1in case the function failed and no catalog was
loaded. The global variableerrnocontains a code for the error causing the failure.
But even if the function call succeeded this does not mean that all messages can be
translated.
Locating the catalog file must happen in a way which lets the user of the program
influence the decision. It is up to the user to decide about the language to use and
sometimes it is useful to use alternate catalog files. All this can be specified by the
user by setting some environment variables.
The first problem is to find out where all the message catalogs are stored. Every
program could have its own place to keep all the different files but usually the catalog
files are grouped by languages and the catalogs for all programs are kept in the same
place.
To tell thecatopenfunction where the catalog for the program can be found the user
can set the environment variableNLSPATHto a value which describes her/his choice.
Since this value must be usable for different languages and locales it cannot be a
simple string. Instead it is a format string (similar toprintf¡¯s). An example is
/usr/share/locale/%L/%N:/usr/share/locale/%L/LC_MESSAGES/%N
First one can see that more than one directory can be specified (with the usual syntax
of separating them by colons). The next things to observe are the format string,%L
and%N in this case. Thecatopenfunction knows about several of them and the
replacement for all of them is of course different.
```
```
%N This format element is substituted with the name of the catalog file. This
is the value of thecatnameargument given tocatgets.
```
```
%L This format element is substituted with the name of the currently selected
locale for translating messages. How this is determined is explained be-
low.
```
```
%l (This is the lowercase ell.) This format element is substituted with the
language element of the locale name. The string describing the selected
locale is expected to have the formlang[_terr[.codeset]] and this
format uses the first partlang.
```
```
%t This format element is substituted by the territory partterrof the name
of the currently selected locale. See the explanation of the format above.
```
```
%c This format element is substituted by the codeset partcodesetof the
name of the currently selected locale. See the explanation of the format
above.
```
```
%% Since%is used as a meta character there must be a way to express the
%character in the result itself. Using%%does this just like it works for
printf.
```

Chapter 8: Message Translation 205

```
UsingNLSPATHallows arbitrary directories to be searched for message catalogs while
still allowing different languages to be used. If theNLSPATHenvironment variable is
not set, the default value is
prefix/share/locale/%L/%N:prefix/share/locale/%L/LC_MESSAGES/%N
whereprefixis given toconfigurewhile installing the GNU C Library (this value is
in many cases/usror the empty string).
The remaining problem is to decide which must be used. The value decides about
the substitution of the format elements mentioned above. First of all the user can
specify a path in the message catalog name (i.e., the name contains a slash character).
In this situation theNLSPATHenvironment variable is not used. The catalog must
exist as specified in the program, perhaps relative to the current working directory.
This situation in not desirable and catalogs names never should be written this way.
Beside this, this behavior is not portable to all other platforms providing thecatgets
interface.
Otherwise the values of environment variables from the standard environment are
examined (seeSection 25.4.2 [Standard Environment Variables], page 795). Which
variables are examined is decided by theflagparameter ofcatopen. If the value is
NL_CAT_LOCALE(which is defined innl_types.h) then thecatopenfunction uses the
name of the locale currently selected for theLC_MESSAGEScategory.
Ifflagis zero theLANGenvironment variable is examined. This is a left-over from
the early days when the concept of locales had not even reached the level of POSIX
locales.
The environment variable and the locale name should have a value of the formlang[_
terr[.codeset]]as explained above. If no environment variable is set the"C"locale
is used which prevents any translation.
The return value of the function is in any case a valid string. Either it is a translation
from a message catalog or it is the same as thestringparameter. So a piece of code
to decide whether a translation actually happened must look like this:
{
char *trans = catgets (desc, set, msg, input_string);
if (trans == input_string)
{
/* Something went wrong. */
}
}
When an error occurs the global variableerrnois set to
EBADF The catalog does not exist.
ENOMSG The set/message tuple does not name an existing element in the message
catalog.
While it sometimes can be useful to test for errors programs normally will avoid any
test. If the translation is not available it is no big problem if the original, untranslated
message is printed. Either the user understands this as well or s/he will look for the
reason why the messages are not translated.
```
Please note that the currently selected locale does not depend on a call to thesetlocale
function. It is not necessary that the locale data files for this locale exist and calling


Chapter 8: Message Translation 206

setlocalesucceeds. Thecatopenfunction directly reads the values of the environment
variables.

char * catgets(nlcatdcatalog_desc, intset, intmessage, const [Function]
char *string)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functioncatgetshas to be used to access the message catalog previously opened
using thecatopenfunction. Thecatalogdescparameter must be a value previously
returned bycatopen.
The next two parameters,setandmessage, reflect the internal organization of the
message catalog files. This will be explained in detail below. For now it is interesting
to know that a catalog can consist of several sets and the messages in each thread
are individually numbered using numbers. Neither the set number nor the message
number must be consecutive. They can be arbitrarily chosen. But each message
(unless equal to another one) must have its own unique pair of set and message
numbers.
Since it is not guaranteed that the message catalog for the language selected by
the user exists the last parameterstringhelps to handle this case gracefully. If no
matching string can be foundstringis returned. This means for the programmer that

- thestringparameters should contain reasonable text (this also helps to under-
    stand the program seems otherwise there would be no hint on the string which
    is expected to be returned.
- allstringarguments should be written in the same language.

It is somewhat uncomfortable to write a program using thecatgetsfunctions if no
supporting functionality is available. Since each set/message number tuple must be unique
the programmer must keep lists of the messages at the same time the code is written. And
the work between several people working on the same project must be coordinated. We
will see how some of these problems can be relaxed a bit (seeSection 8.1.4 [How to use the
catgetsinterface], page 210).

int catclose (nlcatdcatalog_desc) [Function]
Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe corrupt mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thecatclosefunction can be used to free the resources associated with a message
catalog which previously was opened by a call tocatopen. If the resources can be
successfully freed the function returns 0. Otherwise it returns? 1 and the global
variableerrnois set. Errors can occur if the catalog descriptorcatalogdescis not
valid in which caseerrnois set toEBADF.

## 8.1.2 Format of the message catalog files......................

The only reasonable way to translate all the messages of a function and store the result in a
message catalog file which can be read by thecatopenfunction is to write all the message
text to the translator and let her/him translate them all. I.e., we must have a file with


Chapter 8: Message Translation 207

entries which associate the set/message tuple with a specific translation. This file format is
specified in the X/Open standard and is as follows:

- Lines containing only whitespace characters or empty lines are ignored.
- Lines which contain as the first non-whitespace character a$followed by a whitespace
    character are comment and are also ignored.
- If a line contains as the first non-whitespace characters the sequence$setfollowed by
    a whitespace character an additional argument is required to follow. This argument
    can either be:
       ? a number. In this case the value of this number determines the set to which the
          following messages are added.
       ? an identifier consisting of alphanumeric characters plus the underscore character.
          In this case the set get automatically a number assigned. This value is one added
          to the largest set number which so far appeared.
          How to use the symbolic names is explained in sectionSection 8.1.4 [How to use
          thecatgetsinterface], page 210.
          It is an error if a symbol name appears more than once. All following messages
          are placed in a set with this number.
- If a line contains as the first non-whitespace characters the sequence$delsetfollowed
    by a whitespace character an additional argument is required to follow. This argument
    can either be:
       ? a number. In this case the value of this number determines the set which will be
          deleted.
       ? an identifier consisting of alphanumeric characters plus the underscore character.
          This symbolic identifier must match a name for a set which previously was defined.
          It is an error if the name is unknown.
    In both cases all messages in the specified set will be removed. They will not appear in
    the output. But if this set is later again selected with a$setcommand again messages
    could be added and these messages will appear in the output.
- If a line contains after leading whitespaces the sequence$quote, the quoting character
    used for this input file is changed to the first non-whitespace character following$quote.
    If no non-whitespace character is present before the line ends quoting is disabled.
    By default no quoting character is used. In this mode strings are terminated with the
    first unescaped line break. If there is a$quotesequence present newline need not be
    escaped. Instead a string is terminated with the first unescaped appearance of the
    quote character.
    A common usage of this feature would be to set the quote character to". Then any
    appearance of the"in the strings must be escaped using the backslash (i.e.,\"must
    be written).
- Any other line must start with a number or an alphanumeric identifier (with the under-
    score character included). The following characters (starting after the first whitespace
    character) will form the string which gets associated with the currently selected set and
    the message number represented by the number and identifier respectively.
    If the start of the line is a number the message number is obvious. It is an error if the
    same message number already appeared for this set.


Chapter 8: Message Translation 208

```
If the leading token was an identifier the message number gets automatically assigned.
The value is the current maximum message number for this set plus one. It is an error if
the identifier was already used for a message in this set. It is OK to reuse the identifier
for a message in another thread. How to use the symbolic identifiers will be explained
below (seeSection 8.1.4 [How to use thecatgetsinterface], page 210). There is one
limitation with the identifier: it must not beSet. The reason will be explained below.
The text of the messages can contain escape characters. The usual bunch of characters
known from the ISO C language are recognized (\n,\t,\v,\b,\r,\f,\\, and\nnn,
wherennnis the octal coding of a character code).
```
Important: The handling of identifiers instead of numbers for the set and messages is
a GNU extension. Systems strictly following the X/Open specification do not have this
feature. An example for a message catalog file is this:

```
$ This is a leading comment.
$quote "
```
```
$set SetOne
1 Message with ID 1.
two " Message with ID \"two\", which gets the value 2 assigned"
```
```
$set SetTwo
$ Since the last set got the number 1 assigned this set has number 2.
4000 "The numbers can be arbitrary, they need not start at one."
This small example shows various aspects:
```
- Lines 1 and 9 are comments since they start with$followed by a whitespace.
- The quoting character is set to". Otherwise the quotes in the message definition would
    have to be omitted and in this case the message with the identifiertwowould lose its
    leading whitespace.
- Mixing numbered messages with messages having symbolic names is no problem and
    the numbering happens automatically.

While this file format is pretty easy it is not the best possible for use in a running
program. Thecatopenfunction would have to parse the file and handle syntactic errors
gracefully. This is not so easy and the whole process is pretty slow. Therefore thecatgets
functions expect the data in another more compact and ready-to-use file format. There is
a special programgencatwhich is explained in detail in the next section.

Files in this other format are not human readable. To be easy to use by programs it is a
binary file. But the format is byte order independent so translation files can be shared by
systems of arbitrary architecture (as long as they use the GNU C Library).

Details about the binary file format are not important to know since these files are always
created by thegencatprogram. The sources of the GNU C Library also provide the sources
for thegencatprogram and so the interested reader can look through these source files to
learn about the file format.

## 8.1.3 Generate Message Catalogs files.........................

Thegencatprogram is specified in the X/Open standard and the GNU implementation
follows this specification and so processes all correctly formed input files. Additionally some


Chapter 8: Message Translation 209

extension are implemented which help to work in a more reasonable way with thecatgets
functions.

Thegencatprogram can be invoked in two ways:
`gencat [Option ...] [Output-File [Input-File ...]]`
This is the interface defined in the X/Open standard. If noInput-Fileparameter is
given, input will be read from standard input. Multiple input files will be read as if they
were concatenated. IfOutput-Fileis also missing, the output will be written to standard
output. To provide the interface one is used to from other programs a second interface is
provided.

`gencat [Option...] -oOutput-File[Input-File...]`
The option ¡®-o¡¯ is used to specify the output file and all file arguments are used as input
files.

Beside this one can use-or/dev/stdinforInput-Fileto denote the standard input.
Corresponding one can use-and/dev/stdoutforOutput-Fileto denote standard output.
Using-as a file name is allowed in X/Open while using the device names is a GNU extension.

Thegencatprogram works by concatenating all input files and thenmergingthe result-
ing collection of message sets with a possibly existing output file. This is done by removing
all messages with set/message number tuples matching any of the generated messages from
the output file and then adding all the new messages. To regenerate a catalog file while ig-
noring the old contents therefore requires removing the output file if it exists. If the output
is written to standard output no merging takes place.

The following table shows the options understood by thegencatprogram. The X/Open
standard does not specify any options for the program so all of these are GNU extensions.

¡®-V¡¯
¡®--version¡¯
Print the version information and exit.

¡®-h¡¯
¡®--help¡¯ Print a usage message listing all available options, then exit successfully.

¡®--new¡¯ Do not merge the new messages from the input files with the old content of the
output file. The old content of the output file is discarded.

¡®-H¡¯
¡®--header=name¡¯
This option is used to emit the symbolic names given to sets and messages in
the input files for use in the program. Details about how to use this are given in
the next section. Thenameparameter to this option specifies the name of the
output file. It will contain a number of C preprocessor#defines to associate a
name with a number.
Please note that the generated file only contains the symbols from the input
files. If the output is merged with the previous content of the output file the
possibly existing symbols from the file(s) which generated the old output files
are not in the generated header file.


Chapter 8: Message Translation 210

## 8.1.4 How to use thecatgetsinterface........................

Thecatgetsfunctions can be used in two different ways. By following slavishly the X/Open
specs and not relying on the extension and by using the GNU extensions. We will take a
look at the former method first to understand the benefits of extensions.

## 8.1.4.1 Not using symbolic names..........................

Since the X/Open format of the message catalog files does not allow symbol names we have
to work with numbers all the time. When we start writing a program we have to replace
all appearances of translatable strings with something like
catgets (catdesc, set, msg, "string")

catgetsis retrieved from a call tocatopenwhich is normally done once at the program
start. The"string"is the string we want to translate. The problems start with the set
and message numbers.

In a bigger program several programmers usually work at the same time on the program
and so coordinating the number allocation is crucial. Though no two different strings must
be indexed by the same tuple of numbers it is highly desirable to reuse the numbers for
equal strings with equal translations (please note that there might be strings which are
equal in one language but have different translations due to difference contexts).

The allocation process can be relaxed a bit by different set numbers for different parts
of the program. So the number of developers who have to coordinate the allocation can be
reduced. But still lists must be keep track of the allocation and errors can easily happen.
These errors cannot be discovered by the compiler or thecatgetsfunctions. Only the user
of the program might see wrong messages printed. In the worst cases the messages are
so irritating that they cannot be recognized as wrong. Think about the translations for
"true"and"false"being exchanged. This could result in a disaster.

## 8.1.4.2 Using symbolic names..............................

The problems mentioned in the last section derive from the fact that:

1. the numbers are allocated once and due to the possibly frequent use of them it is
    difficult to change a number later.
2. the numbers do not allow guessing anything about the string and therefore collisions
    can easily happen.

By constantly using symbolic names and by providing a method which maps the string
content to a symbolic name (however this will happen) one can prevent both problems
above. The cost of this is that the programmer has to write a complete message catalog file
while s/he is writing the program itself.

This is necessary since the symbolic names must be mapped to numbers before the
program sources can be compiled. In the last section it was described how to generate a
header containing the mapping of the names. E.g., for the example message file given in
the last section we could call thegencatprogram as follows (assumeex.msgcontains the
sources).
gencat -H ex.h -o ex.cat ex.msg

This generates a header file with the following content:
#define SetTwoSet 0x2 /* ex.msg:8 */


Chapter 8: Message Translation 211

#define SetOneSet 0x1 /* ex.msg:4 */
#define SetOnetwo 0x2 /* ex.msg:6 */
As can be seen the various symbols given in the source file are mangled to generate unique
identifiers and these identifiers get numbers assigned. Reading the source file and knowing
about the rules will allow to predict the content of the header file (it is deterministic) but
this is not necessary. Thegencatprogram can take care for everything. All the programmer
has to do is to put the generated header file in the dependency list of the source files of
her/his project and add a rule to regenerate the header if any of the input files change.

One word about the symbol mangling. Every symbol consists of two parts: the name
of the message set plus the name of the message or the special stringSet. SoSetOnetwo
means this macro can be used to access the translation with identifiertwoin the message
setSetOne.

The other names denote the names of the message sets. The special stringSetis used
in the place of the message identifier.

If in the code the second string of the setSetOneis used the C code should look like
this:
catgets (catdesc, SetOneSet, SetOnetwo,
" Message with ID \"two\", which gets the value 2 assigned")
Writing the function this way will allow to change the message number and even the
set number without requiring any change in the C source code. (The text of the string is
normally not the same; this is only for this example.)

## 8.1.4.3 How does to this allow to develop...................

To illustrate the usual way to work with the symbolic version numbers here is a little
example. Assume we want to write the very complex and famous greeting program. We
start by writing the code as usual:
#include <stdio.h>
int
main (void)
{
printf ("Hello, world!\n");
return 0;
}
Now we want to internationalize the message and therefore replace the message with
whatever the user wants.
#include <nl_types.h>
#include <stdio.h>
#include "msgnrs.h"
int
main (void)
{
nl_catd catdesc = catopen ("hello.cat", NL_CAT_LOCALE);
printf (catgets (catdesc, SetMainSet, SetMainHello,
"Hello, world!\n"));
catclose (catdesc);
return 0;
}
We see how the catalog object is opened and the returned descriptor used in the other
function calls. It is not really necessary to check for failure of any of the functions since


Chapter 8: Message Translation 212

even in these situations the functions will behave reasonable. They simply will be return a
translation.

What remains unspecified here are the constantsSetMainSetandSetMainHello. These
are the symbolic names describing the message. To get the actual definitions which match
the information in the catalog file we have to create the message catalog source file and
process it using thegencatprogram.

```
$ Messages for the famous greeting program.
$quote "
```
```
$set Main
Hello "Hallo, Welt!\n"
```
Now we can start building the program (assume the message catalog source file is named
hello.msgand the program source filehello.c):

```
% gencat -H msgnrs.h -o hello.cat hello.msg
% cat msgnrs.h
#define MainSet 0x1 /* hello.msg:4 */
#define MainHello 0x1 /* hello.msg:5 */
% gcc -o hello hello.c -I.
% cp hello.cat /usr/share/locale/de/LC_MESSAGES
% echo $LC_ALL
de
% ./hello
Hallo, Welt!
%
```
The call of thegencatprogram creates the missing header filemsgnrs.has well as the
message catalog binary. The former is used in the compilation ofhello.cwhile the later is
placed in a directory in which thecatopenfunction will try to locate it. Please check the
LC_ALLenvironment variable and the default path forcatopenpresented in the description
above.

## 8.2 The Uniforum approach to Message Translation...............

Sun Microsystems tried to standardize a different approach to message translation in the
Uniforum group. There never was a real standard defined but still the interface was used
in Sun¡¯s operating systems. Since this approach fits better in the development process of
free software it is also used throughout the GNU project and the GNUgettextpackage
provides support for this outside the GNU C Library.

The code of thelibintlfrom GNUgettextis the same as the code in the GNU C
Library. So the documentation in the GNUgettextmanual is also valid for the functional-
ity here. The following text will describe the library functions in detail. But the numerous
helper programs are not described in this manual. Instead people should read the GNU
gettextmanual (seeSection ¡°GNU gettext utilities¡± inNative Language Support Library
and Tools). We will only give a short overview.

Though thecatgetsfunctions are available by default on more systems thegettext
interface is at least as portable as the former. The GNUgettextpackage can be used
wherever the functions are not available.


Chapter 8: Message Translation 213

## 8.2.1 Thegettextfamily of functions.........................

The paradigms underlying thegettextapproach to message translations is different from
that of thecatgetsfunctions the basic functionally is equivalent. There are functions of
the following categories:

## 8.2.1.1 What has to be done to translate a message?........

Thegettextfunctions have a very simple interface. The most basic function just takes
the string which shall be translated as the argument and it returns the translation. This
is fundamentally different from thecatgetsapproach where an extra key is necessary and
the original string is only used for the error case.

If the string which has to be translated is the only argument this of course means the
string itself is the key. I.e., the translation will be selected based on the original string.
The message catalogs must therefore contain the original strings plus one translation for
any such string. The task of thegettextfunction is to compare the argument string with
the available strings in the catalog and return the appropriate translation. Of course this
process is optimized so that this process is not more expensive than an access using an
atomic key like incatgets.

Thegettextapproach has some advantages but also some disadvantages. Please see
the GNUgettextmanual for a detailed discussion of the pros and cons.

All the definitions and declarations forgettextcan be found in thelibintl.hheader
file. On systems where these functions are not part of the C library they can be found in a
separate library namedlibintl.a(or accordingly different for shared libraries).

char * gettext(const char *msgid) [Function]
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegettextfunction searches the currently selected message catalogs for a string
which is equal tomsgid. If there is such a string available it is returned. Otherwise
the argument stringmsgidis returned.
Please note that although the return value ischar *the returned string must not
be changed. This broken type results from the history of the function and does not
reflect the way the function should be used.
Please note that above we wrote ¡°message catalogs¡± (plural). This is a specialty of
the GNU implementation of these functions and we will say more about this when
we talk about the ways message catalogs are selected (seeSection 8.2.1.2 [How to
determine which catalog to be used], page 215).
Thegettextfunction does not modify the value of the globalerrnovariable. This
is necessary to make it possible to write something like
printf (gettext ("Operation failed: %m\n"));
Here theerrnovalue is used in theprintffunction while processing the%mformat
element and if thegettextfunction would change this value (it is called beforeprintf
is called) we would get a wrong message.
So there is no easy way to detect a missing message catalog besides comparing the
argument string with the result. But it is normally the task of the user to react
on missing catalogs. The program cannot guess when a message catalog is really


Chapter 8: Message Translation 214

```
necessary since for a user who speaks the language the program was developed in, the
message does not need any translation.
```
The remaining two functions to access the message catalog add some functionality to
select a message catalog which is not the default one. This is important if parts of the
program are developed independently. Every part can have its own message catalog and all
of them can be used at the same time. The C library itself is an example: internally it uses
thegettextfunctions but since it must not depend on a currently selected default message
catalog it must specify all ambiguous information.

char * dgettext (const char *domainname, const char *msgid) [Function]
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thedgettextfunction acts just like thegettextfunction. It only takes an additional
first argumentdomainnamewhich guides the selection of the message catalogs which
are searched for the translation. If thedomainnameparameter is the null pointer the
dgettextfunction is exactly equivalent togettextsince the default value for the
domain name is used.
As forgettextthe return value type ischar *which is an anachronism. The returned
string must never be modified.

char * dcgettext (const char *domainname, const char *msgid, int [Function]
category)
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thedcgettextadds another argument to those whichdgettexttakes. This argu-
mentcategoryspecifies the last piece of information needed to localize the message
catalog. I.e., the domain name and the locale category exactly specify which message
catalog has to be used (relative to a given directory, see below).
Thedgettextfunction can be expressed in terms ofdcgettextby using
dcgettext (domain, string, LC_MESSAGES)
instead of
dgettext (domain, string)
This also shows which values are expected for the third parameter. One has to use the
available selectors for the categories available inlocale.h. Normally the available
values areLC_CTYPE,LC_COLLATE,LC_MESSAGES,LC_MONETARY,LC_NUMERIC, andLC_
TIME. Please note thatLC_ALLmust not be used and even though the names might
suggest this, there is no relation to the environment variable of this name.
Thedcgettextfunction is only implemented for compatibility with other systems
which havegettextfunctions. There is not really any situation where it is necessary
(or useful) to use a different value thanLC_MESSAGESfor thecategoryparameter. We
are dealing with messages here and any other choice can only be irritating.
As forgettextthe return value type ischar *which is an anachronism. The returned
string must never be modified.


Chapter 8: Message Translation 215

When using the three functions above in a program it is a frequent case that themsgid
argument is a constant string. So it is worthwhile to optimize this case. Thinking shortly
about this one will realize that as long as no new message catalog is loaded the translation
of a message will not change. This optimization is actually implemented by thegettext,
dgettextanddcgettextfunctions.

## 8.2.1.2 How to determine which catalog to be used.........

The functions to retrieve the translations for a given message have a remarkable simple
interface. But to provide the user of the program still the opportunity to select exactly the
translation s/he wants and also to provide the programmer the possibility to influence the
way to locate the search for catalogs files there is a quite complicated underlying mechanism
which controls all this. The code is complicated the use is easy.

Basically we have two different tasks to perform which can also be performed by the
catgetsfunctions:

1. Locate the set of message catalogs. There are a number of files for different languages
    which all belong to the package. Usually they are all stored in the filesystem below a
    certain directory.
    There can be arbitrarily many packages installed and they can follow different guidelines
    for the placement of their files.
2. Relative to the location specified by the package the actual translation files must be
    searched, based on the wishes of the user. I.e., for each language the user selects the
    program should be able to locate the appropriate file.
This is the functionality required by the specifications forgettextand this is also what
thecatgetsfunctions are able to do. But there are some problems unresolved:
- The language to be used can be specified in several different ways. There is no generally
accepted standard for this and the user always expects the program to understand
what s/he means. E.g., to select the German translation one could writede,german,
ordeutschand the program should always react the same.
- Sometimes the specification of the user is too detailed. If s/he, e.g., specifiesde_
DE.ISO-8859-1which means German, spoken in Germany, coded using the ISO 8859-1
character set there is the possibility that a message catalog matching this exactly is
not available. But there could be a catalog matchingdeand if the character set used
on the machine is always ISO 8859-1 there is no reason why this later message catalog
should not be used. (We call thismessage inheritance.)
- If a catalog for a wanted language is not available it is not always the second best choice
to fall back on the language of the developer and simply not translate any message.
Instead a user might be better able to read the messages in another language and so
the user of the program should be able to define a precedence order of languages.
We can divide the configuration actions in two parts: the one is performed by the
programmer, the other by the user. We will start with the functions the programmer can
use since the user configuration will be based on this.

As the functions described in the last sections already mention separate sets of messages
can be selected by adomain name. This is a simple string which should be unique for each
program part that uses a separate domain. It is possible to use in one program arbitrarily


Chapter 8: Message Translation 216

many domains at the same time. E.g., the GNU C Library itself uses a domain namedlibc
while the program using the C Library could use a domain namedfoo. The important
point is that at any time exactly one domain is active. This is controlled with the following
function.

char * textdomain(const char *domainname) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thetextdomainfunction sets the default domain, which is used in all futuregettext
calls, todomainname. Please note thatdgettextanddcgettextcalls are not influ-
enced if thedomainnameparameter of these functions is not the null pointer.
Before the first call totextdomainthe default domain ismessages. This is the name
specified in the specification of thegettextAPI. This name is as good as any other
name. No program should ever really use a domain with this name since this can
only lead to problems.
The function returns the value which is from now on taken as the default domain. If
the system went out of memory the returned value isNULLand the global variable
errnois set toENOMEM. Despite the return value type beingchar *the return string
must not be changed. It is allocated internally by thetextdomainfunction.
If thedomainnameparameter is the null pointer no new default domain is set. Instead
the currently selected default domain is returned.
If thedomainnameparameter is the empty string the default domain is reset to its
initial value, the domain with the namemessages. This possibility is questionable to
use since the domainmessagesreally never should be used.

char * bindtextdomain(const char *domainname, const char [Function]
*dirname)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thebindtextdomainfunction can be used to specify the directory which contains
the message catalogs for domaindomainnamefor the different languages. To be
correct, this is the directory where the hierarchy of directories is expected. Details
are explained below.
For the programmer it is important to note that the translations which come with the
program have to be placed in a directory hierarchy starting at, say,/foo/bar. Then
the program should make abindtextdomaincall to bind the domain for the current
program to this directory. So it is made sure the catalogs are found. A correctly
running program does not depend on the user setting an environment variable.
Thebindtextdomainfunction can be used several times and if the domainname
argument is different the previously bound domains will not be overwritten.
If the program which wish to usebindtextdomainat some point of time use thechdir
function to change the current working directory it is important that thedirname
strings ought to be an absolute pathname. Otherwise the addressed directory might
vary with the time.
If thedirnameparameter is the null pointerbindtextdomainreturns the currently
selected directory for the domain with the namedomainname.


Chapter 8: Message Translation 217

```
Thebindtextdomainfunction returns a pointer to a string containing the name of
the selected directory name. The string is allocated internally in the function and
must not be changed by the user. If the system went out of core during the execution
ofbindtextdomainthe return value isNULLand the global variableerrnois set
accordingly.
```
## 8.2.1.3 Additional functions for more complicated situations..

The functions of thegettextfamily described so far (and all thecatgetsfunctions as
well) have one problem in the real world which has been neglected completely in all existing
approaches. What is meant here is the handling of plural forms.

Looking through Unix source code before the time anybody thought about internation-
alization (and, sadly, even afterwards) one can often find code similar to the following:
printf ("%d file%s deleted", n, n == 1? "" : "s");

After the first complaints from people internationalizing the code people either completely
avoided formulations like this or used strings like"file(s)". Both look unnatural and
should be avoided. First tries to solve the problem correctly looked like this:
if (n == 1)
printf ("%d file deleted", n);
else
printf ("%d files deleted", n);
But this does not solve the problem. It helps languages where the plural form of a noun
is not simply constructed by adding an ¡®s¡¯ but that is all. Once again people fell into the trap
of believing the rules their language uses are universal. But the handling of plural forms
differs widely between the language families. There are two things we can differ between
(and even inside language families);

- The form how plural forms are build differs. This is a problem with language which
    have many irregularities. German, for instance, is a drastic case. Though English and
    German are part of the same language family (Germanic), the almost regular forming
    of plural noun forms (appending an ¡®s¡¯) is hardly found in German.
- The number of plural forms differ. This is somewhat surprising for those who only have
    experiences with Romanic and Germanic languages since here the number is the same
    (there are two).
    But other language families have only one form or many forms. More information on
    this in an extra section.
The consequence of this is that application writers should not try to solve the problem in
their code. This would be localization since it is only usable for certain, hardcoded language
environments. Instead the extendedgettextinterface should be used.

These extra functions are taking instead of the one key string two strings and a numerical
argument. The idea behind this is that using the numerical argument and the first string
as a key, the implementation can select using rules specified by the translator the right
plural form. The two string arguments then will be used to provide a return value in case
no message catalog is found (similar to the normalgettextbehavior). In this case the
rules for Germanic language are used and it is assumed that the first string argument is the
singular form, the second the plural form.

This has the consequence that programs without language catalogs can display the cor-
rect strings only if the program itself is written using a Germanic language. This is a


Chapter 8: Message Translation 218

limitation but since the GNU C Library (as well as the GNUgettextpackage) is written
as part of the GNU package and the coding standards for the GNU project require programs
to be written in English, this solution nevertheless fulfills its purpose.

char * ngettext (const char *msgid1, const char *msgid2, unsigned [Function]
long intn)
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thengettextfunction is similar to thegettextfunction as it finds the message
catalogs in the same way. But it takes two extra arguments. Themsgid1parameter
must contain the singular form of the string to be converted. It is also used as the
key for the search in the catalog. Themsgid2 parameter is the plural form. The
parameternis used to determine the plural form. If no message catalog is found
msgid1is returned ifn == 1, otherwisemsgid2.
An example for the use of this function is:
printf (ngettext ("%d file removed", "%d files removed", n), n);
Please note that the numeric valuenhas to be passed to theprintffunction as well.
It is not sufficient to pass it only tongettext.

char * dngettext (const char *domain, const char *msgid1, const [Function]
char *msgid2, unsigned long intn)
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thedngettextis similar to thedgettextfunction in the way the message catalog is
selected. The difference is that it takes two extra parameters to provide the correct
plural form. These two parameters are handled in the same wayngettexthandles
them.

char * dcngettext(const char *domain, const char *msgid1, const [Function]
char *msgid2, unsigned long intn, intcategory)
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thedcngettextis similar to thedcgettextfunction in the way the message catalog
is selected. The difference is that it takes two extra parameters to provide the correct
plural form. These two parameters are handled in the same wayngettexthandles
them.

The problem of plural forms

A description of the problem can be found at the beginning of the last section. Now there
is the question how to solve it. Without the input of linguists (which was not available) it
was not possible to determine whether there are only a few different forms in which plural
forms are formed or whether the number can increase with every new supported language.

Therefore the solution implemented is to allow the translator to specify the rules of how
to select the plural form. Since the formula varies with every language this is the only viable
solution except for hardcoding the information in the code (which still would require the
possibility of extensions to not prevent the use of new languages). The details are explained
in the GNUgettextmanual. Here only a bit of information is provided.


Chapter 8: Message Translation 219

The information about the plural form selection has to be stored in the header entry
(the one with the emptymsgidstring). It looks like this:
Plural-Forms: nplurals=2; plural=n == 1? 0 : 1;
Thenpluralsvalue must be a decimal number which specifies how many different
plural forms exist for this language. The string followingpluralis an expression using the
C language syntax. Exceptions are that no negative numbers are allowed, numbers must be
decimal, and the only variable allowed isn. This expression will be evaluated whenever one
of the functionsngettext,dngettext, ordcngettextis called. The numeric value passed
to these functions is then substituted for all uses of the variablenin the expression. The
resulting value then must be greater or equal to zero and smaller than the value given as
the value ofnplurals.

The following rules are known at this point. The language with families are listed. But this
does not necessarily mean the information can be generalized for the whole family (as can
be easily seen in the table below).^1

Only one form:
Some languages only require one single form. There is no distinction between
the singular and plural form. An appropriate header entry would look like this:
Plural-Forms: nplurals=1; plural=0;
Languages with this property include:

```
Finno-Ugric family
Hungarian
Asian family
Japanese, Korean
Turkic/Altaic family
Turkish
```
Two forms, singular used for one only
This is the form used in most existing programs since it is what English uses.
A header entry would look like this:
Plural-Forms: nplurals=2; plural=n != 1;
(Note: this uses the feature of C expressions that boolean expressions have to
value zero or one.)
Languages with this property include:
Germanic family
Danish, Dutch, English, German, Norwegian, Swedish

```
Finno-Ugric family
Estonian, Finnish
Latin/Greek family
Greek
Semitic family
Hebrew
```
(^1) Additions are welcome. Send appropriate information tobug-glibc-manual@gnu.org.


Chapter 8: Message Translation 220

```
Romance family
Italian, Portuguese, Spanish
```
```
Artificial Esperanto
```
Two forms, singular used for zero and one
Exceptional case in the language family. The header entry would be:
Plural-Forms: nplurals=2; plural=n>1;
Languages with this property include:

```
Romanic family
French, Brazilian Portuguese
```
Three forms, special case for zero
The header entry would be:
Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11? 0 : n != 0? 1 : 2;
Languages with this property include:

```
Baltic family
Latvian
```
Three forms, special cases for one and two
The header entry would be:
Plural-Forms: nplurals=3; plural=n==1? 0 : n==2? 1 : 2;
Languages with this property include:

```
Celtic Gaeilge (Irish)
```
Three forms, special case for numbers ending in 1[2-9]
The header entry would look like this:
Plural-Forms: nplurals=3; \
plural=n%10==1 && n%100!=11? 0 : \
n%10>=2 && (n%100<10 || n%100>=20)? 1 : 2;
Languages with this property include:

```
Baltic family
Lithuanian
```
Three forms, special cases for numbers ending in 1 and 2, 3, 4, except those ending in
1[1-4]
The header entry would look like this:
Plural-Forms: nplurals=3; \
plural=n%100/10==1? 2 : n%10==1? 0 : (n+9)%10>3? 2 : 1;
Languages with this property include:

```
Slavic family
Croatian, Czech, Russian, Ukrainian
```
Three forms, special cases for 1 and 2, 3, 4
The header entry would look like this:
Plural-Forms: nplurals=3; \
plural=(n==1)? 1 : (n>=2 && n<=4)? 2 : 0;


Chapter 8: Message Translation 221

```
Languages with this property include:
```
```
Slavic family
Slovak
```
Three forms, special case for one and some numbers ending in 2, 3, or 4
The header entry would look like this:
Plural-Forms: nplurals=3; \
plural=n==1? 0 : \
n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20)? 1 : 2;
Languages with this property include:

```
Slavic family
Polish
```
Four forms, special case for one and all numbers ending in 02, 03, or 04
The header entry would look like this:
Plural-Forms: nplurals=4; \
plural=n%100==1? 0 : n%100==2? 1 : n%100==3 || n%100==4? 2 : 3;
Languages with this property include:

```
Slavic family
Slovenian
```
## 8.2.1.4 How to specify the output character setgettextuses..

gettextnot only looks up a translation in a message catalog, it also converts the translation
on the fly to the desired output character set. This is useful if the user is working in
a different character set than the translator who created the message catalog, because it
avoids distributing variants of message catalogs which differ only in the character set.

The output character set is, by default, the value ofnl_langinfo (CODESET), which
depends on theLC_CTYPEpart of the current locale. But programs which store strings in a
locale independent way (e.g. UTF-8) can request thatgettextand related functions return
the translations in that encoding, by use of thebind_textdomain_codesetfunction.

Note that themsgidargument togettextis not subject to character set conversion.
Also, whengettextdoes not find a translation formsgid, it returnsmsgidunchanged ¨C
independently of the current output character set. It is therefore recommended that all
msgids be US-ASCII strings.

char * bind_textdomain_codeset (const char *domainname, const [Function]
char *codeset)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thebind_textdomain_codesetfunction can be used to specify the output character
set for message catalogs for domaindomainname. Thecodesetargument must be a
valid codeset name which can be used for theiconv_openfunction, or a null pointer.
If thecodesetparameter is the null pointer,bind_textdomain_codesetreturns the
currently selected codeset for the domain with the namedomainname. It returns
NULLif no codeset has yet been selected.


Chapter 8: Message Translation 222

```
Thebind_textdomain_codesetfunction can be used several times. If used multiple
times with the samedomainnameargument, the later call overrides the settings made
by the earlier one.
Thebind_textdomain_codesetfunction returns a pointer to a string containing the
name of the selected codeset. The string is allocated internally in the function and
must not be changed by the user. If the system went out of core during the execution
ofbind_textdomain_codeset, the return value isNULLand the global variableerrno
is set accordingly.
```
## 8.2.1.5 How to usegettextin GUI programs...............

One place where thegettextfunctions, if used normally, have big problems is within
programs with graphical user interfaces (GUIs). The problem is that many of the strings
which have to be translated are very short. They have to appear in pull-down menus
which restricts the length. But strings which are not containing entire sentences or at least
large fragments of a sentence may appear in more than one situation in the program but
might have different translations. This is especially true for the one-word strings which are
frequently used in GUI programs.

As a consequence many people say that thegettextapproach is wrong and instead
catgetsshould be used which indeed does not have this problem. But there is a very
simple and powerful method to handle these kind of problems with thegettextfunctions.

As an example consider the following fictional situation. A GUI program has a menu bar
with the following entries:
+------------+------------+--------------------------------------+
| File | Printer | |
+------------+------------+--------------------------------------+
| Open | | Select |
| New | | Open |
+----------+ | Connect |
+----------+
To have the stringsFile,Printer,Open,New,Select, andConnecttranslated there
has to be at some point in the code a call to a function of thegettextfamily. But in two
places the string passed into the function would beOpen. The translations might not be
the same and therefore we are in the dilemma described above.

One solution to this problem is to artificially extend the strings to make them unambigu-
ous. But what would the program do if no translation is available? The extended string is
not what should be printed. So we should use a slightly modified version of the functions.

To extend the strings a uniform method should be used. E.g., in the example above, the
strings could be chosen as
Menu|File
Menu|Printer
Menu|File|Open
Menu|File|New
Menu|Printer|Select
Menu|Printer|Open
Menu|Printer|Connect
Now all the strings are different and if now instead ofgettextthe following little wrapper
function is used, everything works just fine:
char *


Chapter 8: Message Translation 223

```
sgettext (const char *msgid)
{
char *msgval = gettext (msgid);
if (msgval == msgid)
msgval = strrchr (msgid, '|') + 1;
return msgval;
}
```
What this little function does is to recognize the case when no translation is available.
This can be done very efficiently by a pointer comparison since the return value is the input
value. If there is no translation we know that the input string is in the format we used
for the Menu entries and therefore contains a|character. We simply search for the last
occurrence of this character and return a pointer to the character following it. That¡¯s it!

If one now consistently uses the extended string form and replaces thegettextcalls with
calls tosgettext(this is normally limited to very few places in the GUI implementation)
then it is possible to produce a program which can be internationalized.

With advanced compilers (such as GNU C) one can write thesgettextfunctions as an
inline function or as a macro like this:

```
#define sgettext(msgid) \
({ const char *__msgid = (msgid); \
char *__msgstr = gettext (__msgid); \
if (__msgval == __msgid) \
__msgval = strrchr (__msgid, '|') + 1; \
__msgval; })
```
The othergettextfunctions (dgettext,dcgettextand thengettextequivalents) can
and should have corresponding functions as well which look almost identical, except for the
parameters and the call to the underlying function.

Now there is of course the question why such functions do not exist in the GNU C
Library? There are two parts of the answer to this question.

- They are easy to write and therefore can be provided by the project they are used in.
    This is not an answer by itself and must be seen together with the second part which
    is:
- There is no way the C library can contain a version which can work everywhere. The
    problem is the selection of the character to separate the prefix from the actual string in
    the extended string. The examples above used|which is a quite good choice because
    it resembles a notation frequently used in this context and it also is a character not
    often used in message strings.
    But what if the character is used in message strings. Or if the chose character is not
    available in the character set on the machine one compiles (e.g.,|is not required to exist
    for ISO C; this is why theiso646.hfile exists in ISO C programming environments).

There is only one more comment to make left. The wrapper function above requires
that the translations strings are not extended themselves. This is only logical. There is no
need to disambiguate the strings (since they are never used as keys for a search) and one
also saves quite some memory and disk space by doing this.


Chapter 8: Message Translation 224

## 8.2.1.6 User influence ongettext..........................

The last sections described what the programmer can do to internationalize the messages
of the program. But it is finally up to the user to select the message s/he wants to see.
S/He must understand them.

The POSIX locale model uses the environment variablesLC_COLLATE,LC_CTYPE,LC_
MESSAGES,LC_MONETARY,LC_NUMERIC, andLC_TIMEto select the locale which is to be used.
This way the user can influence lots of functions. As we mentioned above, thegettext
functions also take advantage of this.

To understand how this happens it is necessary to take a look at the various components
of the filename which gets computed to locate a message catalog. It is composed as follows:
dir_name/locale/LC_category/domain_name.mo
The default value fordirnameis system specific. It is computed from the value given
as the prefix while configuring the C library. This value normally is/usror/. For the
former the completedirnameis:
/usr/share/locale
We can use/usr/sharesince the .mofiles containing the message catalogs are sys-
tem independent, so all systems can use the same files. If the program executed the
bindtextdomainfunction for the message domain that is currently handled, thedir_name
component is exactly the value which was given to the function as the second parameter.
I.e.,bindtextdomainallows overwriting the only system dependent and fixed value to make
it possible to address files anywhere in the filesystem.

Thecategoryis the name of the locale category which was selected in the program code.
Forgettextanddgettextthis is alwaysLC_MESSAGES, fordcgettextthis is selected by
the value of the third parameter. As said above it should be avoided to ever use a category
other thanLC_MESSAGES.

The locale component is computed based on the category used. Just like for the
setlocalefunction here comes the user selection into the play. Some environment variables
are examined in a fixed order and the first environment variable set determines the return
value of the lookup process. In detail, for the categoryLC_xxxthe following variables in
this order are examined:

LANGUAGE

LC_ALL

LC_xxx

LANG

This looks very familiar. With the exception of theLANGUAGEenvironment variable this
is exactly the lookup order thesetlocalefunction uses. But why introduce theLANGUAGE
variable?

The reason is that the syntax of the values these variables can have is different to what
is expected by thesetlocalefunction. If we would setLC_ALLto a value following the
extended syntax that would mean thesetlocalefunction will never be able to use the
value of this variable as well. An additional variable removes this problem plus we can
select the language independently of the locale setting which sometimes is useful.


Chapter 8: Message Translation 225

While for theLC_xxxvariables the value should consist of exactly one specification of a
locale theLANGUAGEvariable¡¯s value can consist of a colon separated list of locale names.
The attentive reader will realize that this is the way we manage to implement one of our
additional demands above: we want to be able to specify an ordered list of languages.

Back to the constructed filename we have only one component missing. The
domainnamepart is the name which was either registered using thetextdomainfunction
or which was given todgettextordcgettextas the first parameter. Now it becomes
obvious that a good choice for the domain name in the program code is a string which is
closely related to the program/package name. E.g., for the GNU C Library the domain
name islibc.

A limited piece of example code should show how the program is supposed to work:
{
setlocale (LC_ALL, "");
textdomain ("test-package");
bindtextdomain ("test-package", "/usr/local/share/locale");
puts (gettext ("Hello, world!"));
}
At the program start the default domain ismessages, and the default locale is"C".
Thesetlocalecall sets the locale according to the user¡¯s environment variables; remember
that correct functioning ofgettextrelies on the correct setting of theLC_MESSAGESlocale
(for looking up the message catalog) and of the LC_CTYPElocale (for the character set
conversion). The textdomaincall changes the default domain to test-package. The
bindtextdomaincall specifies that the message catalogs for the domaintest-packagecan
be found below the directory/usr/local/share/locale.

If the user sets in her/his environment the variableLANGUAGEtodethegettextfunction
will try to use the translations from the file
/usr/local/share/locale/de/LC_MESSAGES/test-package.mo
From the above descriptions it should be clear which component of this filename is
determined by which source.

In the above example we assumed theLANGUAGEenvironment variable to bede. This
might be an appropriate selection but what happens if the user wants to useLC_ALLbe-
cause of the wider usability and here the required value isde_DE.ISO-8859-1? We already
mentioned above that a situation like this is not infrequent. E.g., a person might prefer
reading a dialect and if this is not available fall back on the standard language.

Thegettextfunctions know about situations like this and can handle them gracefully.
The functions recognize the format of the value of the environment variable. It can split the
value is different pieces and by leaving out the only or the other part it can construct new
values. This happens of course in a predictable way. To understand this one must know
the format of the environment variable value. There is one more or less standardized form,
originally from the X/Open specification:

```
language[_territory[.codeset]][@modifier]
Less specific locale names will be stripped in the order of the following list:
```
1. codeset
2. normalized codeset
3. territory


Chapter 8: Message Translation 226

4. modifier

Thelanguagefield will never be dropped for obvious reasons.
The only new thing is thenormalized codesetentry. This is another goodie which is
introduced to help reduce the chaos which derives from the inability of people to stan-
dardize the names of character sets. Instead of ISO-8859-1 one can often see 8859-1,
88591, iso8859-1, or iso8859-1. Thenormalized codesetvalue is generated from the
user-provided character set name by applying the following rules:

1. Remove all characters besides numbers and letters.
2. Fold letters to lowercase.
3. If the same only contains digits prepend the string"iso".

So all of the above names will be normalized toiso88591. This allows the program user
much more freedom in choosing the locale name.

Even this extended functionality still does not help to solve the problem that completely
different names can be used to denote the same locale (e.g., deandgerman). To be of
help in this situation the locale implementation and also thegettextfunctions know about
aliases.

The file/usr/share/locale/locale.alias(replace/usrwith whatever prefix you used
for configuring the C library) contains a mapping of alternative names to more regular
names. The system manager is free to add new entries to fill her/his own needs. The
selected locale from the environment is compared with the entries in the first column of this
file ignoring the case. If they match, the value of the second column is used instead for the
further handling.

In the description of the format of the environment variables we already mentioned the
character set as a factor in the selection of the message catalog. In fact, only catalogs which
contain text written using the character set of the system/program can be used (directly;
there will come a solution for this some day). This means for the user that s/he will always
have to take care of this. If in the collection of the message catalogs there are files for the
same language but coded using different character sets the user has to be careful.

## 8.2.2 Programs to handle message catalogs forgettext........

The GNU C Library does not contain the source code for the programs to handle message
catalogs for thegettextfunctions. As part of the GNU project the GNU gettext package
contains everything the developer needs. The functionality provided by the tools in this
package by far exceeds the abilities of thegencatprogram described above for thecatgets
functions.

There is a programmsgfmtwhich is the equivalent program to thegencatprogram. It
generates from the human-readable and -editable form of the message catalog a binary file
which can be used by thegettextfunctions. But there are several more programs available.

Thexgettextprogram can be used to automatically extract the translatable messages
from a source file. I.e., the programmer need not take care of the translations and the list
of messages which have to be translated. S/He will simply wrap the translatable string in
calls togettextet.al and the rest will be done byxgettext. This program has a lot of
options which help to customize the output or help to understand the input better.


Chapter 8: Message Translation 227

Other programs help to manage the development cycle when new messages appear in
the source files or when a new translation of the messages appears. Here it should only
be noted that using all the tools in GNU gettext it is possible tocompletelyautomate the
handling of message catalogs. Besides marking the translatable strings in the source code
and generating the translations the developers do not have anything to do themselves.


### 228

## 9 Searching and Sorting........................

## 9 Searching and Sorting................................

This chapter describes functions for searching and sorting arrays of arbitrary objects. You
pass the appropriate comparison function to be applied as an argument, along with the size
of the objects in the array and the total number of elements.

## 9.1 Defining the Comparison Function............................

In order to use the sorted array library functions, you have to describe how to compare the
elements of the array.

To do this, you supply a comparison function to compare two elements of the array. The
library will call this function, passing as arguments pointers to two array elements to be
compared. Your comparison function should return a value the waystrcmp(seeSection 5.7
[String/Array Comparison], page 113) does: negative if the first argument is ¡°less¡± than
the second, zero if they are ¡°equal¡±, and positive if the first argument is ¡°greater¡±.

Here is an example of a comparison function which works with an array of numbers of
typedouble:
int
compare_doubles (const void *a, const void *b)
{
const double *da = (const double *) a;
const double *db = (const double *) b;

return (*da > *db) - (*da < *db);
}
The header filestdlib.hdefines a name for the data type of comparison functions. This
type is a GNU extension.
int comparison_fn_t (const void *, const void *);

## 9.2 Array Search Function........................................

Generally searching for a specific element in an array means that potentially all elements
must be checked. The GNU C Library contains functions to perform linear search. The
prototypes for the following two functions can be found insearch.h.

void * lfind (const void *key, const void *base, sizet *nmemb, [Function]
sizetsize, comparisonfn tcompar)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelfindfunction searches in the array with*nmembelements ofsizebytes pointed
to bybasefor an element which matches the one pointed to bykey. The function
pointed to bycomparis used to decide whether two elements match.
The return value is a pointer to the matching element in the array starting atbaseif
it is found. If no matching element is availableNULLis returned.
The mean runtime of this function is*nmemb/2. This function should only be used if
elements often get added to or deleted from the array in which case it might not be
useful to sort the array before searching.


Chapter 9: Searching and Sorting 229

void * lsearch(const void *key, void *base, sizet *nmemb, sizet [Function]
size, comparisonfntcompar)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelsearchfunction is similar to thelfindfunction. It searches the given array
for an element and returns it if found. The difference is that if no matching element
is found thelsearchfunction adds the object pointed to bykey(with a size ofsize
bytes) at the end of the array and it increments the value of*nmembto reflect this
addition.
This means for the caller that if it is not sure that the array contains the element one
is searching for the memory allocated for the array starting atbasemust have room
for at leastsizemore bytes. If one is sure the element is in the array it is better to use
lfindso having more room in the array is always necessary when callinglsearch.

To search a sorted array for an element matching the key, use thebsearchfunction.
The prototype for this function is in the header filestdlib.h.

void * bsearch(const void *key, const void *array, size tcount, [Function]
sizetsize, comparisonfn tcompare)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thebsearchfunction searches the sorted arrayarrayfor an object that is equivalent
tokey. The array containscountelements, each of which is of sizesizebytes.
Thecomparefunction is used to perform the comparison. This function is called with
two pointer arguments and should return an integer less than, equal to, or greater
than zero corresponding to whether its first argument is considered less than, equal
to, or greater than its second argument. The elements of thearraymust already be
sorted in ascending order according to this comparison function.
The return value is a pointer to the matching array element, or a null pointer if no
match is found. If the array contains more than one element that matches, the one
that is returned is unspecified.
This function derives its name from the fact that it is implemented using the binary
search algorithm.

## 9.3 Array Sort Function..........................................

To sort an array using an arbitrary comparison function, use theqsortfunction. The
prototype for this function is instdlib.h.

void qsort(void *array, sizetcount, sizetsize, comparisonfnt [Function]
compare)
Preliminary:|MT-Safe|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Theqsortfunction sorts the arrayarray. The array containscountelements, each
of which is of sizesize.
Thecomparefunction is used to perform the comparison on the array elements. This
function is called with two pointer arguments and should return an integer less than,


Chapter 9: Searching and Sorting 230

```
equal to, or greater than zero corresponding to whether its first argument is considered
less than, equal to, or greater than its second argument.
Warning:If two objects compare as equal, their order after sorting is unpredictable.
That is to say, the sorting is not stable. This can make a difference when the compar-
ison considers only part of the elements. Two elements with the same sort key may
differ in other respects.
Although the object addresses passed to the comparison function lie within the array,
they need not correspond with the original locations of those objects because the
sorting algorithm may swap around objects in the array before making some com-
parisons. The only way to perform a stable sort withqsortis to first augment the
objects with a monotonic counter of some kind.
Here is a simple example of sorting an array of doubles in numerical order, using
the comparison function defined above (seeSection 9.1 [Defining the Comparison
Function], page 228):
{
double *array;
int size;
```
```
qsort (array, size, sizeof (double), compare_doubles);
}
Theqsortfunction derives its name from the fact that it was originally implemented
using the ¡°quick sort¡± algorithm.
The implementation ofqsortin this library might not be an in-place sort and might
thereby use an extra amount of memory to store the array.
```
## 9.4 Searching and Sorting Example...............................

Here is an example showing the use ofqsortandbsearchwith an array of structures. The
objects in the array are sorted by comparing theirnamefields with thestrcmpfunction.
Then, we can look up individual objects based on their names.

```
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
```
```
/*Define an array of critters to sort.*/
```
```
struct critter
{
const char *name;
const char *species;
};
```
```
struct critter muppets[] =
{
{"Kermit", "frog"},
{"Piggy", "pig"},
{"Gonzo", "whatever"},
{"Fozzie", "bear"},
{"Sam", "eagle"},
{"Robin", "frog"},
```

Chapter 9: Searching and Sorting 231

```
{"Animal", "animal"},
{"Camilla", "chicken"},
{"Sweetums", "monster"},
{"Dr. Strangepork", "pig"},
{"Link Hogthrob", "pig"},
{"Zoot", "human"},
{"Dr. Bunsen Honeydew", "human"},
{"Beaker", "human"},
{"Swedish Chef", "human"}
};
```
```
int count = sizeof (muppets) / sizeof (struct critter);
```
```
/*This is the comparison function used for sorting and searching.*/
```
```
int
critter_cmp (const void *v1, const void *v2)
{
const struct critter *c1 = v1;
const struct critter *c2 = v2;
```
```
return strcmp (c1->name, c2->name);
}
```
```
/*Print information about a critter.*/
```
```
void
print_critter (const struct critter *c)
{
printf ("%s, the %s\n", c->name, c->species);
}
```
```
/*Do the lookup into the sorted array.*/
```
```
void
find_critter (const char *name)
{
struct critter target, *result;
target.name = name;
result = bsearch (&target, muppets, count, sizeof (struct critter),
critter_cmp);
if (result)
print_critter (result);
else
printf ("Couldn't find %s.\n", name);
}
```
```
/*Main program.*/
```
```
int
main (void)
{
int i;
```

Chapter 9: Searching and Sorting 232

```
for (i = 0; i < count; i++)
print_critter (&muppets[i]);
printf ("\n");
```
```
qsort (muppets, count, sizeof (struct critter), critter_cmp);
```
```
for (i = 0; i < count; i++)
print_critter (&muppets[i]);
printf ("\n");
```
```
find_critter ("Kermit");
find_critter ("Gonzo");
find_critter ("Janice");
```
```
return 0;
}
The output from this program looks like:
Kermit, the frog
Piggy, the pig
Gonzo, the whatever
Fozzie, the bear
Sam, the eagle
Robin, the frog
Animal, the animal
Camilla, the chicken
Sweetums, the monster
Dr. Strangepork, the pig
Link Hogthrob, the pig
Zoot, the human
Dr. Bunsen Honeydew, the human
Beaker, the human
Swedish Chef, the human
```
```
Animal, the animal
Beaker, the human
Camilla, the chicken
Dr. Bunsen Honeydew, the human
Dr. Strangepork, the pig
Fozzie, the bear
Gonzo, the whatever
Kermit, the frog
Link Hogthrob, the pig
Piggy, the pig
Robin, the frog
Sam, the eagle
Swedish Chef, the human
Sweetums, the monster
Zoot, the human
```
```
Kermit, the frog
Gonzo, the whatever
Couldn't find Janice.
```
## 9.5 Thehsearchfunction........................................

The functions mentioned so far in this chapter are for searching in a sorted or unsorted
array. There are other methods to organize information which later should be searched.


Chapter 9: Searching and Sorting 233

The costs of insert, delete and search differ. One possible implementation is using hashing
tables. The following functions are declared in the header filesearch.h.

int hcreate(sizetnel) [Function]
Preliminary:|MT-Unsafe race:hsearch|AS-Unsafe heap|AC-Unsafe corrupt mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thehcreatefunction creates a hashing table which can contain at leastnelelements.
There is no possibility to grow this table so it is necessary to choose the value for
nelwisely. The method used to implement this function might make it necessary to
make the number of elements in the hashing table larger than the expected maximal
number of elements. Hashing tables usually work inefficiently if they are filled 80%
or more. The constant access time guaranteed by hashing can only be achieved if few
collisions exist. See Knuth¡¯s ¡°The Art of Computer Programming, Part 3: Searching
and Sorting¡± for more information.
The weakest aspect of this function is that there can be at most one hashing table
used through the whole program. The table is allocated in local memory out of control
of the programmer. As an extension the GNU C Library provides an additional set
of functions with a reentrant interface which provides a similar interface but which
allows keeping arbitrarily many hashing tables.
It is possible to use more than one hashing table in the program run if the former
table is first destroyed by a call tohdestroy.
The function returns a non-zero value if successful. If it returns zero, something went
wrong. This could either mean there is already a hashing table in use or the program
ran out of memory.

void hdestroy(void) [Function]
Preliminary:|MT-Unsafe race:hsearch|AS-Unsafe heap|AC-Unsafe corrupt mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thehdestroyfunction can be used to free all the resources allocated in a previous
call ofhcreate. After a call to this function it is again possible to callhcreateand
allocate a new table with possibly different size.
It is important to remember that the elements contained in the hashing table at the
timehdestroyis called arenot freed by this function. It is the responsibility of
the program code to free those strings (if necessary at all). Freeing all the element
memory is not possible without extra, separately kept information since there is no
function to iterate through all available elements in the hashing table. If it is really
necessary to free a table and all elements the programmer has to keep a list of all
table elements and before callinghdestroys/he has to free all element¡¯s data using
this list. This is a very unpleasant mechanism and it also shows that this kind of
hashing table is mainly meant for tables which are created once and used until the
end of the program run.

```
Entries of the hashing table and keys for the search are defined using this type:
```
struct ENTRY [Data type]
Both elements of this structure are pointers to zero-terminated strings. This is a
limiting restriction of the functionality of thehsearchfunctions. They can only be


Chapter 9: Searching and Sorting 234

```
used for data sets which use the NUL character always and solely to terminate the
records. It is not possible to handle general binary data.
```
```
char *key Pointer to a zero-terminated string of characters describing the key for
the search or the element in the hashing table.
```
```
char *data
Pointer to a zero-terminated string of characters describing the data.
If the functions will be called only for searching an existing entry this
element might stay undefined since it is not used.
```
ENTRY * hsearch (ENTRYitem, ACTIONaction) [Function]
Preliminary: | MT-Unsafe race:hsearch | AS-Unsafe | AC-Unsafe cor-
rupt/action==ENTER | See Section 1.2.2.1 [POSIX Safety Concepts],
page 2.
To search in a hashing table created usinghcreatethehsearchfunction must be
used. This function can perform a simple search for an element (ifactionhas the value
FIND) or it can alternatively insert the key element into the hashing table. Entries
are never replaced.
The key is denoted by a pointer to an object of typeENTRY. For locating the cor-
responding position in the hashing table only thekeyelement of the structure is
used.
If an entry with a matching key is found theactionparameter is irrelevant. The found
entry is returned. If no matching entry is found and theactionparameter has the
valueFINDthe function returns aNULLpointer. If no entry is found and theaction
parameter has the valueENTERa new entry is added to the hashing table which is
initialized with the parameteritem. A pointer to the newly added entry is returned.

As mentioned before, the hashing table used by the functions described so far is global
and there can be at any time at most one hashing table in the program. A solution is to
use the following functions which are a GNU extension. All have in common that they
operate on a hashing table which is described by the content of an object of the type
struct hsearch_data. This type should be treated as opaque, none of its members should
be changed directly.

int hcreate_r(sizetnel, struct hsearchdata *htab) [Function]
Preliminary:|MT-Safe race:htab|AS-Unsafe heap|AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thehcreate_rfunction initializes the object pointed to byhtabto contain a hashing
table with at leastnelelements. So this function is equivalent to thehcreatefunction
except that the initialized data structure is controlled by the user.
This allows having more than one hashing table at one time. The memory neces-
sary for thestruct hsearch_dataobject can be allocated dynamically. It must be
initialized with zero before calling this function.
The return value is non-zero if the operation was successful. If the return value is
zero, something went wrong, which probably means the program ran out of memory.


Chapter 9: Searching and Sorting 235

void hdestroy_r (struct hsearchdata *htab) [Function]
Preliminary:|MT-Safe race:htab|AS-Unsafe heap|AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thehdestroy_rfunction frees all resources allocated by thehcreate_rfunction for
this very same objecthtab. As forhdestroyit is the program¡¯s responsibility to free
the strings for the elements of the table.

int hsearch_r(ENTRYitem, ACTIONaction, ENTRY **retval, [Function]
struct hsearchdata *htab)
Preliminary:|MT-Safe race:htab|AS-Safe|AC-Unsafe corrupt/action==ENTER
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thehsearch_rfunction is equivalent tohsearch. The meaning of the first two
arguments is identical. But instead of operating on a single global hashing table the
function works on the table described by the object pointed to byhtab(which is
initialized by a call tohcreate_r).
Another difference tohcreateis that the pointer to the found entry in the table is
not the return value of the function. It is returned by storing it in a pointer variable
pointed to by theretvalparameter. The return value of the function is an integer
value indicating success if it is non-zero and failure if it is zero. In the latter case the
global variableerrnosignals the reason for the failure.

```
ENOMEM The table is filled andhsearch_rwas called with a so far unknown key
andactionset toENTER.
```
```
ESRCH Theactionparameter isFINDand no corresponding element is found in
the table.
```
## 9.6 Thetsearchfunction........................................

Another common form to organize data for efficient search is to use trees. Thetsearch
function family provides a nice interface to functions to organize possibly large amounts
of data by providing a mean access time proportional to the logarithm of the number of
elements. The GNU C Library implementation even guarantees that this bound is never
exceeded even for input data which cause problems for simple binary tree implementations.

The functions described in the chapter are all described in the System V and X/Open
specifications and are therefore quite portable.

In contrast to thehsearchfunctions thetsearchfunctions can be used with arbitrary
data and not only zero-terminated strings.

Thetsearchfunctions have the advantage that no function to initialize data structures
is necessary. A simple pointer of typevoid *initialized toNULLis a valid tree and can be
extended or searched. The prototypes for these functions can be found in the header file
search.h.

void * tsearch(const void *key, void **rootp, comparisonfnt [Function]
compar)
Preliminary: |MT-Safe race:rootp|AS-Unsafe heap|AC-Unsafe corrupt mem|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 9: Searching and Sorting 236

```
Thetsearchfunction searches in the tree pointed to by*rootpfor an element match-
ingkey. The function pointed to bycomparis used to determine whether two ele-
ments match. SeeSection 9.1 [Defining the Comparison Function], page 228, for a
specification of the functions which can be used for thecomparparameter.
If the tree does not contain a matching entry thekeyvalue will be added to the tree.
tsearchdoes not make a copy of the object pointed to bykey(how could it since the
size is unknown). Instead it adds a reference to this object which means the object
must be available as long as the tree data structure is used.
The tree is represented by a pointer to a pointer since it is sometimes necessary to
change the root node of the tree. So it must not be assumed that the variable pointed
to byrootphas the same value after the call. This also shows that it is not safe to
call thetsearchfunction more than once at the same time using the same tree. It is
no problem to run it more than once at a time on different trees.
The return value is a pointer to the matching element in the tree. If a new element
was created the pointer points to the new data (which is in factkey). If an entry had
to be created and the program ran out of spaceNULLis returned.
```
void * tfind (const void *key, void *const *rootp, comparison fnt [Function]
compar)
Preliminary:|MT-Safe race:rootp|AS-Safe|AC-Safe|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thetfindfunction is similar to thetsearchfunction. It locates an element matching
the one pointed to bykeyand returns a pointer to this element. But if no matching
element is available no new element is entered (note that therootpparameter points
to a constant pointer). Instead the function returnsNULL.

Another advantage of thetsearchfunctions in contrast to thehsearchfunctions is that
there is an easy way to remove elements.

void * tdelete(const void *key, void **rootp, comparisonfnt [Function]
compar)
Preliminary: |MT-Safe race:rootp|AS-Unsafe heap|AC-Unsafe corrupt mem|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
To remove a specific element matchingkeyfrom the treetdeletecan be used. It
locates the matching element using the same method astfind. The corresponding
element is then removed and a pointer to the parent of the deleted node is returned
by the function. If there is no matching entry in the tree nothing can be deleted and
the function returnsNULL. If the root of the tree is deletedtdeletereturns some
unspecified value not equal toNULL.

void tdestroy(void *vroot, free fntfreefct) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
If the complete search tree has to be removed one can usetdestroy. It frees all
resources allocated by thetsearchfunctions to generate the tree pointed to byvroot.


Chapter 9: Searching and Sorting 237

```
For the data in each tree node the functionfreefctis called. The pointer to the data
is passed as the argument to the function. If no such work is necessaryfreefctmust
point to a function doing nothing. It is called in any case.
This function is a GNU extension and not covered by the System V or X/Open
specifications.
```
In addition to the functions to create and destroy the tree data structure, there is another
function which allows you to apply a function to all elements of the tree. The function must
have this type:
void __action_fn_t (const void *nodep, VISIT value, int level);
Thenodepis the data value of the current node (once given as thekey argument to
tsearch). levelis a numeric value which corresponds to the depth of the current node in
the tree. The root node has the depth 0 and its children have a depth of 1 and so on. The
VISITtype is an enumeration type.

VISIT [Data Type]
TheVISITvalue indicates the status of the current node in the tree and how the
function is called. The status of a node is either ¡®leaf¡¯ or ¡®internal node¡¯. For each
leaf node the function is called exactly once, for each internal node it is called three
times: before the first child is processed, after the first child is processed and after
both children are processed. This makes it possible to handle all three methods of
tree traversal (or even a combination of them).

```
preorder The current node is an internal node and the function is called before the
first child was processed.
postorder
The current node is an internal node and the function is called after the
first child was processed.
```
```
endorder The current node is an internal node and the function is called after the
second child was processed.
leaf The current node is a leaf.
```
void twalk(const void *root, actionfntaction) [Function]
Preliminary:|MT-Safe race:root|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
For each node in the tree with a node pointed to byroot, thetwalkfunction calls
the function provided by the parameteraction. For leaf nodes the function is called
exactly once withvalueset toleaf. For internal nodes the function is called three
times, setting thevalueparameter or actionto the appropriate value. Thelevel
argument for theactionfunction is computed while descending the tree by increasing
the value by one for each descent to a child, starting with the value 0 for the root
node.
Since the functions used for theactionparameter totwalkmust not modify the tree
data, it is safe to runtwalkin more than one thread at the same time, working on
the same tree. It is also safe to calltfindin parallel. Functions which modify the
tree must not be used, otherwise the behavior is undefined. However, it is difficult


Chapter 9: Searching and Sorting 238

```
to pass data external to the tree to the callback function without resorting to global
variables (and thread safety issues), so see thetwalk_rfunction below.
```
void twalk_r (const void *root, void(*action)(const void *key, [Function]
VISITwhich, void *closure), void *closure)
Preliminary:|MT-Safe race:root|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
For each node in the tree with a node pointed to byroot, thetwalk_rfunction calls
the function provided by the parameteraction. For leaf nodes the function is called
exactly once withwhichset toleaf. For internal nodes the function is called three
times, setting thewhichparameter ofactionto the appropriate value. Theclosure
parameter is passed down to each call of theactionfunction, unmodified.
It is possible to implement thetwalkfunction on top of thetwalk_rfunction, which
is why there is no separate level parameter.

```
#include <search.h>
```
```
struct twalk_with_twalk_r_closure
{
void (*action) (const void *, VISIT, int);
int depth;
};
```
```
static void
twalk_with_twalk_r_action (const void *nodep, VISIT which, void *closure0)
{
struct twalk_with_twalk_r_closure *closure = closure0;
```
```
switch (which)
{
case leaf:
closure->action (nodep, which, closure->depth);
break;
case preorder:
closure->action (nodep, which, closure->depth);
++closure->depth;
break;
case postorder:
/*The preorder action incremented the depth.*/
closure->action (nodep, which, closure->depth - 1);
break;
case endorder:
--closure->depth;
closure->action (nodep, which, closure->depth);
break;
}
}
```
```
void
twalk (const void *root, void (*action) (const void *, VISIT, int))
{
struct twalk_with_twalk_r_closure closure = { action, 0 };
twalk_r (root, twalk_with_twalk_r_action, &closure);
}
```

### 239

## 10 Pattern Matching............................

## 10 Pattern Matching...................................

The GNU C Library provides pattern matching facilities for two kinds of patterns: regular
expressions and file-name wildcards. The library also provides a facility for expanding
variable and command references and parsing text into words in the way the shell does.

## 10.1 Wildcard Matching..........................................

This section describes how to match a wildcard pattern against a particular string. The
result is a yes or no answer: does the string fit the pattern or not. The symbols described
here are all declared infnmatch.h.

int fnmatch(const char *pattern, const char *string, intflags) [Function]
Preliminary: | MT-Safe env locale | AS-Unsafe heap |AC-Unsafe mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function tests whether the stringstring matches the patternpattern. It re-
turns 0 if they do match; otherwise, it returns the nonzero valueFNM_NOMATCH. The
argumentspatternandstringare both strings.
The argumentflagsis a combination of flag bits that alter the details of matching.
See below for a list of the defined flags.
In the GNU C Library,fnmatchmight sometimes report ¡°errors¡± by returning nonzero
values that are not equal toFNM_NOMATCH.

```
These are the available flags for theflagsargument:
```
FNM_FILE_NAME
Treat the ¡®/¡¯ character specially, for matching file names. If this flag is set,
wildcard constructs inpatterncannot match ¡®/¡¯ instring. Thus, the only way
to match ¡®/¡¯ is with an explicit ¡®/¡¯ inpattern.

FNM_PATHNAME
This is an alias forFNM_FILE_NAME; it comes from POSIX.2. We don¡¯t recom-
mend this name because we don¡¯t use the term ¡°pathname¡± for file names.

FNM_PERIOD
Treat the ¡®.¡¯ character specially if it appears at the beginning ofstring. If this
flag is set, wildcard constructs inpatterncannot match ¡®.¡¯ as the first character
ofstring.
If you set bothFNM_PERIODandFNM_FILE_NAME, then the special treatment
applies to ¡®.¡¯ following ¡®/¡¯ as well as to ¡®.¡¯ at the beginning ofstring. (The
shell uses theFNM_PERIODandFNM_FILE_NAMEflags together for matching file
names.)

FNM_NOESCAPE
Don¡¯t treat the ¡®\¡¯ character specially in patterns. Normally, ¡®\¡¯ quotes the
following character, turning off its special meaning (if any) so that it matches
only itself. When quoting is enabled, the pattern ¡®\?¡¯ matches only the string
¡®?¡¯, because the question mark in the pattern acts like an ordinary character.
If you useFNM_NOESCAPE, then ¡®\¡¯ is an ordinary character.


Chapter 10: Pattern Matching 240

### FNM_LEADING_DIR

```
Ignore a trailing sequence of characters starting with a ¡®/¡¯ instring; that is to
say, test whetherstringstarts with a directory name thatpatternmatches.
If this flag is set, either ¡®foo*¡¯ or ¡®foobar¡¯ as a pattern would match the string
¡®foobar/frobozz¡¯.
```
FNM_CASEFOLD
Ignore case in comparingstringtopattern.

FNM_EXTMATCH
Besides the normal patterns, also recognize the extended patterns introduced
inksh. The patterns are written in the form explained in the following table
wherepattern-listis a|separated list of patterns.

```
?(pattern-list)
The pattern matches if zero or one occurrences of any of the pat-
terns in thepattern-listallow matching the input string.
```
```
*(pattern-list)
The pattern matches if zero or more occurrences of any of the pat-
terns in thepattern-listallow matching the input string.
```
```
+(pattern-list)
The pattern matches if one or more occurrences of any of the pat-
terns in thepattern-listallow matching the input string.
```
```
@(pattern-list)
The pattern matches if exactly one occurrence of any of the patterns
in thepattern-listallows matching the input string.
```
```
!(pattern-list)
The pattern matches if the input string cannot be matched with
any of the patterns in thepattern-list.
```
## 10.2 Globbing....................................................

The archetypal use of wildcards is for matching against the files in a directory, and making
a list of all the matches. This is calledglobbing.

You could do this usingfnmatch, by reading the directory entries one by one and testing
each one withfnmatch. But that would be slow (and complex, since you would have to
handle subdirectories by hand).

The library provides a functionglobto make this particular use of wildcards convenient.
globand the other symbols in this section are declared inglob.h.

## 10.2.1 Callingglob...........................................

The result of globbing is a vector of file names (strings). To return this vector,globuses a
special data type,glob_t, which is a structure. You passglobthe address of the structure,
and it fills in the structure¡¯s fields to tell you about the results.


Chapter 10: Pattern Matching 241

glob_t [Data Type]
This data type holds a pointer to a word vector. More precisely, it records both the
address of the word vector and its size. The GNU implementation contains some
more fields which are non-standard extensions.

```
gl_pathc The number of elements in the vector, excluding the initial null entries if
the GLOB DOOFFS flag is used (see gloffs below).
gl_pathv The address of the vector. This field has typechar **.
```
```
gl_offs The offset of the first real element of the vector, from its nominal address
in thegl_pathvfield. Unlike the other fields, this is always an input to
glob, rather than an output from it.
If you use a nonzero offset, then that many elements at the beginning
of the vector are left empty. (The globfunction fills them with null
pointers.)
Thegl_offsfield is meaningful only if you use theGLOB_DOOFFSflag.
Otherwise, the offset is always zero regardless of what is in this field, and
the first real element comes at the beginning of the vector.
gl_closedir
The address of an alternative implementation of theclosedirfunction.
It is used if theGLOB_ALTDIRFUNCbit is set in the flag parameter. The
type of this field isvoid (*) (void *).
This is a GNU extension.
gl_readdir
The address of an alternative implementation of the readdir
function used to read the contents of a directory. It is used if the
GLOB_ALTDIRFUNCbit is set in the flag parameter. The type of this field
isstruct dirent *(*) (void *).
An implementation ofgl_readdirneeds to initialize the following mem-
bers of thestruct direntobject:
```
```
d_type This member should be set to the file type of the entry if
it is known. Otherwise, the valueDT_UNKNOWNcan be used.
Theglobfunction may use the specified file type to avoid
callbacks in cases where the file type indicates that the data
is not required.
```
```
d_ino This member needs to be non-zero, otherwiseglobmay skip
the current entry and call thegl_readdircallback function
again to retrieve another entry.
d_name This member must be set to the name of the entry. It must
be null-terminated.
```
```
The example below shows how to allocate astruct direntobject con-
taining a given name.
```
```
#include <dirent.h>
```

Chapter 10: Pattern Matching 242

```
#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
```
```
struct dirent *
mkdirent (const char *name)
{
size_t dirent_size = offsetof (struct dirent, d_name) + 1;
size_t name_length = strlen (name);
size_t total_size = dirent_size + name_length;
if (total_size < dirent_size)
{
errno = ENOMEM;
return NULL;
}
struct dirent *result = malloc (total_size);
if (result == NULL)
return NULL;
result->d_type = DT_UNKNOWN;
result->d_ino = 1; /*Do not skip this entry.*/
memcpy (result->d_name, name, name_length + 1);
return result;
}
Theglobfunction reads thestruct direntmembers listed above and
makes a copy of the file name in thed_namemember immediately after
thegl_readdircallback function returns. Future invocations of any of
the callback functions may dealloacte or reuse the buffer. It is the respon-
sibility of the caller of theglobfunction to allocate and deallocate the
buffer, around the call toglobor using the callback functions. For exam-
ple, an application could allocate the buffer in thegl_readdircallback
function, and deallocate it in thegl_closedircallback function.
Thegl_readdirmember is a GNU extension.
```
```
gl_opendir
The address of an alternative implementation of theopendirfunction.
It is used if theGLOB_ALTDIRFUNCbit is set in the flag parameter. The
type of this field isvoid *(*) (const char *).
This is a GNU extension.
```
```
gl_stat The address of an alternative implementation of thestatfunction to get
information about an object in the filesystem. It is used if theGLOB_
ALTDIRFUNC bit is set in the flag parameter. The type of this field is
int (*) (const char *, struct stat *).
This is a GNU extension.
```
```
gl_lstat The address of an alternative implementation of thelstatfunction to
get information about an object in the filesystems, not following symbolic
links. It is used if theGLOB_ALTDIRFUNCbit is set in the flag parameter.
The type of this field isint (*) (const char *, struct stat *).
This is a GNU extension.
```

Chapter 10: Pattern Matching 243

```
gl_flags The flags used whenglobwas called. In addition,GLOB_MAGCHARmight
be set. SeeSection 10.2.2 [Flags for Globbing], page 245,for more details.
This is a GNU extension.
```
For use in theglob64functionglob.hcontains another definition for a very similar type.
glob64_tdiffers fromglob_tonly in the types of the membersgl_readdir,gl_stat, and
gl_lstat.

glob64_t [Data Type]
This data type holds a pointer to a word vector. More precisely, it records both the
address of the word vector and its size. The GNU implementation contains some
more fields which are non-standard extensions.
gl_pathc The number of elements in the vector, excluding the initial null entries if
the GLOB DOOFFS flag is used (see gloffs below).
gl_pathv The address of the vector. This field has typechar **.
gl_offs The offset of the first real element of the vector, from its nominal address
in thegl_pathvfield. Unlike the other fields, this is always an input to
glob, rather than an output from it.
If you use a nonzero offset, then that many elements at the beginning
of the vector are left empty. (The globfunction fills them with null
pointers.)
Thegl_offsfield is meaningful only if you use theGLOB_DOOFFSflag.
Otherwise, the offset is always zero regardless of what is in this field, and
the first real element comes at the beginning of the vector.
gl_closedir
The address of an alternative implementation of theclosedirfunction.
It is used if theGLOB_ALTDIRFUNCbit is set in the flag parameter. The
type of this field isvoid (*) (void *).
This is a GNU extension.
gl_readdir
The address of an alternative implementation of thereaddir64func-
tion used to read the contents of a directory. It is used if theGLOB_
ALTDIRFUNC bit is set in the flag parameter. The type of this field is
struct dirent64 *(*) (void *).
This is a GNU extension.
gl_opendir
The address of an alternative implementation of theopendirfunction.
It is used if theGLOB_ALTDIRFUNCbit is set in the flag parameter. The
type of this field isvoid *(*) (const char *).
This is a GNU extension.
gl_stat The address of an alternative implementation of thestat64function to
get information about an object in the filesystem. It is used if theGLOB_
ALTDIRFUNC bit is set in the flag parameter. The type of this field is
int (*) (const char *, struct stat64 *).


Chapter 10: Pattern Matching 244

```
This is a GNU extension.
gl_lstat The address of an alternative implementation of thelstat64function to
get information about an object in the filesystems, not following symbolic
links. It is used if theGLOB_ALTDIRFUNCbit is set in the flag parameter.
The type of this field isint (*) (const char *, struct stat64 *).
This is a GNU extension.
gl_flags The flags used whenglobwas called. In addition,GLOB_MAGCHARmight
be set. SeeSection 10.2.2 [Flags for Globbing], page 245,for more details.
This is a GNU extension.
```
int glob (const char *pattern, intflags, int(*errfunc)(const [Function]
char *filename, interror-code), globt *vector-ptr)
Preliminary:|MT-Unsafe race:utent env sig:ALRM timer locale|AS-Unsafe dlopen
plugin corrupt heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The functionglobdoes globbing using the patternpatternin the current directory.
It puts the result in a newly allocated vector, and stores the size and address of
this vector into*vector-ptr. The argumentflagsis a combination of bit flags; see
Section 10.2.2 [Flags for Globbing], page 245, for details of the flags.
The result of globbing is a sequence of file names. The functiongloballocates a string
for each resulting word, then allocates a vector of typechar **to store the addresses
of these strings. The last element of the vector is a null pointer. This vector is called
theword vector.
To return this vector,globstores both its address and its length (number of elements,
not counting the terminating null pointer) into*vector-ptr.
Normally,globsorts the file names alphabetically before returning them. You can
turn this off with the flagGLOB_NOSORTif you want to get the information as fast
as possible. Usually it¡¯s a good idea to letglobsort them¡ªif you process the files
in alphabetical order, the users will have a feel for the rate of progress that your
application is making.
Ifglobsucceeds, it returns 0. Otherwise, it returns one of these error codes:
GLOB_ABORTED
There was an error opening a directory, and you used the flagGLOB_ERR
or your specifiederrfunc returned a nonzero value. See below for an
explanation of theGLOB_ERRflag anderrfunc.
GLOB_NOMATCH
The pattern didn¡¯t match any existing files. If you use theGLOB_NOCHECK
flag, then you never get this error code, because that flag tellsglobto
pretendthat the pattern matched at least one file.
GLOB_NOSPACE
It was impossible to allocate memory to hold the result.
In the event of an error,globstores information in*vector-ptrabout all the matches
it has found so far.


Chapter 10: Pattern Matching 245

```
It is important to notice that theglobfunction will not fail if it encounters directories
or files which cannot be handled without the LFS interfaces. The implementation of
globis supposed to use these functions internally. This at least is the assumption
made by the Unix standard. The GNU extension of allowing the user to provide their
own directory handling andstatfunctions complicates things a bit. If these callback
functions are used and a large file or directory is encounteredglobcanfail.
```
int glob64(const char *pattern, intflags, int(*errfunc)(const [Function]
char *filename, interror-code), glob64t *vector-ptr)
Preliminary:|MT-Unsafe race:utent env sig:ALRM timer locale|AS-Unsafe dlopen
corrupt heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Theglob64function was added as part of the Large File Summit extensions but is not
part of the original LFS proposal. The reason for this is simple: it is not necessary.
The necessity for aglob64function is added by the extensions of the GNUglob
implementation which allows the user to provide their own directory handling and
statfunctions. Thereaddirandstatfunctions do depend on the choice of_FILE_
OFFSET_BITSsince the definition of the typesstruct direntandstruct statwill
change depending on the choice.
Besides this difference,glob64works just likeglobin all aspects.
This function is a GNU extension.

## 10.2.2 Flags for Globbing.....................................

This section describes the standard flags that you can specify in theflagsargument toglob.
Choose the flags you want, and combine them with the C bitwise OR operator|.

Note that there areSection 10.2.3 [More Flags for Globbing], page 246,available as GNU
extensions.

GLOB_APPEND
Append the words from this expansion to the vector of words produced by
previous calls toglob. This way you can effectively expand several words as if
they were concatenated with spaces between them.
In order for appending to work, you must not modify the contents of the word
vector structure between calls toglob. And, if you setGLOB_DOOFFSin the first
call toglob, you must also set it when you append to the results.
Note that the pointer stored ingl_pathvmay no longer be valid after you call
globthe second time, becauseglobmight have relocated the vector. So always
fetchgl_pathvfrom theglob_tstructure after eachglobcall;neversave the
pointer across calls.

GLOB_DOOFFS
Leave blank slots at the beginning of the vector of words. Thegl_offsfield
says how many slots to leave. The blank slots contain null pointers.

GLOB_ERR Give up right away and report an error if there is any difficulty reading the
directories that must be read in order to expandpatternfully. Such difficulties


Chapter 10: Pattern Matching 246

```
might include a directory in which you don¡¯t have the requisite access. Nor-
mally,globtries its best to keep on going despite any errors, reading whatever
directories it can.
You can exercise even more control than this by specifying an error-handler
functionerrfuncwhen you call glob. Iferrfunc is not a null pointer, then
globdoesn¡¯t give up right away when it can¡¯t read a directory; instead, it calls
errfuncwith two arguments, like this:
(*errfunc) (filename,error-code)
The argumentfilenameis the name of the directory thatglobcouldn¡¯t open
or couldn¡¯t read, anderror-codeis theerrnovalue that was reported toglob.
If the error handler function returns nonzero, thenglobgives up right away.
Otherwise, it continues.
```
GLOB_MARK
If the pattern matches the name of a directory, append ¡®/¡¯ to the directory¡¯s
name when returning it.

GLOB_NOCHECK
If the pattern doesn¡¯t match any file names, return the pattern itself as if it
were a file name that had been matched. (Normally, when the pattern doesn¡¯t
match anything,globreturns that there were no matches.)

GLOB_NOESCAPE
Don¡¯t treat the ¡®\¡¯ character specially in patterns. Normally, ¡®\¡¯ quotes the
following character, turning off its special meaning (if any) so that it matches
only itself. When quoting is enabled, the pattern ¡®\?¡¯ matches only the string
¡®?¡¯, because the question mark in the pattern acts like an ordinary character.
If you useGLOB_NOESCAPE, then ¡®\¡¯ is an ordinary character.
globdoes its work by calling the functionfnmatchrepeatedly. It handles the
flagGLOB_NOESCAPEby turning on theFNM_NOESCAPEflag in calls tofnmatch.

GLOB_NOSORT
Don¡¯t sort the file names; return them in no particular order. (In practice, the
order will depend on the order of the entries in the directory.) The only reason
notto sort is to save time.

## 10.2.3 More Flags for Globbing................................

Beside the flags described in the last section, the GNU implementation ofgloballows a
few more flags which are also defined in theglob.hfile. Some of the extensions implement
functionality which is available in modern shell implementations.

GLOB_PERIOD
The.character (period) is treated special. It cannot be matched by wildcards.
SeeSection 10.1 [Wildcard Matching], page 239,FNM_PERIOD.

GLOB_MAGCHAR
TheGLOB_MAGCHARvalue is not to be given toglobin theflagsparameter. In-
stead,globsets this bit in theglflagselement of theglobtstructure provided
as the result if the pattern used for matching contains any wildcard character.


Chapter 10: Pattern Matching 247

### GLOB_ALTDIRFUNC

```
Instead of using the normal functions for accessing the filesystem theglobim-
plementation uses the user-supplied functions specified in the structure pointed
to bypglob parameter. For more information about the functions refer to
the sections about directory handling seeSection 14.2 [Accessing Directories],
page 404, andSection 14.9.2 [Reading the Attributes of a File], page 429.
```
GLOB_BRACE
If this flag is given, the handling of braces in the pattern is changed. It is
now required that braces appear correctly grouped. I.e., for each opening brace
there must be a closing one. Braces can be used recursively. So it is possible
to define one brace expression in another one. It is important to note that
the range of each brace expression is completely contained in the outer brace
expression (if there is one).
The string between the matching braces is separated into single expressions
by splitting at,(comma) characters. The commas themselves are discarded.
Please note what we said above about recursive brace expressions. The commas
used to separate the subexpressions must be at the same level. Commas in brace
subexpressions are not matched. They are used during expansion of the brace
expression of the deeper level. The example below shows this
glob ("{foo/{,bar,biz},baz}", GLOB_BRACE, NULL, &result)
is equivalent to the sequence
glob ("foo/", GLOB_BRACE, NULL, &result)
glob ("foo/bar", GLOB_BRACE|GLOB_APPEND, NULL, &result)
glob ("foo/biz", GLOB_BRACE|GLOB_APPEND, NULL, &result)
glob ("baz", GLOB_BRACE|GLOB_APPEND, NULL, &result)
if we leave aside error handling.

GLOB_NOMAGIC
If the pattern contains no wildcard constructs (it is a literal file name), return
it as the sole ¡°matching¡± word, even if no file exists by that name.

GLOB_TILDE
If this flag is used the character~(tilde) is handled specially if it appears at the
beginning of the pattern. Instead of being taken verbatim it is used to represent
the home directory of a known user.
If~is the only character in pattern or it is followed by a/(slash), the home
directory of the process owner is substituted. Usinggetloginandgetpwnam
the information is read from the system databases. As an example take user
bartwith his home directory at/home/bart. For him a call like
glob ("~/bin/*", GLOB_TILDE, NULL, &result)
would return the contents of the directory/home/bart/bin. Instead of referring
to the own home directory it is also possible to name the home directory of other
users. To do so one has to append the user name after the tilde character. So
the contents of userhomer¡¯sbindirectory can be retrieved by
glob ("~homer/bin/*", GLOB_TILDE, NULL, &result)
If the user name is not valid or the home directory cannot be determined
for some reason the pattern is left untouched and itself used as the result.


Chapter 10: Pattern Matching 248

```
I.e., if in the last examplehomeis not available the tilde expansion yields to
"~homer/bin/*"andglobis not looking for a directory named~homer.
This functionality is equivalent to what is available in C-shells if thenonomatch
flag is set.
```
GLOB_TILDE_CHECK
If this flag is usedglobbehaves as ifGLOB_TILDEis given. The only difference
is that if the user name is not available or the home directory cannot be deter-
mined for other reasons this leads to an error.globwill returnGLOB_NOMATCH
instead of using the pattern itself as the name.
This functionality is equivalent to what is available in C-shells if thenonomatch
flag is not set.

GLOB_ONLYDIR
If this flag is used the globbing function takes this as ahintthat the caller is
only interested in directories matching the pattern. If the information about
the type of the file is easily available non-directories will be rejected but no
extra work will be done to determine the information for each file. I.e., the
caller must still be able to filter directories out.
This functionality is only available with the GNUglobimplementation. It is
mainly used internally to increase the performance but might be useful for a
user as well and therefore is documented here.
Callingglobwill in most cases allocate resources which are used to represent the result
of the function call. If the same object of typeglob_tis used in multiple call toglobthe
resources are freed or reused so that no leaks appear. But this does not include the time
when allglobcalls are done.

void globfree(globt *pglob) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt heap|AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theglobfreefunction frees all resources allocated by previous calls toglobassoci-
ated with the object pointed to bypglob. This function should be called whenever
the currently usedglob_ttyped object isn¡¯t used anymore.

void globfree64 (glob64t *pglob) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt lock|AC-Unsafe corrupt lock fd mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is equivalent toglobfreebut it frees records of typeglob64_twhich
were allocated byglob64.

## 10.3 Regular Expression Matching................................

The GNU C Library supports two interfaces for matching regular expressions. One is the
standard POSIX.2 interface, and the other is what the GNU C Library has had for many
years.

Both interfaces are declared in the header fileregex.h. If you define_POSIX_C_SOURCE,
then only the POSIX.2 functions, structures, and constants are declared.


Chapter 10: Pattern Matching 249

## 10.3.1 POSIX Regular Expression Compilation................

Before you can actually match a regular expression, you mustcompileit. This is not true
compilation¡ªit produces a special data structure, not machine instructions. But it is like
ordinary compilation in that its purpose is to enable you to ¡°execute¡± the pattern fast. (See
Section 10.3.3 [Matching a Compiled POSIX Regular Expression], page 251, for how to use
the compiled regular expression for matching.)

```
There is a special data type for compiled regular expressions:
```
regex_t [Data Type]
This type of object holds a compiled regular expression. It is actually a structure. It
has just one field that your programs should look at:

```
re_nsub This field holds the number of parenthetical subexpressions in the regular
expression that was compiled.
```
```
There are several other fields, but we don¡¯t describe them here, because only the
functions in the library should use them.
```
After you create aregex_tobject, you can compile a regular expression into it by calling
regcomp.

int regcomp(regext *restrictcompiled, const char *restrict [Function]
pattern, intcflags)
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionregcomp¡°compiles¡± a regular expression into a data structure that you
can use withregexecto match against a string. The compiled regular expression
format is designed for efficient matching.regcompstores it into*compiled.
It¡¯s up to you to allocate an object of typeregex_tand pass its address toregcomp.
The argumentcflags lets you specify various options that control the syntax and
semantics of regular expressions. SeeSection 10.3.2 [Flags for POSIX Regular Ex-
pressions], page 250.
If you use the flagREG_NOSUB, thenregcompomits from the compiled regular expres-
sion the information necessary to record how subexpressions actually match. In this
case, you might as well pass 0 for thematchptrandnmatcharguments when you call
regexec.
If you don¡¯t useREG_NOSUB, then the compiled regular expression does have the
capacity to record how subexpressions match. Also,regcomptells you how many
subexpressionspatternhas, by storing the number incompiled->re_nsub. You can
use that value to decide how long an array to allocate to hold information about
subexpression matches.
regcompreturns 0 if it succeeds in compiling the regular expression; otherwise, it
returns a nonzero error code (see the table below). You can useregerrorto produce
an error message string describing the reason for a nonzero value; seeSection 10.3.6
[POSIX Regexp Matching Cleanup], page 253.


Chapter 10: Pattern Matching 250

```
Here are the possible nonzero values thatregcompcan return:
```
REG_BADBR
There was an invalid ¡®\{...\}¡¯ construct in the regular expression. A valid
¡®\{...\}¡¯ construct must contain either a single number, or two numbers in
increasing order separated by a comma.

REG_BADPAT
There was a syntax error in the regular expression.

REG_BADRPT
A repetition operator such as ¡®?¡¯ or ¡®*¡¯ appeared in a bad position (with no
preceding subexpression to act on).

REG_ECOLLATE
The regular expression referred to an invalid collating element (one not defined
in the current locale for string collation). SeeSection 7.3 [Locale Categories],
page 184.

REG_ECTYPE
The regular expression referred to an invalid character class name.

REG_EESCAPE
The regular expression ended with ¡®\¡¯.

REG_ESUBREG
There was an invalid number in the ¡®\digit¡¯ construct.

REG_EBRACK
There were unbalanced square brackets in the regular expression.

REG_EPAREN
An extended regular expression had unbalanced parentheses, or a basic regular
expression had unbalanced ¡®\(¡¯ and ¡®\)¡¯.

REG_EBRACE
The regular expression had unbalanced ¡®\{¡¯ and ¡®\}¡¯.

REG_ERANGE
One of the endpoints in a range expression was invalid.

REG_ESPACE
regcompran out of memory.

## 10.3.2 Flags for POSIX Regular Expressions...................

These are the bit flags that you can use in thecflagsoperand when compiling a regular
expression withregcomp.

REG_EXTENDED
Treat the pattern as an extended regular expression, rather than as a basic
regular expression.

REG_ICASE
Ignore case when matching letters.


Chapter 10: Pattern Matching 251

### REG_NOSUB

```
Don¡¯t bother storing the contents of thematchptrarray.
```
REG_NEWLINE
Treat a newline instringas dividingstringinto multiple lines, so that ¡®$¡¯ can
match before the newline and ¡®^¡¯ can match after. Also, don¡¯t permit ¡®.¡¯ to
match a newline, and don¡¯t permit ¡®[^...]¡¯ to match a newline.
Otherwise, newline acts like any other ordinary character.

## 10.3.3 Matching a Compiled POSIX Regular Expression.......

Once you have compiled a regular expression, as described inSection 10.3.1 [POSIX Regular
Expression Compilation], page 249, you can match it against strings usingregexec. A
match anywhere inside the string counts as success, unless the regular expression contains
anchor characters (¡®^¡¯ or ¡®$¡¯).

int regexec(const regext *restrictcompiled, const char *restrict [Function]
string, size tnmatch, regmatch tmatchptr[restrict], inteflags)
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function tries to match the compiled regular expression*compiledagainststring.
regexecreturns 0 if the regular expression matches; otherwise, it returns a nonzero
value. See the table below for what nonzero values mean. You can useregerror
to produce an error message string describing the reason for a nonzero value; see
Section 10.3.6 [POSIX Regexp Matching Cleanup], page 253.
The argumenteflagsis a word of bit flags that enable various options.
If you want to get information about what part ofstringactually matched the regular
expression or its subexpressions, use the argumentsmatchptrandnmatch. Otherwise,
pass 0 fornmatch, andNULLformatchptr. SeeSection 10.3.4 [Match Results with
Subexpressions], page 252.

You must match the regular expression with the same set of current locales that were in
effect when you compiled the regular expression.

```
The functionregexecaccepts the following flags in theeflagsargument:
```
REG_NOTBOL
Do not regard the beginning of the specified string as the beginning of a line;
more generally, don¡¯t make any assumptions about what text might precede it.

REG_NOTEOL
Do not regard the end of the specified string as the end of a line; more generally,
don¡¯t make any assumptions about what text might follow it.
Here are the possible nonzero values thatregexeccan return:

REG_NOMATCH
The pattern didn¡¯t match the string. This isn¡¯t really an error.

REG_ESPACE
regexecran out of memory.


Chapter 10: Pattern Matching 252

## 10.3.4 Match Results with Subexpressions.....................

Whenregexecmatches parenthetical subexpressions ofpattern, it records which parts of
stringthey match. It returns that information by storing the offsets into an array whose
elements are structures of typeregmatch_t. The first element of the array (index 0 ) records
the part of the string that matched the entire regular expression. Each other element of
the array records the beginning and end of the part that matched a single parenthetical
subexpression.

regmatch_t [Data Type]
This is the data type of thematchptr array that you pass toregexec. It contains
two structure fields, as follows:

```
rm_so The offset instring of the beginning of a substring. Add this value to
stringto get the address of that part.
```
```
rm_eo The offset instringof the end of the substring.
```
regoff_t [Data Type]
regoff_tis an alias for another signed integer type. The fields ofregmatch_thave
typeregoff_t.

Theregmatch_telements correspond to subexpressions positionally; the first element
(index 1 ) records where the first subexpression matched, the second element records the
second subexpression, and so on. The order of the subexpressions is the order in which they
begin.

When you callregexec, you specify how long thematchptrarray is, with thenmatch
argument. This tellsregexechow many elements to store. If the actual regular expression
has more thannmatchsubexpressions, then you won¡¯t get offset information about the rest
of them. But this doesn¡¯t alter whether the pattern matches a particular string or not.

If you don¡¯t wantregexecto return any information about where the subexpressions
matched, you can either supply 0 fornmatch, or use the flagREG_NOSUBwhen you compile
the pattern withregcomp.

## 10.3.5 Complications in Subexpression Matching...............

Sometimes a subexpression matches a substring of no characters. This happens when
¡®f\(o*\)¡¯ matches the string ¡®fum¡¯. (It really matches just the ¡®f¡¯.) In this case, both
of the offsets identify the point in the string where the null substring was found. In this
example, the offsets are both 1.

Sometimes the entire regular expression can match without using some of its subex-
pressions at all¡ªfor example, when ¡®ba\(na\)*¡¯ matches the string ¡®ba¡¯, the parenthetical
subexpression is not used. When this happens,regexecstores -1in both fields of the
element for that subexpression.

Sometimes matching the entire regular expression can match a particular subexpression
more than once¡ªfor example, when ¡®ba\(na\)*¡¯ matches the string ¡®bananana¡¯, the par-
enthetical subexpression matches three times. When this happens,regexecusually stores
the offsets of the last part of the string that matched the subexpression. In the case of
¡®bananana¡¯, these offsets are 6 and 8.


Chapter 10: Pattern Matching 253

But the last match is not always the one that is chosen. It¡¯s more accurate to say that
the lastopportunityto match is the one that takes precedence. What this means is that
when one subexpression appears within another, then the results reported for the inner
subexpression reflect whatever happened on the last match of the outer subexpression. For
an example, consider ¡®\(ba\(na\)*s \)*¡¯ matching the string ¡®bananas bas¡¯. The last
time the inner expression actually matches is near the end of the first word. But it is
consideredagain in the second word, and fails to match there.regexecreports nonuse of
the ¡°na¡± subexpression.

```
Another place where this rule applies is when the regular expression
\(ba\(na\)*s \|nefer\(ti\)* \)*
```
matches ¡®bananas nefertiti¡¯. The ¡°na¡± subexpression does match in the first word, but it
doesn¡¯t match in the second word because the other alternative is used there. Once again,
the second repetition of the outer subexpression overrides the first, and within that second
repetition, the ¡°na¡± subexpression is not used. Soregexecreports nonuse of the ¡°na¡±
subexpression.

## 10.3.6 POSIX Regexp Matching Cleanup......................

When you are finished using a compiled regular expression, you can free the storage it uses
by callingregfree.

void regfree (regext *compiled) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Callingregfreefrees all the storage that*compiledpoints to. This includes various
internal fields of theregex_tstructure that aren¡¯t documented in this manual.
regfreedoes not free the object*compileditself.

You should always free the space in aregex_tstructure withregfreebefore using the
structure to compile another regular expression.

Whenregcomporregexecreports an error, you can use the functionregerrorto turn
it into an error message string.

size_t regerror (interrcode, const regext *restrictcompiled, [Function]
char *restrictbuffer, sizetlength)
Preliminary: |MT-Safe env|AS-Unsafe corrupt heap lock dlopen |AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function produces an error message string for the error codeerrcode, and stores
the string inlengthbytes of memory starting atbuffer. For thecompiledargument,
supply the same compiled regular expression structure thatregcomporregexecwas
working with when it got the error. Alternatively, you can supplyNULLforcompiled;
you will still get a meaningful error message, but it might not be as detailed.
If the error message can¡¯t fit inlengthbytes (including a terminating null character),
thenregerrortruncates it. The string thatregerrorstores is always null-terminated
even if it has been truncated.
The return value ofregerroris the minimum length needed to store the entire error
message. If this is less thanlength, then the error message was not truncated, and
you can use it. Otherwise, you should callregerroragain with a larger buffer.


Chapter 10: Pattern Matching 254

```
Here is a function which usesregerror, but always dynamically allocates a buffer for
the error message:
char *get_regerror (int errcode, regex_t *compiled)
{
size_t length = regerror (errcode, compiled, NULL, 0);
char *buffer = xmalloc (length);
(void) regerror (errcode, compiled, buffer, length);
return buffer;
}
```
## 10.4 Shell-Style Word Expansion.................................

Word expansionmeans the process of splitting a string intowordsand substituting for
variables, commands, and wildcards just as the shell does.

For example, when you write ¡®ls -l foo.c¡¯, this string is split into three separate
words¡ª¡®ls¡¯, ¡®-l¡¯ and ¡®foo.c¡¯. This is the most basic function of word expansion.

When you write ¡®ls *.c¡¯, this can become many words, because the word ¡®*.c¡¯ can be
replaced with any number of file names. This is calledwildcard expansion, and it is also a
part of word expansion.

When you use ¡®echo $PATH¡¯ to print your path, you are taking advantage ofvariable
substitution, which is also part of word expansion.

Ordinary programs can perform word expansion just like the shell by calling the library
functionwordexp.

## 10.4.1 The Stages of Word Expansion.........................

When word expansion is applied to a sequence of words, it performs the following transfor-
mations in the order shown here:

1. Tilde expansion: Replacement of ¡®~foo¡¯ with the name of the home directory of ¡®foo¡¯.
2. Next, three different transformations are applied in the same step, from left to right:
    - Variable substitution: Environment variables are substituted for references such
       as ¡®$foo¡¯.
    - Command substitution: Constructs such as ¡®`cat foo`¡¯ and the equivalent
       ¡®$(cat foo)¡¯ are replaced with the output from the inner command.
    - Arithmetic expansion: Constructs such as ¡®$(($x-1))¡¯ are replaced with the result
       of the arithmetic computation.
3. Field splitting: subdivision of the text intowords.
4. Wildcard expansion: The replacement of a construct such as ¡®*.c¡¯ with a list of ¡®.c¡¯
    file names. Wildcard expansion applies to an entire word at a time, and replaces that
    word with 0 or more file names that are themselves words.
5. Quote removal: The deletion of string-quotes, now that they have done their job by
    inhibiting the above transformations when appropriate.

For the details of these transformations, and how to write the constructs that use them,
seeThe BASH Manual(to appear).


Chapter 10: Pattern Matching 255

## 10.4.2 Callingwordexp........................................

All the functions, constants and data types for word expansion are declared in the header
filewordexp.h.

Word expansion produces a vector of words (strings). To return this vector,wordexp
uses a special data type,wordexp_t, which is a structure. You passwordexpthe address
of the structure, and it fills in the structure¡¯s fields to tell you about the results.

wordexp_t [Data Type]
This data type holds a pointer to a word vector. More precisely, it records both the
address of the word vector and its size.

```
we_wordc The number of elements in the vector.
```
```
we_wordv The address of the vector. This field has typechar **.
```
```
we_offs The offset of the first real element of the vector, from its nominal address
in thewe_wordvfield. Unlike the other fields, this is always an input to
wordexp, rather than an output from it.
If you use a nonzero offset, then that many elements at the beginning
of the vector are left empty. (Thewordexpfunction fills them with null
pointers.)
Thewe_offsfield is meaningful only if you use theWRDE_DOOFFSflag.
Otherwise, the offset is always zero regardless of what is in this field, and
the first real element comes at the beginning of the vector.
```
int wordexp(const char *words, wordexpt *word-vector-ptr, int [Function]
flags)
Preliminary: |MT-Unsafe race:utent const:env env sig:ALRM timer locale|AS-
Unsafe dlopen plugin i18n heap corrupt lock|AC-Unsafe corrupt lock fd mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Perform word expansion on the stringwords, putting the result in a newly allocated
vector, and store the size and address of this vector into*word-vector-ptr. The
argumentflagsis a combination of bit flags; seeSection 10.4.3 [Flags for Word Ex-
pansion], page 256, for details of the flags.
You shouldn¡¯t use any of the characters ¡®|&;<>¡¯ in the stringwordsunless they are
quoted; likewise for newline. If you use these characters unquoted, you will get the
WRDE_BADCHARerror code. Don¡¯t use parentheses or braces unless they are quoted
or part of a word expansion construct. If you use quotation characters ¡®'"`¡¯, they
should come in pairs that balance.
The results of word expansion are a sequence of words. The functionwordexpallocates
a string for each resulting word, then allocates a vector of typechar **to store the
addresses of these strings. The last element of the vector is a null pointer. This vector
is called theword vector.
To return this vector, wordexpstores both its address and its length (number of
elements, not counting the terminating null pointer) into*word-vector-ptr.
Ifwordexpsucceeds, it returns 0. Otherwise, it returns one of these error codes:


Chapter 10: Pattern Matching 256

### WRDE_BADCHAR

```
The input stringwordscontains an unquoted invalid character such as
¡®|¡¯.
```
```
WRDE_BADVAL
The input string refers to an undefined shell variable, and you used the
flagWRDE_UNDEFto forbid such references.
```
```
WRDE_CMDSUB
The input string uses command substitution, and you used the flagWRDE_
NOCMDto forbid command substitution.
```
```
WRDE_NOSPACE
It was impossible to allocate memory to hold the result. In this case,
wordexpcan store part of the results¡ªas much as it could allocate room
for.
```
```
WRDE_SYNTAX
There was a syntax error in the input string. For example, an unmatched
quoting character is a syntax error. This error code is also used to signal
division by zero and overflow in arithmetic expansion.
```
void wordfree(wordexpt *word-vector-ptr) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt heap|AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Free the storage used for the word-strings and vector that*word-vector-ptrpoints
to. This does not free the structure*word-vector-ptritself¡ªonly the other data it
points to.

## 10.4.3 Flags for Word Expansion..............................

This section describes the flags that you can specify in theflagsargument towordexp.
Choose the flags you want, and combine them with the C operator|.

WRDE_APPEND
Append the words from this expansion to the vector of words produced by
previous calls towordexp. This way you can effectively expand several words
as if they were concatenated with spaces between them.
In order for appending to work, you must not modify the contents of the word
vector structure between calls towordexp. And, if you setWRDE_DOOFFSin the
first call towordexp, you must also set it when you append to the results.

WRDE_DOOFFS
Leave blank slots at the beginning of the vector of words. Thewe_offsfield
says how many slots to leave. The blank slots contain null pointers.

WRDE_NOCMD
Don¡¯t do command substitution; if the input requests command substitution,
report an error.


Chapter 10: Pattern Matching 257

### WRDE_REUSE

```
Reuse a word vector made by a previous call towordexp. Instead of allocating
a new vector of words, this call towordexpwill use the vector that already
exists (making it larger if necessary).
Note that the vector may move, so it is not safe to save an old pointer and use
it again after callingwordexp. You must fetchwe_pathvanew after each call.
```
WRDE_SHOWERR
Do show any error messages printed by commands run by command substi-
tution. More precisely, allow these commands to inherit the standard error
output stream of the current process. By default,wordexpgives these com-
mands a standard error stream that discards all output.

WRDE_UNDEF
If the input refers to a shell variable that is not defined, report an error.

10.4.4 wordexpExample

Here is an example of usingwordexpto expand several strings and use the results to run a
shell command. It also shows the use ofWRDE_APPENDto concatenate the expansions and
ofwordfreeto free the space allocated bywordexp.
int
expand_and_execute (const char *program, const char **options)
{
wordexp_t result;
pid_t pid
int status, i;

```
/*Expand the string for the program to run. */
switch (wordexp (program, &result, 0))
{
case 0: /*Successful. */
break;
case WRDE_NOSPACE:
/*If the error wasWRDE_NOSPACE,
then perhaps part of the result was allocated. */
wordfree (&result);
default: /*Some other error. */
return -1;
}
```
```
/*Expand the strings specified for the arguments. */
for (i = 0; options[i] != NULL; i++)
{
if (wordexp (options[i], &result, WRDE_APPEND))
{
wordfree (&result);
return -1;
}
}
```
```
pid = fork ();
if (pid == 0)
{
/*This is the child process. Execute the command.*/
execv (result.we_wordv[0], result.we_wordv);
```

Chapter 10: Pattern Matching 258

```
exit (EXIT_FAILURE);
}
else if (pid < 0)
/*The fork failed. Report failure. */
status = -1;
else
/*This is the parent process. Wait for the child to complete. */
if (waitpid (pid, &status, 0) != pid)
status = -1;
```
```
wordfree (&result);
return status;
}
```
## 10.4.5 Details of Tilde Expansion..............................

It¡¯s a standard part of shell syntax that you can use ¡®~¡¯ at the beginning of a file name to
stand for your own home directory. You can use ¡®~user¡¯ to stand foruser¡¯s home directory.

Tilde expansionis the process of converting these abbreviations to the directory names
that they stand for.

Tilde expansion applies to the ¡®~¡¯ plus all following characters up to whitespace or a
slash. It takes place only at the beginning of a word, and only if none of the characters to
be transformed is quoted in any way.

Plain ¡®~¡¯ uses the value of the environment variableHOMEas the proper home directory
name. ¡®~¡¯ followed by a user name usesgetpwnameto look up that user in the user database,
and uses whatever directory is recorded there. Thus, ¡®~¡¯ followed by your own name can
give different results from plain ¡®~¡¯, if the value ofHOMEis not really your home directory.

## 10.4.6 Details of Variable Substitution.........................

Part of ordinary shell syntax is the use of ¡®$variable¡¯ to substitute the value of a shell
variable into a command. This is calledvariable substitution, and it is one part of doing
word expansion.

```
There are two basic ways you can write a variable reference for substitution:
```
${variable}
If you write braces around the variable name, then it is completely unambiguous
where the variable name ends. You can concatenate additional letters onto the
end of the variable value by writing them immediately after the close brace.
For example, ¡®${foo}s¡¯ expands into ¡®tractors¡¯.

$variable
If you do not put braces around the variable name, then the variable name
consists of all the alphanumeric characters and underscores that follow the ¡®$¡¯.
The next punctuation character ends the variable name. Thus, ¡®$foo-bar¡¯
refers to the variablefooand expands into ¡®tractor-bar¡¯.
When you use braces, you can also use various constructs to modify the value that is
substituted, or test it in various ways.

${variable:-default}
Substitute the value ofvariable, but if that is empty or undefined, usedefault
instead.


Chapter 10: Pattern Matching 259

${variable:=default}
Substitute the value ofvariable, but if that is empty or undefined, usedefault
instead and set the variable todefault.

${variable:?message}
Ifvariableis defined and not empty, substitute its value.
Otherwise, printmessageas an error message on the standard error stream,
and consider word expansion a failure.

${variable:+replacement}
Substitutereplacement, but only ifvariableis defined and nonempty. Other-
wise, substitute nothing for this construct.

${#variable}
Substitute a numeral which expresses in base ten the number of characters
in the value ofvariable. ¡®${#foo}¡¯ stands for ¡® 7 ¡¯, because ¡®tractor¡¯ is seven
characters.
These variants of variable substitution let you remove part of the variable¡¯s value before
substituting it. Theprefixandsuffixare not mere strings; they are wildcard patterns, just
like the patterns that you use to match multiple file names. But in this context, they match
against parts of the variable value rather than against file names.

${variable%%suffix}
Substitute the value ofvariable, but first discard from that variable any portion
at the end that matches the patternsuffix.
If there is more than one alternative for how to match againstsuffix, this con-
struct uses the longest possible match.
Thus, ¡®${foo%%r*}¡¯ substitutes ¡®t¡¯, because the largest match for ¡®r*¡¯ at the
end of ¡®tractor¡¯ is ¡®ractor¡¯.

${variable%suffix}
Substitute the value ofvariable, but first discard from that variable any portion
at the end that matches the patternsuffix.
If there is more than one alternative for how to match againstsuffix, this con-
struct uses the shortest possible alternative.
Thus, ¡®${foo%r*}¡¯ substitutes ¡®tracto¡¯, because the shortest match for ¡®r*¡¯ at
the end of ¡®tractor¡¯ is just ¡®r¡¯.

${variable##prefix}
Substitute the value ofvariable, but first discard from that variable any portion
at the beginning that matches the patternprefix.
If there is more than one alternative for how to match againstprefix, this
construct uses the longest possible match.
Thus, ¡®${foo##*t}¡¯ substitutes ¡®or¡¯, because the largest match for ¡®*t¡¯ at the
beginning of ¡®tractor¡¯ is ¡®tract¡¯.

${variable#prefix}
Substitute the value ofvariable, but first discard from that variable any portion
at the beginning that matches the patternprefix.


Chapter 10: Pattern Matching 260

```
If there is more than one alternative for how to match againstprefix, this
construct uses the shortest possible alternative.
Thus, ¡®${foo#*t}¡¯ substitutes ¡®ractor¡¯, because the shortest match for ¡®*t¡¯ at
the beginning of ¡®tractor¡¯ is just ¡®t¡¯.
```

### 261

## 11 Input/Output Overview....................

## 11 Input/Output Overview..............................

Most programs need to do either input (reading data) or output (writing data), or most
frequently both, in order to do anything useful. The GNU C Library provides such a large
selection of input and output functions that the hardest part is often deciding which function
is most appropriate!

This chapter introduces concepts and terminology relating to input and output. Other
chapters relating to the GNU I/O facilities are:

- Chapter 12 [Input/Output on Streams], page 266, which covers the high-level functions
    that operate on streams, including formatted input and output.
- Chapter 13 [Low-Level Input/Output], page 342, which covers the basic I/O and control
    functions on file descriptors.
- Chapter 14 [File System Interface], page 402, which covers functions for operating on
    directories and for manipulating file attributes such as access modes and ownership.
- Chapter 15 [Pipes and FIFOs], page 450, which includes information on the basic
    interprocess communication facilities.
- Chapter 16 [Sockets], page 455, which covers a more complicated interprocess commu-
    nication facility with support for networking.
- Chapter 17 [Low-Level Terminal Interface], page 503, which covers functions for chang-
    ing how input and output to terminals or other serial devices are processed.

## 11.1 Input/Output Concepts.....................................

Before you can read or write the contents of a file, you must establish a connection or
communications channel to the file. This process is calledopeningthe file. You can open
a file for reading, writing, or both.

The connection to an open file is represented either as a stream or as a file descriptor.
You pass this as an argument to the functions that do the actual read or write operations,
to tell them which file to operate on. Certain functions expect streams, and others are
designed to operate on file descriptors.

When you have finished reading to or writing from the file, you can terminate the
connection byclosingthe file. Once you have closed a stream or file descriptor, you cannot
do any more input or output operations on it.

## 11.1.1 Streams and File Descriptors...........................

When you want to do input or output to a file, you have a choice of two basic mechanisms for
representing the connection between your program and the file: file descriptors and streams.
File descriptors are represented as objects of typeint, while streams are represented asFILE
*objects.

File descriptors provide a primitive, low-level interface to input and output operations.
Both file descriptors and streams can represent a connection to a device (such as a terminal),
or a pipe or socket for communicating with another process, as well as a normal file. But,
if you want to do control operations that are specific to a particular kind of device, you
must use a file descriptor; there are no facilities to use streams in this way. You must also


Chapter 11: Input/Output Overview 262

use file descriptors if your program needs to do input or output in special modes, such as
nonblocking (or polled) input (seeSection 13.15 [File Status Flags], page 387).

Streams provide a higher-level interface, layered on top of the primitive file descriptor
facilities. The stream interface treats all kinds of files pretty much alike¡ªthe sole exception
being the three styles of buffering that you can choose (seeSection 12.20 [Stream Buffering],
page 328).

The main advantage of using the stream interface is that the set of functions for per-
forming actual input and output operations (as opposed to control operations) on streams is
much richer and more powerful than the corresponding facilities for file descriptors. The file
descriptor interface provides only simple functions for transferring blocks of characters, but
the stream interface also provides powerful formatted input and output functions (printf
andscanf) as well as functions for character- and line-oriented input and output.

Since streams are implemented in terms of file descriptors, you can extract the file de-
scriptor from a stream and perform low-level operations directly on the file descriptor. You
can also initially open a connection as a file descriptor and then make a stream associated
with that file descriptor.

In general, you should stick with using streams rather than file descriptors, unless there
is some specific operation you want to do that can only be done on a file descriptor. If
you are a beginning programmer and aren¡¯t sure what functions to use, we suggest that
you concentrate on the formatted input functions (seeSection 12.14 [Formatted Input],
page 311) and formatted output functions (seeSection 12.12 [Formatted Output], page 288).

If you are concerned about portability of your programs to systems other than GNU, you
should also be aware that file descriptors are not as portable as streams. You can expect
any system running ISO C to support streams, but non-GNU systems may not support file
descriptors at all, or may only implement a subset of the GNU functions that operate on
file descriptors. Most of the file descriptor functions in the GNU C Library are included in
the POSIX.1 standard, however.

## 11.1.2 File Position...........................................

One of the attributes of an open file is itsfile positionthat keeps track of where in the file
the next character is to be read or written. On GNU systems, and all POSIX.1 systems,
the file position is simply an integer representing the number of bytes from the beginning
of the file.

The file position is normally set to the beginning of the file when it is opened, and each
time a character is read or written, the file position is incremented. In other words, access
to the file is normallysequential.

Ordinary files permit read or write operations at any position within the file. Some other
kinds of files may also permit this. Files which do permit this are sometimes referred to as
random-accessfiles. You can change the file position using thefseekfunction on a stream
(seeSection 12.18 [File Positioning], page 323) or thelseekfunction on a file descriptor
(seeSection 13.2 [Input and Output Primitives], page 345). If you try to change the file
position on a file that doesn¡¯t support random access, you get theESPIPEerror.

Streams and descriptors that are opened forappend accessare treated specially for
output: output to such files isalwaysappended sequentially to theendof the file, regardless


Chapter 11: Input/Output Overview 263

of the file position. However, the file position is still used to control where in the file reading
is done.

If you think about it, you¡¯ll realize that several programs can read a given file at the same
time. In order for each program to be able to read the file at its own pace, each program
must have its own file pointer, which is not affected by anything the other programs do.

In fact, each opening of a file creates a separate file position. Thus, if you open a file
twice even in the same program, you get two streams or descriptors with independent file
positions.

By contrast, if you open a descriptor and then duplicate it to get another descriptor,
these two descriptors share the same file position: changing the file position of one descriptor
will affect the other.

## 11.2 File Names..................................................

In order to open a connection to a file, or to perform other operations such as deleting a file,
you need some way to refer to the file. Nearly all files have names that are strings¡ªeven
files which are actually devices such as tape drives or terminals. These strings are called
file names. You specify the file name to say which file you want to open or operate on.

This section describes the conventions for file names and how the operating system works
with them.

## 11.2.1 Directories.............................................

In order to understand the syntax of file names, you need to understand how the file system
is organized into a hierarchy of directories.

Adirectoryis a file that contains information to associate other files with names; these
associations are calledlinks ordirectory entries. Sometimes, people speak of ¡°files in a
directory¡±, but in reality, a directory only contains pointers to files, not the files themselves.

The name of a file contained in a directory entry is called afile name component. In
general, a file name consists of a sequence of one or more such components, separated by
the slash character (¡®/¡¯). A file name which is just one component names a file with respect
to its directory. A file name with multiple components names a directory, and then a file
in that directory, and so on.

Some other documents, such as the POSIX standard, use the termpathnamefor what
we call a file name, and eitherfilename orpathname componentfor what this manual
calls a file name component. We don¡¯t use this terminology because a ¡°path¡± is something
completely different (a list of directories to search), and we think that ¡°pathname¡± used for
something else will confuse users. We always use ¡°file name¡± and ¡°file name component¡±
(or sometimes just ¡°component¡±, where the context is obvious) in GNU documentation.
Some macros use the POSIX terminology in their names, such asPATH_MAX. These macros
are defined by the POSIX standard, so we cannot change their names.

You can find more detailed information about operations on directories inChapter 14
[File System Interface], page 402.


Chapter 11: Input/Output Overview 264

## 11.2.2 File Name Resolution...................................

A file name consists of file name components separated by slash (¡®/¡¯) characters. On the
systems that the GNU C Library supports, multiple successive ¡®/¡¯ characters are equivalent
to a single ¡®/¡¯ character.

The process of determining what file a file name refers to is calledfile name resolution.
This is performed by examining the components that make up a file name in left-to-right
order, and locating each successive component in the directory named by the previous
component. Of course, each of the files that are referenced as directories must actually
exist, be directories instead of regular files, and have the appropriate permissions to be
accessible by the process; otherwise the file name resolution fails.

If a file name begins with a ¡®/¡¯, the first component in the file name is located in theroot
directoryof the process (usually all processes on the system have the same root directory).
Such a file name is called anabsolute file name.

Otherwise, the first component in the file name is located in the current working directory
(seeSection 14.1 [Working Directory], page 402). This kind of file name is called arelative
file name.

The file name components.(¡°dot¡±) and..(¡°dot-dot¡±) have special meanings. Every
directory has entries for these file name components. The file name component.refers to
the directory itself, while the file name component..refers to itsparent directory (the
directory that contains the link for the directory in question). As a special case,..in the
root directory refers to the root directory itself, since it has no parent; thus/..is the same
as/.

```
Here are some examples of file names:
```
/a The file nameda, in the root directory.

/a/b The file namedb, in the directory namedain the root directory.

a The file nameda, in the current working directory.

/a/./b This is the same as/a/b.

./a The file nameda, in the current working directory.

../a The file nameda, in the parent directory of the current working directory.

A file name that names a directory may optionally end in a ¡®/¡¯. You can specify a file
name of/to refer to the root directory, but the empty string is not a meaningful file name.
If you want to refer to the current working directory, use a file name of.or./.

Unlike some other operating systems, GNU systems don¡¯t have any built-in support for
file types (or extensions) or file versions as part of its file name syntax. Many programs and
utilities use conventions for file names¡ªfor example, files containing C source code usually
have names suffixed with ¡®.c¡¯¡ªbut there is nothing in the file system itself that enforces
this kind of convention.

## 11.2.3 File Name Errors.......................................

Functions that accept file name arguments usually detect theseerrnoerror conditions
relating to the file name syntax or trouble finding the named file. These errors are referred
to throughout this manual as theusual file name errors.


Chapter 11: Input/Output Overview 265

EACCES The process does not have search permission for a directory component of the
file name.

ENAMETOOLONG
This error is used when either the total length of a file name is greater than
PATH_MAX, or when an individual file name component has a length greater than
NAME_MAX. SeeSection 32.6 [Limits on File System Capacity], page 903.
On GNU/Hurd systems, there is no imposed limit on overall file name length,
but some file systems may place limits on the length of a component.

ENOENT This error is reported when a file referenced as a directory component in the
file name doesn¡¯t exist, or when a component is a symbolic link whose target
file does not exist. SeeSection 14.5 [Symbolic Links], page 419.

ENOTDIR A file that is referenced as a directory component in the file name exists, but
it isn¡¯t a directory.

ELOOP Too many symbolic links were resolved while trying to look up the file name.
The system has an arbitrary limit on the number of symbolic links that may
be resolved in looking up a single file name, as a primitive way to detect loops.
SeeSection 14.5 [Symbolic Links], page 419.

## 11.2.4 Portability of File Names...............................

The rules for the syntax of file names discussed inSection 11.2 [File Names], page 263, are
the rules normally used by GNU systems and by other POSIX systems. However, other
operating systems may use other conventions.

There are two reasons why it can be important for you to be aware of file name portability
issues:

- If your program makes assumptions about file name syntax, or contains embedded
    literal file name strings, it is more difficult to get it to run under other operating
    systems that use different syntax conventions.
- Even if you are not concerned about running your program on machines that run other
    operating systems, it may still be possible to access files that use different naming
    conventions. For example, you may be able to access file systems on another computer
    running a different operating system over a network, or read and write disks in formats
    used by other operating systems.

The ISO C standard says very little about file name syntax, only that file names are
strings. In addition to varying restrictions on the length of file names and what characters
can validly appear in a file name, different operating systems use different conventions
and syntax for concepts such as structured directories and file types or extensions. Some
concepts such as file versions might be supported in some operating systems and not by
others.

The POSIX.1 standard allows implementations to put additional restrictions on file name
syntax, concerning what characters are permitted in file names and on the length of file
name and file name component strings. However, on GNU systems, any character except
the null character is permitted in a file name string, and on GNU/Hurd systems there are
no limits on the length of file name strings.


### 266

## 12 Input/Output on Streams..................

## 12 Input/Output on Streams.............................

This chapter describes the functions for creating streams and performing input and output
operations on them. As discussed inChapter 11 [Input/Output Overview], page 261, a
stream is a fairly abstract, high-level concept representing a communications channel to a
file, device, or process.

## 12.1 Streams.....................................................

For historical reasons, the type of the C data structure that represents a stream is called
FILErather than ¡°stream¡±. Since most of the library functions deal with objects of type
FILE *, sometimes the term file pointer is also used to mean ¡°stream¡±. This leads to
unfortunate confusion over terminology in many books on C. This manual, however, is
careful to use the terms ¡°file¡± and ¡°stream¡± only in the technical sense.

```
TheFILEtype is declared in the header filestdio.h.
```
FILE [Data Type]
This is the data type used to represent stream objects. AFILEobject holds all of the
internal state information about the connection to the associated file, including such
things as the file position indicator and buffering information. Each stream also has
error and end-of-file status indicators that can be tested with theferrorandfeof
functions; seeSection 12.15 [End-Of-File and Errors], page 320.

FILEobjects are allocated and managed internally by the input/output library functions.
Don¡¯t try to create your own objects of typeFILE; let the library do it. Your programs
should deal only with pointers to these objects (that is,FILE *values) rather than the
objects themselves.

## 12.2 Standard Streams...........................................

When themainfunction of your program is invoked, it already has three predefined streams
open and available for use. These represent the ¡°standard¡± input and output channels that
have been established for the process.

```
These streams are declared in the header filestdio.h.
```
FILE * stdin [Variable]
Thestandard inputstream, which is the normal source of input for the program.

FILE * stdout [Variable]
Thestandard outputstream, which is used for normal output from the program.

FILE * stderr [Variable]
Thestandard errorstream, which is used for error messages and diagnostics issued
by the program.

On GNU systems, you can specify what files or processes correspond to these streams
using the pipe and redirection facilities provided by the shell. (The primitives shells use to
implement these facilities are described inChapter 14 [File System Interface], page 402.)


Chapter 12: Input/Output on Streams 267

Most other operating systems provide similar mechanisms, but the details of how to use
them can vary.

In the GNU C Library,stdin,stdout, andstderrare normal variables which you can
set just like any others. For example, to redirect the standard output to a file, you could
do:
fclose (stdout);
stdout = fopen ("standard-output-file", "w");
Note however, that in other systemsstdin,stdout, andstderrare macros that you
cannot assign to in the normal way. But you can usefreopento get the effect of closing
one and reopening it. SeeSection 12.3 [Opening Streams], page 267.

The three streamsstdin,stdout, andstderrare not unoriented at program start (see
Section 12.6 [Streams in Internationalized Applications], page 275).

## 12.3 Opening Streams............................................

Opening a file with thefopenfunction creates a new stream and establishes a connection
between the stream and a file. This may involve creating a new file.

```
Everything described in this section is declared in the header filestdio.h.
```
FILE * fopen (const char *filename, const char *opentype) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe mem fd lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefopenfunction opens a stream for I/O to the filefilename, and returns a pointer
to the stream.
Theopentypeargument is a string that controls how the file is opened and specifies
attributes of the resulting stream. It must begin with one of the following sequences
of characters:

```
¡®r¡¯ Open an existing file for reading only.
¡®w¡¯ Open the file for writing only. If the file already exists, it is truncated to
zero length. Otherwise a new file is created.
¡®a¡¯ Open a file for append access; that is, writing at the end of file only. If
the file already exists, its initial contents are unchanged and output to
the stream is appended to the end of the file. Otherwise, a new, empty
file is created.
¡®r+¡¯ Open an existing file for both reading and writing. The initial contents
of the file are unchanged and the initial file position is at the beginning
of the file.
¡®w+¡¯ Open a file for both reading and writing. If the file already exists, it is
truncated to zero length. Otherwise, a new file is created.
¡®a+¡¯ Open or create file for both reading and appending. If the file exists,
its initial contents are unchanged. Otherwise, a new file is created. The
initial file position for reading is at the beginning of the file, but output
is always appended to the end of the file.
```

Chapter 12: Input/Output on Streams 268

```
As you can see, ¡®+¡¯ requests a stream that can do both input and output. When using
such a stream, you must callfflush(seeSection 12.20 [Stream Buffering], page 328)
or a file positioning function such asfseek(see Section 12.18 [File Positioning],
page 323) when switching from reading to writing or vice versa. Otherwise, internal
buffers might not be emptied properly.
Additional characters may appear after these to specify flags for the call. Always
put the mode (¡®r¡¯, ¡®w+¡¯, etc.) first; that is the only part you are guaranteed will be
understood by all systems.
The GNU C Library defines additional characters for use inopentype:
```
```
¡®c¡¯ The file is opened with cancellation in the I/O functions disabled.
```
```
¡®e¡¯ The underlying file descriptor will be closed if you use any of theexec...
functions (seeSection 26.5 [Executing a File], page 806). (This is equiva-
lent to having setFD_CLOEXECon that descriptor. SeeSection 13.14 [File
Descriptor Flags], page 386.)
```
```
¡®m¡¯ The file is opened and accessed usingmmap. This is only supported with
files opened for reading.
```
```
¡®x¡¯ Insist on creating a new file¡ªif a filefilenamealready exists,fopenfails
rather than opening it. If you use ¡®x¡¯ you are guaranteed that you will not
clobber an existing file. This is equivalent to theO_EXCLoption to the
openfunction (seeSection 13.1 [Opening and Closing Files], page 342).
The ¡®x¡¯ modifier is part of ISO C11, which says the file is created with
exclusive access; in the GNU C Library this means the equivalent ofO_
EXCL.
```
```
The character ¡®b¡¯ inopentype has a standard meaning; it requests a binary stream
rather than a text stream. But this makes no difference in POSIX systems (including
GNU systems). If both ¡®+¡¯ and ¡®b¡¯ are specified, they can appear in either order. See
Section 12.17 [Text and Binary Streams], page 322.
If theopentypestring contains the sequence,ccs=STRINGthenSTRINGis taken as
the name of a coded character set andfopenwill mark the stream as wide-oriented
with appropriate conversion functions in place to convert from and to the character
setSTRING. Any other stream is opened initially unoriented and the orientation is
decided with the first file operation. If the first operation is a wide character operation,
the stream is not only marked as wide-oriented, also the conversion functions to
convert to the coded character set used for the current locale are loaded. This will
not change anymore from this point on even if the locale selected for theLC_CTYPE
category is changed.
Any other characters inopentype are simply ignored. They may be meaningful in
other systems.
If the open fails,fopenreturns a null pointer.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bit machine
this function is in factfopen64since the LFS interface replaces transparently the old
interface.
```

Chapter 12: Input/Output on Streams 269

You can have multiple streams (or file descriptors) pointing to the same file open at the
same time. If you do only input, this works straightforwardly, but you must be careful if any
output streams are included. SeeSection 13.5 [Dangers of Mixing Streams and Descriptors],
page 353. This is equally true whether the streams are in one program (not usual) or in
several programs (which can easily happen). It may be advantageous to use the file locking
facilities to avoid simultaneous access. SeeSection 13.16 [File Locks], page 393.

FILE * fopen64(const char *filename, const char *opentype) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe mem fd lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofopenbut the stream it returns a pointer for is opened
usingopen64. Therefore this stream can be used even on files larger than 2^31 bytes
on 32 bit machines.
Please note that the return type is stillFILE *. There is no specialFILEtype for the
LFS interface.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the namefopenand so transparently replaces the old
interface.

int FOPEN_MAX [Macro]
The value of this macro is an integer constant expression that represents the minimum
number of streams that the implementation guarantees can be open simultaneously.
You might be able to open more than this many streams, but that is not guaranteed.
The value of this constant is at least eight, which includes the three standard streams
stdin,stdout, andstderr. In POSIX.1 systems this value is determined by the
OPEN_MAXparameter; seeSection 32.1 [General Capacity Limits], page 890. In BSD
and GNU, it is controlled by theRLIMIT_NOFILEresource limit; see Section 22.2
[Limiting Resource Usage], page 685.

FILE * freopen(const char *filename, const char *opentype, [Function]
FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt fd | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is like a combination offcloseandfopen. It first closes the stream
referred to bystream, ignoring any errors that are detected in the process. (Because
errors are ignored, you should not usefreopenon an output stream if you have
actually done any output using the stream.) Then the file named byfilename is
opened with modeopentypeas forfopen, and associated with the same stream object
stream.
If the operation fails, a null pointer is returned; otherwise,freopenreturnsstream.
On Linux,freopenmay also fail and seterrnotoEBUSYwhen the kernel structure
for the old file descriptor was not initialized completely beforefreopenwas called.
This can only happen in multi-threaded programs, when two threads race to allocate
the same file descriptor number. To avoid the possibility of this race, do not use
closeto close the underlying file descriptor for aFILE; either usefreopenwhile the
file is still open, or useopenand thendup2to install the new file descriptor.


Chapter 12: Input/Output on Streams 270

```
freopenhas traditionally been used to connect a standard stream such asstdinwith
a file of your own choice. This is useful in programs in which use of a standard stream
for certain purposes is hard-coded. In the GNU C Library, you can simply close the
standard streams and open new ones withfopen. But other systems lack this ability,
so usingfreopenis more portable.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bit machine
this function is in factfreopen64since the LFS interface replaces transparently the
old interface.
```
FILE * freopen64 (const char *filename, const char *opentype, [Function]
FILE *stream)
Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt fd | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofreopen. The only difference is that on 32 bit machine the
stream returned is able to read beyond the 2^31 bytes limits imposed by the normal
interface. It should be noted that the stream pointed to bystreamneed not be opened
usingfopen64orfreopen64since its mode is not important for this function.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the namefreopenand so transparently replaces the old
interface.

In some situations it is useful to know whether a given stream is available for reading
or writing. This information is normally not available and would have to be remembered
separately. Solaris introduced a few functions to get this information from the stream
descriptor and these functions are also available in the GNU C Library.

int __freadable (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The__freadablefunction determines whether the streamstream was opened to
allow reading. In this case the return value is nonzero. For write-only streams the
function returns zero.
This function is declared instdio_ext.h.

int __fwritable (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The__fwritablefunction determines whether the streamstream was opened to
allow writing. In this case the return value is nonzero. For read-only streams the
function returns zero.
This function is declared instdio_ext.h.

For slightly different kinds of problems there are two more functions. They provide even
finer-grained information.

int __freading(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 12: Input/Output on Streams 271

```
The__freadingfunction determines whether the streamstreamwas last read from
or whether it is opened read-only. In this case the return value is nonzero, otherwise it
is zero. Determining whether a stream opened for reading and writing was last used
for writing allows to draw conclusions about the content about the buffer, among
other things.
This function is declared instdio_ext.h.
```
int __fwriting(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The__fwritingfunction determines whether the streamstreamwas last written to
or whether it is opened write-only. In this case the return value is nonzero, otherwise
it is zero.
This function is declared instdio_ext.h.

## 12.4 Closing Streams.............................................

When a stream is closed withfclose, the connection between the stream and the file is
canceled. After you have closed a stream, you cannot perform any additional operations on
it.

int fclose(FILE *stream) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe lock mem fd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function causesstreamto be closed and the connection to the corresponding file
to be broken. Any buffered output is written and any buffered input is discarded.
Thefclosefunction returns a value of 0 if the file was closed successfully, andEOF
if an error was detected.
It is important to check for errors when you callfcloseto close an output stream,
because real, everyday errors can be detected at this time. For example, whenfclose
writes the remaining buffered output, it might get an error because the disk is full.
Even if you know the buffer is empty, errors can still occur when closing a file if you
are using NFS.
The functionfcloseis declared instdio.h.

```
To close all streams currently available the GNU C Library provides another function.
```
int fcloseall(void) [Function]
Preliminary:|MT-Unsafe race:streams|AS-Unsafe|AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function causes all open streams of the process to be closed and the connections
to corresponding files to be broken. All buffered data is written and any buffered
input is discarded. Thefcloseallfunction returns a value of 0 if all the files were
closed successfully, andEOFif an error was detected.
This function should be used only in special situations, e.g., when an error occurred
and the program must be aborted. Normally each single stream should be closed


Chapter 12: Input/Output on Streams 272

```
separately so that problems with individual streams can be identified. It is also prob-
lematic since the standard streams (seeSection 12.2 [Standard Streams], page 266)
will also be closed.
The functionfcloseallis declared instdio.h.
```
If themainfunction to your program returns, or if you call theexitfunction (see
Section 25.7.1 [Normal Termination], page 799), all open streams are automatically closed
properly. If your program terminates in any other manner, such as by calling theabort
function (seeSection 25.7.4 [Aborting a Program], page 801) or from a fatal signal (see
Chapter 24 [Signal Handling], page 714), open streams might not be closed properly.
Buffered output might not be flushed and files may be incomplete. For more information
on buffering of streams, seeSection 12.20 [Stream Buffering], page 328.

## 12.5 Streams and Threads........................................

Streams can be used in multi-threaded applications in the same way they are used in single-
threaded applications. But the programmer must be aware of the possible complications.
It is important to know about these also if the program one writes never use threads since
the design and implementation of many stream functions are heavily influenced by the
requirements added by multi-threaded programming.

The POSIX standard requires that by default the stream operations are atomic. I.e.,
issuing two stream operations for the same stream in two threads at the same time will cause
the operations to be executed as if they were issued sequentially. The buffer operations
performed while reading or writing are protected from other uses of the same stream. To
do this each stream has an internal lock object which has to be (implicitly) acquired before
any work can be done.

But there are situations where this is not enough and there are also situations where
this is not wanted. The implicit locking is not enough if the program requires more than
one stream function call to happen atomically. One example would be if an output line a
program wants to generate is created by several function calls. The functions by themselves
would ensure only atomicity of their own operation, but not atomicity over all the function
calls. For this it is necessary to perform the stream locking in the application code.

void flockfile(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
The flockfile function acquires the internal locking object associated with
the stream stream. This ensures that no other thread can explicitly through
flockfile/ftrylockfileor implicitly through the call of a stream function lock
the stream. The thread will block until the lock is acquired. An explicit call to
funlockfilehas to be used to release the lock.

int ftrylockfile (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Theftrylockfilefunction tries to acquire the internal locking object associated
with the streamstream just likeflockfile. But unlike flockfilethis function


Chapter 12: Input/Output on Streams 273

```
does not block if the lock is not available.ftrylockfilereturns zero if the lock was
successfully acquired. Otherwise the stream is locked by another thread.
```
void funlockfile (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thefunlockfilefunction releases the internal locking object of the streamstream.
The stream must have been locked before by a call toflockfileor a successful call
offtrylockfile. The implicit locking performed by the stream operations do not
count. Thefunlockfilefunction does not return an error status and the behavior
of a call for a stream which is not locked by the current thread is undefined.

The following example shows how the functions above can be used to generate an output
line atomically even in multi-threaded applications (yes, the same job could be done with
onefprintfcall but it is sometimes not possible):
FILE *fp;
{
...
flockfile (fp);
fputs ("This is test number ", fp);
fprintf (fp, "%d\n", test);
funlockfile (fp)
}
Without the explicit locking it would be possible for another thread to use the streamfp
after thefputscall returns and beforefprintfwas called with the result that the number
does not follow the word ¡®number¡¯.

From this description it might already be clear that the locking objects in streams are
no simple mutexes. Since locking the same stream twice in the same thread is allowed the
locking objects must be equivalent to recursive mutexes. These mutexes keep track of the
owner and the number of times the lock is acquired. The same number offunlockfile
calls by the same threads is necessary to unlock the stream completely. For instance:
void
foo (FILE *fp)
{
ftrylockfile (fp);
fputs ("in foo\n", fp);
/*This is very wrong!!! */
funlockfile (fp);
}
It is important here that thefunlockfilefunction is only called if theftrylockfile
function succeeded in locking the stream. It is therefore always wrong to ignore the result
offtrylockfile. And it makes no sense since otherwise one would useflockfile. The
result of code like that above is that eitherfunlockfiletries to free a stream that hasn¡¯t
been locked by the current thread or it frees the stream prematurely. The code should look
like this:
void
foo (FILE *fp)
{
if (ftrylockfile (fp) == 0)
{


Chapter 12: Input/Output on Streams 274

fputs ("in foo\n", fp);
funlockfile (fp);
}
}
Now that we covered why it is necessary to have locking it is necessary to talk about
situations when locking is unwanted and what can be done. The locking operations (explicit
or implicit) don¡¯t come for free. Even if a lock is not taken the cost is not zero. The
operations which have to be performed require memory operations that are safe in multi-
processor environments. With the many local caches involved in such systems this is quite
costly. So it is best to avoid the locking completely if it is not needed ¨C because the code in
question is never used in a context where two or more threads may use a stream at a time.
This can be determined most of the time for application code; for library code which can
be used in many contexts one should default to be conservative and use locking.

There are two basic mechanisms to avoid locking. The first is to use the_unlocked
variants of the stream operations. The POSIX standard defines quite a few of those and
the GNU C Library adds a few more. These variants of the functions behave just like
the functions with the name without the suffix except that they do not lock the stream.
Using these functions is very desirable since they are potentially much faster. This is
not only because the locking operation itself is avoided. More importantly, functions like
putcandgetcare very simple and traditionally (before the introduction of threads) were
implemented as macros which are very fast if the buffer is not empty. With the addition of
locking requirements these functions are no longer implemented as macros since they would
expand to too much code. But these macros are still available with the same functionality
under the new namesputc_unlockedandgetc_unlocked. This possibly huge difference
of speed also suggests the use of the_unlockedfunctions even if locking is required. The
difference is that the locking then has to be performed in the program:

void
foo (FILE *fp, char *buf)
{
flockfile (fp);
while (*buf != '/')
putc_unlocked (*buf++, fp);
funlockfile (fp);
}
If in this example theputcfunction would be used and the explicit locking would be
missing theputcfunction would have to acquire the lock in every call, potentially many
times depending on when the loop terminates. Writing it the way illustrated above allows
theputc_unlockedmacro to be used which means no locking and direct manipulation of
the buffer of the stream.

A second way to avoid locking is by using a non-standard function which was introduced
in Solaris and is available in the GNU C Library as well.

int __fsetlocking(FILE *stream, inttype) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe lock|AC-Safe|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The__fsetlockingfunction can be used to select whether the stream operations will
implicitly acquire the locking object of the streamstream. By default this is done but


Chapter 12: Input/Output on Streams 275

```
it can be disabled and reinstated using this function. There are three values defined
for thetypeparameter.
FSETLOCKING_INTERNAL
The streamstreamwill from now on use the default internal locking.
Every stream operation with exception of the_unlockedvariants will
implicitly lock the stream.
FSETLOCKING_BYCALLER
After the __fsetlocking function returns, the user is responsible for
locking the stream. None of the stream operations will implicitly do this
anymore until the state is set back toFSETLOCKING_INTERNAL.
FSETLOCKING_QUERY
__fsetlockingonly queries the current locking state of the stream. The
return value will beFSETLOCKING_INTERNALorFSETLOCKING_BYCALLER
depending on the state.
```
```
The return value of __fsetlocking is either FSETLOCKING_INTERNAL or
FSETLOCKING_BYCALLERdepending on the state of the stream before the call.
This function and the values for thetypeparameter are declared instdio_ext.h.
```
This function is especially useful when program code has to be used which is written
without knowledge about the_unlockedfunctions (or if the programmer was too lazy to
use them).

## 12.6 Streams in Internationalized Applications....................

ISO C90 introduced the new typewchar_tto allow handling larger character sets. What
was missing was a possibility to output strings ofwchar_tdirectly. One had to convert
them into multibyte strings usingmbstowcs(there was nombsrtowcsyet) and then use the
normal stream functions. While this is doable it is very cumbersome since performing the
conversions is not trivial and greatly increases program complexity and size.

The Unix standard early on (I think in XPG4.2) introduced two additional format spec-
ifiers for theprintfandscanffamilies of functions. Printing and reading of single wide
characters was made possible using the%C specifier and wide character strings can be
handled with%S. These modifiers behave just like%cand%sonly that they expect the
corresponding argument to have the wide character type and that the wide character and
string are transformed into/from multibyte strings before being used.

This was a beginning but it is still not good enough. Not always is it desirable to use
printfandscanf. The other, smaller and faster functions cannot handle wide characters.
Second, it is not possible to have a format string forprintfandscanfconsisting of wide
characters. The result is that format strings would have to be generated if they have to
contain non-basic characters.

In the Amendment 1 to ISO C90 a whole new set of functions was added to solve the
problem. Most of the stream functions got a counterpart which take a wide character
or wide character string instead of a character or string respectively. The new functions
operate on the same streams (likestdout). This is different from the model of the C++
runtime library where separate streams for wide and normal I/O are used.


Chapter 12: Input/Output on Streams 276

Being able to use the same stream for wide and normal operations comes with a re-
striction: a stream can be used either for wide operations or for normal operations. Once
it is decided there is no way back. Only a call tofreopenorfreopen64can reset the
orientation. The orientation can be decided in three ways:

- If any of the normal character functions are used (this includes thefreadandfwrite
    functions) the stream is marked as not wide oriented.
- If any of the wide character functions are used the stream is marked as wide oriented.
- Thefwidefunction can be used to set the orientation either way.
    It is important to never mix the use of wide and not wide operations on a stream. There
are no diagnostics issued. The application behavior will simply be strange or the application
will simply crash. Thefwidefunction can help avoid this.

int fwide (FILE *stream, intmode) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thefwidefunction can be used to set and query the state of the orientation of the
streamstream. If themodeparameter has a positive value the streams get wide
oriented, for negative values narrow oriented. It is not possible to overwrite previous
orientations withfwide. I.e., if the streamstreamwas already oriented before the
call nothing is done.
Ifmodeis zero the current orientation state is queried and nothing is changed.
Thefwidefunction returns a negative value, zero, or a positive value if the stream is
narrow, not at all, or wide oriented respectively.
This function was introduced in Amendment 1 to ISO C90 and is declared inwchar.h.

It is generally a good idea to orient a stream as early as possible. This can prevent
surprise especially for the standard streamsstdin,stdout, andstderr. If some library
function in some situations uses one of these streams and this use orients the stream in a
different way the rest of the application expects it one might end up with hard to reproduce
errors. Remember that no errors are signal if the streams are used incorrectly. Leaving
a stream unoriented after creation is normally only necessary for library functions which
create streams which can be used in different contexts.

When writing code which uses streams and which can be used in different contexts it
is important to query the orientation of the stream before using it (unless the rules of the
library interface demand a specific orientation). The following little, silly function illustrates
this.
void
print_f (FILE *fp)
{
if (fwide (fp, 0) > 0)
/*Positive return value means wide orientation. */
fputwc (L'f', fp);
else
fputc ('f', fp);
}
Note that in this case the functionprint_fdecides about the orientation of the stream
if it was unoriented before (will not happen if the advice above is followed).


Chapter 12: Input/Output on Streams 277

The encoding used for thewchar_tvalues is unspecified and the user must not make any
assumptions about it. For I/O ofwchar_tvalues this means that it is impossible to write
these values directly to the stream. This is not what follows from the ISO C locale model
either. What happens instead is that the bytes read from or written to the underlying media
are first converted into the internal encoding chosen by the implementation forwchar_t.
The external encoding is determined by theLC_CTYPEcategory of the current locale or by
the ¡®ccs¡¯ part of the mode specification given tofopen,fopen64,freopen, orfreopen64.
How and when the conversion happens is unspecified and it happens invisibly to the user.

Since a stream is created in the unoriented state it has at that point no conversion
associated with it. The conversion which will be used is determined by theLC_CTYPE
category selected at the time the stream is oriented. If the locales are changed at the runtime
this might produce surprising results unless one pays attention. This is just another good
reason to orient the stream explicitly as soon as possible, perhaps with a call tofwide.

## 12.7 Simple Output by Characters or Lines.......................

This section describes functions for performing character- and line-oriented output.

These narrow stream functions are declared in the header filestdio.hand the wide
stream functions inwchar.h.

int fputc (intc, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefputcfunction converts the charactercto typeunsigned char, and writes it to
the streamstream.EOFis returned if a write error occurs; otherwise the characterc
is returned.

wint_t fputwc(wchartwc, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefputwc function writes the wide characterwc to the streamstream. WEOFis
returned if a write error occurs; otherwise the characterwcis returned.

int fputc_unlocked(intc, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefputc_unlockedfunction is equivalent to thefputcfunction except that it does
not implicitly lock the stream.

wint_t fputwc_unlocked (wchartwc, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefputwc_unlockedfunction is equivalent to thefputwcfunction except that it
does not implicitly lock the stream.
This function is a GNU extension.


Chapter 12: Input/Output on Streams 278

int putc (intc, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is just likefputc, except that most systems implement it as a macro, making
it faster. One consequence is that it may evaluate thestreamargument more than
once, which is an exception to the general rule for macros. putcis usually the best
function to use for writing a single character.

wint_t putwc (wchartwc, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is just likefputwc, except that it can be implement as a macro, making it faster.
One consequence is that it may evaluate thestreamargument more than once, which
is an exception to the general rule for macros. putwcis usually the best function to
use for writing a single wide character.

int putc_unlocked(intc, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputc_unlockedfunction is equivalent to theputcfunction except that it does
not implicitly lock the stream.

wint_t putwc_unlocked(wchartwc, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputwc_unlockedfunction is equivalent to theputwcfunction except that it does
not implicitly lock the stream.
This function is a GNU extension.

int putchar(intc) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputcharfunction is equivalent toputcwithstdoutas the value of thestream
argument.

wint_t putwchar (wchartwc) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputwcharfunction is equivalent toputwcwithstdoutas the value of thestream
argument.

int putchar_unlocked(intc) [Function]
Preliminary: |MT-Unsafe race:stdout|AS-Unsafe corrupt|AC-Unsafe corrupt|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputchar_unlockedfunction is equivalent to theputcharfunction except that it
does not implicitly lock the stream.


Chapter 12: Input/Output on Streams 279

wint_t putwchar_unlocked(wchartwc) [Function]
Preliminary: |MT-Unsafe race:stdout|AS-Unsafe corrupt|AC-Unsafe corrupt|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputwchar_unlockedfunction is equivalent to theputwcharfunction except that
it does not implicitly lock the stream.
This function is a GNU extension.

int fputs (const char *s, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionfputswrites the stringsto the streamstream. The terminating null
character is not written. This function doesnotadd a newline character, either. It
outputs only the characters in the string.
This function returnsEOFif a write error occurs, and otherwise a non-negative value.
For example:
fputs ("Are ", stdout);
fputs ("you ", stdout);
fputs ("hungry?\n", stdout);
outputs the text ¡®Are you hungry?¡¯ followed by a newline.

int fputws(const wchar t *ws, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionfputwswrites the wide character stringwsto the streamstream. The
terminating null character is not written. This function doesnot add a newline
character, either. It outputs only the characters in the string.
This function returnsWEOFif a write error occurs, and otherwise a non-negative value.

int fputs_unlocked(const char *s, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefputs_unlockedfunction is equivalent to thefputsfunction except that it does
not implicitly lock the stream.
This function is a GNU extension.

int fputws_unlocked (const wchart *ws, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefputws_unlockedfunction is equivalent to thefputwsfunction except that it
does not implicitly lock the stream.
This function is a GNU extension.

int puts (const char *s) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 280

```
Theputsfunction writes the stringsto the streamstdoutfollowed by a newline.
The terminating null character of the string is not written. (Note thatfputsdoes
notwrite a newline as this function does.)
putsis the most convenient function for printing simple messages. For example:
puts ("This is a message.");
outputs the text ¡®This is a message.¡¯ followed by a newline.
```
int putw (intw, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function writes the wordw(that is, anint) tostream. It is provided for com-
patibility with SVID, but we recommend you usefwriteinstead (seeSection 12.11
[Block Input/Output], page 287).

## 12.8 Character Input.............................................

This section describes functions for performing character-oriented input. These narrow
stream functions are declared in the header filestdio.hand the wide character functions
are declared inwchar.h.

These functions return anintorwint_tvalue (for narrow and wide stream functions
respectively) that is either a character of input, or the special valueEOF/WEOF(usually -1).
For the narrow stream functions it is important to store the result of these functions in
a variable of typeintinstead ofchar, even when you plan to use it only as a character.
StoringEOFin acharvariable truncates its value to the size of a character, so that it is
no longer distinguishable from the valid character ¡®(char) -1¡¯. So always use anintfor
the result ofgetcand friends, and check forEOFafter the call; once you¡¯ve verified that
the result is notEOF, you can be sure that it will fit in a ¡®char¡¯ variable without loss of
information.

int fgetc (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function reads the next character as anunsigned charfrom the streamstream
and returns its value, converted to anint. If an end-of-file condition or read error
occurs,EOFis returned instead.

wint_t fgetwc(FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function reads the next wide character from the streamstreamand returns its
value. If an end-of-file condition or read error occurs,WEOFis returned instead.

int fgetc_unlocked(FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgetc_unlockedfunction is equivalent to thefgetcfunction except that it does
not implicitly lock the stream.


Chapter 12: Input/Output on Streams 281

wint_t fgetwc_unlocked (FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgetwc_unlockedfunction is equivalent to thefgetwcfunction except that it
does not implicitly lock the stream.
This function is a GNU extension.

int getc (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is just likefgetc, except that it is permissible (and typical) for it to be imple-
mented as a macro that evaluates thestreamargument more than once.getcis often
highly optimized, so it is usually the best function to use to read a single character.

wint_t getwc (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is just likefgetwc, except that it is permissible for it to be implemented as
a macro that evaluates thestreamargument more than once. getwccan be highly
optimized, so it is usually the best function to use to read a single wide character.

int getc_unlocked(FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetc_unlockedfunction is equivalent to thegetcfunction except that it does
not implicitly lock the stream.

wint_t getwc_unlocked(FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetwc_unlockedfunction is equivalent to thegetwcfunction except that it does
not implicitly lock the stream.
This function is a GNU extension.

int getchar(void) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetcharfunction is equivalent togetcwithstdinas the value of thestream
argument.

wint_t getwchar (void) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetwcharfunction is equivalent togetwcwithstdinas the value of thestream
argument.


Chapter 12: Input/Output on Streams 282

int getchar_unlocked(void) [Function]
Preliminary: |MT-Unsafe race:stdin|AS-Unsafe corrupt|AC-Unsafe corrupt|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetchar_unlockedfunction is equivalent to thegetcharfunction except that it
does not implicitly lock the stream.

wint_t getwchar_unlocked(void) [Function]
Preliminary: |MT-Unsafe race:stdin|AS-Unsafe corrupt|AC-Unsafe corrupt|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetwchar_unlockedfunction is equivalent to thegetwcharfunction except that
it does not implicitly lock the stream.
This function is a GNU extension.

Here is an example of a function that does input usingfgetc. It would work just as well
usinggetcinstead, or usinggetchar ()instead offgetc (stdin). The code would also
work the same for the wide character stream functions.

```
int
y_or_n_p (const char *question)
{
fputs (question, stdout);
while (1)
{
int c, answer;
/*Write a space to separate answer from question.*/
fputc (' ', stdout);
/*Read the first character of the line.
This should be the answer character, but might not be.*/
c = tolower (fgetc (stdin));
answer = c;
/*Discard rest of input line.*/
while (c != '\n' && c != EOF)
c = fgetc (stdin);
/*Obey the answer if it was valid.*/
if (answer == 'y')
return 1;
if (answer == 'n')
return 0;
/*Answer was invalid: ask for valid answer.*/
fputs ("Please answer y or n:", stdout);
}
}
```
int getw (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function reads a word (that is, anint) fromstream. It¡¯s provided for compat-
ibility with SVID. We recommend you usefreadinstead (seeSection 12.11 [Block
Input/Output], page 287). Unlikegetc, anyintvalue could be a valid result.getw
returnsEOFwhen it encounters end-of-file or an error, but there is no way to distin-
guish this from an input word with value -1.


Chapter 12: Input/Output on Streams 283

## 12.9 Line-Oriented Input.........................................

Since many programs interpret input on the basis of lines, it is convenient to have functions
to read a line of text from a stream.

Standard C has functions to do this, but they aren¡¯t very safe: null characters and even
(forgets) long lines can confuse them. So the GNU C Library provides the nonstandard
getlinefunction that makes it easy to read lines reliably.

Another GNU extension,getdelim, generalizesgetline. It reads a delimited record,
defined as everything through the next occurrence of a specified delimiter character.

```
All these functions are declared instdio.h.
```
ssize_t getline (char **lineptr, sizet *n, FILE *stream) [Function]
Preliminary: |MT-Safe |AS-Unsafe corrupt heap|AC-Unsafe lock corrupt mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function reads an entire line fromstream, storing the text (including the new-
line and a terminating null character) in a buffer and storing the buffer address in
*lineptr.
Before callinggetline, you should place in*lineptrthe address of a buffer *n
bytes long, allocated withmalloc. If this buffer is long enough to hold the line,
getlinestores the line in this buffer. Otherwise,getlinemakes the buffer bigger
usingrealloc, storing the new buffer address back in*lineptrand the increased
size back in*n. SeeSection 3.2.3 [Unconstrained Allocation], page 45.
If you set*lineptrto a null pointer, and*nto zero, before the call, thengetline
allocates the initial buffer for you by callingmalloc. This buffer remains allocated
even ifgetlineencounters errors and is unable to read any bytes.
In either case, whengetlinereturns,*lineptris achar *which points to the text
of the line.
Whengetline is successful, it returns the number of characters read (including
the newline, but not including the terminating null). This value enables you to
distinguish null characters that are part of the line from the null character inserted
as a terminator.
This function is a GNU extension, but it is the recommended way to read lines from
a stream. The alternative standard functions are unreliable.
If an error occurs or end of file is reached without any bytes read,getlinereturns
-1.

ssize_t getdelim (char **lineptr, size t *n, intdelimiter, FILE [Function]
*stream)
Preliminary: |MT-Safe |AS-Unsafe corrupt heap|AC-Unsafe lock corrupt mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is likegetlineexcept that the character which tells it to stop reading
is not necessarily newline. The argumentdelimiterspecifies the delimiter character;
getdelimkeeps reading until it sees that character (or end of file).
The text is stored inlineptr, including the delimiter character and a terminating null.
Likegetline,getdelimmakeslineptrbigger if it isn¡¯t big enough.


Chapter 12: Input/Output on Streams 284

```
getlineis in fact implemented in terms ofgetdelim, just like this:
ssize_t
getline (char **lineptr, size_t *n, FILE *stream)
{
return getdelim (lineptr, n, '\n', stream);
}
```
char * fgets (char *s, intcount, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgetsfunction reads characters from the streamstreamup to and including a
newline character and stores them in the strings, adding a null character to mark
the end of the string. You must supplycountcharacters worth of space ins, but the
number of characters read is at mostcount?1. The extra character space is used to
hold the null character at the end of the string.
If the system is already at end of file when you callfgets, then the contents of the
arraysare unchanged and a null pointer is returned. A null pointer is also returned
if a read error occurs. Otherwise, the return value is the pointers.
Warning:If the input data has a null character, you can¡¯t tell. So don¡¯t usefgets
unless you know the data cannot contain a null. Don¡¯t use it to read files edited by the
user because, if the user inserts a null character, you should either handle it properly
or print a clear error message. We recommend usinggetlineinstead offgets.

wchar_t * fgetws (wchart *ws, intcount, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgetwsfunction reads wide characters from the streamstreamup to and includ-
ing a newline character and stores them in the stringws, adding a null wide character
to mark the end of the string. You must supplycountwide characters worth of space
inws, but the number of characters read is at mostcount?1. The extra character
space is used to hold the null wide character at the end of the string.
If the system is already at end of file when you callfgetws, then the contents of the
arraywsare unchanged and a null pointer is returned. A null pointer is also returned
if a read error occurs. Otherwise, the return value is the pointerws.
Warning: If the input data has a null wide character (which are null bytes in the
input stream), you can¡¯t tell. So don¡¯t usefgetwsunless you know the data cannot
contain a null. Don¡¯t use it to read files edited by the user because, if the user inserts
a null character, you should either handle it properly or print a clear error message.

char * fgets_unlocked(char *s, intcount, FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgets_unlockedfunction is equivalent to thefgetsfunction except that it does
not implicitly lock the stream.
This function is a GNU extension.


Chapter 12: Input/Output on Streams 285

wchar_t * fgetws_unlocked(wchart *ws, intcount, FILE [Function]
*stream)
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgetws_unlockedfunction is equivalent to thefgetwsfunction except that it
does not implicitly lock the stream.
This function is a GNU extension.

char * gets(char *s) [Deprecated function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functiongetsreads characters from the streamstdinup to the next newline
character, and stores them in the strings. The newline character is discarded (note
that this differs from the behavior offgets, which copies the newline character into
the string). Ifgetsencounters a read error or end-of-file, it returns a null pointer;
otherwise it returnss.
Warning: Thegetsfunction is very dangerousbecause it provides no protection
against overflowing the strings. The GNU C Library includes it for compatibility
only. You shouldalwaysusefgetsorgetlineinstead. To remind you of this, the
linker (if using GNUld) will issue a warning whenever you usegets.

## 12.10 Unreading.................................................

In parser programs it is often useful to examine the next character in the input stream
without removing it from the stream. This is called ¡°peeking ahead¡± at the input because
your program gets a glimpse of the input it will read next.

Using stream I/O, you can peek ahead at input by first reading it and thenunreading
it (also calledpushing it backon the stream). Unreading a character makes it available to
be input again from the stream, by the next call tofgetcor other input function on that
stream.

## 12.10.1 What Unreading Means...............................

Here is a pictorial explanation of unreading. Suppose you have a stream reading a file that
contains just six characters, the letters ¡®foobar¡¯. Suppose you have read three characters
so far. The situation looks like this:
f o o b a r
^

so the next input character will be ¡®b¡¯.

```
If instead of reading ¡®b¡¯ you unread the letter ¡®o¡¯, you get a situation like this:
f o o b a r
|
o--
^
```
so that the next input characters will be ¡®o¡¯ and ¡®b¡¯.

```
If you unread ¡® 9 ¡¯ instead of ¡®o¡¯, you get this situation:
f o o b a r
```

Chapter 12: Input/Output on Streams 286

```
|
9--
^
```
so that the next input characters will be ¡® 9 ¡¯ and ¡®b¡¯.

## 12.10.2 UsingungetcTo Do Unreading.......................

The function to unread a character is calledungetc, because it reverses the action ofgetc.

int ungetc(intc, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theungetcfunction pushes back the characterconto the input streamstream. So
the next input fromstreamwill readcbefore anything else.
IfcisEOF,ungetcdoes nothing and just returnsEOF. This lets you callungetcwith
the return value ofgetcwithout needing to check for an error fromgetc.
The character that you push back doesn¡¯t have to be the same as the last character
that was actually read from the stream. In fact, it isn¡¯t necessary to actually read
any characters from the stream before unreading them withungetc! But that is a
strange way to write a program; usuallyungetcis used only to unread a character
that was just read from the same stream. The GNU C Library supports this even on
files opened in binary mode, but other systems might not.
The GNU C Library only supports one character of pushback¡ªin other words, it
does not work to callungetctwice without doing input in between. Other systems
might let you push back multiple characters; then reading from the stream retrieves
the characters in the reverse order that they were pushed.
Pushing back characters doesn¡¯t alter the file; only the internal buffering for the
stream is affected. If a file positioning function (such asfseek,fseekoorrewind;
seeSection 12.18 [File Positioning], page 323) is called, any pending pushed-back
characters are discarded.
Unreading a character on a stream that is at end of file clears the end-of-file indicator
for the stream, because it makes the character of input available. After you read that
character, trying to read again will encounter end of file.

wint_t ungetwc(winttwc, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theungetwcfunction behaves just likeungetcjust that it pushes back a wide char-
acter.

Here is an example showing the use ofgetcandungetcto skip over whitespace charac-
ters. When this function reaches a non-whitespace character, it unreads that character to
be seen again on the next read operation on the stream.
#include <stdio.h>
#include <ctype.h>

```
void
skip_whitespace (FILE *stream)
```

Chapter 12: Input/Output on Streams 287

```
{
int c;
do
/*No need to check forEOFbecause it is not
isspace, andungetcignoresEOF. */
c = getc (stream);
while (isspace (c));
ungetc (c, stream);
}
```
## 12.11 Block Input/Output.......................................

This section describes how to do input and output operations on blocks of data. You can
use these functions to read and write binary data, as well as to read and write text in
fixed-size blocks instead of by characters or lines.

Binary files are typically used to read and write blocks of data in the same format as
is used to represent the data in a running program. In other words, arbitrary blocks of
memory¡ªnot just character or string objects¡ªcan be written to a binary file, and mean-
ingfully read in again by the same program.

Storing data in binary form is often considerably more efficient than using the formatted
I/O functions. Also, for floating-point numbers, the binary form avoids possible loss of
precision in the conversion process. On the other hand, binary files can¡¯t be examined or
modified easily using many standard file utilities (such as text editors), and are not portable
between different implementations of the language, or different kinds of computers.

```
These functions are declared instdio.h.
```
size_t fread (void *data, sizetsize, sizetcount, FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function reads up tocountobjects of sizesize into the arraydata, from the
streamstream. It returns the number of objects actually read, which might be less
thancountif a read error occurs or the end of the file is reached. This function
returns a value of zero (and doesn¡¯t read anything) if eithersizeorcountis zero.
Iffreadencounters end of file in the middle of an object, it returns the number of
complete objects read, and discards the partial object. Therefore, the stream remains
at the actual end of the file.

size_t fread_unlocked(void *data, size tsize, size tcount, [Function]
FILE *stream)
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefread_unlockedfunction is equivalent to thefreadfunction except that it does
not implicitly lock the stream.
This function is a GNU extension.

size_t fwrite(const void *data, sizetsize, sizetcount, FILE [Function]
*stream)
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 288

```
This function writes up tocount objects of sizesize from the arraydata, to the
streamstream. The return value is normallycount, if the call succeeds. Any other
value indicates some sort of error, such as running out of space.
```
size_t fwrite_unlocked (const void *data, sizetsize, sizet [Function]
count, FILE *stream)
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefwrite_unlockedfunction is equivalent to thefwritefunction except that it
does not implicitly lock the stream.
This function is a GNU extension.

## 12.12 Formatted Output.........................................

The functions described in this section (printfand related functions) provide a convenient
way to perform formatted output. You callprintfwith aformat stringortemplate string
that specifies how to format the values of the remaining arguments.

Unless your program is a filter that specifically performs line- or character-oriented
processing, usingprintfor one of the other related functions described in this section is
usually the easiest and most concise way to perform output. These functions are especially
useful for printing error messages, tables of data, and the like.

## 12.12.1 Formatted Output Basics..............................

Theprintffunction can be used to print any number of arguments. The template string
argument you supply in a call provides information not only about the number of additional
arguments, but also about their types and what style should be used for printing them.

Ordinary characters in the template string are simply written to the output stream
as-is, whileconversion specificationsintroduced by a ¡®%¡¯ character in the template cause
subsequent arguments to be formatted and written to the output stream. For example,
int pct = 37;
char filename[] = "foo.txt";
printf ("Processing of `%s' is %d%% finished.\nPlease be patient.\n",
filename, pct);

produces output like
Processing of `foo.txt' is 37% finished.
Please be patient.
This example shows the use of the ¡®%d¡¯ conversion to specify that anintargument should
be printed in decimal notation, the ¡®%s¡¯ conversion to specify printing of a string argument,
and the ¡®%%¡¯ conversion to print a literal ¡®%¡¯ character.

There are also conversions for printing an integer argument as an unsigned value in
octal, decimal, or hexadecimal radix (¡®%o¡¯, ¡®%u¡¯, or ¡®%x¡¯, respectively); or as a character
value (¡®%c¡¯).

Floating-point numbers can be printed in normal, fixed-point notation using the ¡®%f¡¯
conversion or in exponential notation using the ¡®%e¡¯ conversion. The ¡®%g¡¯ conversion uses
either ¡®%e¡¯ or ¡®%f¡¯ format, depending on what is more appropriate for the magnitude of the
particular number.


Chapter 12: Input/Output on Streams 289

You can control formatting more precisely by writingmodifiers between the ¡®%¡¯ and
the character that indicates which conversion to apply. These slightly alter the ordinary
behavior of the conversion. For example, most conversion specifications permit you to
specify a minimum field width and a flag indicating whether you want the result left- or
right-justified within the field.

The specific flags and modifiers that are permitted and their interpretation vary de-
pending on the particular conversion. They¡¯re all described in more detail in the following
sections. Don¡¯t worry if this all seems excessively complicated at first; you can almost
always get reasonable free-format output without using any of the modifiers at all. The
modifiers are mostly used to make the output look ¡°prettier¡± in tables.

## 12.12.2 Output Conversion Syntax............................

This section provides details about the precise syntax of conversion specifications that can
appear in aprintftemplate string.

Characters in the template string that are not part of a conversion specification are
printed as-is to the output stream. Multibyte character sequences (seeChapter 6 [Character
Set Handling], page 140) are permitted in a template string.

```
The conversion specifications in aprintftemplate string have the general form:
%[param-no$]flags width[.precision]type conversion
```
or
%[param-no$]flags width.* [param-no$]type conversion
For example, in the conversion specifier ¡®%-10.8ld¡¯, the ¡®-¡¯ is a flag, ¡® 10 ¡¯ specifies the field
width, the precision is ¡® 8 ¡¯, the letter ¡®l¡¯ is a type modifier, and ¡®d¡¯ specifies the conversion
style. (This particular type specifier says to print along intargument in decimal notation,
with a minimum of 8 digits left-justified in a field at least 10 characters wide.)

In more detail, output conversion specifications consist of an initial ¡®%¡¯ character followed
in sequence by:

- An optional specification of the parameter used for this format. Normally the param-
    eters to theprintffunction are assigned to the formats in the order of appearance
    in the format string. But in some situations (such as message translation) this is not
    desirable and this extension allows an explicit parameter to be specified.
    Theparam-noparts of the format must be integers in the range of 1 to the maximum
    number of arguments present to the function call. Some implementations limit this
    number to a certain upper bound. The exact limit can be retrieved by the following
    constant.

```
NL_ARGMAX [Macro]
The value ofNL_ARGMAXis the maximum value allowed for the specification of
a positional parameter in a printf call. The actual value in effect at run-
time can be retrieved by usingsysconf using the_SC_NL_ARGMAXparameter
seeSection 32.4.1 [Definition ofsysconf], page 893.
Some systems have a quite low limit such as 9 for System V systems. The GNU
C Library has no real limit.
```
```
If any of the formats has a specification for the parameter position all of them in the
format string shall have one. Otherwise the behavior is undefined.
```

Chapter 12: Input/Output on Streams 290

- Zero or moreflag charactersthat modify the normal behavior of the conversion speci-
    fication.
- An optional decimal integer specifying theminimum field width. If the normal conver-
    sion produces fewer characters than this, the field is padded with spaces to the specified
    width. This is aminimum value; if the normal conversion produces more characters
    than this, the field isnottruncated. Normally, the output is right-justified within the
    field.
    You can also specify a field width of ¡®*¡¯. This means that the next argument in the
    argument list (before the actual value to be printed) is used as the field width. The
    value must be anint. If the value is negative, this means to set the ¡®-¡¯ flag (see below)
    and to use the absolute value as the field width.
- An optionalprecisionto specify the number of digits to be written for the numeric
    conversions. If the precision is specified, it consists of a period (¡®.¡¯) followed optionally
    by a decimal integer (which defaults to zero if omitted).
    You can also specify a precision of ¡®*¡¯. This means that the next argument in the
    argument list (before the actual value to be printed) is used as the precision. The value
    must be anint, and is ignored if it is negative. If you specify ¡®*¡¯ for both the field
    width and precision, the field width argument precedes the precision argument. Other
    C library versions may not recognize this syntax.
- An optionaltype modifier character, which is used to specify the data type of the
    corresponding argument if it differs from the default type. (For example, the integer
    conversions assume a type ofint, but you can specify ¡®h¡¯, ¡®l¡¯, or ¡®L¡¯ for other integer
    types.)
- A character that specifies the conversion to be applied.

The exact options that are permitted and how they are interpreted vary between the
different conversion specifiers. See the descriptions of the individual conversions for infor-
mation about the particular options that they use.

With the ¡®-Wformat¡¯ option, the GNU C compiler checks calls toprintfand related
functions. It examines the format string and verifies that the correct number and types
of arguments are supplied. There is also a GNU C syntax to tell the compiler that a
function you write uses aprintf-style format string. SeeSection ¡°Declaring Attributes of
Functions¡± inUsing GNU CC, for more information.

## 12.12.3 Table of Output Conversions..........................

Here is a table summarizing what all the different conversions do:

¡®%d¡¯, ¡®%i¡¯ Print an integer as a signed decimal number. SeeSection 12.12.4 [Integer
Conversions], page 291, for details. ¡®%d¡¯ and ¡®%i¡¯ are synonymous for output,
but are different when used withscanffor input (seeSection 12.14.3 [Table of
Input Conversions], page 312).

¡®%o¡¯ Print an integer as an unsigned octal number. SeeSection 12.12.4 [Integer
Conversions], page 291, for details.

¡®%u¡¯ Print an integer as an unsigned decimal number. SeeSection 12.12.4 [Integer
Conversions], page 291, for details.


Chapter 12: Input/Output on Streams 291

¡®%x¡¯, ¡®%X¡¯ Print an integer as an unsigned hexadecimal number. ¡®%x¡¯ uses lower-case letters
and ¡®%X¡¯ uses upper-case. SeeSection 12.12.4 [Integer Conversions], page 291,
for details.

¡®%f¡¯ Print a floating-point number in normal (fixed-point) notation. See
Section 12.12.5 [Floating-Point Conversions], page 293, for details.

¡®%e¡¯, ¡®%E¡¯ Print a floating-point number in exponential notation. ¡®%e¡¯ uses lower-case let-
ters and ¡®%E¡¯ uses upper-case. SeeSection 12.12.5 [Floating-Point Conversions],
page 293, for details.

¡®%g¡¯, ¡®%G¡¯ Print a floating-point number in either normal or exponential notation, which-
ever is more appropriate for its magnitude. ¡®%g¡¯ uses lower-case letters and ¡®%G¡¯
uses upper-case. SeeSection 12.12.5 [Floating-Point Conversions], page 293, for
details.

¡®%a¡¯, ¡®%A¡¯ Print a floating-point number in a hexadecimal fractional notation with the
exponent to base 2 represented in decimal digits. ¡®%a¡¯ uses lower-case letters
and ¡®%A¡¯ uses upper-case. SeeSection 12.12.5 [Floating-Point Conversions],
page 293, for details.

¡®%c¡¯ Print a single character. SeeSection 12.12.6 [Other Output Conversions],
page 295.

¡®%C¡¯ This is an alias for ¡®%lc¡¯ which is supported for compatibility with the Unix
standard.

¡®%s¡¯ Print a string. SeeSection 12.12.6 [Other Output Conversions], page 295.

¡®%S¡¯ This is an alias for ¡®%ls¡¯ which is supported for compatibility with the Unix
standard.

¡®%p¡¯ Print the value of a pointer. SeeSection 12.12.6 [Other Output Conversions],
page 295.

¡®%n¡¯ Get the number of characters printed so far. SeeSection 12.12.6 [Other Output
Conversions], page 295. Note that this conversion specification never produces
any output.

¡®%m¡¯ Print the string corresponding to the value oferrno. (This is a GNU extension.)
SeeSection 12.12.6 [Other Output Conversions], page 295.

¡®%%¡¯ Print a literal ¡®%¡¯ character. SeeSection 12.12.6 [Other Output Conversions],
page 295.

If the syntax of a conversion specification is invalid, unpredictable things will happen,
so don¡¯t do this. If there aren¡¯t enough function arguments provided to supply values for
all the conversion specifications in the template string, or if the arguments are not of the
correct types, the results are unpredictable. If you supply more arguments than conversion
specifications, the extra argument values are simply ignored; this is sometimes useful.

## 12.12.4 Integer Conversions...................................

This section describes the options for the ¡®%d¡¯, ¡®%i¡¯, ¡®%o¡¯, ¡®%u¡¯, ¡®%x¡¯, and ¡®%X¡¯ conversion
specifications. These conversions print integers in various formats.


Chapter 12: Input/Output on Streams 292

The ¡®%d¡¯ and ¡®%i¡¯ conversion specifications both print anint argument as a signed
decimal number; while ¡®%o¡¯, ¡®%u¡¯, and ¡®%x¡¯ print the argument as an unsigned octal, decimal,
or hexadecimal number (respectively). The ¡®%X¡¯ conversion specification is just like ¡®%x¡¯
except that it uses the characters ¡®ABCDEF¡¯ as digits instead of ¡®abcdef¡¯.

```
The following flags are meaningful:
```
¡®-¡¯ Left-justify the result in the field (instead of the normal right-justification).

¡®+¡¯ For the signed ¡®%d¡¯ and ¡®%i¡¯ conversions, print a plus sign if the value is positive.

¡® ¡¯ For the signed ¡®%d¡¯ and ¡®%i¡¯ conversions, if the result doesn¡¯t start with a plus
or minus sign, prefix it with a space character instead. Since the ¡®+¡¯ flag ensures
that the result includes a sign, this flag is ignored if you supply both of them.

¡®#¡¯ For the ¡®%o¡¯ conversion, this forces the leading digit to be ¡® 0 ¡¯, as if by increasing
the precision. For ¡®%x¡¯ or ¡®%X¡¯, this prefixes a leading ¡®0x¡¯ or ¡®0X¡¯ (respectively) to
the result. This doesn¡¯t do anything useful for the ¡®%d¡¯, ¡®%i¡¯, or ¡®%u¡¯ conversions.
Using this flag produces output which can be parsed by thestrtoulfunction
(seeSection 20.11.1 [Parsing of Integers], page 635) andscanfwith the ¡®%i¡¯
conversion (seeSection 12.14.4 [Numeric Input Conversions], page 314).

¡®'¡¯ Separate the digits into groups as specified by the locale specified for theLC_
NUMERICcategory; seeSection 7.7.1.1 [Generic Numeric Formatting Parame-
ters], page 189. This flag is a GNU extension.

¡® 0 ¡¯ Pad the field with zeros instead of spaces. The zeros are placed after any
indication of sign or base. This flag is ignored if the ¡®-¡¯ flag is also specified, or
if a precision is specified.
If a precision is supplied, it specifies the minimum number of digits to appear; leading
zeros are produced if necessary. If you don¡¯t specify a precision, the number is printed with
as many digits as it needs. If you convert a value of zero with an explicit precision of zero,
then no characters at all are produced.

Without a type modifier, the corresponding argument is treated as anint(for the signed
conversions ¡®%i¡¯ and ¡®%d¡¯) orunsigned int(for the unsigned conversions ¡®%o¡¯, ¡®%u¡¯, ¡®%x¡¯, and
¡®%X¡¯). Recall that sinceprintfand friends are variadic, anycharandshortarguments
are automatically converted tointby the default argument promotions. For arguments of
other integer types, you can use these modifiers:

¡®hh¡¯ Specifies that the argument is asigned charorunsigned char, as appropri-
ate. Acharargument is converted to anintorunsigned intby the default
argument promotions anyway, but the ¡®hh¡¯ modifier says to convert it back to
acharagain.
This modifier was introduced in ISO C99.

¡®h¡¯ Specifies that the argument is ashort intorunsigned short int, as appro-
priate. Ashortargument is converted to an intorunsigned intby the
default argument promotions anyway, but the ¡®h¡¯ modifier says to convert it
back to ashortagain.

¡®j¡¯ Specifies that the argument is aintmax_toruintmax_t, as appropriate.

```
This modifier was introduced in ISO C99.
```

Chapter 12: Input/Output on Streams 293

¡®l¡¯ Specifies that the argument is along intorunsigned long int, as appropri-
ate. Two ¡®l¡¯ characters are like the ¡®L¡¯ modifier, below.
If used with ¡®%c¡¯ or ¡®%s¡¯ the corresponding parameter is considered as a wide
character or wide character string respectively. This use of ¡®l¡¯ was introduced
in Amendment 1 to ISO C90.

¡®L¡¯
¡®ll¡¯
¡®q¡¯ Specifies that the argument is along long int. (This type is an extension
supported by the GNU C compiler. On systems that don¡¯t support extra-long
integers, this is the same aslong int.)
The ¡®q¡¯ modifier is another name for the same thing, which comes from 4.4
BSD; along long intis sometimes called a ¡°quad¡±int.

¡®t¡¯ Specifies that the argument is aptrdiff_t.

```
This modifier was introduced in ISO C99.
```
¡®z¡¯
¡®Z¡¯ Specifies that the argument is asize_t.

```
¡®z¡¯ was introduced in ISO C99. ¡®Z¡¯ is a GNU extension predating this addition
and should not be used in new code.
Here is an example. Using the template string:
"|%5d|%-5d|%+5d|%+-5d|% 5d|%05d|%5.0d|%5.2d|%d|\n"
```
to print numbers using the different options for the ¡®%d¡¯ conversion gives results like:
| 0|0 | +0|+0 | 0|00000| | 00|0|
| 1|1 | +1|+1 | 1|00001| 1| 01|1|
| -1|-1 | -1|-1 | -1|-0001| -1| -01|-1|
|100000|100000|+100000|+100000| 100000|100000|100000|100000|100000|
In particular, notice what happens in the last case where the number is too large to fit
in the minimum field width specified.

Here are some more examples showing how unsigned integers print under various format
options, using the template string:
"|%5u|%5o|%5x|%5X|%#5o|%#5x|%#5X|%#10.8x|\n"
| 0| 0| 0| 0| 0| 0| 0| 00000000|
| 1| 1| 1| 1| 01| 0x1| 0X1|0x00000001|
|100000|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|

## 12.12.5 Floating-Point Conversions............................

This section discusses the conversion specifications for floating-point numbers: the ¡®%f¡¯,
¡®%e¡¯, ¡®%E¡¯, ¡®%g¡¯, and ¡®%G¡¯ conversions.

The ¡®%f¡¯ conversion prints its argument in fixed-point notation, producing output of the
form [-]ddd.ddd, where the number of digits following the decimal point is controlled by
the precision you specify.

The ¡®%e¡¯ conversion prints its argument in exponential notation, producing output of
the form [-]d.ddde[+|-]dd. Again, the number of digits following the decimal point is
controlled by the precision. The exponent always contains at least two digits. The ¡®%E¡¯
conversion is similar but the exponent is marked with the letter ¡®E¡¯ instead of ¡®e¡¯.


Chapter 12: Input/Output on Streams 294

The ¡®%g¡¯ and ¡®%G¡¯ conversions print the argument in the style of ¡®%e¡¯ or ¡®%E¡¯ (respectively)
if the exponent would be less than -4 or greater than or equal to the precision; otherwise
they use the ¡®%f¡¯ style. A precision of 0 , is taken as 1. Trailing zeros are removed from the
fractional portion of the result and a decimal-point character appears only if it is followed
by a digit.

The ¡®%a¡¯ and ¡®%A¡¯ conversions are meant for representing floating-point numbers exactly
in textual form so that they can be exchanged as texts between different programs and/or
machines. The numbers are represented in the form [-]0xh.hhhp[+|-]dd. At the left of the
decimal-point character exactly one digit is print. This character is only 0 if the number
is denormalized. Otherwise the value is unspecified; it is implementation dependent how
many bits are used. The number of hexadecimal digits on the right side of the decimal-
point character is equal to the precision. If the precision is zero it is determined to be
large enough to provide an exact representation of the number (or it is large enough to
distinguish two adjacent values if theFLT_RADIXis not a power of 2, seeSection A.5.3.2
[Floating Point Parameters], page 961). For the ¡®%a¡¯ conversion lower-case characters are
used to represent the hexadecimal number and the prefix and exponent sign are printed as
0xandprespectively. Otherwise upper-case characters are used and0XandPare used for
the representation of prefix and exponent string. The exponent to the base of two is printed
as a decimal number using at least one digit but at most as many digits as necessary to
represent the value exactly.

If the value to be printed represents infinity or a NaN, the output is [-]infornan
respectively if the conversion specifier is ¡®%a¡¯, ¡®%e¡¯, ¡®%f¡¯, or ¡®%g¡¯ and it is [-]INForNAN
respectively if the conversion is ¡®%A¡¯, ¡®%E¡¯, or ¡®%G¡¯.

```
The following flags can be used to modify the behavior:
```
¡®-¡¯ Left-justify the result in the field. Normally the result is right-justified.

¡®+¡¯ Always include a plus or minus sign in the result.

¡® ¡¯ If the result doesn¡¯t start with a plus or minus sign, prefix it with a space
instead. Since the ¡®+¡¯ flag ensures that the result includes a sign, this flag is
ignored if you supply both of them.

¡®#¡¯ Specifies that the result should always include a decimal point, even if no digits
follow it. For the ¡®%g¡¯ and ¡®%G¡¯ conversions, this also forces trailing zeros after
the decimal point to be left in place where they would otherwise be removed.

¡®'¡¯ Separate the digits of the integer part of the result into groups as specified by
the locale specified for theLC_NUMERICcategory; seeSection 7.7.1.1 [Generic
Numeric Formatting Parameters], page 189. This flag is a GNU extension.

¡® 0 ¡¯ Pad the field with zeros instead of spaces; the zeros are placed after any sign.
This flag is ignored if the ¡®-¡¯ flag is also specified.
The precision specifies how many digits follow the decimal-point character for the ¡®%f¡¯,
¡®%e¡¯, and ¡®%E¡¯ conversions. For these conversions, the default precision is 6. If the precision
is explicitly 0 , this suppresses the decimal point character entirely. For the ¡®%g¡¯ and ¡®%G¡¯
conversions, the precision specifies how many significant digits to print. Significant digits
are the first digit before the decimal point, and all the digits after it. If the precision is 0
or not specified for ¡®%g¡¯ or ¡®%G¡¯, it is treated like a value of 1. If the value being printed


Chapter 12: Input/Output on Streams 295

cannot be expressed accurately in the specified number of digits, the value is rounded to
the nearest number that fits.

Without a type modifier, the floating-point conversions use an argument of typedouble.
(By the default argument promotions, anyfloatarguments are automatically converted
todouble.) The following type modifier is supported:

¡®L¡¯ An uppercase ¡®L¡¯ specifies that the argument is along double.

Here are some examples showing how numbers print using the various floating-point
conversions. All of the numbers were printed using this template string:
"|%13.4a|%13.4f|%13.4e|%13.4g|\n"
Here is the output:
| 0x0.0000p+0| 0.0000| 0.0000e+00| 0|
| 0x1.0000p-1| 0.5000| 5.0000e-01| 0.5|
| 0x1.0000p+0| 1.0000| 1.0000e+00| 1|
| -0x1.0000p+0| -1.0000| -1.0000e+00| -1|
| 0x1.9000p+6| 100.0000| 1.0000e+02| 100|
| 0x1.f400p+9| 1000.0000| 1.0000e+03| 1000|
| 0x1.3880p+13| 10000.0000| 1.0000e+04| 1e+04|
| 0x1.81c8p+13| 12345.0000| 1.2345e+04| 1.234e+04|
| 0x1.86a0p+16| 100000.0000| 1.0000e+05| 1e+05|
| 0x1.e240p+16| 123456.0000| 1.2346e+05| 1.235e+05|
Notice how the ¡®%g¡¯ conversion drops trailing zeros.

## 12.12.6 Other Output Conversions.............................

This section describes miscellaneous conversions forprintf.

The ¡®%c¡¯ conversion prints a single character. In case there is no ¡®l¡¯ modifier theint
argument is first converted to anunsigned char. Then, if used in a wide stream function,
the character is converted into the corresponding wide character. The ¡®-¡¯ flag can be used
to specify left-justification in the field, but no other flags are defined, and no precision or
type modifier can be given. For example:
printf ("%c%c%c%c%c", 'h', 'e', 'l', 'l', 'o');

prints ¡®hello¡¯.

If there is an ¡®l¡¯ modifier present the argument is expected to be of typewint_t. If used
in a multibyte function the wide character is converted into a multibyte character before
being added to the output. In this case more than one output byte can be produced.

The ¡®%s¡¯ conversion prints a string. If no ¡®l¡¯ modifier is present the corresponding
argument must be of typechar *(orconst char *). If used in a wide stream function the
string is first converted to a wide character string. A precision can be specified to indicate
the maximum number of characters to write; otherwise characters in the string up to but
not including the terminating null character are written to the output stream. The ¡®-¡¯ flag
can be used to specify left-justification in the field, but no other flags or type modifiers are
defined for this conversion. For example:
printf ("%3s%-6s", "no", "where");

prints ¡®nowhere¡¯.

If there is an ¡®l¡¯ modifier present, the argument is expected to be of typewchar_t(or
const wchar_t *).


Chapter 12: Input/Output on Streams 296

If you accidentally pass a null pointer as the argument for a ¡®%s¡¯ conversion, the GNU
C Library prints it as ¡®(null)¡¯. We think this is more useful than crashing. But it¡¯s not
good practice to pass a null argument intentionally.

The ¡®%m¡¯ conversion prints the string corresponding to the error code inerrno. See
Section 2.3 [Error Messages], page 36. Thus:

```
fprintf (stderr, "can't open `%s': %m\n", filename);
```
is equivalent to:

```
fprintf (stderr, "can't open `%s': %s\n", filename, strerror (errno));
```
The ¡®%m¡¯ conversion is a GNU C Library extension.

The ¡®%p¡¯ conversion prints a pointer value. The corresponding argument must be of type
void *. In practice, you can use any type of pointer.

In the GNU C Library, non-null pointers are printed as unsigned integers, as if a ¡®%#x¡¯
conversion were used. Null pointers print as ¡®(nil)¡¯. (Pointers might print differently in
other systems.)

```
For example:
printf ("%p", "testing");
```
prints ¡®0x¡¯ followed by a hexadecimal number¡ªthe address of the string constant"testing".
It does not print the word ¡®testing¡¯.

You can supply the ¡®-¡¯ flag with the ¡®%p¡¯ conversion to specify left-justification, but no
other flags, precision, or type modifiers are defined.

The ¡®%n¡¯ conversion is unlike any of the other output conversions. It uses an argument
which must be a pointer to anint, but instead of printing anything it stores the number
of characters printed so far by this call at that location. The ¡®h¡¯ and ¡®l¡¯ type modifiers are
permitted to specify that the argument is of typeshort int *orlong int *instead ofint
*, but no flags, field width, or precision are permitted.

```
For example,
int nchar;
printf ("%d %s%n\n", 3, "bears", &nchar);
```
prints:
3 bears

and setsncharto 7 , because ¡®3 bears¡¯ is seven characters.

The ¡®%%¡¯ conversion prints a literal ¡®%¡¯ character. This conversion doesn¡¯t use an argu-
ment, and no flags, field width, precision, or type modifiers are permitted.

## 12.12.7 Formatted Output Functions..........................

This section describes how to callprintf and related functions. Prototypes for these
functions are in the header filestdio.h. Because these functions take a variable number of
arguments, youmustdeclare prototypes for them before using them. Of course, the easiest
way to make sure you have all the right prototypes is to just includestdio.h.

int printf(const char *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 297

```
Theprintffunction prints the optional arguments under the control of the template
stringtemplateto the streamstdout. It returns the number of characters printed,
or a negative value if there was an output error.
```
int wprintf(const wchart *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewprintffunction prints the optional arguments under the control of the wide
template stringtemplateto the streamstdout. It returns the number of wide char-
acters printed, or a negative value if there was an output error.

int fprintf(FILE *stream, const char *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is just likeprintf, except that the output is written to the stream
streaminstead ofstdout.

int fwprintf (FILE *stream, const wchar t *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is just likewprintf, except that the output is written to the stream
streaminstead ofstdout.

int sprintf(char *s, const char *template,.. .) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is likeprintf, except that the output is stored in the character arraysinstead
of written to a stream. A null character is written to mark the end of the string.
Thesprintffunction returns the number of characters stored in the arrays, not
including the terminating null character.
The behavior of this function is undefined if copying takes place between objects that
overlap¡ªfor example, ifsis also given as an argument to be printed under control of
the ¡®%s¡¯ conversion. SeeSection 5.4 [Copying Strings and Arrays], page 101.
Warning:Thesprintffunction can bedangerousbecause it can potentially output
more characters than can fit in the allocation size of the strings. Remember that the
field width given in a conversion specification is only aminimumvalue.
To avoid this problem, you can usesnprintforasprintf, described below.

int swprintf (wchart *ws, sizetsize, const wchart *template, [Function]

.. .)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is likewprintf, except that the output is stored in the wide character arrayws
instead of written to a stream. A null wide character is written to mark the end of the
string. Thesizeargument specifies the maximum number of characters to produce.
The trailing null character is counted towards this limit, so you should allocate at
leastsizewide characters for the stringws.


Chapter 12: Input/Output on Streams 298

```
The return value is the number of characters generated for the given input, excluding
the trailing null. If not all output fits into the provided buffer a negative value is
returned. You should try again with a bigger output string. Note: this is different
from howsnprintfhandles this situation.
Note that the corresponding narrow stream function takes fewer parameters.
swprintfin fact corresponds to thesnprintffunction. Since thesprintffunction
can be dangerous and should be avoided the ISO C committee refused to make the
same mistake again and decided to not define a function exactly corresponding to
sprintf.
```
int snprintf (char *s, sizetsize, const char *template,.. .) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesnprintffunction is similar tosprintf, except that thesizeargument specifies
the maximum number of characters to produce. The trailing null character is counted
towards this limit, so you should allocate at leastsizecharacters for the strings. If
sizeis zero, nothing, not even the null byte, shall be written ands may be a null
pointer.
The return value is the number of characters which would be generated for the given
input, excluding the trailing null. If this value is greater than or equal tosize, not all
characters from the result have been stored ins. You should try again with a bigger
output string. Here is an example of doing this:
/*Construct a message describing the value of a variable
whose name isnameand whose value isvalue.*/
char *
make_message (char *name, char *value)
{
/*Guess we need no more than 100 chars of space.*/
int size = 100;
char *buffer = (char *) xmalloc (size);
int nchars;
if (buffer == NULL)
return NULL;

```
/*Try to print in the allocated space. */
nchars = snprintf (buffer, size, "value of %s is %s",
name, value);
if (nchars >= size)
{
/*Reallocate buffer now that we know
how much space is needed.*/
size = nchars + 1;
buffer = (char *) xrealloc (buffer, size);
```
```
if (buffer != NULL)
/*Try again.*/
snprintf (buffer, size, "value of %s is %s",
name, value);
}
/*The last call worked, return the string.*/
return buffer;
}
```

Chapter 12: Input/Output on Streams 299

```
In practice, it is often easier just to useasprintf, below.
Attention: In versions of the GNU C Library prior to 2.1 the return value is the
number of characters stored, not including the terminating null; unless there was not
enough space insto store the result in which case-1is returned. This was changed
in order to comply with the ISO C99 standard.
```
## 12.12.8 Dynamically Allocating Formatted Output............

The functions in this section do formatted output and place the results in dynamically
allocated memory.

int asprintf (char **ptr, const char *template,.. .) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tosprintf, except that it dynamically allocates a string
(as withmalloc; seeSection 3.2.3 [Unconstrained Allocation], page 45) to hold the
output, instead of putting the output in a buffer you allocate in advance. Theptr
argument should be the address of achar *object, and a successful call toasprintf
stores a pointer to the newly allocated string at that location.
The return value is the number of characters allocated for the buffer, or less than zero
if an error occurred. Usually this means that the buffer could not be allocated.
Here is how to useasprintfto get the same result as thesnprintfexample, but
more easily:
/*Construct a message describing the value of a variable
whose name isnameand whose value isvalue.*/
char *
make_message (char *name, char *value)
{
char *result;
if (asprintf (&result, "value of %s is %s", name, value) < 0)
return NULL;
return result;
}

int obstack_printf(struct obstack *obstack, const char [Function]
*template,.. .)
Preliminary: |MT-Safe race:obstack locale|AS-Unsafe corrupt heap|AC-Unsafe
corrupt mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toasprintf, except that it uses the obstackobstack to
allocate the space. SeeSection 3.2.6 [Obstacks], page 63.
The characters are written onto the end of the current object. To get at them, you
must finish the object withobstack_finish(seeSection 3.2.6.6 [Growing Objects],
page 67).

## 12.12.9 Variable Arguments Output Functions.................

The functionsvprintfand friends are provided so that you can define your own variadic
printf-like functions that make use of the same internals as the built-in formatted output
functions.


Chapter 12: Input/Output on Streams 300

The most natural way to define such functions would be to use a language construct
to say, ¡°Callprintfand pass this template plus all of my arguments after the first five.¡±
But there is no way to do this in C, and it would be hard to provide a way, since at the C
language level there is no way to tell how many arguments your function received.

Since that method is impossible, we provide alternative functions, thevprintfseries,
which lets you pass ava_listto describe ¡°all of my arguments after the first five.¡±

When it is sufficient to define a macro rather than a real function, the GNU C compiler
provides a way to do this much more easily with macros. For example:
#define myprintf(a, b, c, d, e, rest...) \
printf (mytemplate , ## rest)

SeeSection ¡°Variadic Macros¡± inThe C preprocessor, for details. But this is limited to
macros, and does not apply to real functions at all.

Before callingvprintfor the other functions listed in this section, youmustcallva_
start(seeSection A.2 [Variadic Functions], page 950) to initialize a pointer to the variable
arguments. Then you can callva_argto fetch the arguments that you want to handle
yourself. This advances the pointer past those arguments.

Once yourva_listpointer is pointing at the argument of your choice, you are ready
to callvprintf. That argument and all subsequent arguments that were passed to your
function are used byvprintfalong with the template that you specified separately.

Portability Note: The value of theva_listpointer is undetermined after the call to
vprintf, so you must not useva_argafter you callvprintf. Instead, you should call
va_endto retire the pointer from service. You can callva_startagain and begin fetching
the arguments from the start of the variable argument list. (Alternatively, you can use
va_copyto make a copy of theva_listpointer before callingvfprintf.) Callingvprintf
does not destroy the argument list of your function, merely the particular pointer that you
passed to it.

```
Prototypes for these functions are declared instdio.h.
```
int vprintf(const char *template, va listap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toprintfexcept that, instead of taking a variable number
of arguments directly, it takes an argument list pointerap.

int vwprintf (const wchart *template, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar towprintfexcept that, instead of taking a variable number
of arguments directly, it takes an argument list pointerap.

int vfprintf (FILE *stream, const char *template, va listap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent offprintfwith the variable argument list specified directly as
forvprintf.


Chapter 12: Input/Output on Streams 301

int vfwprintf(FILE *stream, const wchar t *template, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.

```
This is the equivalent offwprintfwith the variable argument list specified directly
as forvwprintf.
```
int vsprintf (char *s, const char *template, valistap) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent ofsprintfwith the variable argument list specified directly as
forvprintf.

int vswprintf(wchart *ws, size tsize, const wchar t *template, [Function]
valistap)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent ofswprintfwith the variable argument list specified directly
as forvwprintf.

int vsnprintf(char *s, sizetsize, const char *template, valist [Function]
ap)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.

```
This is the equivalent ofsnprintfwith the variable argument list specified directly
as forvprintf.
```
int vasprintf(char **ptr, const char *template, va listap) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.

```
Thevasprintffunction is the equivalent ofasprintfwith the variable argument
list specified directly as forvprintf.
```
int obstack_vprintf (struct obstack *obstack, const char [Function]
*template, valistap)
Preliminary: |MT-Safe race:obstack locale|AS-Unsafe corrupt heap|AC-Unsafe
corrupt mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theobstack_vprintffunction is the equivalent ofobstack_printfwith the variable
argument list specified directly as forvprintf.

Here¡¯s an example showing how you might usevfprintf. This is a function that prints
error messages to the streamstderr, along with a prefix indicating the name of the program
(seeSection 2.3 [Error Messages], page 36, for a description ofprogram_invocation_short_
name).


Chapter 12: Input/Output on Streams 302

```
#include <stdio.h>
#include <stdarg.h>
```
```
void
eprintf (const char *template, ...)
{
va_list ap;
extern char *program_invocation_short_name;
```
```
fprintf (stderr, "%s: ", program_invocation_short_name);
va_start (ap, template);
vfprintf (stderr, template, ap);
va_end (ap);
}
```
You could calleprintflike this:
eprintf ("file `%s' does not exist\n", filename);
In GNU C, there is a special construct you can use to let the compiler know that a
function uses aprintf-style format string. Then it can check the number and types of
arguments in each call to the function, and warn you when they do not match the format
string. For example, take this declaration ofeprintf:
void eprintf (const char *template, ...)
__attribute__ ((format (printf, 1, 2)));

This tells the compiler thateprintfuses a format string likeprintf(as opposed toscanf;
seeSection 12.14 [Formatted Input], page 311); the format string appears as the first argu-
ment; and the arguments to satisfy the format begin with the second. SeeSection ¡°Declaring
Attributes of Functions¡± inUsing GNU CC, for more information.

## 12.12.10 Parsing a Template String............................

You can use the functionparse_printf_formatto obtain information about the number
and types of arguments that are expected by a given template string. This function permits
interpreters that provide interfaces toprintfto avoid passing along invalid arguments from
the user¡¯s program, which could cause a crash.

```
All the symbols described in this section are declared in the header fileprintf.h.
```
size_t parse_printf_format (const char *template, sizetn, int [Function]
*argtypes)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns information about the number and types of arguments expected
by theprintf template string template. The information is stored in the array
argtypes; each element of this array describes one argument. This information is
encoded using the various ¡®PA_¡¯ macros, listed below.
The argumentnspecifies the number of elements in the arrayargtypes. This is the
maximum number of elements thatparse_printf_formatwill try to write.
parse_printf_formatreturns the total number of arguments required bytemplate.
If this number is greater thann, then the information returned describes only the
firstnarguments. If you want information about additional arguments, allocate a
bigger array and callparse_printf_formatagain.


Chapter 12: Input/Output on Streams 303

```
The argument types are encoded as a combination of a basic type and modifier flag bits.
```
int PA_FLAG_MASK [Macro]
This macro is a bitmask for the type modifier flag bits. You can write the expression
(argtypes[i] & PA_FLAG_MASK)to extract just the flag bits for an argument, or
(argtypes[i] & ~PA_FLAG_MASK)to extract just the basic type code.

```
Here are symbolic constants that represent the basic types; they stand for integer values.
```
PA_INT This specifies that the base type isint.

PA_CHAR This specifies that the base type isint, cast tochar.

PA_STRING
This specifies that the base type ischar *, a null-terminated string.

PA_POINTER
This specifies that the base type isvoid *, an arbitrary pointer.

PA_FLOAT This specifies that the base type isfloat.

PA_DOUBLE
This specifies that the base type isdouble.

PA_LAST You can define additional base types for your own programs as offsets from
PA_LAST. For example, if you have data types ¡®foo¡¯ and ¡®bar¡¯ with their own
specializedprintfconversions, you could define encodings for these types as:
#define PA_FOO PA_LAST
#define PA_BAR (PA_LAST + 1)

Here are the flag bits that modify a basic type. They are combined with the code for
the basic type using inclusive-or.

PA_FLAG_PTR
If this bit is set, it indicates that the encoded type is a pointer to the base
type, rather than an immediate value. For example, ¡®PA_INT|PA_FLAG_PTR¡¯
represents the type ¡®int *¡¯.

PA_FLAG_SHORT
If this bit is set, it indicates that the base type is modified withshort. (This
corresponds to the ¡®h¡¯ type modifier.)

PA_FLAG_LONG
If this bit is set, it indicates that the base type is modified withlong. (This
corresponds to the ¡®l¡¯ type modifier.)

PA_FLAG_LONG_LONG
If this bit is set, it indicates that the base type is modified withlong long.
(This corresponds to the ¡®L¡¯ type modifier.)

PA_FLAG_LONG_DOUBLE
This is a synonym forPA_FLAG_LONG_LONG, used by convention with a base
type ofPA_DOUBLEto indicate a type oflong double.


Chapter 12: Input/Output on Streams 304

## 12.12.11 Example of Parsing a Template String................

Here is an example of decoding argument types for a format string. We assume this is part
of an interpreter which contains arguments of typeNUMBER,CHAR,STRINGandSTRUCTURE
(and perhaps others which are not valid here).

```
/*Test whether thenargsspecified objects
in the vectorargsare valid
for the format stringformat:
if so, return 1.
If not, return 0 after printing an error message. */
```
```
int
validate_args (char *format, int nargs, OBJECT *args)
{
int *argtypes;
int nwanted;
```
```
/*Get the information about the arguments.
Each conversion specification must be at least two characters
long, so there cannot be more specifications than half the
length of the string. */
```
```
argtypes = (int *) alloca (strlen (format) / 2 * sizeof (int));
nwanted = parse_printf_format (format, nargs, argtypes);
```
```
/*Check the number of arguments. */
if (nwanted > nargs)
{
error ("too few arguments (at least %d required)", nwanted);
return 0;
}
```
```
/*Check the C type wanted for each argument
and see if the object given is suitable. */
for (i = 0; i < nwanted; i++)
{
int wanted;
```
```
if (argtypes[i] & PA_FLAG_PTR)
wanted = STRUCTURE;
else
switch (argtypes[i] & ~PA_FLAG_MASK)
{
case PA_INT:
case PA_FLOAT:
case PA_DOUBLE:
wanted = NUMBER;
break;
case PA_CHAR:
wanted = CHAR;
break;
case PA_STRING:
wanted = STRING;
break;
case PA_POINTER:
wanted = STRUCTURE;
break;
}
```

Chapter 12: Input/Output on Streams 305

```
if (TYPE (args[i]) != wanted)
{
error ("type mismatch for arg number %d", i);
return 0;
}
}
return 1;
}
```
## 12.13 Customizingprintf.......................................

The GNU C Library lets you define your own custom conversion specifiers for printf
template strings, to teachprintfclever ways to print the important data structures of
your program.

The way you do this is by registering the conversion with the functionregister_printf_
function; seeSection 12.13.1 [Registering New Conversions], page 305. One of the argu-
ments you pass to this function is a pointer to a handler function that produces the actual
output; seeSection 12.13.3 [Defining the Output Handler], page 307, for information on
how to write this function.

You can also install a function that just returns information about the number and type
of arguments expected by the conversion specifier. SeeSection 12.12.10 [Parsing a Template
String], page 302, for information about this.

The facilities of this section are declared in the header fileprintf.h.
Portability Note:The ability to extend the syntax ofprintftemplate strings is a GNU
extension. ISO standard C has nothing similar. When using the GNU C compiler or any
other compiler that interprets calls to standard I/O functions according to the rules of
the language standard it is necessary to disable such handling by the appropriate compiler
option. Otherwise the behavior of a program that relies on the extension is undefined.

## 12.13.1 Registering New Conversions..........................

The function to register a new output conversion isregister_printf_function, declared
inprintf.h.

int register_printf_function(intspec, printffunction [Function]
handler-function, printfarginfo functionarginfo-function)
Preliminary:|MT-Unsafe const:printfext|AS-Unsafe heap lock|AC-Unsafe mem
lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function defines the conversion specifier characterspec. Thus, ifspecis'Y', it
defines the conversion ¡®%Y¡¯. You can redefine the built-in conversions like ¡®%s¡¯, but
flag characters like ¡®#¡¯ and type modifiers like ¡®l¡¯ can never be used as conversions;
callingregister_printf_functionfor those characters has no effect. It is advisable
not to use lowercase letters, since the ISO C standard warns that additional lowercase
letters may be standardized in future editions of the standard.
Thehandler-functionis the function called byprintfand friends when this conversion
appears in a template string. SeeSection 12.13.3 [Defining the Output Handler],
page 307, for information about how to define a function to pass as this argument. If
you specify a null pointer, any existing handler function forspecis removed.


Chapter 12: Input/Output on Streams 306

```
Thearginfo-functionis the function called byparse_printf_formatwhen this con-
version appears in a template string. SeeSection 12.12.10 [Parsing a Template String],
page 302, for information about this.
Attention: In the GNU C Library versions before 2.0 thearginfo-functionfunction
did not need to be installed unless the user used theparse_printf_formatfunction.
This has changed. Now a call to any of theprintffunctions will call this function
when this format specifier appears in the format string.
The return value is 0 on success, and-1on failure (which occurs ifspecis out of
range).
Portability Note:It is possible to redefine the standard output conversions but doing
so is strongly discouraged because it may interfere with the behavior of programs and
compiler implementations that assume the effects of the conversions conform to the
relevant language standards. In addition, conforming compilers need not guarantee
that the function registered for a standard conversion will be called for each such
conversion in every format string in a program.
```
## 12.13.2 Conversion Specifier Options..........................

If you define a meaning for ¡®%A¡¯, what if the template contains ¡®%+23A¡¯ or ¡®%-#A¡¯? To
implement a sensible meaning for these, the handler when called needs to be able to get the
options specified in the template.

Both thehandler-functionandarginfo-functionaccept an argument that points to a
struct printf_info, which contains information about the options appearing in an in-
stance of the conversion specifier. This data type is declared in the header fileprintf.h.

struct printf_info [Type]
This structure is used to pass information about the options appearing in an instance
of a conversion specifier in aprintftemplate string to the handler and arginfo func-
tions for that specifier. It contains the following members:

```
int prec This is the precision specified. The value is-1if no precision was specified.
If the precision was given as ¡®*¡¯, theprintf_infostructure passed to the
handler function contains the actual value retrieved from the argument
list. But the structure passed to the arginfo function contains a value of
INT_MIN, since the actual value is not known.
```
```
int width This is the minimum field width specified. The value is 0 if no width was
specified. If the field width was given as ¡®*¡¯, theprintf_infostructure
passed to the handler function contains the actual value retrieved from the
argument list. But the structure passed to the arginfo function contains
a value ofINT_MIN, since the actual value is not known.
```
```
wchar_t spec
This is the conversion specifier character specified. It¡¯s stored in the
structure so that you can register the same handler function for multiple
characters, but still have a way to tell them apart when the handler
function is called.
```

Chapter 12: Input/Output on Streams 307

```
unsigned int is_long_double
This is a boolean that is true if the ¡®L¡¯, ¡®ll¡¯, or ¡®q¡¯ type modifier was spec-
ified. For integer conversions, this indicateslong long int, as opposed
tolong doublefor floating point conversions.
unsigned int is_char
This is a boolean that is true if the ¡®hh¡¯ type modifier was specified.
unsigned int is_short
This is a boolean that is true if the ¡®h¡¯ type modifier was specified.
unsigned int is_long
This is a boolean that is true if the ¡®l¡¯ type modifier was specified.
unsigned int alt
This is a boolean that is true if the ¡®#¡¯ flag was specified.
unsigned int space
This is a boolean that is true if the ¡® ¡¯ flag was specified.
unsigned int left
This is a boolean that is true if the ¡®-¡¯ flag was specified.
unsigned int showsign
This is a boolean that is true if the ¡®+¡¯ flag was specified.
unsigned int group
This is a boolean that is true if the ¡®'¡¯ flag was specified.
unsigned int extra
This flag has a special meaning depending on the context. It could be
used freely by the user-defined handlers but when called from theprintf
function this variable always contains the value 0.
unsigned int wide
This flag is set if the stream is wide oriented.
wchar_t pad
This is the character to use for padding the output to the minimum field
width. The value is'0'if the ¡® 0 ¡¯ flag was specified, and' 'otherwise.
```
## 12.13.3 Defining the Output Handler..........................

Now let¡¯s look at how to define the handler and arginfo functions which are passed as
arguments toregister_printf_function.

Compatibility Note:The interface changed in the GNU C Library version 2.0. Previously
the third argument was of typeva_list *.

You should define your handler functions with a prototype like:
intfunction(FILE *stream, const struct printf_info *info,
const void *const *args)
Thestreamargument passed to the handler function is the stream to which it should
write output.

Theinfoargument is a pointer to a structure that contains information about the various
options that were included with the conversion in the template string. You should not


Chapter 12: Input/Output on Streams 308

modify this structure inside your handler function. SeeSection 12.13.2 [Conversion Specifier
Options], page 306, for a description of this data structure.

Theargsis a vector of pointers to the arguments data. The number of arguments was
determined by calling the argument information function provided by the user.

Your handler function should return a value just likeprintfdoes: it should return the
number of characters it has written, or a negative value to indicate an error.

printf_function [Data Type]
This is the data type that a handler function should have.

If you are going to useparse_printf_formatin your application, you must also define
a function to pass as thearginfo-functionargument for each new conversion you install with
register_printf_function.

You have to define these functions with a prototype like:
intfunction(const struct printf_info *info,
size_t n, int *argtypes)
The return value from the function should be the number of arguments the conversion
expects. The function should also fill in no more thannelements of theargtypesarray
with information about the types of each of these arguments. This information is encoded
using the various ¡®PA_¡¯ macros. (You will notice that this is the same calling convention
parse_printf_formatitself uses.)

printf_arginfo_function [Data Type]
This type is used to describe functions that return information about the number and
type of arguments used by a conversion specifier.

## 12.13.4 printfExtension Example............................

Here is an example showing how to define aprintfhandler function. This program defines
a data structure called aWidgetand defines the ¡®%W¡¯ conversion to print information about
Widget *arguments, including the pointer value and the name stored in the data structure.
The ¡®%W¡¯ conversion supports the minimum field width and left-justification options, but
ignores everything else.

```
#include <stdio.h>
#include <stdlib.h>
#include <printf.h>
```
```
typedef struct
{
char *name;
}
Widget;
```
```
int
print_widget (FILE *stream,
const struct printf_info *info,
const void *const *args)
{
const Widget *w;
char *buffer;
int len;
```

Chapter 12: Input/Output on Streams 309

```
/*Format the output into a string.*/
w = *((const Widget **) (args[0]));
len = asprintf (&buffer, "<Widget %p: %s>", w, w->name);
if (len == -1)
return -1;
```
```
/*Pad to the minimum field width and print to the stream.*/
len = fprintf (stream, "%*s",
(info->left? -info->width : info->width),
buffer);
```
```
/*Clean up and return.*/
free (buffer);
return len;
}
```
```
int
print_widget_arginfo (const struct printf_info *info, size_t n,
int *argtypes)
{
/*We always take exactly one argument and this is a pointer to the
structure..*/
if (n > 0)
argtypes[0] = PA_POINTER;
return 1;
}
```
```
int
main (void)
{
/*Make a widget to print.*/
Widget mywidget;
mywidget.name = "mywidget";
```
```
/*Register the print function for widgets.*/
register_printf_function ('W', print_widget, print_widget_arginfo);
```
```
/*Now print the widget.*/
printf ("|%W|\n", &mywidget);
printf ("|%35W|\n", &mywidget);
printf ("|%-35W|\n", &mywidget);
```
```
return 0;
}
The output produced by this program looks like:
|<Widget 0xffeffb7c: mywidget>|
| <Widget 0xffeffb7c: mywidget>|
|<Widget 0xffeffb7c: mywidget> |
```
## 12.13.5 PredefinedprintfHandlers...........................

The GNU C Library also contains a concrete and useful application of theprintfhandler
extension. There are two functions available which implement a special way to print floating-
point numbers.


Chapter 12: Input/Output on Streams 310

int printf_size (FILE *fp, const struct printf info *info, const [Function]
void *const *args)
Preliminary:|MT-Safe race:fp locale|AS-Unsafe corrupt heap|AC-Unsafe mem
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Print a given floating point number as for the format%fexcept that there is a postfix
character indicating the divisor for the number to make this less than 1000. There are
two possible divisors: powers of 1024 or powers of 1000. Which one is used depends
on the format character specified while registered this handler. If the character is of
lower case, 1024 is used. For upper case characters, 1000 is used.
The postfix tag corresponds to bytes, kilobytes, megabytes, gigabytes, etc. The full
table is:
low Multiplier From Upper Multiplier
? 1 ? 1
k 210 = 1024 kilo K 103 = 1000
m 220 mega M 106
g 230 giga G 109
t 240 tera T 1012
p 250 peta P 1015
e 260 exa E 1018
z 270 zetta Z 1021
y 280 yotta Y 1024

```
The default precision is 3, i.e., 1024 is printed with a lower-case format character as
if it were%.3fkand will yield1.000k.
```
Due to the requirements ofregister_printf_functionwe must also provide the func-
tion which returns information about the arguments.

int printf_size_info(const struct printf info *info, size tn, int [Function]
*argtypes)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function will return inargtypesthe information about the used parameters in the
way thevfprintfimplementation expects it. The format always takes one argument.

To use these functions both functions must be registered with a call like
register_printf_function ('B', printf_size, printf_size_info);
Here we register the functions to print numbers as powers of 1000 since the format
character'B'is an upper-case character. If we would additionally use'b'in a line like

```
register_printf_function ('b', printf_size, printf_size_info);
```
we could also print using a power of 1024. Please note that all that is different in these two
lines is the format specifier. Theprintf_sizefunction knows about the difference between
lower and upper case format specifiers.

The use of'B'and'b'is no coincidence. Rather it is the preferred way to use this
functionality since it is available on some other systems which also use format specifiers.


Chapter 12: Input/Output on Streams 311

## 12.14 Formatted Input...........................................

The functions described in this section (scanfand related functions) provide facilities for
formatted input analogous to the formatted output facilities. These functions provide a
mechanism for reading arbitrary values under the control of aformat stringortemplate
string.

12.14.1 Formatted Input Basics

Calls toscanfare superficially similar to calls toprintfin that arbitrary arguments are
read under the control of a template string. While the syntax of the conversion specifications
in the template is very similar to that forprintf, the interpretation of the template is
oriented more towards free-format input and simple pattern matching, rather than fixed-
field formatting. For example, mostscanfconversions skip over any amount of ¡°white
space¡± (including spaces, tabs, and newlines) in the input file, and there is no concept
of precision for the numeric input conversions as there is for the corresponding output
conversions. Ordinarily, non-whitespace characters in the template are expected to match
characters in the input stream exactly, but a matching failure is distinct from an input error
on the stream.

Another area of difference betweenscanfandprintfis that you must remember to
supply pointers rather than immediate values as the optional arguments toscanf; the
values that are read are stored in the objects that the pointers point to. Even experienced
programmers tend to forget this occasionally, so if your program is getting strange errors
that seem to be related toscanf, you might want to double-check this.

When a matching failure occurs, scanf returns immediately, leaving the first non-
matching character as the next character to be read from the stream. The normal re-
turn value fromscanfis the number of values that were assigned, so you can use this to
determine if a matching error happened before all the expected values were read.

Thescanffunction is typically used for things like reading in the contents of tables. For
example, here is a function that usesscanfto initialize an array ofdouble:
void
readarray (double *array, int n)
{
int i;
for (i=0; i<n; i++)
if (scanf (" %lf", &(array[i])) != 1)
invalid_input_error ();
}
The formatted input functions are not used as frequently as the formatted output func-
tions. Partly, this is because it takes some care to use them properly. Another reason is
that it is difficult to recover from a matching error.

If you are trying to read input that doesn¡¯t match a single, fixed pattern, you may be
better off using a tool such as Flex to generate a lexical scanner, or Bison to generate a
parser, rather than usingscanf. For more information about these tools, seeFlex: The
Lexical Scanner Generator, andThe Bison Reference Manual.

## 12.14.2 Input Conversion Syntax..............................

Ascanftemplate string is a string that contains ordinary multibyte characters interspersed
with conversion specifications that start with ¡®%¡¯.


Chapter 12: Input/Output on Streams 312

Any whitespace character (as defined by theisspacefunction; seeSection 4.1 [Classifi-
cation of Characters], page 87) in the template causes any number of whitespace characters
in the input stream to be read and discarded. The whitespace characters that are matched
need not be exactly the same whitespace characters that appear in the template string. For
example, write ¡®,¡¯ in the template to recognize a comma with optional whitespace before
and after.

Other characters in the template string that are not part of conversion specifications
must match characters in the input stream exactly; if this is not the case, a matching
failure occurs.

The conversion specifications in ascanftemplate string have the general form:
%flags width type conversion
In more detail, an input conversion specification consists of an initial ¡®%¡¯ character fol-
lowed in sequence by:

- An optionalflag character¡®*¡¯, which says to ignore the text read for this specification.
    Whenscanffinds a conversion specification that uses this flag, it reads input as directed
    by the rest of the conversion specification, but it discards this input, does not use a
    pointer argument, and does not increment the count of successful assignments.
- An optional flag character ¡®a¡¯ (valid with string conversions only) which requests allo-
    cation of a buffer long enough to store the string in. (This is a GNU extension.) See
    Section 12.14.6 [Dynamically Allocating String Conversions], page 317.
- An optional decimal integer that specifies themaximum field width. Reading of char-
    acters from the input stream stops either when this maximum is reached or when a
    non-matching character is found, whichever happens first. Most conversions discard
    initial whitespace characters (those that don¡¯t are explicitly documented), and these
    discarded characters don¡¯t count towards the maximum field width. String input con-
    versions store a null character to mark the end of the input; the maximum field width
    does not include this terminator.
- An optionaltype modifier character. For example, you can specify a type modifier of
    ¡®l¡¯ with integer conversions such as ¡®%d¡¯ to specify that the argument is a pointer to a
    long intrather than a pointer to anint.
- A character that specifies the conversion to be applied.
    The exact options that are permitted and how they are interpreted vary between the
different conversion specifiers. See the descriptions of the individual conversions for infor-
mation about the particular options that they allow.

With the ¡®-Wformat¡¯ option, the GNU C compiler checks calls toscanfand related
functions. It examines the format string and verifies that the correct number and types of
arguments are supplied. There is also a GNU C syntax to tell the compiler that a function
you write uses ascanf-style format string. SeeSection ¡°Declaring Attributes of Functions¡±
inUsing GNU CC, for more information.

## 12.14.3 Table of Input Conversions............................

Here is a table that summarizes the various conversion specifications:

¡®%d¡¯ Matches an optionally signed integer written in decimal. SeeSection 12.14.4
[Numeric Input Conversions], page 314.


Chapter 12: Input/Output on Streams 313

¡®%i¡¯ Matches an optionally signed integer in any of the formats that the C language
defines for specifying an integer constant. SeeSection 12.14.4 [Numeric Input
Conversions], page 314.

¡®%o¡¯ Matches an unsigned integer written in octal radix. SeeSection 12.14.4 [Nu-
meric Input Conversions], page 314.

¡®%u¡¯ Matches an unsigned integer written in decimal radix. SeeSection 12.14.4
[Numeric Input Conversions], page 314.

¡®%x¡¯, ¡®%X¡¯ Matches an unsigned integer written in hexadecimal radix. SeeSection 12.14.4
[Numeric Input Conversions], page 314.

¡®%e¡¯, ¡®%f¡¯, ¡®%g¡¯, ¡®%E¡¯, ¡®%G¡¯
Matches an optionally signed floating-point number. SeeSection 12.14.4 [Nu-
meric Input Conversions], page 314.

¡®%s¡¯

```
Matches a string containing only non-whitespace characters. SeeSection 12.14.5
[String Input Conversions], page 315. The presence of the ¡®l¡¯ modifier deter-
mines whether the output is stored as a wide character string or a multibyte
string. If ¡®%s¡¯ is used in a wide character function the string is converted as
with multiple calls towcrtombinto a multibyte string. This means that the
buffer must provide room forMB_CUR_MAXbytes for each wide character read.
In case ¡®%ls¡¯ is used in a multibyte function the result is converted into wide
characters as with multiple calls ofmbrtowcbefore being stored in the user
provided buffer.
```
¡®%S¡¯ This is an alias for ¡®%ls¡¯ which is supported for compatibility with the Unix
standard.

¡®%[¡¯ Matches a string of characters that belong to a specified set. SeeSection 12.14.5
[String Input Conversions], page 315. The presence of the ¡®l¡¯ modifier deter-
mines whether the output is stored as a wide character string or a multibyte
string. If ¡®%[¡¯ is used in a wide character function the string is converted as
with multiple calls towcrtombinto a multibyte string. This means that the
buffer must provide room forMB_CUR_MAXbytes for each wide character read.
In case ¡®%l[¡¯ is used in a multibyte function the result is converted into wide
characters as with multiple calls ofmbrtowcbefore being stored in the user
provided buffer.

¡®%c¡¯ Matches a string of one or more characters; the number of characters read is con-
trolled by the maximum field width given for the conversion. SeeSection 12.14.5
[String Input Conversions], page 315.
If ¡®%c¡¯ is used in a wide stream function the read value is converted from a
wide character to the corresponding multibyte character before storing it. Note
that this conversion can produce more than one byte of output and therefore
the provided buffer must be large enough for up toMB_CUR_MAXbytes for each
character. If ¡®%lc¡¯ is used in a multibyte function the input is treated as a
multibyte sequence (and not bytes) and the result is converted as with calls to
mbrtowc.


Chapter 12: Input/Output on Streams 314

¡®%C¡¯ This is an alias for ¡®%lc¡¯ which is supported for compatibility with the Unix
standard.

¡®%p¡¯ Matches a pointer value in the same implementation-defined format used by
the ¡®%p¡¯ output conversion forprintf. SeeSection 12.14.7 [Other Input Con-
versions], page 317.

¡®%n¡¯ This conversion doesn¡¯t read any characters; it records the number of characters
read so far by this call. SeeSection 12.14.7 [Other Input Conversions], page 317.

¡®%%¡¯ This matches a literal ¡®%¡¯ character in the input stream. No corresponding
argument is used. SeeSection 12.14.7 [Other Input Conversions], page 317.
If the syntax of a conversion specification is invalid, the behavior is undefined. If there
aren¡¯t enough function arguments provided to supply addresses for all the conversion spec-
ifications in the template strings that perform assignments, or if the arguments are not of
the correct types, the behavior is also undefined. On the other hand, extra arguments are
simply ignored.

## 12.14.4 Numeric Input Conversions............................

This section describes thescanfconversions for reading numeric values.

The ¡®%d¡¯ conversion matches an optionally signed integer in decimal radix. The syntax
that is recognized is the same as that for thestrtolfunction (seeSection 20.11.1 [Parsing
of Integers], page 635) with the value 10 for thebaseargument.

The ¡®%i¡¯ conversion matches an optionally signed integer in any of the formats that the
C language defines for specifying an integer constant. The syntax that is recognized is the
same as that for thestrtolfunction (seeSection 20.11.1 [Parsing of Integers], page 635)
with the value 0 for thebaseargument. (You can print integers in this syntax withprintf
by using the ¡®#¡¯ flag character with the ¡®%x¡¯, ¡®%o¡¯, or ¡®%d¡¯ conversion. SeeSection 12.12.4
[Integer Conversions], page 291.)

For example, any of the strings ¡® 10 ¡¯, ¡®0xa¡¯, or ¡® 012 ¡¯ could be read in as integers under
the ¡®%i¡¯ conversion. Each of these specifies a number with decimal value 10.

The ¡®%o¡¯, ¡®%u¡¯, and ¡®%x¡¯ conversions match unsigned integers in octal, decimal, and hex-
adecimal radices, respectively. The syntax that is recognized is the same as that for the
strtoulfunction (seeSection 20.11.1 [Parsing of Integers], page 635) with the appropriate
value ( 8 , 10 , or 16 ) for thebaseargument.

The ¡®%X¡¯ conversion is identical to the ¡®%x¡¯ conversion. They both permit either uppercase
or lowercase letters to be used as digits.

The default type of the corresponding argument for the%dand%iconversions isint
*, andunsigned int *for the other integer conversions. You can use the following type
modifiers to specify other sizes of integer:

¡®hh¡¯ Specifies that the argument is asigned char *orunsigned char *.

```
This modifier was introduced in ISO C99.
```
¡®h¡¯ Specifies that the argument is ashort int *orunsigned short int *.

¡®j¡¯ Specifies that the argument is aintmax_t *oruintmax_t *.

```
This modifier was introduced in ISO C99.
```

Chapter 12: Input/Output on Streams 315

¡®l¡¯ Specifies that the argument is along int *orunsigned long int *. Two ¡®l¡¯
characters is like the ¡®L¡¯ modifier, below.
If used with ¡®%c¡¯ or ¡®%s¡¯ the corresponding parameter is considered as a pointer
to a wide character or wide character string respectively. This use of ¡®l¡¯ was
introduced in Amendment 1 to ISO C90.

¡®ll¡¯
¡®L¡¯
¡®q¡¯ Specifies that the argument is along long int *orunsigned long long int
*. (Thelong longtype is an extension supported by the GNU C compiler. For
systems that don¡¯t provide extra-long integers, this is the same aslong int.)
The ¡®q¡¯ modifier is another name for the same thing, which comes from 4.4
BSD; along long intis sometimes called a ¡°quad¡±int.

¡®t¡¯ Specifies that the argument is aptrdiff_t *.

```
This modifier was introduced in ISO C99.
```
¡®z¡¯ Specifies that the argument is asize_t *.

This modifier was introduced in ISO C99.
All of the ¡®%e¡¯, ¡®%f¡¯, ¡®%g¡¯, ¡®%E¡¯, and ¡®%G¡¯ input conversions are interchangeable. They all
match an optionally signed floating point number, in the same syntax as for thestrtod
function (seeSection 20.11.2 [Parsing of Floats], page 640).

For the floating-point input conversions, the default argument type isfloat *. (This
is different from the corresponding output conversions, where the default type isdouble;
remember thatfloatarguments toprintfare converted todoubleby the default argument
promotions, butfloat *arguments are not promoted todouble *.) You can specify other
sizes of float using these type modifiers:

¡®l¡¯ Specifies that the argument is of typedouble *.

¡®L¡¯ Specifies that the argument is of typelong double *.

For all the above number parsing formats there is an additional optional flag ¡®'¡¯. When
this flag is given thescanffunction expects the number represented in the input string to be
formatted according to the grouping rules of the currently selected locale (seeSection 7.7.1.1
[Generic Numeric Formatting Parameters], page 189).

If the"C"or"POSIX"locale is selected there is no difference. But for a locale which
specifies values for the appropriate fields in the locale the input must have the correct form
in the input. Otherwise the longest prefix with a correct form is processed.

## 12.14.5 String Input Conversions..............................

This section describes thescanfinput conversions for reading string and character values:
¡®%s¡¯, ¡®%S¡¯, ¡®%[¡¯, ¡®%c¡¯, and ¡®%C¡¯.

```
You have two options for how to receive the input from these conversions:
```
- Provide a buffer to store it in. This is the default. You should provide an argument of
    typechar *orwchar_t *(the latter if the ¡®l¡¯ modifier is present).
    Warning: To make a robust program, you must make sure that the input (plus its
    terminating null) cannot possibly exceed the size of the buffer you provide. In general,


Chapter 12: Input/Output on Streams 316

```
the only way to do this is to specify a maximum field width one less than the buffer size.
If you provide the buffer, always specify a maximum field width to prevent overflow.
```
- Askscanfto allocate a big enough buffer, by specifying the ¡®a¡¯ flag character. This is
    a GNU extension. You should provide an argument of typechar **for the buffer ad-
    dress to be stored in. SeeSection 12.14.6 [Dynamically Allocating String Conversions],
    page 317.
The ¡®%c¡¯ conversion is the simplest: it matches a fixed number of characters, always. The
maximum field width says how many characters to read; if you don¡¯t specify the maximum,
the default is 1. This conversion doesn¡¯t append a null character to the end of the text it
reads. It also does not skip over initial whitespace characters. It reads precisely the next
ncharacters, and fails if it cannot get that many. Since there is always a maximum field
width with ¡®%c¡¯ (whether specified, or 1 by default), you can always prevent overflow by
making the buffer long enough.

If the format is ¡®%lc¡¯ or ¡®%C¡¯ the function stores wide characters which are converted
using the conversion determined at the time the stream was opened from the external byte
stream. The number of bytes read from the medium is limited byMB_CUR_LEN *nbut at
mostnwide characters get stored in the output string.

The ¡®%s¡¯ conversion matches a string of non-whitespace characters. It skips and dis-
cards initial whitespace, but stops when it encounters more whitespace after having read
something. It stores a null character at the end of the text that it reads.

```
For example, reading the input:
hello, world
```
with the conversion ¡®%10c¡¯ produces" hello, wo", but reading the same input with the
conversion ¡®%10s¡¯ produces"hello,".

Warning: If you do not specify a field width for ¡®%s¡¯, then the number of characters
read is limited only by where the next whitespace character appears. This almost certainly
means that invalid input can make your program crash¡ªwhich is a bug.

The ¡®%ls¡¯ and ¡®%S¡¯ format are handled just like ¡®%s¡¯ except that the external byte sequence
is converted using the conversion associated with the stream to wide characters with their
own encoding. A width or precision specified with the format do not directly determine how
many bytes are read from the stream since they measure wide characters. But an upper
limit can be computed by multiplying the value of the width or precision byMB_CUR_MAX.

To read in characters that belong to an arbitrary set of your choice, use the ¡®%[¡¯ conver-
sion. You specify the set between the ¡®[¡¯ character and a following ¡®]¡¯ character, using the
same syntax used in regular expressions for explicit sets of characters. As special cases:

- A literal ¡®]¡¯ character can be specified as the first character of the set.
- An embedded ¡®-¡¯ character (that is, one that is not the first or last character of the
    set) is used to specify a range of characters.
- If a caret character ¡®^¡¯ immediately follows the initial ¡®[¡¯, then the set of allowed input
    characters is everythingexceptthe characters listed.
The ¡®%[¡¯ conversion does not skip over initial whitespace characters.
Note that thecharacter classsyntax available in character sets that appear inside regular
expressions (such as ¡®[:alpha:]¡¯) isnotavailable in the ¡®%[¡¯ conversion.


Chapter 12: Input/Output on Streams 317

```
Here are some examples of ¡®%[¡¯ conversions and what they mean:
```
¡®%25[1234567890]¡¯
Matches a string of up to 25 digits.

¡®%25[][]¡¯ Matches a string of up to 25 square brackets.

¡®%25[^ \f\n\r\t\v]¡¯
Matches a string up to 25 characters long that doesn¡¯t contain any of the stan-
dard whitespace characters. This is slightly different from ¡®%s¡¯, because if the
input begins with a whitespace character, ¡®%[¡¯ reports a matching failure while
¡®%s¡¯ simply discards the initial whitespace.

¡®%25[a-z]¡¯
Matches up to 25 lowercase characters.
As for ¡®%c¡¯ and ¡®%s¡¯ the ¡®%[¡¯ format is also modified to produce wide characters if the ¡®l¡¯
modifier is present. All what is said about ¡®%ls¡¯ above is true for ¡®%l[¡¯.

One more reminder: the ¡®%s¡¯ and ¡®%[¡¯ conversions aredangerousif you don¡¯t specify a
maximum width or use the ¡®a¡¯ flag, because input too long would overflow whatever buffer
you have provided for it. No matter how long your buffer is, a user could supply input
that is longer. A well-written program reports invalid input with a comprehensible error
message, not with a crash.

## 12.14.6 Dynamically Allocating String Conversions............

A GNU extension to formatted input lets you safely read a string with no maximum size.
Using this feature, you don¡¯t supply a buffer; instead,scanfallocates a buffer big enough
to hold the data and gives you its address. To use this feature, write ¡®a¡¯ as a flag character,
as in ¡®%as¡¯ or ¡®%a[0-9a-z]¡¯.

The pointer argument you supply for where to store the input should have typechar **.
Thescanffunction allocates a buffer and stores its address in the word that the argument
points to. You should free the buffer withfreewhen you no longer need it.

Here is an example of using the ¡®a¡¯ flag with the ¡®%[...]¡¯ conversion specification to
read a ¡°variable assignment¡± of the form ¡®variable=value¡¯.
{
char *variable, *value;

```
if (2 > scanf ("%a[a-zA-Z0-9] = %a[^\n]\n",
&variable, &value))
{
invalid_input_error ();
return 0;
}
```
```
}
```
## 12.14.7 Other Input Conversions..............................

This section describes the miscellaneous input conversions.

The ¡®%p¡¯ conversion is used to read a pointer value. It recognizes the same syntax used
by the ¡®%p¡¯ output conversion forprintf(seeSection 12.12.6 [Other Output Conversions],


Chapter 12: Input/Output on Streams 318

page 295); that is, a hexadecimal number just as the ¡®%x¡¯ conversion accepts. The corre-
sponding argument should be of typevoid **; that is, the address of a place to store a
pointer.

The resulting pointer value is not guaranteed to be valid if it was not originally written
during the same program execution that reads it in.

The ¡®%n¡¯ conversion produces the number of characters read so far by this call. The
corresponding argument should be of typeint *. This conversion works in the same way as
the ¡®%n¡¯ conversion forprintf; seeSection 12.12.6 [Other Output Conversions], page 295,
for an example.

The ¡®%n¡¯ conversion is the only mechanism for determining the success of literal matches
or conversions with suppressed assignments. If the ¡®%n¡¯ follows the locus of a matching
failure, then no value is stored for it sincescanfreturns before processing the ¡®%n¡¯. If you
store-1in that argument slot before callingscanf, the presence of-1afterscanfindicates
an error occurred before the ¡®%n¡¯ was reached.

Finally, the ¡®%%¡¯ conversion matches a literal ¡®%¡¯ character in the input stream, without
using an argument. This conversion does not permit any flags, field width, or type modifier
to be specified.

## 12.14.8 Formatted Input Functions............................

Here are the descriptions of the functions for performing formatted input. Prototypes for
these functions are in the header filestdio.h.

int scanf (const char *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thescanffunction reads formatted input from the streamstdinunder the control
of the template stringtemplate. The optional arguments are pointers to the places
which receive the resulting values.
The return value is normally the number of successful assignments. If an end-of-file
condition is detected before any matches are performed, including matches against
whitespace and literal characters in the template, thenEOFis returned.

int wscanf(const wchar t *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thewscanffunction reads formatted input from the streamstdinunder the control
of the template stringtemplate. The optional arguments are pointers to the places
which receive the resulting values.
The return value is normally the number of successful assignments. If an end-of-file
condition is detected before any matches are performed, including matches against
whitespace and literal characters in the template, thenWEOFis returned.

int fscanf(FILE *stream, const char *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is just likescanf, except that the input is read from the streamstream
instead ofstdin.


Chapter 12: Input/Output on Streams 319

int fwscanf(FILE *stream, const wchar t *template,.. .) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is just likewscanf, except that the input is read from the streamstream
instead ofstdin.

int sscanf(const char *s, const char *template,.. .) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is likescanf, except that the characters are taken from the null-terminated
stringsinstead of from a stream. Reaching the end of the string is treated as an
end-of-file condition.
The behavior of this function is undefined if copying takes place between objects that
overlap¡ªfor example, ifsis also given as an argument to receive a string read under
control of the ¡®%s¡¯, ¡®%S¡¯, or ¡®%[¡¯ conversion.

int swscanf(const wchart *ws, const wchart *template,.. .) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is likewscanf, except that the characters are taken from the null-terminated
stringwsinstead of from a stream. Reaching the end of the string is treated as an
end-of-file condition.
The behavior of this function is undefined if copying takes place between objects that
overlap¡ªfor example, ifwsis also given as an argument to receive a string read under
control of the ¡®%s¡¯, ¡®%S¡¯, or ¡®%[¡¯ conversion.

## 12.14.9 Variable Arguments Input Functions...................

The functionsvscanfand friends are provided so that you can define your own variadic
scanf-like functions that make use of the same internals as the built-in formatted output
functions. These functions are analogous to thevprintfseries of output functions. See
Section 12.12.9 [Variable Arguments Output Functions], page 299, for important informa-
tion on how to use them.

Portability Note: The functions listed in this section were introduced in ISO C99 and
were before available as GNU extensions.

int vscanf(const char *template, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toscanf, but instead of taking a variable number of arguments
directly, it takes an argument list pointerapof typeva_list(seeSection A.2 [Variadic
Functions], page 950).

int vwscanf(const wchart *template, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 320

```
This function is similar towscanf, but instead of taking a variable number of argu-
ments directly, it takes an argument list pointerapof typeva_list(seeSection A.2
[Variadic Functions], page 950).
```
int vfscanf(FILE *stream, const char *template, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent offscanfwith the variable argument list specified directly as
forvscanf.

int vfwscanf (FILE *stream, const wchar t *template, valistap) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe mem lock
corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent offwscanfwith the variable argument list specified directly as
forvwscanf.

int vsscanf(const char *s, const char *template, valistap) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent ofsscanfwith the variable argument list specified directly as
forvscanf.

int vswscanf (const wchart *s, const wchart *template, valist [Function]
ap)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is the equivalent ofswscanfwith the variable argument list specified directly as
forvwscanf.

In GNU C, there is a special construct you can use to let the compiler know that a
function uses ascanf-style format string. Then it can check the number and types of
arguments in each call to the function, and warn you when they do not match the format
string. For details, seeSection ¡°Declaring Attributes of Functions¡± inUsing GNU CC.

## 12.15 End-Of-File and Errors.....................................

Many of the functions described in this chapter return the value of the macroEOFto indicate
unsuccessful completion of the operation. SinceEOFis used to report both end of file and
random errors, it¡¯s often better to use thefeoffunction to check explicitly for end of file and
ferrorto check for errors. These functions check indicators that are part of the internal
state of the stream object, indicators set if the appropriate condition was detected by a
previous I/O operation on that stream.

int EOF [Macro]
This macro is an integer value that is returned by a number of narrow stream functions
to indicate an end-of-file condition, or some other error situation. With the GNU C
Library,EOFis-1. In other libraries, its value may be some other negative number.
This symbol is declared instdio.h.


Chapter 12: Input/Output on Streams 321

int WEOF [Macro]
This macro is an integer value that is returned by a number of wide stream functions
to indicate an end-of-file condition, or some other error situation. With the GNU C
Library,WEOFis-1. In other libraries, its value may be some other negative number.
This symbol is declared inwchar.h.

int feof (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thefeoffunction returns nonzero if and only if the end-of-file indicator for the
streamstreamis set.
This symbol is declared instdio.h.

int feof_unlocked(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefeof_unlockedfunction is equivalent to thefeoffunction except that it does
not implicitly lock the stream.
This function is a GNU extension.
This symbol is declared instdio.h.

int ferror(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Theferrorfunction returns nonzero if and only if the error indicator for the stream
streamis set, indicating that an error has occurred on a previous operation on the
stream.
This symbol is declared instdio.h.

int ferror_unlocked (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theferror_unlockedfunction is equivalent to theferrorfunction except that it
does not implicitly lock the stream.
This function is a GNU extension.
This symbol is declared instdio.h.

In addition to setting the error indicator associated with the stream, the functions that
operate on streams also seterrnoin the same way as the corresponding low-level functions
that operate on file descriptors. For example, all of the functions that perform output
to a stream¡ªsuch asfputc,printf, andfflush¡ªare implemented in terms ofwrite,
and all of theerrnoerror conditions defined forwriteare meaningful for these functions.
For more information about the descriptor-level I/O functions, seeChapter 13 [Low-Level
Input/Output], page 342.


Chapter 12: Input/Output on Streams 322

## 12.16 Recovering from errors.....................................

You may explicitly clear the error and EOF flags with theclearerrfunction.

void clearerr(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function clears the end-of-file and error indicators for the streamstream.
The file positioning functions (seeSection 12.18 [File Positioning], page 323) also clear
the end-of-file indicator for the stream.

void clearerr_unlocked (FILE *stream) [Function]
Preliminary: |MT-Safe race:stream|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theclearerr_unlockedfunction is equivalent to theclearerrfunction except that
it does not implicitly lock the stream.
This function is a GNU extension.

Note that it isnotcorrect to just clear the error flag and retry a failed stream operation.
After a failed write, any number of characters since the last buffer flush may have been
committed to the file, while some buffered data may have been discarded. Merely retrying
can thus cause lost or repeated data.

A failed read may leave the file pointer in an inappropriate position for a second try. In
both cases, you should seek to a known position before retrying.

Most errors that can happen are not recoverable ¡ª a second try will always fail again
in the same way. So usually it is best to give up and report the error to the user, rather
than install complicated recovery logic.

One important exception isEINTR(seeSection 24.5 [Primitives Interrupted by Signals],
page 741). Many stream I/O implementations will treat it as an ordinary error, which can be
quite inconvenient. You can avoid this hassle by installing all signals with theSA_RESTART
flag.

For similar reasons, setting nonblocking I/O on a stream¡¯s file descriptor is not usually
advisable.

## 12.17 Text and Binary Streams...................................

GNU systems and other POSIX-compatible operating systems organize all files as uniform
sequences of characters. However, some other systems make a distinction between files
containing text and files containing binary data, and the input and output facilities of
ISO C provide for this distinction. This section tells you how to write programs portable
to such systems.

When you open a stream, you can specify either atext stream or abinary stream.
You indicate that you want a binary stream by specifying the ¡®b¡¯ modifier in theopentype
argument tofopen; seeSection 12.3 [Opening Streams], page 267. Without this option,
fopenopens the file as a text stream.


Chapter 12: Input/Output on Streams 323

```
Text and binary streams differ in several ways:
```
- The data read from a text stream is divided intolineswhich are terminated by new-
    line ('\n') characters, while a binary stream is simply a long series of characters. A
    text stream might on some systems fail to handle lines more than 254 characters long
    (including the terminating newline character).
- On some systems, text files can contain only printing characters, horizontal tab char-
    acters, and newlines, and so text streams may not support other characters. However,
    binary streams can handle any character value.
- Space characters that are written immediately preceding a newline character in a text
    stream may disappear when the file is read in again.
- More generally, there need not be a one-to-one mapping between characters that are
    read from or written to a text stream, and the characters in the actual file.

Since a binary stream is always more capable and more predictable than a text stream,
you might wonder what purpose text streams serve. Why not simply always use binary
streams? The answer is that on these operating systems, text and binary streams use
different file formats, and the only way to read or write ¡°an ordinary file of text¡± that can
work with other text-oriented programs is through a text stream.

In the GNU C Library, and on all POSIX systems, there is no difference between text
streams and binary streams. When you open a stream, you get the same kind of stream
regardless of whether you ask for binary. This stream can handle any file content, and has
none of the restrictions that text streams sometimes have.

## 12.18 File Positioning............................................

Thefile positionof a stream describes where in the file the stream is currently reading or
writing. I/O on the stream advances the file position through the file. On GNU systems,
the file position is represented as an integer, which counts the number of bytes from the
beginning of the file. SeeSection 11.1.2 [File Position], page 262.

During I/O to an ordinary disk file, you can change the file position whenever you wish,
so as to read or write any portion of the file. Some other kinds of files may also permit this.
Files which support changing the file position are sometimes referred to asrandom-access
files.

You can use the functions in this section to examine or modify the file position indicator
associated with a stream. The symbols listed below are declared in the header filestdio.h.

long int ftell(FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns the current file position of the streamstream.
This function can fail if the stream doesn¡¯t support file positioning, or if the file
position can¡¯t be represented in along int, and possibly for other reasons as well. If
a failure occurs, a value of-1is returned.


Chapter 12: Input/Output on Streams 324

off_t ftello (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theftellofunction is similar toftell, except that it returns a value of typeoff_
t. Systems which support this type use it to describe all file positions, unlike the
POSIX specification which uses a long int. The two are not necessarily the same size.
Therefore, using ftell can lead to problems if the implementation is written on top
of a POSIX compliant low-level I/O implementation, and usingftellois preferable
whenever it is available.
If this function fails it returns(off_t) -1. This can happen due to missing support
for file positioning or internal errors. Otherwise the return value is the current file
position.
The function is an extension defined in the Unix Single Specification version 2.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bit system
this function is in factftello64. I.e., the LFS interface transparently replaces the
old interface.

off64_t ftello64 (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toftellowith the only difference that the return value is
of typeoff64_t. This also requires that the streamstreamwas opened using either
fopen64,freopen64, ortmpfile64since otherwise the underlying file operations to
position the file pointer beyond the 2^31 bytes limit might fail.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the nameftelloand so transparently replaces the old
interface.

int fseek (FILE *stream, long intoffset, intwhence) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefseekfunction is used to change the file position of the streamstream. The
value ofwhencemust be one of the constantsSEEK_SET, SEEK_CUR, orSEEK_END,
to indicate whether theoffsetis relative to the beginning of the file, the current file
position, or the end of the file, respectively.
This function returns a value of zero if the operation was successful, and a nonzero
value to indicate failure. A successful call also clears the end-of-file indicator ofstream
and discards any characters that were ¡°pushed back¡± by the use ofungetc.
fseekeither flushes any buffered output before setting the file position or else re-
members it so it will be written later in its proper place in the file.

int fseeko(FILE *stream, offtoffset, intwhence) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 325

```
This function is similar tofseekbut it corrects a problem withfseekin a system
with POSIX types. Using a value of typelong intfor the offset is not compatible
with POSIX.fseekouses the correct typeoff_tfor theoffsetparameter.
For this reason it is a good idea to preferftellowhenever it is available since its
functionality is (if different at all) closer the underlying definition.
The functionality and return value are the same as forfseek.
The function is an extension defined in the Unix Single Specification version 2.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bit system
this function is in factfseeko64. I.e., the LFS interface transparently replaces the
old interface.
```
int fseeko64 (FILE *stream, off64 toffset, intwhence) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofseekowith the only difference that theoffsetparameter
is of typeoff64_t. This also requires that the streamstreamwas opened using either
fopen64,freopen64, ortmpfile64since otherwise the underlying file operations to
position the file pointer beyond the 2^31 bytes limit might fail.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the namefseekoand so transparently replaces the old
interface.

Portability Note:In non-POSIX systems,ftell,ftello,fseekandfseekomight work
reliably only on binary streams. SeeSection 12.17 [Text and Binary Streams], page 322.

The following symbolic constants are defined for use as thewhenceargument tofseek.
They are also used with thelseekfunction (seeSection 13.2 [Input and Output Primitives],
page 345) and to specify offsets for file locks (seeSection 13.12 [Control Operations on Files],
page 383).

int SEEK_SET [Macro]
This is an integer constant which, when used as thewhenceargument to thefseek
orfseekofunctions, specifies that the offset provided is relative to the beginning of
the file.

int SEEK_CUR [Macro]
This is an integer constant which, when used as thewhenceargument to thefseek
orfseekofunctions, specifies that the offset provided is relative to the current file
position.

int SEEK_END [Macro]
This is an integer constant which, when used as thewhenceargument to thefseek
orfseekofunctions, specifies that the offset provided is relative to the end of the file.

void rewind(FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 326

```
Therewindfunction positions the streamstreamat the beginning of the file. It is
equivalent to callingfseekorfseekoon thestreamwith anoffsetargument of0L
and awhenceargument ofSEEK_SET, except that the return value is discarded and
the error indicator for the stream is reset.
```
These three aliases for the ¡®SEEK_...¡¯ constants exist for the sake of compatibility with
older BSD systems. They are defined in two different header files:fcntl.handsys/file.h.

L_SET An alias forSEEK_SET.

L_INCR An alias forSEEK_CUR.

L_XTND An alias forSEEK_END.

## 12.19 Portable File-Position Functions............................

On GNU systems, the file position is truly a character count. You can specify any character
count value as an argument tofseekorfseekoand get reliable results for any random
access file. However, some ISO C systems do not represent file positions in this way.

On some systems where text streams truly differ from binary streams, it is impossible
to represent the file position of a text stream as a count of characters from the beginning
of the file. For example, the file position on some systems must encode both a record offset
within the file, and a character offset within the record.

As a consequence, if you want your programs to be portable to these systems, you must
observe certain rules:

- The value returned fromftellon a text stream has no predictable relationship to the
    number of characters you have read so far. The only thing you can rely on is that you
    can use it subsequently as theoffsetargument tofseekorfseekoto move back to the
    same file position.
- In a call tofseekorfseekoon a text stream, either theoffsetmust be zero, orwhence
    must beSEEK_SETand theoffsetmust be the result of an earlier call toftellon the
    same stream.
- The value of the file position indicator of a text stream is undefined while there are
    characters that have been pushed back withungetcthat haven¡¯t been read or discarded.
    SeeSection 12.10 [Unreading], page 285.

But even if you observe these rules, you may still have trouble for long files, because
ftellandfseekuse along intvalue to represent the file position. This type may not have
room to encode all the file positions in a large file. Using theftelloandfseekofunctions
might help here since theoff_ttype is expected to be able to hold all file position values
but this still does not help to handle additional information which must be associated with
a file position.

So if you do want to support systems with peculiar encodings for the file positions, it
is better to use the functionsfgetposandfsetposinstead. These functions represent the
file position using the data typefpos_t, whose internal representation varies from system
to system.

```
These symbols are declared in the header filestdio.h.
```

Chapter 12: Input/Output on Streams 327

fpos_t [Data Type]
This is the type of an object that can encode information about the file position of a
stream, for use by the functionsfgetposandfsetpos.
In the GNU C Library,fpos_tis an opaque data structure that contains internal
data to represent file offset and conversion state information. In other systems, it
might have a different internal representation.
When compiling with_FILE_OFFSET_BITS == 64on a 32 bit machine this type is in
fact equivalent tofpos64_tsince the LFS interface transparently replaces the old
interface.

fpos64_t [Data Type]
This is the type of an object that can encode information about the file position of a
stream, for use by the functionsfgetpos64andfsetpos64.
In the GNU C Library,fpos64_tis an opaque data structure that contains internal
data to represent file offset and conversion state information. In other systems, it
might have a different internal representation.

int fgetpos(FILE *stream, fpost *position) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function stores the value of the file position indicator for the streamstreamin the
fpos_tobject pointed to byposition. If successful,fgetposreturns zero; otherwise it
returns a nonzero value and stores an implementation-defined positive value inerrno.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bit system
the function is in factfgetpos64. I.e., the LFS interface transparently replaces the
old interface.

int fgetpos64(FILE *stream, fpos64t *position) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofgetposbut the file position is returned in a variable of
typefpos64_tto whichpositionpoints.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the namefgetposand so transparently replaces the old
interface.

int fsetpos(FILE *stream, const fpost *position) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function sets the file position indicator for the streamstreamto the position
position, which must have been set by a previous call tofgetposon the same stream.
If successful, fsetposclears the end-of-file indicator on the stream, discards any
characters that were ¡°pushed back¡± by the use ofungetc, and returns a value of zero.
Otherwise,fsetposreturns a nonzero value and stores an implementation-defined
positive value inerrno.


Chapter 12: Input/Output on Streams 328

```
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bit system
the function is in factfsetpos64. I.e., the LFS interface transparently replaces the
old interface.
```
int fsetpos64(FILE *stream, const fpos64t *position) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofsetposbut the file position used for positioning is provided
in a variable of typefpos64_tto whichpositionpoints.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the namefsetposand so transparently replaces the old
interface.

## 12.20 Stream Buffering...........................................

Characters that are written to a stream are normally accumulated and transmitted asyn-
chronously to the file in a block, instead of appearing as soon as they are output by the
application program. Similarly, streams often retrieve input from the host environment in
blocks rather than on a character-by-character basis. This is calledbuffering.

If you are writing programs that do interactive input and output using streams, you
need to understand how buffering works when you design the user interface to your program.
Otherwise, you might find that output (such as progress or prompt messages) doesn¡¯t appear
when you intended it to, or displays some other unexpected behavior.

This section deals only with controlling when characters are transmitted between the
stream and the file or device, andnotwith how things like echoing, flow control, and the like
are handled on specific classes of devices. For information on common control operations
on terminal devices, seeChapter 17 [Low-Level Terminal Interface], page 503.

You can bypass the stream buffering facilities altogether by using the low-level input
and output functions that operate on file descriptors instead. SeeChapter 13 [Low-Level
Input/Output], page 342.

## 12.20.1 Buffering Concepts....................................

There are three different kinds of buffering strategies:

- Characters written to or read from anunbufferedstream are transmitted individually
    to or from the file as soon as possible.
- Characters written to aline bufferedstream are transmitted to the file in blocks when
    a newline character is encountered.
- Characters written to or read from afully bufferedstream are transmitted to or from
    the file in blocks of arbitrary size.

Newly opened streams are normally fully buffered, with one exception: a stream
connected to an interactive device such as a terminal is initially line buffered. See
Section 12.20.3 [Controlling Which Kind of Buffering], page 330, for information on how
to select a different kind of buffering. Usually the automatic selection gives you the most
convenient kind of buffering for the file or device you open.


Chapter 12: Input/Output on Streams 329

The use of line buffering for interactive devices implies that output messages ending in
a newline will appear immediately¡ªwhich is usually what you want. Output that doesn¡¯t
end in a newline might or might not show up immediately, so if you want them to ap-
pear immediately, you should flush buffered output explicitly withfflush, as described in
Section 12.20.2 [Flushing Buffers], page 329.

## 12.20.2 Flushing Buffers.......................................

Flushingoutput on a buffered stream means transmitting all accumulated characters to the
file. There are many circumstances when buffered output on a stream is flushed automati-
cally:

- When you try to do output and the output buffer is full.
- When the stream is closed. SeeSection 12.4 [Closing Streams], page 271.
- When the program terminates by callingexit. SeeSection 25.7.1 [Normal Termina-
    tion], page 799.
- When a newline is written, if the stream is line buffered.
- Whenever an input operation onanystream actually reads data from its file.

If you want to flush the buffered output at another time, callfflush, which is declared
in the header filestdio.h.

int fflush(FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function causes any buffered output onstreamto be delivered to the file. If
streamis a null pointer, then fflushcauses buffered output onall open output
streams to be flushed.
This function returnsEOFif a write error occurs, or zero otherwise.

int fflush_unlocked (FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefflush_unlockedfunction is equivalent to thefflushfunction except that it
does not implicitly lock the stream.

Thefflushfunction can be used to flush all streams currently opened. While this
is useful in some situations it does often more than necessary since it might be done in
situations when terminal input is required and the program wants to be sure that all output
is visible on the terminal. But this means that only line buffered streams have to be flushed.
Solaris introduced a function especially for this. It was always available in the GNU C
Library in some form but never officially exported.

void _flushlbf(void) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The_flushlbffunction flushes all line buffered streams currently opened.
This function is declared in thestdio_ext.hheader.


Chapter 12: Input/Output on Streams 330

Compatibility Note:Some brain-damaged operating systems have been known to be so
thoroughly fixated on line-oriented input and output that flushing a line buffered stream
causes a newline to be written! Fortunately, this ¡°feature¡± seems to be becoming less
common. You do not need to worry about this with the GNU C Library.

In some situations it might be useful to not flush the output pending for a stream but
instead simply forget it. If transmission is costly and the output is not needed anymore
this is valid reasoning. In this situation a non-standard function introduced in Solaris and
available in the GNU C Library can be used.

void __fpurge(FILE *stream) [Function]
Preliminary:|MT-Safe race:stream|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The__fpurgefunction causes the buffer of the streamstream to be emptied. If
the stream is currently in read mode all input in the buffer is lost. If the stream is
in output mode the buffered output is not written to the device (or whatever other
underlying storage) and the buffer is cleared.
This function is declared instdio_ext.h.

## 12.20.3 Controlling Which Kind of Buffering...................

After opening a stream (but before any other operations have been performed on it), you
can explicitly specify what kind of buffering you want it to have using thesetvbuffunction.

```
The facilities listed in this section are declared in the header filestdio.h.
```
int setvbuf(FILE *stream, char *buf, intmode, sizetsize) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is used to specify that the streamstreamshould have the buffering mode
mode, which can be either_IOFBF(for full buffering),_IOLBF(for line buffering), or
_IONBF(for unbuffered input/output).
If you specify a null pointer as thebuf argument, thensetvbufallocates a buffer
itself usingmalloc. This buffer will be freed when you close the stream.
Otherwise,bufshould be a character array that can hold at leastsizecharacters. You
should not free the space for this array as long as the stream remains open and this
array remains its buffer. You should usually either allocate it statically, ormalloc
(seeSection 3.2.3 [Unconstrained Allocation], page 45) the buffer. Using an automatic
array is not a good idea unless you close the file before exiting the block that declares
the array.
While the array remains a stream buffer, the stream I/O functions will use the buffer
for their internal purposes. You shouldn¡¯t try to access the values in the array directly
while the stream is using it for buffering.
Thesetvbuffunction returns zero on success, or a nonzero value if the value ofmode
is not valid or if the request could not be honored.


Chapter 12: Input/Output on Streams 331

int _IOFBF [Macro]
The value of this macro is an integer constant expression that can be used as the
modeargument to thesetvbuffunction to specify that the stream should be fully
buffered.

int _IOLBF [Macro]
The value of this macro is an integer constant expression that can be used as the
modeargument to thesetvbuffunction to specify that the stream should be line
buffered.

int _IONBF [Macro]
The value of this macro is an integer constant expression that can be used as themode
argument to thesetvbuffunction to specify that the stream should be unbuffered.

int BUFSIZ [Macro]
The value of this macro is an integer constant expression that is good to use for the
sizeargument tosetvbuf. This value is guaranteed to be at least 256.
The value ofBUFSIZis chosen on each system so as to make stream I/O efficient. So
it is a good idea to useBUFSIZas the size for the buffer when you callsetvbuf.
Actually, you can get an even better value to use for the buffer size by means of
thefstatsystem call: it is found in thest_blksizefield of the file attributes. See
Section 14.9.1 [The meaning of the File Attributes], page 425.
Sometimes people also useBUFSIZas the allocation size of buffers used for related
purposes, such as strings used to receive a line of input withfgets(seeSection 12.8
[Character Input], page 280). There is no particular reason to useBUFSIZfor this
instead of any other integer, except that it might lead to doing I/O in chunks of an
efficient size.

void setbuf(FILE *stream, char *buf) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Ifbuf is a null pointer, the effect of this function is equivalent to callingsetvbuf
with amodeargument of_IONBF. Otherwise, it is equivalent to callingsetvbufwith
buf, and amodeof_IOFBFand asizeargument ofBUFSIZ.
Thesetbuffunction is provided for compatibility with old code; usesetvbufin all
new programs.

void setbuffer(FILE *stream, char *buf, size tsize) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Ifbuf is a null pointer, this function makesstreamunbuffered. Otherwise, it makes
streamfully buffered usingbuf as the buffer. Thesizeargument specifies the length
ofbuf.
This function is provided for compatibility with old BSD code. Usesetvbufinstead.

void setlinebuf (FILE *stream) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 332

```
This function makesstreambe line buffered, and allocates the buffer for you.
This function is provided for compatibility with old BSD code. Usesetvbufinstead.
```
It is possible to query whether a given stream is line buffered or not using a non-standard
function introduced in Solaris and available in the GNU C Library.

int __flbf(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The__flbffunction will return a nonzero value in case the streamstreamis line
buffered. Otherwise the return value is zero.
This function is declared in thestdio_ext.hheader.

Two more extensions allow to determine the size of the buffer and how much of it is
used. These functions were also introduced in Solaris.

size_t __fbufsize(FILE *stream) [Function]
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Safe | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The__fbufsizefunction return the size of the buffer in the streamstream. This
value can be used to optimize the use of the stream.
This function is declared in thestdio_ext.hheader.

size_t __fpending(FILE *stream) [Function]
Preliminary: | MT-Safe race:stream | AS-Unsafe corrupt | AC-Safe | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The__fpendingfunction returns the number of bytes currently in the output buffer.
For wide-oriented streams the measuring unit is wide characters. This function should
not be used on buffers in read mode or opened read-only.
This function is declared in thestdio_ext.hheader.

## 12.21 Other Kinds of Streams....................................

The GNU C Library provides ways for you to define additional kinds of streams that do
not necessarily correspond to an open file.

One such type of stream takes input from or writes output to a string. These kinds
of streams are used internally to implement thesprintfandsscanffunctions. You can
also create such a stream explicitly, using the functions described inSection 12.21.1 [String
Streams], page 333.

More generally, you can define streams that do input/output to arbitrary objects using
functions supplied by your program. This protocol is discussed inSection 12.21.2 [Program-
ming Your Own Custom Streams], page 335.

Portability Note: The facilities described in this section are specific to GNU. Other
systems or C implementations might or might not provide equivalent functionality.


Chapter 12: Input/Output on Streams 333

## 12.21.1 String Streams........................................

Thefmemopenandopen_memstreamfunctions allow you to do I/O to a string or memory
buffer. These facilities are declared instdio.h.

FILE * fmemopen (void *buf, sizetsize, const char *opentype) [Function]
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe mem lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function opens a stream that allows the access specified by theopentypeargu-
ment, that reads from or writes to the buffer specified by the argumentbuf. This
array must be at leastsizebytes long.
If you specify a null pointer as thebuf argument,fmemopendynamically allocates an
arraysizebytes long (as withmalloc; seeSection 3.2.3 [Unconstrained Allocation],
page 45). This is really only useful if you are going to write things to the buffer and
then read them back in again, because you have no way of actually getting a pointer
to the buffer (for this, tryopen_memstream, below). The buffer is freed when the
stream is closed.
The argumentopentypeis the same as infopen(seeSection 12.3 [Opening Streams],
page 267). If theopentypespecifies append mode, then the initial file position is set
to the first null character in the buffer. Otherwise the initial file position is at the
beginning of the buffer.
When a stream open for writing is flushed or closed, a null character (zero byte) is
written at the end of the buffer if it fits. You should add an extra byte to thesize
argument to account for this. Attempts to write more thansizebytes to the buffer
result in an error.
For a stream open for reading, null characters (zero bytes) in the buffer do not count
as ¡°end of file¡±. Read operations indicate end of file only when the file position
advances pastsizebytes. So, if you want to read characters from a null-terminated
string, you should supply the length of the string as thesizeargument.

```
Here is an example of usingfmemopento create a stream for reading from a string:
```
```
#include <stdio.h>
```
```
static char buffer[] = "foobar";
```
```
int
main (void)
{
int ch;
FILE *stream;
```
```
stream = fmemopen (buffer, strlen (buffer), "r");
while ((ch = fgetc (stream)) != EOF)
printf ("Got %c\n", ch);
fclose (stream);
```
```
return 0;
}
This program produces the following output:
Got f
```

Chapter 12: Input/Output on Streams 334

```
Got o
Got o
Got b
Got a
Got r
```
FILE * open_memstream(char **ptr, sizet *sizeloc) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.

```
This function opens a stream for writing to a buffer. The buffer is allocated dynam-
ically and grown as necessary, usingmalloc. After you¡¯ve closed the stream, this
buffer is your responsibility to clean up usingfreeorrealloc. SeeSection 3.2.3
[Unconstrained Allocation], page 45.
```
```
When the stream is closed withfcloseor flushed withfflush, the locationsptrand
sizelocare updated to contain the pointer to the buffer and its size. The values thus
stored remain valid only as long as no further output on the stream takes place. If
you do more output, you must flush the stream again to store new values before you
use them again.
```
```
A null character is written at the end of the buffer. This null character isnotincluded
in the size value stored atsizeloc.
```
```
You can move the stream¡¯s file position withfseekorfseeko(seeSection 12.18 [File
Positioning], page 323). Moving the file position past the end of the data already
written fills the intervening space with zeroes.
```
```
Here is an example of usingopen_memstream:
```
```
#include <stdio.h>
```
```
int
main (void)
{
char *bp;
size_t size;
FILE *stream;
```
```
stream = open_memstream (&bp, &size);
fprintf (stream, "hello");
fflush (stream);
printf ("buf = `%s', size = %zu\n", bp, size);
fprintf (stream, ", world");
fclose (stream);
printf ("buf = `%s', size = %zu\n", bp, size);
```
```
return 0;
}
```
```
This program produces the following output:
buf = `hello', size = 5
buf = `hello, world', size = 12
```

Chapter 12: Input/Output on Streams 335

## 12.21.2 Programming Your Own Custom Streams.............

This section describes how you can make a stream that gets input from an arbitrary data
source or writes output to an arbitrary data sink programmed by you. We call thesecustom
streams. The functions and types described here are all GNU extensions.

## 12.21.2.1 Custom Streams and Cookies.....................

Inside every custom stream is a special object called thecookie. This is an object supplied
by you which records where to fetch or store the data read or written. It is up to you to
define a data type to use for the cookie. The stream functions in the library never refer
directly to its contents, and they don¡¯t even know what the type is; they record its address
with typevoid *.

To implement a custom stream, you must specifyhowto fetch or store the data in the
specified place. You do this by defininghook functionsto read, write, change ¡°file position¡±,
and close the stream. All four of these functions will be passed the stream¡¯s cookie so they
can tell where to fetch or store the data. The library functions don¡¯t know what¡¯s inside
the cookie, but your functions will know.

When you create a custom stream, you must specify the cookie pointer, and also the
four hook functions stored in a structure of typecookie_io_functions_t.

```
These facilities are declared instdio.h.
```
cookie_io_functions_t [Data Type]
This is a structure type that holds the functions that define the communications
protocol between the stream and its cookie. It has the following members:

```
cookie_read_function_t *read
This is the function that reads data from the cookie. If the value is a null
pointer instead of a function, then read operations on this stream always
returnEOF.
```
```
cookie_write_function_t *write
This is the function that writes data to the cookie. If the value is a null
pointer instead of a function, then data written to the stream is discarded.
```
```
cookie_seek_function_t *seek
This is the function that performs the equivalent of file positioning on the
cookie. If the value is a null pointer instead of a function, calls tofseek
orfseekoon this stream can only seek to locations within the buffer; any
attempt to seek outside the buffer will return anESPIPEerror.
cookie_close_function_t *close
This function performs any appropriate cleanup on the cookie when clos-
ing the stream. If the value is a null pointer instead of a function, nothing
special is done to close the cookie when the stream is closed.
```
FILE * fopencookie(void *cookie, const char *opentype, [Function]
cookieiofunctionstio-functions)
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe mem lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 12: Input/Output on Streams 336

```
This function actually creates the stream for communicating with thecookieusing
the functions in theio-functionsargument. Theopentypeargument is interpreted as
forfopen; seeSection 12.3 [Opening Streams], page 267. (But note that the ¡°truncate
on open¡± option is ignored.) The new stream is fully buffered.
Thefopencookiefunction returns the newly created stream, or a null pointer in case
of an error.
```
## 12.21.2.2 Custom Stream Hook Functions..................

Here are more details on how you should define the four hook functions that a custom
stream needs.

You should define the function to read data from the cookie as:
ssize_treader(void *cookie, char *buffer, size_tsize)
This is very similar to thereadfunction; seeSection 13.2 [Input and Output Primitives],
page 345. Your function should transfer up tosizebytes into thebuffer, and return the
number of bytes read, or zero to indicate end-of-file. You can return a value of-1to indicate
an error.

You should define the function to write data to the cookie as:
ssize_twriter(void *cookie, const char *buffer, size_tsize)
This is very similar to thewritefunction; seeSection 13.2 [Input and Output Primitives],
page 345. Your function should transfer up tosizebytes from the buffer, and return the
number of bytes written. You can return a value of 0 to indicate an error. You must not
return any negative value.

You should define the function to perform seek operations on the cookie as:
intseeker(void *cookie, off64_t *position, intwhence)
For this function, thepositionandwhencearguments are interpreted as forfgetpos;
seeSection 12.19 [Portable File-Position Functions], page 326.

After doing the seek operation, your function should store the resulting file position
relative to the beginning of the file inposition. Your function should return a value of 0 on
success and-1to indicate an error.

You should define the function to do cleanup operations on the cookie appropriate for
closing the stream as:
intcleaner(void *cookie)
Your function should return-1to indicate an error, and 0 otherwise.

cookie_read_function_t [Data Type]
This is the data type that the read function for a custom stream should have. If you
declare the function as shown above, this is the type it will have.

cookie_write_function_t [Data Type]
The data type of the write function for a custom stream.

cookie_seek_function_t [Data Type]
The data type of the seek function for a custom stream.

cookie_close_function_t [Data Type]
The data type of the close function for a custom stream.


Chapter 12: Input/Output on Streams 337

## 12.22 Formatted Messages........................................

On systems which are based on System V messages of programs (especially the system
tools) are printed in a strict form using thefmtmsgfunction. The uniformity sometimes
helps the user to interpret messages and the strictness tests of thefmtmsgfunction ensure
that the programmer follows some minimal requirements.

## 12.22.1 Printing Formatted Messages..........................

Messages can be printed to standard error and/or to the console. To select the destination
the programmer can use the following two values, bitwise OR combined if wanted, for the
classificationparameter offmtmsg:

MM_PRINT Display the message in standard error.

MM_CONSOLE
Display the message on the system console.
The erroneous piece of the system can be signalled by exactly one of the following values
which also is bitwise ORed with theclassificationparameter tofmtmsg:

MM_HARD The source of the condition is some hardware.

MM_SOFT The source of the condition is some software.

MM_FIRM The source of the condition is some firmware.

A third component of theclassificationparameter tofmtmsgcan describe the part of
the system which detects the problem. This is done by using exactly one of the following
values:

MM_APPL The erroneous condition is detected by the application.

MM_UTIL The erroneous condition is detected by a utility.

MM_OPSYS The erroneous condition is detected by the operating system.

A last component ofclassificationcan signal the results of this message. Exactly one of
the following values can be used:

MM_RECOVER
It is a recoverable error.

MM_NRECOV
It is a non-recoverable error.

int fmtmsg(long intclassification, const char *label, int [Function]
severity, const char *text, const char *action, const char *tag)
Preliminary:|MT-Safe |AS-Unsafe lock|AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Display a message described by its parameters on the device(s) specified in theclas-
sificationparameter. Thelabelparameter identifies the source of the message. The
string should consist of two colon separated parts where the first part has not more
than 10 and the second part not more than 14 characters. Thetextparameter de-
scribes the condition of the error, theactionparameter possible steps to recover from
the error and thetag parameter is a reference to the online documentation where


Chapter 12: Input/Output on Streams 338

```
more information can be found. It should contain thelabelvalue and a unique iden-
tification number.
Each of the parameters can be a special value which means this value is to be omitted.
The symbolic names for these values are:
MM_NULLLBL
Ignorelabelparameter.
MM_NULLSEV
Ignoreseverityparameter.
MM_NULLMC
Ignore classificationparameter. This implies that nothing is actually
printed.
MM_NULLTXT
Ignoretextparameter.
MM_NULLACT
Ignoreactionparameter.
MM_NULLTAG
Ignoretagparameter.
There is another way certain fields can be omitted from the output to standard error.
This is described below in the description of environment variables influencing the
behavior.
Theseverityparameter can have one of the values in the following table:
MM_NOSEV Nothing is printed, this value is the same asMM_NULLSEV.
MM_HALT This value is printed asHALT.
MM_ERROR This value is printed asERROR.
MM_WARNING
This value is printed asWARNING.
MM_INFO This value is printed asINFO.
The numeric value of these five macros are between 0 and 4. Using the environ-
ment variable SEV_LEVELor using the addseverityfunction one can add more
severity levels with their corresponding string to print. This is described below (see
Section 12.22.2 [Adding Severity Classes], page 339).
If no parameter is ignored the output looks like this:
label:severity-string:text
TO FIX:action tag
The colons, new line characters and theTO FIXstring are inserted if necessary, i.e., if
the corresponding parameter is not ignored.
This function is specified in the X/Open Portability Guide. It is also available on all
systems derived from System V.
The function returns the valueMM_OKif no error occurred. If only the printing to
standard error failed, it returnsMM_NOMSG. If printing to the console fails, it returns
MM_NOCON. If nothing is printedMM_NOTOKis returned. Among situations where all
outputs fail this last value is also returned if a parameter value is incorrect.
```

Chapter 12: Input/Output on Streams 339

There are two environment variables which influence the behavior offmtmsg. The first
isMSGVERB. It is used to control the output actually happening on standard error (notthe
console output). Each of the five fields can explicitly be enabled. To do this the user has to
put theMSGVERBvariable with a format like the following in the environment before calling
thefmtmsgfunction the first time:

MSGVERB=keyword[:keyword[:...]]
Validkeywords arelabel,severity,text,action, andtag. If the environment variable
is not given or is the empty string, a not supported keyword is given or the value is somehow
else invalid, no part of the message is masked out.

The second environment variable which influences the behavior offmtmsgisSEV_LEVEL.
This variable and the change in the behavior offmtmsg is not specified in the X/Open
Portability Guide. It is available in System V systems, though. It can be used to introduce
new severity levels. By default, only the five severity levels described above are available.
Any other numeric value would makefmtmsgprint nothing.

```
If the user putsSEV_LEVELwith a format like
SEV_LEVEL=[description[:description[:...]]]
```
in the environment of the process before the first call tofmtmsg, wheredescriptionhas a
value of the form

severity-keyword,level,printstring
Theseverity-keywordpart is not used byfmtmsgbut it has to be present. Thelevel
part is a string representation of a number. The numeric value must be a number greater
than 4. This value must be used in theseverityparameter offmtmsgto select this class.
It is not possible to overwrite any of the predefined classes. Theprintstringis the string
printed when a message of this class is processed byfmtmsg(see above,fmtsmgdoes not
print the numeric value but instead the string representation).

## 12.22.2 Adding Severity Classes...............................

There is another possibility to introduce severity classes besides using the environment vari-
ableSEV_LEVEL. This simplifies the task of introducing new classes in a running program.
One could use thesetenvorputenvfunction to set the environment variable, but this is
toilsome.

int addseverity (intseverity, const char *string) [Function]
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function allows the introduction of new severity classes which can be addressed
by the severity parameter of the fmtmsg function. The severity parameter of
addseverity must match the value for the parameter with the same name of
fmtmsg, and string is the string printed in the actual messages instead of the
numeric value.
Ifstring isNULLthe severity class with the numeric value according toseverity is
removed.
It is not possible to overwrite or remove one of the default severity classes. All calls
toaddseveritywithseverityset to one of the values for the default classes will fail.


Chapter 12: Input/Output on Streams 340

```
The return value isMM_OKif the task was successfully performed. If the return value is
MM_NOTOKsomething went wrong. This could mean that no more memory is available
or a class is not available when it has to be removed.
This function is not specified in the X/Open Portability Guide although thefmtsmg
function is. It is available on System V systems.
```
## 12.22.3 How to usefmtmsgandaddseverity..................

Here is a simple example program to illustrate the use of both functions described in this
section.

```
#include <fmtmsg.h>
```
int
main (void)
{
addseverity (5, "NOTE2");
fmtmsg (MM_PRINT, "only1field", MM_INFO, "text2", "action2", "tag2");
fmtmsg (MM_PRINT, "UX:cat", 5, "invalid syntax", "refer to manual",
"UX:cat:001");
fmtmsg (MM_PRINT, "label:foo", 6, "text", "action", "tag");
return 0;
}
The second call tofmtmsgillustrates a use of this function as it usually occurs on System
V systems, which heavily use this function. It seems worthwhile to give a short explanation
here of how this system works on System V. The value of thelabelfield (UX:cat) says that
the error occurred in the Unix programcat. The explanation of the error follows and the
value for theactionparameter is"refer to manual". One could be more specific here, if
necessary. Thetagfield contains, as proposed above, the value of the string given for the
labelparameter, and additionally a unique ID ( 001 in this case). For a GNU environment
this string could contain a reference to the corresponding node in the Info page for the
program.

Running this program without specifying theMSGVERBandSEV_LEVELfunction produces
the following output:
UX:cat: NOTE2: invalid syntax
TO FIX: refer to manual UX:cat:001
We see the different fields of the message and how the extra glue (the colons and theTO
FIXstring) is printed. But only one of the three calls tofmtmsgproduced output. The first
call does not print anything because thelabelparameter is not in the correct form. The
string must contain two fields, separated by a colon (seeSection 12.22.1 [Printing Formatted
Messages], page 337). The thirdfmtmsgcall produced no output since the class with the
numeric value 6 is not defined. Although a class with numeric value 5 is also not defined
by default, the call toaddseverityintroduces it and the second call tofmtmsgproduces
the above output.

When we change the environment of the program to containSEV_LEVEL=XXX,6,NOTE
when running it we get a different result:
UX:cat: NOTE2: invalid syntax
TO FIX: refer to manual UX:cat:001
label:foo: NOTE: text
TO FIX: action tag


Chapter 12: Input/Output on Streams 341

Now the third call tofmtmsgproduced some output and we see how the stringNOTE
from the environment variable appears in the message.

Now we can reduce the output by specifying which fields we are interested in. If we
additionally set the environment variableMSGVERBto the valueseverity:label:action
we get the following output:
UX:cat: NOTE2
TO FIX: refer to manual
label:foo: NOTE
TO FIX: action

I.e., the output produced by thetextand thetag parameters tofmtmsgvanished. Please
also note that now there is no colon after theNOTEandNOTE2strings in the output. This
is not necessary since there is no more output on this line because the text is missing.


### 342

## 13 Low-Level Input/Output....................

## 13 Low-Level Input/Output..............................

This chapter describes functions for performing low-level input/output operations on file de-
scriptors. These functions include the primitives for the higher-level I/O functions described
inChapter 12 [Input/Output on Streams], page 266, as well as functions for performing
low-level control operations for which there are no equivalents on streams.

Stream-level I/O is more flexible and usually more convenient; therefore, programmers
generally use the descriptor-level functions only when necessary. These are some of the
usual reasons:

- For reading binary files in large chunks.
- For reading an entire file into core before parsing it.
- To perform operations other than data transfer, which can only be done with a de-
    scriptor. (You can usefilenoto get the descriptor corresponding to a stream.)
- To pass descriptors to a child process. (The child can create its own stream to use a
    descriptor that it inherits, but cannot inherit a stream directly.)

## 13.1 Opening and Closing Files...................................

This section describes the primitives for opening and closing files using file descriptors. The
openandcreatfunctions are declared in the header filefcntl.h, whilecloseis declared
inunistd.h.

int open (const char *filename, intflags[, modetmode]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theopenfunction creates and returns a new file descriptor for the file named by
filename. Initially, the file position indicator for the file is at the beginning of the
file. The argumentmode(seeSection 14.9.5 [The Mode Bits for Access Permission],
page 434) is used only when a file is created, but it doesn¡¯t hurt to supply the argument
in any case.
Theflagsargument controls how the file is to be opened. This is a bit mask; you create
the value by the bitwise OR of the appropriate parameters (using the ¡®|¡¯ operator in
C). SeeSection 13.15 [File Status Flags], page 387, for the parameters available.
The normal return value fromopenis a non-negative integer file descriptor. In the
case of an error, a value of?1 is returned instead. In addition to the usual file name
errors (seeSection 11.2.3 [File Name Errors], page 264), the followingerrnoerror
conditions are defined for this function:
EACCES The file exists but is not readable/writable as requested by the flags
argument, or the file does not exist and the directory is unwritable so it
cannot be created.
EEXIST BothO_CREATandO_EXCLare set, and the named file already exists.
EINTR Theopenoperation was interrupted by a signal. SeeSection 24.5 [Prim-
itives Interrupted by Signals], page 741.
EISDIR Theflagsargument specified write access, and the file is a directory.


Chapter 13: Low-Level Input/Output 343

```
EMFILE The process has too many files open. The maximum number of file
descriptors is controlled by the RLIMIT_NOFILE resource limit; see
Section 22.2 [Limiting Resource Usage], page 685.
```
```
ENFILE The entire system, or perhaps the file system which contains the directory,
cannot support any additional open files at the moment. (This problem
cannot happen on GNU/Hurd systems.)
```
```
ENOENT The named file does not exist, andO_CREATis not specified.
```
```
ENOSPC The directory or file system that would contain the new file cannot be
extended, because there is no disk space left.
```
```
ENXIO O_NONBLOCK and O_WRONLY are both set in the flags argument, the
file named byfilename is a FIFO (seeChapter 15 [Pipes and FIFOs],
page 450), and no process has the file open for reading.
```
```
EROFS The file resides on a read-only file system and any ofO_WRONLY,O_RDWR,
andO_TRUNCare set in theflagsargument, orO_CREATis set and the file
does not already exist.
```
```
If on a 32 bit machine the sources are translated with_FILE_OFFSET_BITS == 64the
functionopenreturns a file descriptor opened in the large file mode which enables
the file handling functions to use files up to 2^63 bytes in size and offset from? 263 to
263. This happens transparently for the user since all of the low-level file handling
functions are equally replaced.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timeopenis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this calls toopenshould be protected
using cancellation handlers.
Theopenfunction is the underlying primitive for thefopenandfreopenfunctions,
that create streams.
```
int open64(const char *filename, intflags[, modetmode]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar toopen. It returns a file descriptor which can be used to
access the file named byfilename. The only difference is that on 32 bit systems the
file is opened in the large file mode. I.e., file length and file offsets can exceed 31 bits.
When the sources are translated with_FILE_OFFSET_BITS == 64this function is ac-
tually available under the nameopen. I.e., the new, extended API using 64 bit file
sizes and offsets transparently replaces the old API.

int creat (const char *filename, modetmode) [Obsolete function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is obsolete. The call:
creat (filename,mode)


Chapter 13: Low-Level Input/Output 344

```
is equivalent to:
open (filename, O_WRONLY | O_CREAT | O_TRUNC,mode)
If on a 32 bit machine the sources are translated with_FILE_OFFSET_BITS == 64the
functioncreatreturns a file descriptor opened in the large file mode which enables
the file handling functions to use files up to 2^63 in size and offset from? 263 to 2^63. This
happens transparently for the user since all of the low-level file handling functions are
equally replaced.
```
int creat64(const char *filename, modetmode) [Obsolete function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tocreat. It returns a file descriptor which can be used to
access the file named byfilename. The only difference is that on 32 bit systems the
file is opened in the large file mode. I.e., file length and file offsets can exceed 31 bits.
To use this file descriptor one must not use the normal operations but instead the
counterparts named*64, e.g.,read64.
When the sources are translated with_FILE_OFFSET_BITS == 64this function is ac-
tually available under the nameopen. I.e., the new, extended API using 64 bit file
sizes and offsets transparently replaces the old API.

int close (intfiledes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functionclosecloses the file descriptorfiledes. Closing a file has the following
consequences:

- The file descriptor is deallocated.
- Any record locks owned by the process on the file are unlocked.
- When all file descriptors associated with a pipe or FIFO have been closed, any
    unread data is discarded.

```
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timecloseis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this, calls tocloseshould be protected
using cancellation handlers.
The normal return value fromcloseis 0; a value of?1 is returned in case of failure.
The followingerrnoerror conditions are defined for this function:
```
```
EBADF Thefiledesargument is not a valid file descriptor.
```
```
EINTR Theclosecall was interrupted by a signal. SeeSection 24.5 [Primitives
Interrupted by Signals], page 741. Here is an example of how to handle
EINTRproperly:
TEMP_FAILURE_RETRY (close (desc));
```

Chapter 13: Low-Level Input/Output 345

### ENOSPC

### EIO

```
EDQUOT When the file is accessed by NFS, these errors from writecan some-
times not be detected untilclose. SeeSection 13.2 [Input and Output
Primitives], page 345, for details on their meaning.
```
```
Please note that there isnoseparateclose64function. This is not necessary since
this function does not determine nor depend on the mode of the file. The kernel which
performs thecloseoperation knows which mode the descriptor is used for and can
handle this situation.
```
To close a stream, callfclose(seeSection 12.4 [Closing Streams], page 271) instead of
trying to close its underlying file descriptor withclose. This flushes any buffered output
and updates the stream object to indicate that it is closed.

## 13.2 Input and Output Primitives................................

This section describes the functions for performing primitive input and output operations
on file descriptors:read,write, andlseek. These functions are declared in the header file
unistd.h.

ssize_t [Data Type]
This data type is used to represent the sizes of blocks that can be read or written in
a single operation. It is similar tosize_t, but must be a signed type.

ssize_t read (intfiledes, void *buffer, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thereadfunction reads up tosizebytes from the file with descriptorfiledes, storing
the results in thebuffer. (This is not necessarily a character string, and no terminating
null character is added.)
The return value is the number of bytes actually read. This might be less thansize;
for example, if there aren¡¯t that many bytes left in the file or if there aren¡¯t that many
bytes immediately available. The exact behavior depends on what kind of file it is.
Note that reading less thansizebytes is not an error.
A value of zero indicates end-of-file (except if the value of thesizeargument is also
zero). This is not considered an error. If you keep callingreadwhile at end-of-file, it
will keep returning zero and doing nothing else.
Ifreadreturns at least one character, there is no way you can tell whether end-of-file
was reached. But if you did reach the end, the next read will return zero.
In case of an error,readreturns?1. The followingerrnoerror conditions are defined
for this function:

```
EAGAIN Normally, when no input is immediately available,readwaits for some
input. But if theO_NONBLOCKflag is set for the file (seeSection 13.15
[File Status Flags], page 387),readreturns immediately without reading
any data, and reports this error.
```

Chapter 13: Low-Level Input/Output 346

```
Compatibility Note:Most versions of BSD Unix use a different error code
for this:EWOULDBLOCK. In the GNU C Library,EWOULDBLOCKis an alias
forEAGAIN, so it doesn¡¯t matter which name you use.
On some systems, reading a large amount of data from a character special
file can also fail withEAGAINif the kernel cannot find enough physical
memory to lock down the user¡¯s pages. This is limited to devices that
transfer with direct memory access into the user¡¯s memory, which means
it does not include terminals, since they always use separate buffers inside
the kernel. This problem never happens on GNU/Hurd systems.
Any condition that could result inEAGAINcan instead result in a success-
fulreadwhich returns fewer bytes than requested. Callingreadagain
immediately would result inEAGAIN.
EBADF Thefiledes argument is not a valid file descriptor, or is not open for
reading.
EINTR readwas interrupted by a signal while it was waiting for input. See
Section 24.5 [Primitives Interrupted by Signals], page 741. A signal will
not necessarily cause readto returnEINTR; it may instead result in a
successfulreadwhich returns fewer bytes than requested.
EIO For many devices, and for disk files, this error code indicates a hardware
error.
EIOalso occurs when a background process tries to read from the control-
ling terminal, and the normal action of stopping the process by sending
it aSIGTTINsignal isn¡¯t working. This might happen if the signal is
being blocked or ignored, or because the process group is orphaned. See
Chapter 28 [Job Control], page 817, for more information about job con-
trol, andChapter 24 [Signal Handling], page 714, for information about
signals.
EINVAL In some systems, when reading from a character or block device, position
and size offsets must be aligned to a particular block size. This error
indicates that the offsets were not properly aligned.
Please note that there is no function namedread64. This is not necessary since this
function does not directly modify or handle the possibly wide file offset. Since the
kernel handles this state internally, thereadfunction can be used for all cases.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timereadis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this, calls toreadshould be protected
using cancellation handlers.
Thereadfunction is the underlying primitive for all of the functions that read from
streams, such asfgetc.
```
ssize_t pread(intfiledes, void *buffer, size tsize, off t [Function]
offset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 13: Low-Level Input/Output 347

```
Thepreadfunction is similar to thereadfunction. The first three arguments are
identical, and the return values and error codes also correspond.
The difference is the fourth argument and its handling. The data block is not read
from the current position of the file descriptorfiledes. Instead the data is read
from the file starting at positionoffset. The position of the file descriptor itself is not
affected by the operation. The value is the same as before the call.
When the source file is compiled with_FILE_OFFSET_BITS == 64thepreadfunction
is in factpread64and the typeoff_thas 64 bits, which makes it possible to handle
files up to 2^63 bytes in length.
The return value ofpreaddescribes the number of bytes read. In the error case it
returns?1 likereaddoes and the error codes are also the same, with these additions:
```
```
EINVAL The value given foroffsetis negative and therefore illegal.
```
```
ESPIPE The file descriptorfiledesis associated with a pipe or a FIFO and this
device does not allow positioning of the file pointer.
The function is an extension defined in the Unix Single Specification version 2.
```
ssize_t pread64 (intfiledes, void *buffer, sizetsize, off64t [Function]
offset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepreadfunction. The difference is that the offset
parameter is of typeoff64_tinstead ofoff_twhich makes it possible on 32 bit
machines to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptor
filedesmust be opened usingopen64since otherwise the large offsets possible with
off64_twill lead to errors with a descriptor in small file mode.
When the source file is compiled with_FILE_OFFSET_BITS == 64on a 32 bit machine
this function is actually available under the namepreadand so transparently replaces
the 32 bit interface.

ssize_t write(intfiledes, const void *buffer, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewritefunction writes up tosizebytes frombufferto the file with descriptor
filedes. The data inbufferis not necessarily a character string and a null character
is output like any other character.
The return value is the number of bytes actually written. This may besize, but can
always be smaller. Your program should always callwritein a loop, iterating until
all the data is written.
Oncewritereturns, the data is enqueued to be written and can be read back right
away, but it is not necessarily written out to permanent storage immediately. You can
usefsyncwhen you need to be sure your data has been permanently stored before
continuing. (It is more efficient for the system to batch up consecutive writes and
do them all at once when convenient. Normally they will always be written to disk
within a minute or less.) Modern systems provide another functionfdatasyncwhich


Chapter 13: Low-Level Input/Output 348

```
guarantees integrity only for the file data and is therefore faster. You can use the
O_FSYNCopen mode to makewritealways store the data to disk before returning;
seeSection 13.15.3 [I/O Operating Modes], page 391.
In the case of an error,writereturns?1. The followingerrnoerror conditions are
defined for this function:
```
```
EAGAIN Normally,writeblocks until the write operation is complete. But if the
O_NONBLOCKflag is set for the file (seeSection 13.12 [Control Operations
on Files], page 383), it returns immediately without writing any data
and reports this error. An example of a situation that might cause the
process to block on output is writing to a terminal device that supports
flow control, where output has been suspended by receipt of a STOP
character.
Compatibility Note:Most versions of BSD Unix use a different error code
for this:EWOULDBLOCK. In the GNU C Library,EWOULDBLOCKis an alias
forEAGAIN, so it doesn¡¯t matter which name you use.
On some systems, writing a large amount of data from a character special
file can also fail withEAGAINif the kernel cannot find enough physical
memory to lock down the user¡¯s pages. This is limited to devices that
transfer with direct memory access into the user¡¯s memory, which means
it does not include terminals, since they always use separate buffers inside
the kernel. This problem does not arise on GNU/Hurd systems.
```
```
EBADF Thefiledes argument is not a valid file descriptor, or is not open for
writing.
```
```
EFBIG The size of the file would become larger than the implementation can
support.
```
```
EINTR Thewriteoperation was interrupted by a signal while it was blocked
waiting for completion. A signal will not necessarily causewriteto return
EINTR; it may instead result in a successfulwritewhich writes fewer bytes
than requested. SeeSection 24.5 [Primitives Interrupted by Signals],
page 741.
```
```
EIO For many devices, and for disk files, this error code indicates a hardware
error.
```
```
ENOSPC The device containing the file is full.
```
```
EPIPE This error is returned when you try to write to a pipe or FIFO that isn¡¯t
open for reading by any process. When this happens, aSIGPIPEsignal
is also sent to the process; seeChapter 24 [Signal Handling], page 714.
```
```
EINVAL In some systems, when writing to a character or block device, position
and size offsets must be aligned to a particular block size. This error
indicates that the offsets were not properly aligned.
```
```
Unless you have arranged to preventEINTRfailures, you should check errnoafter
each failing call towrite, and if the error wasEINTR, you should simply repeat the
```

Chapter 13: Low-Level Input/Output 349

```
call. SeeSection 24.5 [Primitives Interrupted by Signals], page 741. The easy way to
do this is with the macroTEMP_FAILURE_RETRY, as follows:
nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));
Please note that there is no function namedwrite64. This is not necessary since this
function does not directly modify or handle the possibly wide file offset. Since the
kernel handles this state internally thewritefunction can be used for all cases.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timewriteis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this, calls towriteshould be protected
using cancellation handlers.
Thewritefunction is the underlying primitive for all of the functions that write to
streams, such asfputc.
```
ssize_t pwrite(intfiledes, const void *buffer, sizetsize, offt [Function]
offset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thepwritefunction is similar to thewritefunction. The first three arguments are
identical, and the return values and error codes also correspond.
The difference is the fourth argument and its handling. The data block is not written
to the current position of the file descriptorfiledes. Instead the data is written
to the file starting at positionoffset. The position of the file descriptor itself is not
affected by the operation. The value is the same as before the call.
However, on Linux, if a file is opened withO_APPEND,pwriteappends data to the
end of the file, regardless of the value ofoffset.
When the source file is compiled with_FILE_OFFSET_BITS == 64thepwritefunction
is in factpwrite64and the typeoff_thas 64 bits, which makes it possible to handle
files up to 2^63 bytes in length.
The return value ofpwritedescribes the number of written bytes. In the error case it
returns?1 likewritedoes and the error codes are also the same, with these additions:

```
EINVAL The value given foroffsetis negative and therefore illegal.
```
```
ESPIPE The file descriptorfiledesis associated with a pipe or a FIFO and this
device does not allow positioning of the file pointer.
```
```
The function is an extension defined in the Unix Single Specification version 2.
```
ssize_t pwrite64 (intfiledes, const void *buffer, size tsize, [Function]
off64toffset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepwritefunction. The difference is that the offset
parameter is of typeoff64_tinstead ofoff_twhich makes it possible on 32 bit
machines to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptor


Chapter 13: Low-Level Input/Output 350

```
filedesmust be opened usingopen64since otherwise the large offsets possible with
off64_twill lead to errors with a descriptor in small file mode.
When the source file is compiled using_FILE_OFFSET_BITS == 64on a 32 bit ma-
chine this function is actually available under the namepwriteand so transparently
replaces the 32 bit interface.
```
## 13.3 Setting the File Position of a Descriptor.....................

Just as you can set the file position of a stream withfseek, you can set the file position of
a descriptor withlseek. This specifies the position in the file for the nextreadorwrite
operation. SeeSection 12.18 [File Positioning], page 323, for more information on the file
position and what it means.

To read the current file position value from a descriptor, uselseek (desc, 0, SEEK_
CUR).

off_t lseek(intfiledes, offtoffset, intwhence) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelseekfunction is used to change the file position of the file with descriptorfiledes.
Thewhenceargument specifies how theoffsetshould be interpreted, in the same way
as for thefseekfunction, and it must be one of the symbolic constantsSEEK_SET,
SEEK_CUR, orSEEK_END.
SEEK_SET Specifies thatoffsetis a count of characters from the beginning of the file.

```
SEEK_CUR Specifies thatoffsetis a count of characters from the current file position.
This count may be positive or negative.
```
```
SEEK_END Specifies thatoffsetis a count of characters from the end of the file. A
negative count specifies a position within the current extent of the file;
a positive count specifies a position past the current end. If you set the
position past the current end, and actually write data, you will extend
the file with zeros up to that position.
```
```
The return value fromlseekis normally the resulting file position, measured in bytes
from the beginning of the file. You can use this feature together withSEEK_CURto
read the current file position.
If you want to append to the file, setting the file position to the current end of file
withSEEK_ENDis not sufficient. Another process may write more data after you seek
but before you write, extending the file so the position you write onto clobbers their
data. Instead, use theO_APPENDoperating mode; seeSection 13.15.3 [I/O Operating
Modes], page 391.
You can set the file position past the current end of the file. This does not by itself
make the file longer;lseeknever changes the file. But subsequent output at that
position will extend the file. Characters between the previous end of file and the new
position are filled with zeros. Extending the file in this way can create a ¡°hole¡±: the
blocks of zeros are not actually allocated on disk, so the file takes up less space than
it appears to; it is then called a ¡°sparse file¡±.
```

Chapter 13: Low-Level Input/Output 351

```
If the file position cannot be changed, or the operation is in some way invalid,lseek
returns a value of?1. The followingerrnoerror conditions are defined for this
function:
EBADF Thefiledesis not a valid file descriptor.
EINVAL Thewhenceargument value is not valid, or the resulting file offset is not
valid. A file offset is invalid.
ESPIPE Thefiledescorresponds to an object that cannot be positioned, such as
a pipe, FIFO or terminal device. (POSIX.1 specifies this error only for
pipes and FIFOs, but on GNU systems, you always getESPIPE if the
object is not seekable.)
When the source file is compiled with_FILE_OFFSET_BITS == 64thelseekfunction
is in factlseek64and the typeoff_thas 64 bits which makes it possible to handle
files up to 2^63 bytes in length.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timelseekis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this calls tolseekshould be protected
using cancellation handlers.
Thelseekfunction is the underlying primitive for thefseek,fseeko,ftell,ftello
andrewindfunctions, which operate on streams instead of file descriptors.
```
off64_t lseek64 (intfiledes, off64 toffset, intwhence) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thelseekfunction. The difference is that the offset
parameter is of typeoff64_tinstead ofoff_twhich makes it possible on 32 bit
machines to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptor
filedesmust be opened usingopen64since otherwise the large offsets possible with
off64_twill lead to errors with a descriptor in small file mode.
When the source file is compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine
this function is actually available under the namelseekand so transparently replaces
the 32 bit interface.

You can have multiple descriptors for the same file if you open the file more than once,
or if you duplicate a descriptor withdup. Descriptors that come from separate calls toopen
have independent file positions; usinglseekon one descriptor has no effect on the other.
For example,
{
int d1, d2;
char buf[4];
d1 = open ("foo", O_RDONLY);
d2 = open ("foo", O_RDONLY);
lseek (d1, 1024, SEEK_SET);
read (d2, buf, 4);
}

will read the first four characters of the filefoo. (The error-checking code necessary for a
real program has been omitted here for brevity.)


Chapter 13: Low-Level Input/Output 352

By contrast, descriptors made by duplication share a common file position with the
original descriptor that was duplicated. Anything which alters the file position of one of the
duplicates, including reading or writing data, affects all of them alike. Thus, for example,
{
int d1, d2, d3;
char buf1[4], buf2[4];
d1 = open ("foo", O_RDONLY);
d2 = dup (d1);
d3 = dup (d2);
lseek (d3, 1024, SEEK_SET);
read (d1, buf1, 4);
read (d2, buf2, 4);
}

will read four characters starting with the 1024¡¯th character offoo, and then four more
characters starting with the 1028¡¯th character.

off_t [Data Type]
This is a signed integer type used to represent file sizes. In the GNU C Library, this
type is no narrower thanint.
If the source is compiled with_FILE_OFFSET_BITS == 64this type is transparently
replaced byoff64_t.

off64_t [Data Type]
This type is used similar tooff_t. The difference is that even on 32 bit machines,
where theoff_ttype would have 32 bits,off64_t has 64 bits and so is able to
address files up to 2^63 bytes in length.
When compiling with_FILE_OFFSET_BITS == 64this type is available under the name
off_t.

These aliases for the ¡®SEEK_...¡¯ constants exist for the sake of compatibility with older
BSD systems. They are defined in two different header files:fcntl.handsys/file.h.

L_SET An alias forSEEK_SET.

L_INCR An alias forSEEK_CUR.

L_XTND An alias forSEEK_END.

## 13.4 Descriptors and Streams.....................................

Given an open file descriptor, you can create a stream for it with thefdopenfunction.
You can get the underlying file descriptor for an existing stream with thefilenofunction.
These functions are declared in the header filestdio.h.

FILE * fdopen(intfiledes, const char *opentype) [Function]
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe mem lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefdopenfunction returns a new stream for the file descriptorfiledes.
Theopentypeargument is interpreted in the same way as for thefopenfunction (see
Section 12.3 [Opening Streams], page 267), except that the ¡®b¡¯ option is not permitted;
this is because GNU systems make no distinction between text and binary files. Also,


Chapter 13: Low-Level Input/Output 353

```
"w"and"w+"do not cause truncation of the file; these have an effect only when
opening a file, and in this case the file has already been opened. You must make sure
that theopentypeargument matches the actual mode of the open file descriptor.
The return value is the new stream. If the stream cannot be created (for example, if
the modes for the file indicated by the file descriptor do not permit the access specified
by theopentypeargument), a null pointer is returned instead.
In some other systems,fdopenmay fail to detect that the modes for file descriptors
do not permit the access specified byopentype. The GNU C Library always checks
for this.
```
For an example showing the use of thefdopenfunction, seeSection 15.1 [Creating a
Pipe], page 450.

int fileno(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the file descriptor associated with the streamstream. If an
error is detected (for example, if thestreamis not valid) or ifstreamdoes not do I/O
to a file,filenoreturns?1.

int fileno_unlocked (FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefileno_unlockedfunction is equivalent to thefilenofunction except that it
does not implicitly lock the stream if the state isFSETLOCKING_INTERNAL.
This function is a GNU extension.

There are also symbolic constants defined inunistd.hfor the file descriptors belonging
to the standard streamsstdin,stdout, andstderr; seeSection 12.2 [Standard Streams],
page 266.

STDIN_FILENO
This macro has value 0 , which is the file descriptor for standard input.

STDOUT_FILENO
This macro has value 1 , which is the file descriptor for standard output.

STDERR_FILENO
This macro has value 2 , which is the file descriptor for standard error output.

## 13.5 Dangers of Mixing Streams and Descriptors..................

You can have multiple file descriptors and streams (let¡¯s call both streams and descriptors
¡°channels¡± for short) connected to the same file, but you must take care to avoid confusion
between channels. There are two cases to consider:linkedchannels that share a single file
position value, andindependentchannels that have their own file positions.

It¡¯s best to use just one channel in your program for actual data transfer to any given
file, except when all the access is for input. For example, if you open a pipe (something you
can only do at the file descriptor level), either do all I/O with the descriptor, or construct
a stream from the descriptor withfdopenand then do all I/O with the stream.


Chapter 13: Low-Level Input/Output 354

## 13.5.1 Linked Channels.......................................

Channels that come from a single opening share the same file position; we call themlinked
channels. Linked channels result when you make a stream from a descriptor usingfdopen,
when you get a descriptor from a stream withfileno, when you copy a descriptor with
dupordup2, and when descriptors are inherited duringfork. For files that don¡¯t support
random access, such as terminals and pipes,allchannels are effectively linked. On random-
access files, all append-type output streams are effectively linked to each other.

If you have been using a stream for I/O (or have just opened the stream), and you
want to do I/O using another channel (either a stream or a descriptor) that is linked to it,
you must firstclean upthe stream that you have been using. SeeSection 13.5.3 [Cleaning
Streams], page 354.

Terminating a process, or executing a new program in the process, destroys all the
streams in the process. If descriptors linked to these streams persist in other processes,
their file positions become undefined as a result. To prevent this, you must clean up the
streams before destroying them.

## 13.5.2 Independent Channels..................................

When you open channels (streams or descriptors) separately on a seekable file, each channel
has its own file position. These are calledindependent channels.

The system handles each channel independently. Most of the time, this is quite pre-
dictable and natural (especially for input): each channel can read or write sequentially at
its own place in the file. However, if some of the channels are streams, you must take these
precautions:

- You should clean an output stream after use, before doing anything else that might
    read or write from the same part of the file.
- You should clean an input stream before reading data that may have been modified
    using an independent channel. Otherwise, you might read obsolete data that had been
    in the stream¡¯s buffer.
If you do output to one channel at the end of the file, this will certainly leave the other
independent channels positioned somewhere before the new end. You cannot reliably set
their file positions to the new end of file before writing, because the file can always be
extended by another process between when you set the file position and when you write the
data. Instead, use an append-type descriptor or stream; they always output at the current
end of the file. In order to make the end-of-file position accurate, you must clean the output
channel you were using, if it is a stream.

It¡¯s impossible for two channels to have separate file pointers for a file that doesn¡¯t
support random access. Thus, channels for reading or writing such files are always linked,
never independent. Append-type channels are also always linked. For these channels, follow
the rules for linked channels; seeSection 13.5.1 [Linked Channels], page 354.

## 13.5.3 Cleaning Streams.......................................

You can usefflushto clean a stream in most cases.

You can skip thefflushif you know the stream is already clean. A stream is clean
whenever its buffer is empty. For example, an unbuffered stream is always clean. An input


Chapter 13: Low-Level Input/Output 355

stream that is at end-of-file is clean. A line-buffered stream is clean when the last character
output was a newline. However, a just-opened input stream might not be clean, as its input
buffer might not be empty.

There is one case in which cleaning a stream is impossible on most systems. This is when
the stream is doing input from a file that is not random-access. Such streams typically read
ahead, and when the file is not random access, there is no way to give back the excess data
already read. When an input stream reads from a random-access file,fflushdoes clean the
stream, but leaves the file pointer at an unpredictable place; you must set the file pointer
before doing any further I/O.

Closing an output-only stream also doesfflush, so this is a valid way of cleaning an
output stream.

You need not clean a stream before using its descriptor for control operations such as
setting terminal modes; these operations don¡¯t affect the file position and are not affected
by it. You can use any descriptor for these operations, and all channels are affected simulta-
neously. However, text already ¡°output¡± to a stream but still buffered by the stream will be
subject to the new terminal modes when subsequently flushed. To make sure ¡°past¡± output
is covered by the terminal settings that were in effect at the time, flush the output streams
for that terminal before setting the modes. SeeSection 17.4 [Terminal Modes], page 505.

## 13.6 Fast Scatter-Gather I/O.....................................

Some applications may need to read or write data to multiple buffers, which are separated
in memory. Although this can be done easily enough with multiple calls toreadandwrite,
it is inefficient because there is overhead associated with each kernel call.

Instead, many platforms provide special high-speed primitives to perform thesescatter-
gather operations in a single kernel call. The GNU C Library will provide an emulation
on any system that lacks these primitives, so they are not a portability threat. They are
defined insys/uio.h.

These functions are controlled with arrays ofiovecstructures, which describe the loca-
tion and size of each buffer.

struct iovec [Data Type]
Theiovecstructure describes a buffer. It contains two fields:
void *iov_base
Contains the address of a buffer.
size_t iov_len
Contains the length of the buffer.

ssize_t readv(intfiledes, const struct iovec *vector, intcount) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thereadvfunction reads data fromfiledesand scatters it into the buffers described
invector, which is taken to becountstructures long. As each buffer is filled, data is
sent to the next.
Note thatreadvis not guaranteed to fill all the buffers. It may stop at any point, for
the same reasonsreadwould.


Chapter 13: Low-Level Input/Output 356

```
The return value is a count of bytes (notbuffers) read, 0 indicating end-of-file, or? 1
indicating an error. The possible errors are the same as inread.
```
ssize_t writev(intfiledes, const struct iovec *vector, intcount) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thewritevfunction gathers data from the buffers described invector, which is taken
to becountstructures long, and writes them tofiledes. As each buffer is written,
it moves on to the next.
Likereadv,writevmay stop midstream under the same conditionswritewould.
The return value is a count of bytes written, or?1 indicating an error. The possible
errors are the same as inwrite.

ssize_t preadv(intfd, const struct iovec *iov, intiovcnt, off t [Function]
offset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thereadvfunction, with the difference it adds an extra
offsetparameter of typeoff_tsimilar topread. The data is written to the file
starting at positionoffset. The position of the file descriptor itself is not affected by
the operation. The value is the same as before the call.
When the source file is compiled with_FILE_OFFSET_BITS == 64thepreadvfunction
is in factpreadv64and the typeoff_thas 64 bits, which makes it possible to handle
files up to 2^63 bytes in length.
The return value is a count of bytes (notbuffers) read, 0 indicating end-of-file, or? 1
indicating an error. The possible errors are the same as inreadvandpread.

ssize_t preadv64 (intfd, const struct iovec *iov, intiovcnt, [Function]
off64toffset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepreadvfunction with the difference is that theoffset
parameter is of typeoff64_tinstead ofoff_t. It makes it possible on 32 bit machines
to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptorfiledes
must be opened usingopen64since otherwise the large offsets possible withoff64_t
will lead to errors with a descriptor in small file mode.
When the source file is compiled using_FILE_OFFSET_BITS == 64on a 32 bit ma-
chine this function is actually available under the namepreadvand so transparently
replaces the 32 bit interface.

ssize_t pwritev (intfd, const struct iovec *iov, intiovcnt, off t [Function]
offset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thewritevfunction, with the difference it adds an extra
offsetparameter of typeoff_tsimilar topwrite. The data is written to the file


Chapter 13: Low-Level Input/Output 357

```
starting at positionoffset. The position of the file descriptor itself is not affected by
the operation. The value is the same as before the call.
However, on Linux, if a file is opened withO_APPEND,pwriteappends data to the
end of the file, regardless of the value ofoffset.
When the source file is compiled with_FILE_OFFSET_BITS == 64thepwritevfunc-
tion is in factpwritev64and the typeoff_thas 64 bits, which makes it possible to
handle files up to 2^63 bytes in length.
The return value is a count of bytes (notbuffers) written, 0 indicating end-of-file, or
?1 indicating an error. The possible errors are the same as inwritevandpwrite.
```
ssize_t pwritev64(intfd, const struct iovec *iov, intiovcnt, [Function]
off64toffset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepwritevfunction with the difference is that theoffset
parameter is of typeoff64_tinstead ofoff_t. It makes it possible on 32 bit machines
to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptorfiledes
must be opened usingopen64since otherwise the large offsets possible withoff64_t
will lead to errors with a descriptor in small file mode.
When the source file is compiled using_FILE_OFFSET_BITS == 64on a 32 bit ma-
chine this function is actually available under the namepwritevand so transparently
replaces the 32 bit interface.

ssize_t preadv2 (intfd, const struct iovec *iov, intiovcnt, off t [Function]
offset, intflags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepreadvfunction, with the difference it adds an extra
flagsparameter of typeint. Additionally, ifoffsetis?1, the current file position is
used and updated (like thereadvfunction).
The supportedflagsare dependent of the underlying system. For Linux it supports:
RWF_HIPRI
High priority request. This adds a flag that tells the file system that this
is a high priority request for which it is worth to poll the hardware. The
flag is purely advisory and can be ignored if not supported. Thefdmust
be opened usingO_DIRECT.
RWF_DSYNC
Per-IO synchronization as if the file was opened withO_DSYNCflag.
RWF_SYNC Per-IO synchronization as if the file was opened withO_SYNCflag.
RWF_NOWAIT
Use nonblocking mode for this operation; that is, this call topreadv2will
fail and seterrnotoEAGAINif the operation would block.
RWF_APPEND
Per-IO synchronization as if the file was opened withO_APPENDflag.


Chapter 13: Low-Level Input/Output 358

```
When the source file is compiled with_FILE_OFFSET_BITS == 64thepreadv2func-
tion is in factpreadv64v2and the typeoff_thas 64 bits, which makes it possible
to handle files up to 2^63 bytes in length.
The return value is a count of bytes (notbuffers) read, 0 indicating end-of-file, or? 1
indicating an error. The possible errors are the same as inpreadvwith the addition
of:
EOPNOTSUPP
An unsupportedflagswas used.
```
ssize_t preadv64v2(intfd, const struct iovec *iov, intiovcnt, [Function]
off64toffset, intflags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepreadv2function with the difference is that theoffset
parameter is of typeoff64_tinstead ofoff_t. It makes it possible on 32 bit machines
to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptorfiledes
must be opened usingopen64since otherwise the large offsets possible withoff64_t
will lead to errors with a descriptor in small file mode.
When the source file is compiled using_FILE_OFFSET_BITS == 64on a 32 bit ma-
chine this function is actually available under the namepreadv2and so transparently
replaces the 32 bit interface.

ssize_t pwritev2 (intfd, const struct iovec *iov, intiovcnt, offt [Function]
offset, intflags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepwritevfunction, with the difference it adds an extra
flagsparameter of typeint. Additionally, ifoffsetis?1, the current file position
should is used and updated (like thewritevfunction).
The supportedflagsare dependent of the underlying system. For Linux, the supported
flags are the same as those forpreadv2.
When the source file is compiled with_FILE_OFFSET_BITS == 64thepwritev2func-
tion is in factpwritev64v2and the typeoff_thas 64 bits, which makes it possible
to handle files up to 2^63 bytes in length.
The return value is a count of bytes (not buffers) write, 0 indicating end-of-file, or
?1 indicating an error. The possible errors are the same as inpreadv2.

ssize_t pwritev64v2 (intfd, const struct iovec *iov, intiovcnt, [Function]
off64toffset, intflags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thepwritev2function with the difference is that theoffset
parameter is of typeoff64_tinstead ofoff_t. It makes it possible on 32 bit machines
to address files larger than 2^31 bytes and up to 2^63 bytes. The file descriptorfiledes
must be opened usingopen64since otherwise the large offsets possible withoff64_t
will lead to errors with a descriptor in small file mode.


Chapter 13: Low-Level Input/Output 359

```
When the source file is compiled using_FILE_OFFSET_BITS == 64on a 32 bit machine
this function is actually available under the namepwritev2and so transparently
replaces the 32 bit interface.
```
## 13.7 Copying data between two files..............................

A special function is provided to copy data between two files on the same file system. The
system can optimize such copy operations. This is particularly important on network file
systems, where the data would otherwise have to be transferred twice over the network.

Note that this function only copies file data, but not metadata such as file permissions
or extended attributes.

ssize_t copy_file_range (intinputfd, off64 t *inputpos, int [Function]
outputfd, off64t *outputpos, ssizetlength, unsigned intflags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function copies up tolengthbytes from the file descriptorinputfdto the file
descriptoroutputfd.
The function can operate on both the current file position (likereadandwrite) and
an explicit offset (likepreadandpwrite). If theinputpospointer is null, the file
position ofinputfdis used as the starting point of the copy operation, and the file
position is advanced during it. Ifinputposis not null, then*inputposis used as the
starting point of the copy operation, and*inputposis incremented by the number of
copied bytes, but the file position remains unchanged. Similar rules apply tooutputfd
andoutputposfor the output file position.
Theflagsargument is currently reserved and must be zero.
Thecopy_file_rangefunction returns the number of bytes copied. This can be less
than the specifiedlengthin case the input file contains fewer remaining bytes than
length, or if a read or write failure occurs. The return value is zero if the end of the
input file is encountered immediately.
If no bytes can be copied, to report an error,copy_file_rangereturns the value? 1
and setserrno. The table below lists some of the error conditions for this function.
ENOSYS The kernel does not implement the required functionality.
EISDIR At least one of the descriptorsinputfdoroutputfdrefers to a directory.
EINVAL At least one of the descriptorsinputfdoroutputfdrefers to a non-regular,
non-directory file (such as a socket or a FIFO).
The input or output positions before are after the copy operations are
outside of an implementation-defined limit.
Theflagsargument is not zero.
EFBIG The new file size would exceed the process file size limit. SeeSection 22.2
[Limiting Resource Usage], page 685.
The input or output positions before are after the copy operations are
outside of an implementation-defined limit. This can happen if the file
was not opened with large file support (LFS) on 32-bit machines, and the


Chapter 13: Low-Level Input/Output 360

```
copy operation would create a file which is larger than whatoff_tcould
represent.
```
```
EBADF The argumentinputfdis not a valid file descriptor open for reading.
The argumentoutputfdis not a valid file descriptor open for writing, or
outputfdhas been opened withO_APPEND.
```
```
In addition,copy_file_rangecan fail with the error codes which are used byread,
pread,write, andpwrite.
Thecopy_file_rangefunction is a cancellation point. In case of cancellation, the
input location (the file position or the value at*inputpos) is indeterminate.
```
## 13.8 Memory-mapped I/O........................................

On modern operating systems, it is possible tommap(pronounced ¡°em-map¡±) a file to a
region of memory. When this is done, the file can be accessed just like an array in the
program.

This is more efficient thanreadorwrite, as only the regions of the file that a program
actually accesses are loaded. Accesses to not-yet-loaded parts of the mmapped region are
handled in the same way as swapped out pages.

Since mmapped pages can be stored back to their file when physical memory is low, it
is possible to mmap files orders of magnitude larger than both the physical memoryand
swap space. The only limit is address space. The theoretical limit is 4GB on a 32-bit
machine - however, the actual limit will be smaller since some areas will be reserved for
other purposes. If the LFS interface is used the file size on 32-bit systems is not limited to
2GB (offsets are signed which reduces the addressable area of 4GB by half); the full 64-bit
are available.

Memory mapping only works on entire pages of memory. Thus, addresses for mapping
must be page-aligned, and length values will be rounded up. To determine the default size
of a page the machine uses one should use:
size_t page_size = (size_t) sysconf (_SC_PAGESIZE);
On some systems, mappings can use larger page sizes for certain files, and applications
can request larger page sizes for anonymous mappings as well (see theMAP_HUGETLBflag
below).

```
The following functions are declared insys/mman.h:
```
void * mmap(void *address, sizetlength, intprotect, intflags, [Function]
intfiledes, off toffset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themmapfunction creates a new mapping, connected to bytes (offset) to (offset+
length- 1) in the file open onfiledes. A new reference for the file specified byfiledes
is created, which is not removed by closing the file.
addressgives a preferred starting address for the mapping.NULLexpresses no prefer-
ence. Any previous mapping at that address is automatically removed. The address
you give may still be changed, unless you use theMAP_FIXEDflag.


Chapter 13: Low-Level Input/Output 361

```
protectcontains flags that control what kind of access is permitted. They include
PROT_READ, PROT_WRITE, andPROT_EXEC. The special flagPROT_NONEreserves a
region of address space for future use. Themprotectfunction can be used to change
the protection flags. SeeSection 3.4 [Memory Protection], page 77.
flagscontains flags that control the nature of the map. One ofMAP_SHAREDorMAP_
PRIVATEmust be specified.
They include:
```
```
MAP_PRIVATE
This specifies that writes to the region should never be written back to
the attached file. Instead, a copy is made for the process, and the region
will be swapped normally if memory runs low. No other process will see
the changes.
Since private mappings effectively revert to ordinary memory when writ-
ten to, you must have enough virtual memory for a copy of the entire
mmapped region if you use this mode withPROT_WRITE.
```
```
MAP_SHARED
This specifies that writes to the region will be written back to the file.
Changes made will be shared immediately with other processes mmaping
the same file.
Note that actual writing may take place at any time. You need to use
msync, described below, if it is important that other processes using con-
ventional I/O get a consistent view of the file.
MAP_FIXED
This forces the system to use the exact mapping address specified in
addressand fail if it can¡¯t.
MAP_ANONYMOUS
MAP_ANON This flag tells the system to create an anonymous mapping, not connected
to a file.filedesandoffsetare ignored, and the region is initialized with
zeros.
Anonymous maps are used as the basic primitive to extend the heap on
some systems. They are also useful to share data between multiple tasks
without creating a file.
On some systems using private anonymous mmaps is more efficient than
usingmallocfor large blocks. This is not an issue with the GNU C Li-
brary, as the includedmallocautomatically usesmmapwhere appropriate.
```
```
MAP_HUGETLB
This requests that the system uses an alternative page size which is larger
than the default page size for the mapping. For some workloads, increas-
ing the page size for large mappings improves performance because the
system needs to handle far fewer pages. For other workloads which re-
quire frequent transfer of pages between storage or different nodes, the
decreased page granularity may cause performance problems due to the
increased page size and larger transfers.
```

Chapter 13: Low-Level Input/Output 362

```
In order to create the mapping, the system needs physically contiguous
memory of the size of the increased page size. As a result,MAP_HUGETLB
mappings are affected by memory fragmentation, and their creation can
fail even if plenty of memory is available in the system.
Not all file systems support mappings with an increased page size.
TheMAP_HUGETLBflag is specific to Linux.
mmapreturns the address of the new mapping, orMAP_FAILEDfor an error.
Possible errors include:
EINVAL
Eitheraddresswas unusable (because it is not a multiple of the applicable
page size), or inconsistentflagswere given.
IfMAP_HUGETLBwas specified, the file or system does not support large
page sizes.
EACCES
filedeswas not open for the type of access specified inprotect.
ENOMEM
Either there is not enough memory for the operation, or the process is
out of address space.
ENODEV
This file is of a type that doesn¡¯t support mapping.
ENOEXEC
The file is on a filesystem that doesn¡¯t support mapping.
```
void * mmap64(void *address, sizetlength, intprotect, int [Function]
flags, intfiledes, off64toffset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themmap64function is equivalent to themmapfunction but theoffsetparameter is
of typeoff64_t. On 32-bit systems this allows the file associated with thefiledes
descriptor to be larger than 2GB.filedesmust be a descriptor returned from a call to
open64orfopen64andfreopen64where the descriptor is retrieved withfileno.
When the sources are translated with_FILE_OFFSET_BITS == 64this function is ac-
tually available under the namemmap. I.e., the new, extended API using 64 bit file
sizes and offsets transparently replaces the old API.

int munmap(void *addr, size tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
munmapremoves any memory maps from (addr) to (addr+length).lengthshould be
the length of the mapping.
It is safe to unmap multiple mappings in one command, or include unmapped space
in the range. It is also possible to unmap only part of an existing mapping. However,


Chapter 13: Low-Level Input/Output 363

```
only entire pages can be removed. Iflengthis not an even number of pages, it will
be rounded up.
It returns 0 for success and?1 for an error.
One error is possible:
```
```
EINVAL The memory range given was outside the user mmap range or wasn¡¯t page
aligned.
```
int msync (void *address, sizetlength, intflags) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
When using shared mappings, the kernel can write the file at any time before the
mapping is removed. To be certain data has actually been written to the file and will
be accessible to non-memory-mapped I/O, it is necessary to use this function.
It operates on the regionaddressto (address+length). It may be used on part of
a mapping or multiple mappings, however the region given should not contain any
unmapped space.
flagscan contain some options:

```
MS_SYNC
This flag makes sure the data is actually writtento disk. Normallymsync
only makes sure that accesses to a file with conventional I/O reflect the
recent changes.
MS_ASYNC
This tellsmsyncto begin the synchronization, but not to wait for it to
complete.
```
```
msyncreturns 0 for success and?1 for error. Errors include:
EINVAL An invalid region was given, or theflagswere invalid.
```
```
EFAULT There is no existing mapping in at least part of the given region.
```
void * mremap(void *address, sizetlength, sizetnew_length, [Function]
intflag)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function can be used to change the size of an existing memory area. address
andlengthmust cover a region entirely mapped in the samemmapstatement. A new
mapping with the same characteristics will be returned with the lengthnewlength.
One option is possible,MREMAP_MAYMOVE. If it is given inflags, the system may remove
the existing mapping and create a new one of the desired length in another location.
The address of the resulting mapping is returned, or?1. Possible error codes include:

```
EFAULT There is no existing mapping in at least part of the original region, or the
region covers two or more distinct mappings.
```
```
EINVAL The address given is misaligned or inappropriate.
```

Chapter 13: Low-Level Input/Output 364

```
EAGAIN The region has pages locked, and if extended it would exceed the process¡¯s
resource limit for locked pages. SeeSection 22.2 [Limiting Resource Us-
age], page 685.
ENOMEM The region is private writable, and insufficient virtual memory is available
to extend it. Also, this error will occur ifMREMAP_MAYMOVEis not given
and the extension would collide with another mapped region.
```
This function is only available on a few systems. Except for performing optional opti-
mizations one should not rely on this function.

Not all file descriptors may be mapped. Sockets, pipes, and most devices only allow
sequential access and do not fit into the mapping abstraction. In addition, some regular
files may not be mmapable, and older kernels may not support mapping at all. Thus,
programs usingmmapshould have a fallback method to use should it fail. SeeSection
¡°Mmap¡± inGNU Coding Standards.

int madvise(void *addr, sizetlength, intadvice) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function can be used to provide the system withadviceabout the intended usage
patterns of the memory region starting ataddrand extendinglengthbytes.
The valid BSD values foradviceare:
MADV_NORMAL
The region should receive no further special treatment.
MADV_RANDOM
The region will be accessed via random page references. The kernel should
page-in the minimal number of pages for each page fault.
MADV_SEQUENTIAL
The region will be accessed via sequential page references. This may
cause the kernel to aggressively read-ahead, expecting further sequential
references after any page fault within this region.
MADV_WILLNEED
The region will be needed. The pages within this region may be pre-
faulted in by the kernel.
MADV_DONTNEED
The region is no longer needed. The kernel may free these pages, causing
any changes to the pages to be lost, as well as swapped out pages to be
discarded.
MADV_HUGEPAGE
Indicate that it is beneficial to increase the page size for this mapping.
This can improve performance for larger mappings because the system
needs to handle far fewer pages. However, if parts of the mapping are
frequently transferred between storage or different nodes, performance
may suffer because individual transfers can become substantially larger
due to the increased page size.


Chapter 13: Low-Level Input/Output 365

```
This flag is specific to Linux.
MADV_NOHUGEPAGE
Undo the effect of a previousMADV_HUGEPAGEadvice. This flag is specific
to Linux.
The POSIX names are slightly different, but with the same meanings:
```
```
POSIX_MADV_NORMAL
This corresponds with BSD¡¯sMADV_NORMAL.
POSIX_MADV_RANDOM
This corresponds with BSD¡¯sMADV_RANDOM.
POSIX_MADV_SEQUENTIAL
This corresponds with BSD¡¯sMADV_SEQUENTIAL.
```
```
POSIX_MADV_WILLNEED
This corresponds with BSD¡¯sMADV_WILLNEED.
POSIX_MADV_DONTNEED
This corresponds with BSD¡¯sMADV_DONTNEED.
madvisereturns 0 for success and?1 for error. Errors include:
EINVAL An invalid region was given, or theadvicewas invalid.
```
```
EFAULT There is no existing mapping in at least part of the given region.
```
int shm_open (const char *name, intoflag, modetmode) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe init heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns a file descriptor that can be used to allocate shared memory
via mmap. Unrelated processes can use samenameto create or open existing shared
memory objects.
Anameargument specifies the shared memory object to be opened. In the GNU C
Library it must be a string smaller thanNAME_MAXbytes starting with an optional
slash but containing no other slashes.
The semantics ofoflagandmodearguments is same as inopen.
shm_openreturns the file descriptor on success or?1 on error. On failureerrnois
set.

int shm_unlink(const char *name) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe init heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is the inverse ofshm_openand removes the object with the givenname
previously created byshm_open.
shm_unlinkreturns 0 on success or?1 on error. On failureerrnois set.

int memfd_create (const char *name, unsigned intflags) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 13: Low-Level Input/Output 366

```
Thememfd_createfunction returns a file descriptor which can be used to create
memory mappings using themmapfunction. It is similar to theshm_openfunction in
the sense that these mappings are not backed by actual files. However, the descriptor
returned bymemfd_createdoes not correspond to a named object; thenameargu-
ment is used for debugging purposes only (e.g., will appear in/proc), and separate
invocations ofmemfd_createwith the samenamewill not return descriptors for the
same region of memory. The descriptor can also be used to create alias mappings
within the same process.
The descriptor initially refers to a zero-length file. Before mappings can be created
which are backed by memory, the file size needs to be increased with theftruncate
function. SeeSection 14.9.10 [File Size], page 442.
Theflagsargument can be a combination of the following flags:
MFD_CLOEXEC
The descriptor is created with theO_CLOEXECflag.
MFD_ALLOW_SEALING
The descriptor supports the addition of seals using thefcntlfunction.
MFD_HUGETLB
This requests that mappings created using the returned file descriptor use
a larger page size. SeeMAP_HUGETLBabove for details.
This flag is incompatible withMFD_ALLOW_SEALING.
memfd_createreturns a file descriptor on success, and?1 on failure.
The followingerrnoerror conditions are defined for this function:
EINVAL An invalid combination is specified inflags, ornameis too long.
EFAULT Thenameargument does not point to a string.
EMFILE The operation would exceed the file descriptor limit for this process.
ENFILE The operation would exceed the system-wide file descriptor limit.
ENOMEM There is not enough memory for the operation.
```
## 13.9 Waiting for Input or Output.................................

Sometimes a program needs to accept input on multiple input channels whenever input
arrives. For example, some workstations may have devices such as a digitizing tablet, func-
tion button box, or dial box that are connected via normal asynchronous serial interfaces;
good user interface style requires responding immediately to input on any device. Another
example is a program that acts as a server to several other processes via pipes or sockets.

You cannot normally usereadfor this purpose, because this blocks the program until
input is available on one particular file descriptor; input on other channels won¡¯t wake it
up. You could set nonblocking mode and poll each file descriptor in turn, but this is very
inefficient.

A better solution is to use theselectfunction. This blocks the program until input
or output is ready on a specified set of file descriptors, or until a timer expires, whichever
comes first. This facility is declared in the header filesys/types.h.


Chapter 13: Low-Level Input/Output 367

In the case of a server socket (seeSection 16.9.2 [Listening for Connections], page 483),
we say that ¡°input¡± is available when there are pending connections that could be accepted
(seeSection 16.9.3 [Accepting Connections], page 484). acceptfor server sockets blocks
and interacts withselectjust asreaddoes for normal input.

The file descriptor sets for theselectfunction are specified asfd_setobjects. Here is
the description of the data type and some macros for manipulating these objects.

fd_set [Data Type]
Thefd_setdata type represents file descriptor sets for theselectfunction. It is
actually a bit array.

int FD_SETSIZE [Macro]
The value of this macro is the maximum number of file descriptors that afd_set
object can hold information about. On systems with a fixed maximum number,FD_
SETSIZEis at least that number. On some systems, including GNU, there is no
absolute limit on the number of descriptors open, but this macro still has a constant
value which controls the number of bits in anfd_set; if you get a file descriptor with
a value as high asFD_SETSIZE, you cannot put that descriptor into anfd_set.

void FD_ZERO (fd set *set) [Macro]
Preliminary:|MT-Safe race:set|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This macro initializes the file descriptor setsetto be the empty set.

void FD_SET(intfiledes, fdset *set) [Macro]
Preliminary:|MT-Safe race:set|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This macro addsfiledesto the file descriptor setset.
Thefiledesparameter must not have side effects since it is evaluated more than once.

void FD_CLR(intfiledes, fdset *set) [Macro]
Preliminary:|MT-Safe race:set|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This macro removesfiledesfrom the file descriptor setset.
Thefiledesparameter must not have side effects since it is evaluated more than once.

int FD_ISSET (intfiledes, const fdset *set) [Macro]
Preliminary:|MT-Safe race:set|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This macro returns a nonzero value (true) iffiledesis a member of the file descriptor
setset, and zero (false) otherwise.
Thefiledesparameter must not have side effects since it is evaluated more than once.

```
Next, here is the description of theselectfunction itself.
```

Chapter 13: Low-Level Input/Output 368

int select(intnfds, fdset *read-fds, fdset *write-fds, fdset [Function]
*except-fds, struct timeval *timeout)
Preliminary:|MT-Safe race:read-fds race:write-fds race:except-fds|AS-Safe |AC-
Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theselectfunction blocks the calling process until there is activity on any of the
specified sets of file descriptors, or until the timeout period has expired.
The file descriptors specified by theread-fdsargument are checked to see if they are
ready for reading; thewrite-fdsfile descriptors are checked to see if they are ready
for writing; and theexcept-fdsfile descriptors are checked for exceptional conditions.
You can pass a null pointer for any of these arguments if you are not interested in
checking for that kind of condition.
A file descriptor is considered ready for reading if areadcall will not block. This
usually includes the read offset being at the end of the file or there is an error to
report. A server socket is considered ready for reading if there is a pending connec-
tion which can be accepted withaccept; seeSection 16.9.3 [Accepting Connections],
page 484. A client socket is ready for writing when its connection is fully established;
seeSection 16.9.1 [Making a Connection], page 482.
¡°Exceptional conditions¡± does not mean errors¡ªerrors are reported immediately
when an erroneous system call is executed, and do not constitute a state of the
descriptor. Rather, they include conditions such as the presence of an urgent message
on a socket. (SeeChapter 16 [Sockets], page 455, for information on urgent messages.)
Theselectfunction checks only the firstnfdsfile descriptors. The usual thing is to
passFD_SETSIZEas the value of this argument.
Thetimeoutspecifies the maximum time to wait. If you pass a null pointer for this
argument, it means to block indefinitely until one of the file descriptors is ready.
Otherwise, you should provide the time instruct timevalformat; seeSection 21.2
[Time Types], page 647. Specify zero as the time (astruct timevalcontaining all
zeros) if you want to find out which descriptors are ready without waiting if none are
ready.
The normal return value fromselectis the total number of ready file descriptors in
all of the sets. Each of the argument sets is overwritten with information about the
descriptors that are ready for the corresponding operation. Thus, to see if a particular
descriptordeschas input, useFD_ISSET (desc,read-fds)afterselectreturns.
Ifselectreturns because the timeout period expires, it returns a value of zero.
Any signal will causeselectto return immediately. So if your program uses signals,
you can¡¯t rely onselect to keep waiting for the full time specified. If you want
to be sure of waiting for a particular amount of time, you must check forEINTRand
repeat theselectwith a newly calculated timeout based on the current time. See the
example below. See alsoSection 24.5 [Primitives Interrupted by Signals], page 741.
If an error occurs,selectreturns-1and does not modify the argument file descriptor
sets. The followingerrnoerror conditions are defined for this function:
EBADF One of the file descriptor sets specified an invalid file descriptor.
EINTR The operation was interrupted by a signal. SeeSection 24.5 [Primitives
Interrupted by Signals], page 741.


Chapter 13: Low-Level Input/Output 369

```
EINVAL Thetimeoutargument is invalid; one of the components is negative or
too large.
```
```
Portability Note:Theselectfunction is a BSD Unix feature.
```
Here is an example showing how you can useselectto establish a timeout period for
reading from a file descriptor. Theinput_timeoutfunction blocks the calling process until
input is available on the file descriptor, or until the timeout period expires.

```
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/time.h>
```
```
int
input_timeout (int filedes, unsigned int seconds)
{
fd_set set;
struct timeval timeout;
```
```
/*Initialize the file descriptor set.*/
FD_ZERO (&set);
FD_SET (filedes, &set);
```
```
/*Initialize the timeout data structure.*/
timeout.tv_sec = seconds;
timeout.tv_usec = 0;
```
```
/* selectreturns 0 if timeout, 1 if input available, -1 if error.*/
return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
&set, NULL, NULL,
&timeout));
}
```
```
int
main (void)
{
fprintf (stderr, "select returned %d.\n",
input_timeout (STDIN_FILENO, 5));
return 0;
}
```
There is another example showing the use ofselectto multiplex input from multiple
sockets inSection 16.9.7 [Byte Stream Connection Server Example], page 489.

## 13.10 Synchronizing I/O operations..............................

In most modern operating systems, the normal I/O operations are not executed syn-
chronously. I.e., even if awritesystem call returns, this does not mean the data is actually
written to the media, e.g., the disk.

In situations where synchronization points are necessary, you can use special functions
which ensure that all operations finish before they return.


Chapter 13: Low-Level Input/Output 370

void sync (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
A call to this function will not return as long as there is data which has not been
written to the device. All dirty buffers in the kernel will be written and so an overall
consistent system can be achieved (if no other process in parallel writes data).
A prototype forsynccan be found inunistd.h.

Programs more often want to ensure that data written to a given file is committed,
rather than all data in the system. For this,syncis overkill.

int fsync (intfildes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefsyncfunction can be used to make sure all data associated with the open file
fildesis written to the device associated with the descriptor. The function call does
not return unless all actions have finished.
A prototype forfsynccan be found inunistd.h.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timefsyncis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this, calls tofsyncshould be protected
using cancellation handlers.
The return value of the function is zero if no error occurred. Otherwise it is?1 and
the global variableerrnois set to the following values:

```
EBADF The descriptorfildesis not valid.
```
```
EINVAL No synchronization is possible since the system does not implement this.
```
Sometimes it is not even necessary to write all data associated with a file descriptor. E.g.,
in database files which do not change in size it is enough to write all the file content data to
the device. Meta-information, like the modification time etc., are not that important and
leaving such information uncommitted does not prevent a successful recovery of the file in
case of a problem.

int fdatasync(intfildes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
When a call to thefdatasyncfunction returns, it is ensured that all of the file data
is written to the device. For all pending I/O operations, the parts guaranteeing data
integrity finished.
Not all systems implement thefdatasyncoperation. On systems missing this func-
tionalityfdatasyncis emulated by a call tofsyncsince the performed actions are a
superset of those required byfdatasync.
The prototype forfdatasyncis inunistd.h.


Chapter 13: Low-Level Input/Output 371

```
The return value of the function is zero if no error occurred. Otherwise it is?1 and
the global variableerrnois set to the following values:
```
```
EBADF The descriptorfildesis not valid.
```
```
EINVAL No synchronization is possible since the system does not implement this.
```
## 13.11 Perform I/O Operations in Parallel.........................

The POSIX.1b standard defines a new set of I/O operations which can significantly reduce
the time an application spends waiting for I/O. The new functions allow a program to
initiate one or more I/O operations and then immediately resume normal work while the
I/O operations are executed in parallel. This functionality is available if theunistd.hfile
defines the symbol_POSIX_ASYNCHRONOUS_IO.

These functions are part of the library with realtime functions namedlibrt. They are
not actually part of thelibcbinary. The implementation of these functions can be done
using support in the kernel (if available) or using an implementation based on threads at
userlevel. In the latter case it might be necessary to link applications with the thread library
libpthreadin addition tolibrt.

All AIO operations operate on files which were opened previously. There might be
arbitrarily many operations running for one file. The asynchronous I/O operations are
controlled using a data structure namedstruct aiocb(AIO control block). It is defined
inaio.has follows.

struct aiocb [Data Type]
The POSIX.1b standard mandates that thestruct aiocbstructure contains at least
the members described in the following table. There might be more elements which
are used by the implementation, but depending upon these elements is not portable
and is highly deprecated.

```
int aio_fildes
This element specifies the file descriptor to be used for the operation. It
must be a legal descriptor, otherwise the operation will fail.
The device on which the file is opened must allow the seek operation.
I.e., it is not possible to use any of the AIO operations on devices like
terminals where anlseekcall would lead to an error.
```
```
off_t aio_offset
This element specifies the offset in the file at which the operation (input
or output) is performed. Since the operations are carried out in arbitrary
order and more than one operation for one file descriptor can be started,
one cannot expect a current read/write position of the file descriptor.
```
```
volatile void *aio_buf
This is a pointer to the buffer with the data to be written or the place
where the read data is stored.
```
```
size_t aio_nbytes
This element specifies the length of the buffer pointed to byaio_buf.
```

Chapter 13: Low-Level Input/Output 372

```
int aio_reqprio
If the platform has defined _POSIX_PRIORITIZED_IO and _POSIX_
PRIORITY_SCHEDULING, the AIO requests are processed based on the
current scheduling priority. Theaio_reqprioelement can then be used
to lower the priority of the AIO operation.
```
```
struct sigevent aio_sigevent
This element specifies how the calling process is notified once the opera-
tion terminates. If thesigev_notifyelement isSIGEV_NONE, no notifica-
tion is sent. If it isSIGEV_SIGNAL, the signal determined bysigev_signo
is sent. Otherwise,sigev_notifymust beSIGEV_THREAD. In this case,
a thread is created which starts executing the function pointed to by
sigev_notify_function.
```
```
int aio_lio_opcode
This element is only used by thelio_listioandlio_listio64func-
tions. Since these functions allow an arbitrary number of operations to
start at once, and each operation can be input or output (or nothing),
the information must be stored in the control block. The possible values
are:
```
```
LIO_READ Start a read operation. Read from the file at positionaio_
offsetand store the nextaio_nbytesbytes in the buffer
pointed to byaio_buf.
```
```
LIO_WRITE
Start a write operation. Writeaio_nbytesbytes starting at
aio_bufinto the file starting at positionaio_offset.
```
```
LIO_NOP Do nothing for this control block. This value is useful some-
times when an array ofstruct aiocbvalues contains holes,
i.e., some of the values must not be handled although the
whole array is presented to thelio_listiofunction.
```
```
When the sources are compiled using_FILE_OFFSET_BITS == 64on a 32 bit machine,
this type is in factstruct aiocb64, since the LFS interface transparently replaces
thestruct aiocbdefinition.
```
For use with the AIO functions defined in the LFS, there is a similar type defined which
replaces the types of the appropriate members with larger types but otherwise is equivalent
tostruct aiocb. Particularly, all member names are the same.

struct aiocb64 [Data Type]

```
int aio_fildes
This element specifies the file descriptor which is used for the operation.
It must be a legal descriptor since otherwise the operation fails for obvious
reasons.
The device on which the file is opened must allow the seek operation.
I.e., it is not possible to use any of the AIO operations on devices like
terminals where anlseekcall would lead to an error.
```

Chapter 13: Low-Level Input/Output 373

```
off64_t aio_offset
This element specifies at which offset in the file the operation (input or
output) is performed. Since the operation are carried in arbitrary order
and more than one operation for one file descriptor can be started, one
cannot expect a current read/write position of the file descriptor.
```
```
volatile void *aio_buf
This is a pointer to the buffer with the data to be written or the place
where the read data is stored.
size_t aio_nbytes
This element specifies the length of the buffer pointed to byaio_buf.
int aio_reqprio
If for the platform _POSIX_PRIORITIZED_IO and _POSIX_PRIORITY_
SCHEDULING are defined the AIO requests are processed based on the
current scheduling priority. Theaio_reqprioelement can then be used
to lower the priority of the AIO operation.
struct sigevent aio_sigevent
This element specifies how the calling process is notified once the opera-
tion terminates. If thesigev_notifyelement isSIGEV_NONEno notifica-
tion is sent. If it isSIGEV_SIGNAL, the signal determined bysigev_signo
is sent. Otherwise,sigev_notifymust beSIGEV_THREADin which case
a thread is created which starts executing the function pointed to by
sigev_notify_function.
int aio_lio_opcode
This element is only used by thelio_listioandlio_listio64func-
tions. Since these functions allow an arbitrary number of operations
to start at once, and since each operation can be input or output (or
nothing), the information must be stored in the control block. See the
description ofstruct aiocbfor a description of the possible values.
When the sources are compiled using_FILE_OFFSET_BITS == 64on a 32 bit machine,
this type is available under the namestruct aiocb64, since the LFS transparently
replaces the old interface.
```
## 13.11.1 Asynchronous Read and Write Operations.............

int aio_read (struct aiocb *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function initiates an asynchronous read operation. It immediately returns after
the operation was enqueued or when an error was encountered.
The firstaiocbp->aio_nbytesbytes of the file for whichaiocbp->aio_fildesis a
descriptor are written to the buffer starting ataiocbp->aio_buf. Reading starts at
the absolute positionaiocbp->aio_offsetin the file.
If prioritized I/O is supported by the platform theaiocbp->aio_reqpriovalue is
used to adjust the priority before the request is actually enqueued.


Chapter 13: Low-Level Input/Output 374

```
The calling process is notified about the termination of the read request according to
theaiocbp->aio_sigeventvalue.
Whenaio_readreturns, the return value is zero if no error occurred that can be
found before the process is enqueued. If such an early error is found, the function
returns?1 and setserrnoto one of the following values:
EAGAIN The request was not enqueued due to (temporarily) exceeded resource
limitations.
ENOSYS Theaio_readfunction is not implemented.
EBADF Theaiocbp->aio_fildesdescriptor is not valid. This condition need
not be recognized before enqueueing the request and so this error might
also be signaled asynchronously.
EINVAL The aiocbp->aio_offset or aiocbp->aio_reqpiro value is invalid.
This condition need not be recognized before enqueueing the request
and so this error might also be signaled asynchronously.
Ifaio_readreturns zero, the current status of the request can be queried usingaio_
errorandaio_return functions. As long as the value returned byaio_erroris
EINPROGRESSthe operation has not yet completed. Ifaio_errorreturns zero, the
operation successfully terminated, otherwise the value is to be interpreted as an error
code. If the function terminated, the result of the operation can be obtained using
a call toaio_return. The returned value is the same as an equivalent call toread
would have returned. Possible error codes returned byaio_errorare:
EBADF Theaiocbp->aio_fildesdescriptor is not valid.
ECANCELED
The operation was canceled before the operation was finished (see
Section 13.11.4 [Cancellation of AIO Operations], page 381)
EINVAL Theaiocbp->aio_offsetvalue is invalid.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in
factaio_read64since the LFS interface transparently replaces the normal imple-
mentation.
```
int aio_read64(struct aiocb64 *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar to theaio_readfunction. The only difference is that on 32 bit
machines, the file descriptor should be opened in the large file mode. Internally,aio_
read64uses functionality equivalent tolseek64(seeSection 13.3 [Setting the File
Position of a Descriptor], page 350) to position the file descriptor correctly for the
reading, as opposed to thelseekfunctionality used inaio_read.
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is avail-
able under the nameaio_readand so transparently replaces the interface for small
files on 32 bit machines.

To write data asynchronously to a file, there exists an equivalent pair of functions with
a very similar interface.


Chapter 13: Low-Level Input/Output 375

int aio_write(struct aiocb *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function initiates an asynchronous write operation. The function call immedi-
ately returns after the operation was enqueued or if before this happens an error was
encountered.
The firstaiocbp->aio_nbytesbytes from the buffer starting ataiocbp->aio_buf
are written to the file for whichaiocbp->aio_fildesis a descriptor, starting at the
absolute positionaiocbp->aio_offsetin the file.
If prioritized I/O is supported by the platform, theaiocbp->aio_reqpriovalue is
used to adjust the priority before the request is actually enqueued.
The calling process is notified about the termination of the read request according to
theaiocbp->aio_sigeventvalue.
Whenaio_writereturns, the return value is zero if no error occurred that can be
found before the process is enqueued. If such an early error is found the function
returns?1 and setserrnoto one of the following values.

```
EAGAIN The request was not enqueued due to (temporarily) exceeded resource
limitations.
```
```
ENOSYS Theaio_writefunction is not implemented.
```
```
EBADF Theaiocbp->aio_fildesdescriptor is not valid. This condition may
not be recognized before enqueueing the request, and so this error might
also be signaled asynchronously.
```
```
EINVAL The aiocbp->aio_offset or aiocbp->aio_reqprio value is invalid.
This condition may not be recognized before enqueueing the request and
so this error might also be signaled asynchronously.
```
```
In the caseaio_writereturns zero, the current status of the request can be queried
using theaio_errorandaio_returnfunctions. As long as the value returned by
aio_errorisEINPROGRESSthe operation has not yet completed. Ifaio_errorreturns
zero, the operation successfully terminated, otherwise the value is to be interpreted as
an error code. If the function terminated, the result of the operation can be obtained
using a call toaio_return. The returned value is the same as an equivalent call to
readwould have returned. Possible error codes returned byaio_errorare:
```
```
EBADF Theaiocbp->aio_fildesdescriptor is not valid.
```
```
ECANCELED
The operation was canceled before the operation was finished. (see
Section 13.11.4 [Cancellation of AIO Operations], page 381)
```
```
EINVAL Theaiocbp->aio_offsetvalue is invalid.
```
```
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is in
factaio_write64since the LFS interface transparently replaces the normal imple-
mentation.
```

Chapter 13: Low-Level Input/Output 376

int aio_write64 (struct aiocb64 *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar to theaio_writefunction. The only difference is that on
32 bit machines the file descriptor should be opened in the large file mode. Internally
aio_write64uses functionality equivalent tolseek64(seeSection 13.3 [Setting the
File Position of a Descriptor], page 350) to position the file descriptor correctly for
the writing, as opposed to thelseekfunctionality used inaio_write.
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is avail-
able under the nameaio_writeand so transparently replaces the interface for small
files on 32 bit machines.

Besides these functions with the more or less traditional interface, POSIX.1b also defines
a function which can initiate more than one operation at a time, and which can handle
freely mixed read and write operations. It is therefore similar to a combination ofreadv
andwritev.

int lio_listio(intmode, struct aiocb *constlist[], intnent, [Function]
struct sigevent *sig)
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelio_listiofunction can be used to enqueue an arbitrary number of read and
write requests at one time. The requests can all be meant for the same file, all for
different files or every solution in between.
lio_listiogets thenentrequests from the array pointed to bylist. The operation
to be performed is determined by theaio_lio_opcodemember in each element of
list. If this field isLIO_READa read operation is enqueued, similar to a call ofaio_
readfor this element of the array (except that the way the termination is signalled is
different, as we will see below). If theaio_lio_opcodemember isLIO_WRITEa write
operation is enqueued. Otherwise theaio_lio_opcodemust beLIO_NOPin which
case this element oflistis simply ignored. This ¡°operation¡± is useful in situations
where one has a fixed array ofstruct aiocbelements from which only a few need to
be handled at a time. Another situation is where thelio_listiocall was canceled
before all requests are processed (seeSection 13.11.4 [Cancellation of AIO Operations],
page 381) and the remaining requests have to be reissued.
The other members of each element of the array pointed to bylistmust have values
suitable for the operation as described in the documentation foraio_readandaio_
writeabove.
Themodeargument determines howlio_listiobehaves after having enqueued all
the requests. IfmodeisLIO_WAITit waits until all requests terminated. Otherwise
modemust beLIO_NOWAITand in this case the function returns immediately after
having enqueued all the requests. In this case the caller gets a notification of the
termination of all requests according to thesigparameter. IfsigisNULLno notification
is sent. Otherwise a signal is sent or a thread is started, just as described in the
description foraio_readoraio_write.


Chapter 13: Low-Level Input/Output 377

```
IfmodeisLIO_WAIT, the return value oflio_listiois 0 when all requests completed
successfully. Otherwise the function returns?1 anderrnois set accordingly. To find
out which request or requests failed one has to use theaio_errorfunction on all the
elements of the arraylist.
In casemodeisLIO_NOWAIT, the function returns 0 if all requests were enqueued
correctly. The current state of the requests can be found usingaio_errorandaio_
returnas described above. Iflio_listioreturns?1 in this mode, the global variable
errnois set accordingly. If a request did not yet terminate, a call toaio_errorreturns
EINPROGRESS. If the value is different, the request is finished and the error value (or
0) is returned and the result of the operation can be retrieved usingaio_return.
Possible values forerrnoare:
```
```
EAGAIN The resources necessary to queue all the requests are not available at the
moment. The error status for each element oflistmust be checked to
determine which request failed.
Another reason could be that the system wide limit of AIO requests
is exceeded. This cannot be the case for the implementation on GNU
systems since no arbitrary limits exist.
```
```
EINVAL Themodeparameter is invalid ornentis larger thanAIO_LISTIO_MAX.
EIO One or more of the request¡¯s I/O operations failed. The error status of
each request should be checked to determine which one failed.
```
```
ENOSYS Thelio_listiofunction is not supported.
```
```
If themodeparameter isLIO_NOWAITand the caller cancels a request, the error status
for this request returned byaio_errorisECANCELED.
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is in
factlio_listio64since the LFS interface transparently replaces the normal imple-
mentation.
```
int lio_listio64 (intmode, struct aiocb64 *constlist[], intnent, [Function]
struct sigevent *sig)
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar to thelio_listiofunction. The only difference is that on
32 bit machines, the file descriptor should be opened in the large file mode. Internally,
lio_listio64uses functionality equivalent tolseek64(seeSection 13.3 [Setting the
File Position of a Descriptor], page 350) to position the file descriptor correctly for
the reading or writing, as opposed to thelseekfunctionality used inlio_listio.
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is avail-
able under the namelio_listioand so transparently replaces the interface for small
files on 32 bit machines.

## 13.11.2 Getting the Status of AIO Operations.................

As already described in the documentation of the functions in the last section, it must be
possible to get information about the status of an I/O request. When the operation is


Chapter 13: Low-Level Input/Output 378

performed truly asynchronously (as withaio_readandaio_writeand withlio_listio
when the mode isLIO_NOWAIT), one sometimes needs to know whether a specific request
already terminated and if so, what the result was. The following two functions allow you
to get this kind of information.

int aio_error(const struct aiocb *aiocbp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function determines the error state of the request described by thestruct aiocb
variable pointed to byaiocbp. If the request has not yet terminated the value returned
is alwaysEINPROGRESS. Once the request has terminated the valueaio_errorreturns
is either 0 if the request completed successfully or it returns the value which would be
stored in theerrnovariable if the request would have been done usingread,write,
orfsync.
The function can returnENOSYSif it is not implemented. It could also returnEINVAL
if theaiocbp parameter does not refer to an asynchronous operation whose return
status is not yet known.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in
factaio_error64since the LFS interface transparently replaces the normal imple-
mentation.

int aio_error64 (const struct aiocb64 *aiocbp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar toaio_errorwith the only difference that the argument is a
reference to a variable of typestruct aiocb64.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the nameaio_errorand so transparently replaces the interface for small
files on 32 bit machines.

ssize_t aio_return(struct aiocb *aiocbp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function can be used to retrieve the return status of the operation carried out
by the request described in the variable pointed to byaiocbp. As long as the error
status of this request as returned byaio_errorisEINPROGRESSthe return value of
this function is undefined.
Once the request is finished this function can be used exactly once to retrieve the
return value. Following calls might lead to undefined behavior. The return value
itself is the value which would have been returned by theread,write, orfsynccall.
The function can returnENOSYSif it is not implemented. It could also returnEINVAL
if theaiocbp parameter does not refer to an asynchronous operation whose return
status is not yet known.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in
factaio_return64since the LFS interface transparently replaces the normal imple-
mentation.


Chapter 13: Low-Level Input/Output 379

ssize_t aio_return64(struct aiocb64 *aiocbp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar toaio_returnwith the only difference that the argument is
a reference to a variable of typestruct aiocb64.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the nameaio_returnand so transparently replaces the interface for small
files on 32 bit machines.

## 13.11.3 Getting into a Consistent State........................

When dealing with asynchronous operations it is sometimes necessary to get into a consistent
state. This would mean for AIO that one wants to know whether a certain request or a
group of requests were processed. This could be done by waiting for the notification sent
by the system after the operation terminated, but this sometimes would mean wasting
resources (mainly computation time). Instead POSIX.1b defines two functions which will
help with most kinds of consistency.

Theaio_fsyncandaio_fsync64functions are only available if the symbol_POSIX_
SYNCHRONIZED_IOis defined inunistd.h.

int aio_fsync(intop, struct aiocb *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Calling this function forces all I/O operations queued at the time of the function
call operating on the file descriptoraiocbp->aio_fildesinto the synchronized I/O
completion state (seeSection 13.10 [Synchronizing I/O operations], page 369). The
aio_fsyncfunction returns immediately but the notification through the method
described inaiocbp->aio_sigeventwill happen only after all requests for this file
descriptor have terminated and the file is synchronized. This also means that requests
for this very same file descriptor which are queued after the synchronization request
are not affected.
IfopisO_DSYNCthe synchronization happens as with a call tofdatasync. Otherwise
opshould beO_SYNCand the synchronization happens as withfsync.
As long as the synchronization has not happened, a call toaio_errorwith the refer-
ence to the object pointed to byaiocbpreturnsEINPROGRESS. Once the synchroniza-
tion is doneaio_errorreturn 0 if the synchronization was not successful. Otherwise
the value returned is the value to which thefsyncorfdatasyncfunction would have
set theerrnovariable. In this case nothing can be assumed about the consistency of
the data written to this file descriptor.
The return value of this function is 0 if the request was successfully enqueued. Oth-
erwise the return value is?1 anderrnois set to one of the following values:
EAGAIN The request could not be enqueued due to temporary lack of resources.
EBADF The file descriptoraiocbp->aio_fildesis not valid.

```
EINVAL The implementation does not support I/O synchronization or theoppa-
rameter is other thanO_DSYNCandO_SYNC.
```

Chapter 13: Low-Level Input/Output 380

```
ENOSYS This function is not implemented.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in
factaio_fsync64since the LFS interface transparently replaces the normal imple-
mentation.
```
int aio_fsync64 (intop, struct aiocb64 *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toaio_fsyncwith the only difference that the argument is a
reference to a variable of typestruct aiocb64.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the nameaio_fsyncand so transparently replaces the interface for small
files on 32 bit machines.

Another method of synchronization is to wait until one or more requests of a specific set
terminated. This could be achieved by theaio_*functions to notify the initiating process
about the termination but in some situations this is not the ideal solution. In a program
which constantly updates clients somehow connected to the server it is not always the best
solution to go round robin since some connections might be slow. On the other hand letting
theaio_*functions notify the caller might also be not the best solution since whenever
the process works on preparing data for a client it makes no sense to be interrupted by a
notification since the new client will not be handled before the current client is served. For
situations like thisaio_suspendshould be used.

int aio_suspend (const struct aiocb *constlist[], intnent, const [Function]
struct timespec *timeout)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
When calling this function, the calling thread is suspended until at least one of the
requests pointed to by thenentelements of the arraylisthas completed. If any of
the requests has already completed at the timeaio_suspendis called, the function
returns immediately. Whether a request has terminated or not is determined by
comparing the error status of the request withEINPROGRESS. If an element oflistis
NULL, the entry is simply ignored.
If no request has finished, the calling process is suspended. IftimeoutisNULL, the
process is not woken until a request has finished. Iftimeoutis notNULL, the process
remains suspended at least as long as specified intimeout. In this case,aio_suspend
returns with an error.
The return value of the function is 0 if one or more requests from thelisthave
terminated. Otherwise the function returns?1 anderrnois set to one of the following
values:
EAGAIN None of the requests from thelistcompleted in the time specified by
timeout.
EINTR A signal interrupted theaio_suspendfunction. This signal might also
be sent by the AIO implementation while signalling the termination of
one of the requests.


Chapter 13: Low-Level Input/Output 381

```
ENOSYS Theaio_suspendfunction is not implemented.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in
factaio_suspend64since the LFS interface transparently replaces the normal imple-
mentation.
```
int aio_suspend64(const struct aiocb64 *constlist[], intnent, [Function]
const struct timespec *timeout)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function is similar toaio_suspendwith the only difference that the argument
is a reference to a variable of typestruct aiocb64.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the nameaio_suspendand so transparently replaces the interface for
small files on 32 bit machines.

## 13.11.4 Cancellation of AIO Operations.......................

When one or more requests are asynchronously processed, it might be useful in some sit-
uations to cancel a selected operation, e.g., if it becomes obvious that the written data
is no longer accurate and would have to be overwritten soon. As an example, assume an
application, which writes data in files in a situation where new incoming data would have
to be written in a file which will be updated by an enqueued request. The POSIX AIO
implementation provides such a function, but this function is not capable of forcing the
cancellation of the request. It is up to the implementation to decide whether it is possible
to cancel the operation or not. Therefore using this function is merely a hint.

int aio_cancel(intfildes, struct aiocb *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theaio_cancelfunction can be used to cancel one or more outstanding requests.
If theaiocbpparameter isNULL, the function tries to cancel all of the outstanding
requests which would process the file descriptorfildes(i.e., whoseaio_fildesmember
isfildes). Ifaiocbpis notNULL,aio_cancelattempts to cancel the specific request
pointed to byaiocbp.
For requests which were successfully canceled, the normal notification about the ter-
mination of the request should take place. I.e., depending on thestruct sigevent
object which controls this, nothing happens, a signal is sent or a thread is started.
If the request cannot be canceled, it terminates the usual way after performing the
operation.
After a request is successfully canceled, a call toaio_errorwith a reference to this
request as the parameter will returnECANCELEDand a call toaio_returnwill re-
turn?1. If the request wasn¡¯t canceled and is still running the error status is still
EINPROGRESS.
The return value of the function isAIO_CANCELEDif there were requests which haven¡¯t
terminated and which were successfully canceled. If there is one or more requests left
which couldn¡¯t be canceled, the return value isAIO_NOTCANCELED. In this caseaio_
errormust be used to find out which of the, perhaps multiple, requests (ifaiocbp


Chapter 13: Low-Level Input/Output 382

```
isNULL) weren¡¯t successfully canceled. If all requests already terminated at the time
aio_cancelis called the return value isAIO_ALLDONE.
If an error occurred during the execution ofaio_cancelthe function returns?1 and
setserrnoto one of the following values.
EBADF The file descriptorfildesis not valid.
ENOSYS aio_cancelis not implemented.
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is in
factaio_cancel64since the LFS interface transparently replaces the normal imple-
mentation.
```
int aio_cancel64 (intfildes, struct aiocb64 *aiocbp) [Function]
Preliminary: | MT-Safe |AS-Unsafe lock heap | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toaio_cancelwith the only difference that the argument is
a reference to a variable of typestruct aiocb64.
When the sources are compiled with_FILE_OFFSET_BITS == 64, this function is avail-
able under the nameaio_canceland so transparently replaces the interface for small
files on 32 bit machines.

## 13.11.5 How to optimize the AIO implementation..............

The POSIX standard does not specify how the AIO functions are implemented. They could
be system calls, but it is also possible to emulate them at userlevel.

At the time of writing, the available implementation is a user-level implementation which
uses threads for handling the enqueued requests. While this implementation requires mak-
ing some decisions about limitations, hard limitations are something best avoided in the
GNU C Library. Therefore, the GNU C Library provides a means for tuning the AIO
implementation according to the individual use.

struct aioinit [Data Type]
This data type is used to pass the configuration or tunable parameters to the imple-
mentation. The program has to initialize the members of this struct and pass it to
the implementation using theaio_initfunction.
int aio_threads
This member specifies the maximal number of threads which may be used
at any one time.
int aio_num
This number provides an estimate on the maximal number of simultane-
ously enqueued requests.
int aio_locks
Unused.
int aio_usedba
Unused.
int aio_debug
Unused.


Chapter 13: Low-Level Input/Output 383

```
int aio_numusers
Unused.
```
```
int aio_reserved[2]
Unused.
```
void aio_init(const struct aioinit *init) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function must be called before any other AIO function. Calling it is completely
voluntary, as it is only meant to help the AIO implementation perform better.
Before callingaio_init, the members of a variable of typestruct aioinitmust be
initialized. Then a reference to this variable is passed as the parameter toaio_init
which itself may or may not pay attention to the hints.
The function has no return value and no error cases are defined. It is an extension
which follows a proposal from the SGI implementation in Irix 6. It is not covered by
POSIX.1b or Unix98.

13.12 Control Operations on Files

This section describes how you can perform various other operations on file descriptors, such
as inquiring about or setting flags describing the status of the file descriptor, manipulating
record locks, and the like. All of these operations are performed by the functionfcntl.

The second argument to thefcntlfunction is a command that specifies which operation
to perform. The function and macros that name various flags that are used with it are
declared in the header filefcntl.h. Many of these flags are also used by theopenfunction;
seeSection 13.1 [Opening and Closing Files], page 342.

int fcntl (intfiledes, intcommand,.. .) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefcntlfunction performs the operation specified bycommand on the file de-
scriptorfiledes. Some commands require additional arguments to be supplied. These
additional arguments and the return value and error conditions are given in the de-
tailed descriptions of the individual commands.
Briefly, here is a list of what the various commands are.

```
F_DUPFD Duplicate the file descriptor (return another file descriptor pointing to the
same open file). SeeSection 13.13 [Duplicating Descriptors], page 384.
```
```
F_GETFD Get flags associated with the file descriptor. SeeSection 13.14 [File De-
scriptor Flags], page 386.
```
```
F_SETFD Set flags associated with the file descriptor. SeeSection 13.14 [File De-
scriptor Flags], page 386.
```
```
F_GETFL Get flags associated with the open file. SeeSection 13.15 [File Status
Flags], page 387.
```

Chapter 13: Low-Level Input/Output 384

```
F_SETFL Set flags associated with the open file. SeeSection 13.15 [File Status
Flags], page 387.
F_GETLK Test a file lock. SeeSection 13.16 [File Locks], page 393.
F_SETLK Set or clear a file lock. SeeSection 13.16 [File Locks], page 393.
F_SETLKW LikeF_SETLK, but wait for completion. SeeSection 13.16 [File Locks],
page 393.
F_OFD_GETLK
Test an open file description lock. SeeSection 13.17 [Open File Descrip-
tion Locks], page 396. Specific to Linux.
F_OFD_SETLK
Set or clear an open file description lock. SeeSection 13.17 [Open File
Description Locks], page 396. Specific to Linux.
F_OFD_SETLKW
LikeF_OFD_SETLK, but block until lock is acquired. SeeSection 13.17
[Open File Description Locks], page 396. Specific to Linux.
F_GETOWN Get process or process group ID to receive SIGIO signals. See
Section 13.19 [Interrupt-Driven Input], page 400.
F_SETOWN Set process or process group ID to receiveSIGIOsignals. SeeSection 13.19
[Interrupt-Driven Input], page 400.
This function is a cancellation point in multi-threaded programs for the commandsF_
SETLKW(and the LFS analogousF_SETLKW64) andF_OFD_SETLKW. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timefcntlis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this calls tofcntlshould be protected
using cancellation handlers.
```
## 13.13 Duplicating Descriptors....................................

You canduplicatea file descriptor, or allocate another file descriptor that refers to the same
open file as the original. Duplicate descriptors share one file position and one set of file
status flags (seeSection 13.15 [File Status Flags], page 387), but each has its own set of file
descriptor flags (seeSection 13.14 [File Descriptor Flags], page 386).

The major use of duplicating a file descriptor is to implementredirectionof input or
output: that is, to change the file or pipe that a particular file descriptor corresponds to.

You can perform this operation using thefcntlfunction with theF_DUPFDcommand,
but there are also convenient functionsdupanddup2for duplicating descriptors.

Thefcntlfunction and flags are declared infcntl.h, while prototypes fordupand
dup2are in the header fileunistd.h.

int dup(intold) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function copies descriptoroldto the first available descriptor number (the first
number not currently open). It is equivalent tofcntl (old, F_DUPFD, 0).


Chapter 13: Low-Level Input/Output 385

int dup2 (intold, intnew) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function copies the descriptoroldto descriptor numbernew.
Ifoldis an invalid descriptor, thendup2does nothing; it does not closenew. Other-
wise, the new duplicate ofoldreplaces any previous meaning of descriptornew, as if
newwere closed first.
Ifoldandneware different numbers, andoldis a valid descriptor number, thendup2
is equivalent to:
close (new);
fcntl (old, F_DUPFD,new)
However,dup2does this atomically; there is no instant in the middle of callingdup2
at whichnewis closed and not yet a duplicate ofold.

int F_DUPFD [Macro]
This macro is used as thecommandargument tofcntl, to copy the file descriptor
given as the first argument.
The form of the call in this case is:
fcntl (old, F_DUPFD,next-filedes)
Thenext-filedesargument is of typeintand specifies that the file descriptor returned
should be the next available one greater than or equal to this value.
The return value fromfcntlwith this command is normally the value of the new
file descriptor. A return value of?1 indicates an error. The followingerrnoerror
conditions are defined for this command:

```
EBADF Theoldargument is invalid.
EINVAL Thenext-filedesargument is invalid.
```
```
EMFILE There are no more file descriptors available¡ªyour program is already
using the maximum. In BSD and GNU, the maximum is controlled by a
resource limit that can be changed; seeSection 22.2 [Limiting Resource
Usage], page 685, for more information about theRLIMIT_NOFILElimit.
```
```
ENFILEis not a possible error code fordup2becausedup2does not create a new
opening of a file; duplicate descriptors do not count toward the limit whichENFILE
indicates. EMFILE is possible because it refers to the limit on distinct descriptor
numbers in use in one process.
```
Here is an example showing how to usedup2to do redirection. Typically, redirection
of the standard streams (likestdin) is done by a shell or shell-like program before calling
one of theexecfunctions (seeSection 26.5 [Executing a File], page 806) to execute a new
program in a child process. When the new program is executed, it creates and initializes
the standard streams to point to the corresponding file descriptors, before itsmainfunction
is invoked.

```
So, to redirect standard input to a file, the shell could do something like:
pid = fork ();
if (pid == 0)
```

Chapter 13: Low-Level Input/Output 386

```
{
char *filename;
char *program;
int file;
```
file = TEMP_FAILURE_RETRY (open (filename, O_RDONLY));
dup2 (file, STDIN_FILENO);
TEMP_FAILURE_RETRY (close (file));
execv (program, NULL);
}
There is also a more detailed example showing how to implement redirection in the
context of a pipeline of processes inSection 28.5.3 [Launching Jobs], page 822.

## 13.14 File Descriptor Flags.......................................

File descriptor flagsare miscellaneous attributes of a file descriptor. These flags are asso-
ciated with particular file descriptors, so that if you have created duplicate file descriptors
from a single opening of a file, each descriptor has its own set of flags.

Currently there is just one file descriptor flag:FD_CLOEXEC, which causes the descriptor
to be closed if you use any of theexec...functions (seeSection 26.5 [Executing a File],
page 806).

```
The symbols in this section are defined in the header filefcntl.h.
```
int F_GETFD [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should
return the file descriptor flags associated with thefiledesargument.
The normal return value fromfcntlwith this command is a nonnegative number
which can be interpreted as the bitwise OR of the individual flags (except that cur-
rently there is only one flag to use).
In case of an error, fcntlreturns?1. The following errnoerror conditions are
defined for this command:
EBADF Thefiledesargument is invalid.

int F_SETFD [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should set
the file descriptor flags associated with thefiledesargument. This requires a third
intargument to specify the new flags, so the form of the call is:
fcntl (filedes, F_SETFD,new-flags)
The normal return value fromfcntlwith this command is an unspecified value other
than?1, which indicates an error. The flags and error conditions are the same as for
theF_GETFDcommand.
The following macro is defined for use as a file descriptor flag with thefcntlfunction.
The value is an integer constant usable as a bit mask value.

int FD_CLOEXEC [Macro]
This flag specifies that the file descriptor should be closed when anexecfunction
is invoked; seeSection 26.5 [Executing a File], page 806. When a file descriptor is
allocated (as withopenordup), this bit is initially cleared on the new file descriptor,
meaning that descriptor will survive into the new program afterexec.


Chapter 13: Low-Level Input/Output 387

If you want to modify the file descriptor flags, you should get the current flags with
F_GETFDand modify the value. Don¡¯t assume that the flags listed here are the only ones
that are implemented; your program may be run years from now and more flags may exist
then. For example, here is a function to set or clear the flagFD_CLOEXECwithout altering
any other flags:
/*Set theFD_CLOEXECflag ofdescifvalueis nonzero,
or clear the flag ifvalueis 0.
Return 0 on success, or -1 on error witherrnoset.*/

```
int
set_cloexec_flag (int desc, int value)
{
int oldflags = fcntl (desc, F_GETFD, 0);
/*If reading the flags failed, return error indication now.*/
if (oldflags < 0)
return oldflags;
/*Set just the flag we want to set.*/
if (value != 0)
oldflags |= FD_CLOEXEC;
else
oldflags &= ~FD_CLOEXEC;
/*Store modified flag word in the descriptor.*/
return fcntl (desc, F_SETFD, oldflags);
}
```
## 13.15 File Status Flags...........................................

File status flags are used to specify attributes of the opening of a file. Unlike the file
descriptor flags discussed inSection 13.14 [File Descriptor Flags], page 386, the file status
flags are shared by duplicated file descriptors resulting from a single opening of the file. The
file status flags are specified with theflags argument toopen; seeSection 13.1 [Opening
and Closing Files], page 342.

```
File status flags fall into three categories, which are described in the following sections.
```
- Section 13.15.1 [File Access Modes], page 387, specify what type of access is allowed
    to the file: reading, writing, or both. They are set byopenand are returned byfcntl,
    but cannot be changed.
- Section 13.15.2 [Open-time Flags], page 388, control details of whatopenwill do. These
    flags are not preserved after theopencall.
- Section 13.15.3 [I/O Operating Modes], page 391, affect how operations such asread
    andwriteare done. They are set byopen, and can be fetched or changed withfcntl.
The symbols in this section are defined in the header filefcntl.h.

## 13.15.1 File Access Modes.....................................

The file access mode allows a file descriptor to be used for reading, writing, both, or neither.
The access mode is determined when the file is opened, and never change.

int O_RDONLY [Macro]
Open the file for read access.

int O_WRONLY [Macro]
Open the file for write access.


Chapter 13: Low-Level Input/Output 388

int O_RDWR [Macro]
Open the file for both reading and writing.

int O_PATH [Macro]
Obtain a file descriptor for the file, but do not open the file for reading or writing.
Permission checks for the file itself are skipped when the file is opened (but permission
to access the directory that contains it is still needed), and permissions are checked
when the descriptor is used later on.
For example, such descriptors can be used with thefexecvefunction (seeSection 26.5
[Executing a File], page 806).
This access mode is specific to Linux. On GNU/Hurd systems, it is possible to use
O_EXECexplicitly, or specify no access modes at all (see below).

The portable file access modesO_RDONLY,O_WRONLY, andO_RDWRmay not correspond to
individual bits. To determine the file access mode withfcntl, you must extract the access
mode bits from the retrieved file status flags, using theO_ACCMODEmask.

int O_ACCMODE [Macro]
This macro is a mask that can be bitwise-ANDed with the file status flag value to
recover the file access mode, assuming that a standard file access mode is in use.

If a non-standard file access mode is used (such asO_PATHorO_EXEC), masking with
O_ACCMODEmay give incorrect results. These non-standard access modes are identified by
individual bits and have to be checked directly (without masking withO_ACCMODEfirst).

On GNU/Hurd systems (but not on other systems),O_RDONLYandO_WRONLYare inde-
pendent bits that can be bitwise-ORed together, and it is valid for either bit to be set or
clear. This means thatO_RDWRis the same asO_RDONLY|O_WRONLY. A file access mode of
zero is permissible; it allows no operations that do input or output to the file, but does allow
other operations such asfchmod. On GNU/Hurd systems, since ¡°read-only¡± or ¡°write-only¡±
is a misnomer,fcntl.hdefines additional names for the file access modes.

int O_READ [Macro]
Open the file for reading. Same asO_RDONLY; only defined on GNU/Hurd.

int O_WRITE [Macro]
Open the file for writing. Same asO_WRONLY; only defined on GNU/Hurd.

int O_EXEC [Macro]
Open the file for executing. Only defined on GNU/Hurd.

## 13.15.2 Open-time Flags......................................

The open-time flags specify options affecting howopenwill behave. These options are not
preserved once the file is open. The exception to this isO_NONBLOCK, which is also an I/O
operating mode and so itissaved. SeeSection 13.1 [Opening and Closing Files], page 342,
for how to callopen.

```
There are two sorts of options specified by open-time flags.
```
- File name translation flagsaffect howopenlooks up the file name to locate the file,
    and whether the file can be created.


Chapter 13: Low-Level Input/Output 389

- Open-time action flagsspecify extra operations thatopenwill perform on the file once
    it is open.
Here are the file name translation flags.

int O_CREAT [Macro]
If set, the file will be created if it doesn¡¯t already exist.

int O_EXCL [Macro]
If bothO_CREATandO_EXCLare set, thenopenfails if the specified file already exists.
This is guaranteed to never clobber an existing file.
TheO_EXCLflag has a special meaning in combination withO_TMPFILE; see below.

int O_DIRECTORY [Macro]
If set, the open operation fails if the given name is not the name of a directory. The
errnovariable is set toENOTDIRfor this error condition.

int O_NOFOLLOW [Macro]
If set, the open operation fails if the final component of the file name refers to a
symbolic link. Theerrnovariable is set toELOOPfor this error condition.

int O_TMPFILE [Macro]
If this flag is specified, functions in theopenfamily create an unnamed temporary file.
In this case, the pathname argument to theopenfamily of functions (seeSection 13.1
[Opening and Closing Files], page 342) is interpreted as the directory in which the
temporary file is created (thus determining the file system which provides the storage
for the file). TheO_TMPFILEflag must be combined withO_WRONLYorO_RDWR, and
themodeargument is required.
The temporary file can later be given a name usinglinkat, turning it into a regular
file. This allows the atomic creation of a file with the specific file attributes (mode
and extended attributes) and file contents. If, for security reasons, it is not desirable
that a name can be given to the file, theO_EXCLflag can be specified along with
O_TMPFILE.
Not all kernels support this open flag. If this flag is unsupported, an attempt to
create an unnamed temporary file fails with an error ofEINVAL. If the underlying file
system does not support theO_TMPFILEflag, anEOPNOTSUPPerror is the result.
TheO_TMPFILEflag is a GNU extension.

int O_NONBLOCK [Macro]
This preventsopenfrom blocking for a ¡°long time¡± to open the file. This is only
meaningful for some kinds of files, usually devices such as serial ports; when it is
not meaningful, it is harmless and ignored. Often, opening a port to a modem blocks
until the modem reports carrier detection; ifO_NONBLOCKis specified,openwill return
immediately without a carrier.
Note that theO_NONBLOCKflag is overloaded as both an I/O operating mode and a
file name translation flag. This means that specifyingO_NONBLOCKinopenalso sets
nonblocking I/O mode; seeSection 13.15.3 [I/O Operating Modes], page 391. To
open the file without blocking but do normal I/O that blocks, you must callopen
withO_NONBLOCKset and then callfcntlto turn the bit off.


Chapter 13: Low-Level Input/Output 390

int O_NOCTTY [Macro]
If the named file is a terminal device, don¡¯t make it the controlling terminal for the
process. SeeChapter 28 [Job Control], page 817, for information about what it means
to be the controlling terminal.
On GNU/Hurd systems and 4.4 BSD, opening a file never makes it the controlling
terminal andO_NOCTTYis zero. However, GNU/Linux systems and some other systems
use a nonzero value forO_NOCTTYand set the controlling terminal when you open a
file that is a terminal device; so to be portable, useO_NOCTTYwhen it is important
to avoid this.

```
The following three file name translation flags exist only on GNU/Hurd systems.
```
int O_IGNORE_CTTY [Macro]
Do not recognize the named file as the controlling terminal, even if it refers to the
process¡¯s existing controlling terminal device. Operations on the new file descriptor
will never induce job control signals. SeeChapter 28 [Job Control], page 817.

int O_NOLINK [Macro]
If the named file is a symbolic link, open the link itself instead of the file it refers to.
(fstaton the new file descriptor will return the information returned bylstaton
the link¡¯s name.)

int O_NOTRANS [Macro]
If the named file is specially translated, do not invoke the translator. Open the bare
file the translator itself sees.

The open-time action flags tellopento do additional operations which are not really
related to opening the file. The reason to do them as part ofopeninstead of in separate
calls is thatopencan do thematomically.

int O_TRUNC [Macro]
Truncate the file to zero length. This option is only useful for regular files, not special
files such as directories or FIFOs. POSIX.1 requires that you open the file for writing
to useO_TRUNC. In BSD and GNU you must have permission to write the file to
truncate it, but you need not open for write access.
This is the only open-time action flag specified by POSIX.1. There is no good reason
for truncation to be done byopen, instead of by callingftruncateafterwards. The
O_TRUNCflag existed in Unix before ftruncatewas invented, and is retained for
backward compatibility.

The remaining operating modes are BSD extensions. They exist only on some systems.
On other systems, these macros are not defined.

int O_SHLOCK [Macro]
Acquire a shared lock on the file, as withflock. SeeSection 13.16 [File Locks],
page 393.
IfO_CREATis specified, the locking is done atomically when creating the file. You are
guaranteed that no other process will get the lock on the new file first.


Chapter 13: Low-Level Input/Output 391

int O_EXLOCK [Macro]
Acquire an exclusive lock on the file, as withflock. SeeSection 13.16 [File Locks],
page 393. This is atomic likeO_SHLOCK.

## 13.15.3 I/O Operating Modes.................................

The operating modes affect how input and output operations using a file descriptor work.
These flags are set byopenand can be fetched and changed withfcntl.

int O_APPEND [Macro]
The bit that enables append mode for the file. If set, then allwriteoperations write
the data at the end of the file, extending it, regardless of the current file position.
This is the only reliable way to append to a file. In append mode, you are guaranteed
that the data you write will always go to the current end of the file, regardless of
other processes writing to the file. Conversely, if you simply set the file position to
the end of file and write, then another process can extend the file after you set the
file position but before you write, resulting in your data appearing someplace before
the real end of file.

int O_NONBLOCK [Macro]
The bit that enables nonblocking mode for the file. If this bit is set,readrequests on
the file can return immediately with a failure status if there is no input immediately
available, instead of blocking. Likewise,writerequests can also return immediately
with a failure status if the output can¡¯t be written immediately.
Note that theO_NONBLOCKflag is overloaded as both an I/O operating mode and a
file name translation flag; seeSection 13.15.2 [Open-time Flags], page 388.

int O_NDELAY [Macro]
This is an obsolete name forO_NONBLOCK, provided for compatibility with BSD. It is
not defined by the POSIX.1 standard.

The remaining operating modes are BSD and GNU extensions. They exist only on some
systems. On other systems, these macros are not defined.

int O_ASYNC [Macro]
The bit that enables asynchronous input mode. If set, thenSIGIOsignals will be gen-
erated when input is available. SeeSection 13.19 [Interrupt-Driven Input], page 400.
Asynchronous input mode is a BSD feature.

int O_FSYNC [Macro]
The bit that enables synchronous writing for the file. If set, eachwritecall will make
sure the data is reliably stored on disk before returning.
Synchronous writing is a BSD feature.

int O_SYNC [Macro]
This is another name forO_FSYNC. They have the same value.

int O_NOATIME [Macro]
If this bit is set,readwill not update the access time of the file. SeeSection 14.9.9
[File Times], page 439. This is used by programs that do backups, so that backing a


Chapter 13: Low-Level Input/Output 392

```
file up does not count as reading it. Only the owner of the file or the superuser may
use this bit.
```
```
This is a GNU extension.
```
## 13.15.4 Getting and Setting File Status Flags..................

Thefcntlfunction can fetch or change file status flags.

int F_GETFL [Macro]
This macro is used as thecommandargument tofcntl, to read the file status flags
for the open file with descriptorfiledes.

```
The normal return value fromfcntlwith this command is a nonnegative number
which can be interpreted as the bitwise OR of the individual flags. Since the file
access modes are not single-bit values, you can mask off other bits in the returned
flags withO_ACCMODEto compare them.
```
```
In case of an error, fcntlreturns?1. The following errnoerror conditions are
defined for this command:
```
```
EBADF Thefiledesargument is invalid.
```
int F_SETFL [Macro]
This macro is used as thecommandargument tofcntl, to set the file status flags for
the open file corresponding to thefiledesargument. This command requires a third
intargument to specify the new flags, so the call looks like this:

```
fcntl (filedes, F_SETFL,new-flags)
```
```
You can¡¯t change the access mode for the file in this way; that is, whether the file
descriptor was opened for reading or writing.
```
```
The normal return value fromfcntlwith this command is an unspecified value other
than?1, which indicates an error. The error conditions are the same as for the
F_GETFLcommand.
```
If you want to modify the file status flags, you should get the current flags withF_GETFL
and modify the value. Don¡¯t assume that the flags listed here are the only ones that are
implemented; your program may be run years from now and more flags may exist then. For
example, here is a function to set or clear the flagO_NONBLOCKwithout altering any other
flags:


Chapter 13: Low-Level Input/Output 393

```
/*Set theO_NONBLOCKflag ofdescifvalueis nonzero,
or clear the flag ifvalueis 0.
Return 0 on success, or -1 on error witherrnoset.*/
```
```
int
set_nonblock_flag (int desc, int value)
{
int oldflags = fcntl (desc, F_GETFL, 0);
/*If reading the flags failed, return error indication now.*/
if (oldflags == -1)
return -1;
/*Set just the flag we want to set.*/
if (value != 0)
oldflags |= O_NONBLOCK;
else
oldflags &= ~O_NONBLOCK;
/*Store modified flag word in the descriptor.*/
return fcntl (desc, F_SETFL, oldflags);
}
```
## 13.16 File Locks..................................................

This section describes record locks that are associated with the process. There is also a
different type of record lock that is associated with the open file description instead of the
process. SeeSection 13.17 [Open File Description Locks], page 396.

The remaining fcntlcommands are used to supportrecord locking, which permits
multiple cooperating programs to prevent each other from simultaneously accessing parts
of a file in error-prone ways.

Anexclusive orwritelock gives a process exclusive access for writing to the specified
part of the file. While a write lock is in place, no other process can lock that part of the
file.

Asharedorreadlock prohibits any other process from requesting a write lock on the
specified part of the file. However, other processes can request read locks.

Thereadandwritefunctions do not actually check to see whether there are any locks
in place. If you want to implement a locking protocol for a file shared by multiple processes,
your application must do explicitfcntlcalls to request and clear locks at the appropriate
points.

Locks are associated with processes. A process can only have one kind of lock set for
each byte of a given file. When any file descriptor for that file is closed by the process, all of
the locks that process holds on that file are released, even if the locks were made using other
descriptors that remain open. Likewise, locks are released when a process exits, and are
not inherited by child processes created usingfork(seeSection 26.4 [Creating a Process],
page 805).

When making a lock, use astruct flockto specify what kind of lock and where. This
data type and the associated macros for thefcntlfunction are declared in the header file
fcntl.h.

struct flock [Data Type]
This structure is used with thefcntlfunction to describe a file lock. It has these
members:


Chapter 13: Low-Level Input/Output 394

```
short int l_type
Specifies the type of the lock; one ofF_RDLCK,F_WRLCK, orF_UNLCK.
```
```
short int l_whence
This corresponds to thewhenceargument tofseekorlseek, and specifies
what the offset is relative to. Its value can be one ofSEEK_SET,SEEK_CUR,
orSEEK_END.
```
```
off_t l_start
This specifies the offset of the start of the region to which the lock applies,
and is given in bytes relative to the point specified by the l_whence
member.
```
```
off_t l_len
This specifies the length of the region to be locked. A value of 0 is treated
specially; it means the region extends to the end of the file.
```
```
pid_t l_pid
This field is the process ID (seeSection 26.2 [Process Creation Concepts],
page 804) of the process holding the lock. It is filled in by callingfcntl
with theF_GETLKcommand, but is ignored when making a lock. If the
conflicting lock is an open file description lock (seeSection 13.17 [Open
File Description Locks], page 396), then this field will be set to?1.
```
int F_GETLK [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should
get information about a lock. This command requires a third argument of type
struct flock *to be passed tofcntl, so that the form of the call is:
fcntl (filedes, F_GETLK,lockp)
If there is a lock already in place that would block the lock described by thelockp
argument, information about that lock overwrites*lockp. Existing locks are not
reported if they are compatible with making a new lock as specified. Thus, you
should specify a lock type ofF_WRLCKif you want to find out about both read and
write locks, orF_RDLCKif you want to find out about write locks only.
There might be more than one lock affecting the region specified by thelockpargu-
ment, butfcntlonly returns information about one of them. Thel_whencemember
of thelockpstructure is set toSEEK_SETand thel_startandl_lenfields set to
identify the locked region.
If no lock applies, the only change to thelockpstructure is to update thel_typeto
a value ofF_UNLCK.
The normal return value fromfcntlwith this command is an unspecified value other
than?1, which is reserved to indicate an error. The followingerrnoerror conditions
are defined for this command:

```
EBADF Thefiledesargument is invalid.
```
```
EINVAL Either thelockpargument doesn¡¯t specify valid lock information, or the
file associated withfiledesdoesn¡¯t support locks.
```

Chapter 13: Low-Level Input/Output 395

int F_SETLK [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should set
or clear a lock. This command requires a third argument of typestruct flock *to
be passed tofcntl, so that the form of the call is:
fcntl (filedes, F_SETLK,lockp)
If the process already has a lock on any part of the region, the old lock on that part
is replaced with the new lock. You can remove a lock by specifying a lock type of
F_UNLCK.
If the lock cannot be set,fcntlreturns immediately with a value of?1. This function
does not block while waiting for other processes to release locks. Iffcntlsucceeds,
it returns a value other than?1.
The followingerrnoerror conditions are defined for this function:
EAGAIN
EACCES The lock cannot be set because it is blocked by an existing lock on the
file. Some systems useEAGAINin this case, and other systems useEACCES;
your program should treat them alike, afterF_SETLK. (GNU/Linux and
GNU/Hurd systems always useEAGAIN.)
EBADF Either: thefiledesargument is invalid; you requested a read lock but the
filedesis not open for read access; or, you requested a write lock but the
filedesis not open for write access.
EINVAL Either thelockpargument doesn¡¯t specify valid lock information, or the
file associated withfiledesdoesn¡¯t support locks.
ENOLCK The system has run out of file lock resources; there are already too many
file locks in place.
Well-designed file systems never report this error, because they have no
limitation on the number of locks. However, you must still take account
of the possibility of this error, as it could result from network access to a
file system on another machine.

int F_SETLKW [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should set
or clear a lock. It is just like theF_SETLKcommand, but causes the process to block
(or wait) until the request can be specified.
This command requires a third argument of typestruct flock *, as for theF_SETLK
command.
Thefcntlreturn values and errors are the same as for theF_SETLKcommand, but
these additionalerrnoerror conditions are defined for this command:
EINTR The function was interrupted by a signal while it was waiting. See
Section 24.5 [Primitives Interrupted by Signals], page 741.
EDEADLK The specified region is being locked by another process. But that process
is waiting to lock a region which the current process has locked, so waiting
for the lock would result in deadlock. The system does not guarantee that
it will detect all such conditions, but it lets you know if it notices one.


Chapter 13: Low-Level Input/Output 396

The following macros are defined for use as values for thel_typemember of theflock
structure. The values are integer constants.

F_RDLCK This macro is used to specify a read (or shared) lock.

F_WRLCK This macro is used to specify a write (or exclusive) lock.

F_UNLCK This macro is used to specify that the region is unlocked.

As an example of a situation where file locking is useful, consider a program that can
be run simultaneously by several different users, that logs status information to a common
file. One example of such a program might be a game that uses a file to keep track of high
scores. Another example might be a program that records usage or accounting information
for billing purposes.

Having multiple copies of the program simultaneously writing to the file could cause
the contents of the file to become mixed up. But you can prevent this kind of problem by
setting a write lock on the file before actually writing to the file.

If the program also needs to read the file and wants to make sure that the contents of
the file are in a consistent state, then it can also use a read lock. While the read lock is set,
no other process can lock that part of the file for writing.

Remember that file locks are only anadvisoryprotocol for controlling access to a file.
There is still potential for access to the file by programs that don¡¯t use the lock protocol.

## 13.17 Open File Description Locks...............................

In contrast to process-associated record locks (seeSection 13.16 [File Locks], page 393),
open file description record locks are associated with an open file description rather than a
process.

Usingfcntlto apply an open file description lock on a region that already has an
existing open file description lock that was created via the same file descriptor will never
cause a lock conflict.

Open file description locks are also inherited by child processes acrossfork, orclone
withCLONE_FILESset (seeSection 26.4 [Creating a Process], page 805), along with the file
descriptor.

It is important to distinguish between the open filedescription(an instance of an open
file, usually created by a call toopen) and an open filedescriptor, which is a numeric value
that refers to the open file description. The locks described here are associated with the
open filedescriptionand not the open filedescriptor.

Usingdup(seeSection 13.13 [Duplicating Descriptors], page 384) to copy a file descriptor
does not give you a new open file description, but rather copies a reference to an existing
open file description and assigns it to a new file descriptor. Thus, open file description locks
set on a file descriptor cloned bydupwill never conflict with open file description locks set
on the original descriptor since they refer to the same open file description. Depending on
the range and type of lock involved, the original lock may be modified by aF_OFD_SETLK
orF_OFD_SETLKWcommand in this situation however.

Open file description locks always conflict with process-associated locks, even if acquired
by the same process or on the same open file descriptor.


Chapter 13: Low-Level Input/Output 397

Open file description locks use the samestruct flockas process-associated locks as an
argument (seeSection 13.16 [File Locks], page 393) and the macros for thecommandvalues
are also declared in the header filefcntl.h. To use them, the macro_GNU_SOURCEmust be
defined prior to including any header file.

In contrast to process-associated locks, anystruct flockused as an argument to open
file description lock commands must have thel_pidvalue set to 0. Also, when returning
information about an open file description lock in aF_GETLKorF_OFD_GETLKrequest, the
l_pidfield instruct flockwill be set to?1 to indicate that the lock is not associated
with a process.

When the samestruct flockis reused as an argument to aF_OFD_SETLKorF_OFD_
SETLKWrequest after being used for anF_OFD_GETLKrequest, it is necessary to inspect and
reset thel_pidfield to 0.

int F_OFD_GETLK [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should
get information about a lock. This command requires a third argument of type
struct flock *to be passed tofcntl, so that the form of the call is:
fcntl (filedes, F_OFD_GETLK,lockp)
If there is a lock already in place that would block the lock described by thelockp
argument, information about that lock is written to*lockp. Existing locks are not
reported if they are compatible with making a new lock as specified. Thus, you should
specify a lock type ofF_WRLCKif you want to find out about both read and write locks,
orF_RDLCKif you want to find out about write locks only.
There might be more than one lock affecting the region specified by thelockpargu-
ment, butfcntlonly returns information about one of them. Which lock is returned
in this situation is undefined.
Thel_whencemember of thelockpstructure are set toSEEK_SETand thel_start
andl_lenfields are set to identify the locked region.
If no conflicting lock exists, the only change to thelockpstructure is to update the
l_typefield to the valueF_UNLCK.
The normal return value fromfcntlwith this command is either 0 on success or?1,
which indicates an error. The followingerrnoerror conditions are defined for this
command:
EBADF Thefiledesargument is invalid.
EINVAL Either the lockp argument doesn¡¯t specify valid lock information, the
operating system kernel doesn¡¯t support open file description locks, or
the file associated withfiledesdoesn¡¯t support locks.

int F_OFD_SETLK [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should set
or clear a lock. This command requires a third argument of typestruct flock *to
be passed tofcntl, so that the form of the call is:
fcntl (filedes, F_OFD_SETLK,lockp)
If the open file already has a lock on any part of the region, the old lock on that part
is replaced with the new lock. You can remove a lock by specifying a lock type of
F_UNLCK.


Chapter 13: Low-Level Input/Output 398

```
If the lock cannot be set,fcntlreturns immediately with a value of?1. This com-
mand does not wait for other tasks to release locks. Iffcntlsucceeds, it returns
0.
```
```
The followingerrnoerror conditions are defined for this command:
```
```
EAGAIN The lock cannot be set because it is blocked by an existing lock on the
file.
```
```
EBADF Either: thefiledesargument is invalid; you requested a read lock but the
filedesis not open for read access; or, you requested a write lock but the
filedesis not open for write access.
```
```
EINVAL Either the lockp argument doesn¡¯t specify valid lock information, the
operating system kernel doesn¡¯t support open file description locks, or
the file associated withfiledesdoesn¡¯t support locks.
```
```
ENOLCK The system has run out of file lock resources; there are already too many
file locks in place.
Well-designed file systems never report this error, because they have no
limitation on the number of locks. However, you must still take account
of the possibility of this error, as it could result from network access to a
file system on another machine.
```
int F_OFD_SETLKW [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should set
or clear a lock. It is just like theF_OFD_SETLKcommand, but causes the process to
wait until the request can be completed.

```
This command requires a third argument of typestruct flock *, as for theF_OFD_
SETLKcommand.
```
```
Thefcntlreturn values and errors are the same as for theF_OFD_SETLKcommand,
but these additionalerrnoerror conditions are defined for this command:
```
```
EINTR The function was interrupted by a signal while it was waiting. See
Section 24.5 [Primitives Interrupted by Signals], page 741.
```
Open file description locks are useful in the same sorts of situations as process-associated
locks. They can also be used to synchronize file access between threads within the same
process by having each thread perform its ownopenof the file, to obtain its own open file
description.

Because open file description locks are automatically freed only upon closing the last
file descriptor that refers to the open file description, this locking mechanism avoids the
possibility that locks are inadvertently released due to a library routine opening and closing
a file without the application being aware.

```
As with process-associated locks, open file description locks are advisory.
```

Chapter 13: Low-Level Input/Output 399

## 13.18 Open File Description Locks Example......................

Here is an example of using open file description locks in a threaded program. If this
program used process-associated locks, then it would be subject to data corruption because
process-associated locks are shared by the threads inside a process, and thus cannot be used
by one thread to lock out another thread in the same process.

```
Proper error handling has been omitted in the following program for brevity.
```
```
#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
```
```
#define FILENAME "/tmp/foo"
#define NUM_THREADS 3
#define ITERATIONS 5
```
```
void *
thread_start (void *arg)
{
int i, fd, len;
long tid = (long) arg;
char buf[256];
struct flock lck = {
.l_whence = SEEK_SET,
.l_start = 0,
.l_len = 1,
};
```
```
fd = open ("/tmp/foo", O_RDWR | O_CREAT, 0666);
```
```
for (i = 0; i < ITERATIONS; i++)
{
lck.l_type = F_WRLCK;
fcntl (fd, F_OFD_SETLKW, &lck);
```
```
len = sprintf (buf, "%d: tid=%ld fd=%d\n", i, tid, fd);
```
```
lseek (fd, 0, SEEK_END);
write (fd, buf, len);
fsync (fd);
```
```
lck.l_type = F_UNLCK;
fcntl (fd, F_OFD_SETLK, &lck);
```
```
/*sleep to ensure lock is yielded to another thread*/
usleep (1);
}
pthread_exit (NULL);
}
```
```
int
main (int argc, char **argv)
{
```

Chapter 13: Low-Level Input/Output 400

```
long i;
pthread_t threads[NUM_THREADS];
```
```
truncate (FILENAME, 0);
```
```
for (i = 0; i < NUM_THREADS; i++)
pthread_create (&threads[i], NULL, thread_start, (void *) i);
```
pthread_exit (NULL);
return 0;
}
This example creates three threads each of which loops five times, appending to the file.
Access to the file is serialized via open file description locks. If we compile and run the
above program, we¡¯ll end up with /tmp/foo that has 15 lines in it.

If we, however, were to replace theF_OFD_SETLKandF_OFD_SETLKWcommands with
their process-associated lock equivalents, the locking essentially becomes a noop since it is
all done within the context of the same process. That leads to data corruption (typically
manifested as missing lines) as some threads race in and overwrite the data written by
others.

## 13.19 Interrupt-Driven Input.....................................

If you set theO_ASYNCstatus flag on a file descriptor (seeSection 13.15 [File Status Flags],
page 387), aSIGIOsignal is sent whenever input or output becomes possible on that file
descriptor. The process or process group to receive the signal can be selected by using
theF_SETOWNcommand to thefcntlfunction. If the file descriptor is a socket, this also
selects the recipient ofSIGURG signals that are delivered when out-of-band data arrives
on that socket; seeSection 16.9.8 [Out-of-Band Data], page 491. (SIGURGis sent in any
situation whereselectwould report the socket as having an ¡°exceptional condition¡±. See
Section 13.9 [Waiting for Input or Output], page 366.)

If the file descriptor corresponds to a terminal device, thenSIGIOsignals are sent to the
foreground process group of the terminal. SeeChapter 28 [Job Control], page 817.

```
The symbols in this section are defined in the header filefcntl.h.
```
int F_GETOWN [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should get
information about the process or process group to whichSIGIOsignals are sent. (For
a terminal, this is actually the foreground process group ID, which you can get using
tcgetpgrp; seeSection 28.6.3 [Functions for Controlling Terminal Access], page 833.)
The return value is interpreted as a process ID; if negative, its absolute value is the
process group ID.
The followingerrnoerror condition is defined for this command:
EBADF Thefiledesargument is invalid.

int F_SETOWN [Macro]
This macro is used as thecommandargument tofcntl, to specify that it should set
the process or process group to whichSIGIOsignals are sent. This command requires
a third argument of typepid_tto be passed tofcntl, so that the form of the call is:
fcntl (filedes, F_SETOWN,pid)


Chapter 13: Low-Level Input/Output 401

```
Thepidargument should be a process ID. You can also pass a negative number whose
absolute value is a process group ID.
The return value fromfcntlwith this command is?1 in case of error and some
other value if successful. The followingerrnoerror conditions are defined for this
command:
```
```
EBADF Thefiledesargument is invalid.
ESRCH There is no process or process group corresponding topid.
```
## 13.20 Generic I/O Control operations............................

GNU systems can handle most input/output operations on many different devices and
objects in terms of a few file primitives -read,writeandlseek. However, most devices
also have a few peculiar operations which do not fit into this model. Such as:

- Changing the character font used on a terminal.
- Telling a magnetic tape system to rewind or fast forward. (Since they cannot move in
    byte increments,lseekis inapplicable).
- Ejecting a disk from a drive.
- Playing an audio track from a CD-ROM drive.
- Maintaining routing tables for a network.
    Although some such objects such as sockets and terminals^1 have special functions of
their own, it would not be practical to create functions for all these cases.

Instead these minor operations, known asIOCTLs, are assigned code numbers and multi-
plexed through theioctlfunction, defined insys/ioctl.h. The code numbers themselves
are defined in many different headers.

int ioctl (intfiledes, intcommand,.. .) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theioctlfunction performs the generic I/O operationcommandonfiledes.
A third argument is usually present, either a single number or a pointer to a structure.
The meaning of this argument, the returned value, and any error codes depends upon
the command used. Often?1 is returned for a failure.

On some systems, IOCTLs used by different devices share the same numbers. Thus,
although use of an inappropriate IOCTLusually only produces an error, you should not
attempt to use device-specific IOCTLs on an unknown device.

Most IOCTLs are OS-specific and/or only used in special system utilities, and are
thus beyond the scope of this document. For an example of the use of an IOCTL, see
Section 16.9.8 [Out-of-Band Data], page 491.

(^1) Actually, the terminal-specific functions are implemented with IOCTLs on many platforms.


### 402

## 14 File System Interface........................

## 14 File System Interface.................................

This chapter describes the GNU C Library¡¯s functions for manipulating files. Unlike the
input and output functions (seeChapter 12 [Input/Output on Streams], page 266; see
Chapter 13 [Low-Level Input/Output], page 342), these functions are concerned with oper-
ating on the files themselves rather than on their contents.

Among the facilities described in this chapter are functions for examining or modifying
directories, functions for renaming and deleting files, and functions for examining and setting
file attributes such as access permissions and modification times.

## 14.1 Working Directory..........................................

Each process has associated with it a directory, called itscurrent working directoryor simply
working directory, that is used in the resolution of relative file names (seeSection 11.2.2
[File Name Resolution], page 264).

When you log in and begin a new session, your working directory is initially set to the
home directory associated with your login account in the system user database. You can
find any user¡¯s home directory using thegetpwuidorgetpwnamfunctions; seeSection 30.13
[User Database], page 864.

Users can change the working directory using shell commands likecd. The functions
described in this section are the primitives used by those commands and by other programs
for examining and changing the working directory.

```
Prototypes for these functions are declared in the header fileunistd.h.
```
char * getcwd(char *buffer, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thegetcwdfunction returns an absolute file name representing the current working
directory, storing it in the character arraybufferthat you provide. Thesizeargument
is how you tell the system the allocation size ofbuffer.
The GNU C Library version of this function also permits you to specify a null pointer
for thebufferargument. Thengetcwdallocates a buffer automatically, as withmalloc
(seeSection 3.2.3 [Unconstrained Allocation], page 45). If thesizeis greater than zero,
then the buffer is that large; otherwise, the buffer is as large as necessary to hold the
result.
The return value isbufferon success and a null pointer on failure. The following
errnoerror conditions are defined for this function:
EINVAL Thesizeargument is zero andbufferis not a null pointer.
ERANGE Thesizeargument is less than the length of the working directory name.
You need to allocate a bigger array and try again.
EACCES Permission to read or search a component of the file name was denied.

You could implement the behavior of GNU¡¯sgetcwd (NULL, 0)using only the standard
behavior ofgetcwd:
char *


Chapter 14: File System Interface 403

```
gnu_getcwd ()
{
size_t size = 100;
```
```
while (1)
{
char *buffer = (char *) xmalloc (size);
if (getcwd (buffer, size) == buffer)
return buffer;
free (buffer);
if (errno != ERANGE)
return 0;
size *= 2;
}
}
```
SeeSection 3.2.3.2 [Examples ofmalloc], page 46, for information aboutxmalloc, which
is not a library function but is a customary name used in most GNU software.

char * getwd (char *buffer) [Deprecated Function]
Preliminary: | MT-Safe | AS-Unsafe heap i18n | AC-Unsafe mem fd | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is similar togetcwd, but has no way to specify the size of the buffer. The GNU
C Library providesgetwdonly for backwards compatibility with BSD.
Thebufferargument should be a pointer to an array at leastPATH_MAXbytes long (see
Section 32.6 [Limits on File System Capacity], page 903). On GNU/Hurd systems
there is no limit to the size of a file name, so this is not necessarily enough space to
contain the directory name. That is why this function is deprecated.

char * get_current_dir_name (void) [Function]
Preliminary: | MT-Safe env | AS-Unsafe heap | AC-Unsafe mem fd | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theget_current_dir_namefunction is basically equivalent togetcwd (NULL, 0),
except the value of thePWD environment variable is first examined, and if it does
in fact correspond to the current directory, that value is returned. This is a subtle
difference which is visible if the path described by the value inPWDis using one or
more symbolic links, in which case the value returned bygetcwdwould resolve the
symbolic links and therefore yield a different result.
This function is a GNU extension.

int chdir (const char *filename) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to set the process¡¯s working directory tofilename.
The normal, successful return value fromchdiris 0. A value of-1is returned to
indicate an error. Theerrnoerror conditions defined for this function are the usual
file name syntax errors (seeSection 11.2.3 [File Name Errors], page 264), plusENOTDIR
if the filefilenameis not a directory.


Chapter 14: File System Interface 404

int fchdir(intfiledes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to set the process¡¯s working directory to directory associated
with the file descriptorfiledes.
The normal, successful return value fromfchdiris 0. A value of-1is returned to
indicate an error. The followingerrnoerror conditions are defined for this function:

```
EACCES Read permission is denied for the directory named bydirname.
```
```
EBADF Thefiledesargument is not a valid file descriptor.
```
```
ENOTDIR The file descriptorfiledesis not associated with a directory.
```
```
EINTR The function call was interrupt by a signal.
```
```
EIO An I/O error occurred.
```
## 14.2 Accessing Directories........................................

The facilities described in this section let you read the contents of a directory file. This is
useful if you want your program to list all the files in a directory, perhaps as part of a menu.

Theopendirfunction opens adirectory streamwhose elements are directory entries.
Alternativelyfdopendircan be used which can have advantages if the program needs to
have more control over the way the directory is opened for reading. This allows, for instance,
to pass theO_NOATIMEflag toopen.

You use thereaddirfunction on the directory stream to retrieve these entries, rep-
resented asstruct direntobjects. The name of the file for each entry is stored in the
d_namemember of this structure. There are obvious parallels here to the stream facilities
for ordinary files, described inChapter 12 [Input/Output on Streams], page 266.

## 14.2.1 Format of a Directory Entry............................

This section describes what you find in a single directory entry, as you might obtain it from
a directory stream. All the symbols are declared in the header filedirent.h.

struct dirent [Data Type]
This is a structure type used to return information about directory entries. It contains
the following fields:

```
char d_name[]
This is the null-terminated file name component. This is the only field
you can count on in all POSIX systems.
```
```
ino_t d_fileno
This is the file serial number. For BSD compatibility, you can also refer
to this member asd_ino. On GNU/Linux and GNU/Hurd systems and
most POSIX systems, for most files this the same as thest_inomember
that statwill return for the file. SeeSection 14.9 [File Attributes],
page 425.
```

Chapter 14: File System Interface 405

```
unsigned char d_namlen
This is the length of the file name, not including the terminating null
character. Its type is unsigned charbecause that is the integer type
of the appropriate size. This member is a BSD extension. The symbol
_DIRENT_HAVE_D_NAMLENis defined if this member is available.
unsigned char d_type
This is the type of the file, possibly unknown. The following constants
are defined for its value:
DT_UNKNOWN
The type is unknown. Only some filesystems have full sup-
port to return the type of the file, others might always return
this value.
DT_REG A regular file.
DT_DIR A directory.
DT_FIFO A named pipe, or FIFO. SeeSection 15.3 [FIFO Special Files],
page 453.
DT_SOCK A local-domain socket.
DT_CHR A character device.
DT_BLK A block device.
DT_LNK A symbolic link.
This member is a BSD extension. The symbol_DIRENT_HAVE_D_TYPE
is defined if this member is available. On systems where it is used, it
corresponds to the file type bits in thest_modemember ofstruct stat.
If the value cannot be determined the member value is DTUNKNOWN.
These two macros convert betweend_typevalues andst_modevalues:
```
```
int IFTODT (modetmode) [Function]
Preliminary:|MT-Safe |AS-Safe|AC-Safe|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This returns thed_typevalue corresponding tomode.
```
```
mode_t DTTOIF(intdtype) [Function]
Preliminary:|MT-Safe |AS-Safe|AC-Safe|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This returns thest_modevalue corresponding todtype.
```
```
This structure may contain additional members in the future. Their availability
is always announced in the compilation environment by a macro named_DIRENT_
HAVE_D_xxxwherexxxis replaced by the name of the new member. For instance,
the memberd_reclenavailable on some systems is announced through the macro
_DIRENT_HAVE_D_RECLEN.
When a file has multiple names, each name has its own directory entry. The only
way you can tell that the directory entries belong to a single file is that they have the
same value for thed_filenofield.
```

Chapter 14: File System Interface 406

```
File attributes such as size, modification times etc., are part of the file itself, not of
any particular directory entry. SeeSection 14.9 [File Attributes], page 425.
```
## 14.2.2 Opening a Directory Stream............................

This section describes how to open a directory stream. All the symbols are declared in the
header filedirent.h.

DIR [Data Type]
TheDIRdata type represents a directory stream.

You shouldn¡¯t ever allocate objects of thestruct direntorDIRdata types, since the
directory access functions do that for you. Instead, you refer to these objects using the
pointers returned by the following functions.

Directory streams are a high-level interface. On Linux, alternative interfaces for access-
ing directories using file descriptors are available. SeeSection 14.2.8 [Low-level Directory
Access], page 413.

DIR * opendir(const char *dirname) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theopendirfunction opens and returns a directory stream for reading the directory
whose file name isdirname. The stream has typeDIR *.
If unsuccessful,opendirreturns a null pointer. In addition to the usual file name
errors (seeSection 11.2.3 [File Name Errors], page 264), the followingerrnoerror
conditions are defined for this function:
EACCES Read permission is denied for the directory named bydirname.
EMFILE The process has too many files open.
ENFILE The entire system, or perhaps the file system which contains the directory,
cannot support any additional open files at the moment. (This problem
cannot happen on GNU/Hurd systems.)
ENOMEM Not enough memory available.
TheDIR type is typically implemented using a file descriptor, and the opendir
function in terms of theopenfunction. SeeChapter 13 [Low-Level Input/Output],
page 342. Directory streams and the underlying file descriptors are closed onexec
(seeSection 26.5 [Executing a File], page 806).

The directory which is opened for reading byopendiris identified by the name. In some
situations this is not sufficient. Or the wayopendirimplicitly creates a file descriptor for
the directory is not the way a program might want it. In these cases an alternative interface
can be used.

DIR * fdopendir (intfd) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thefdopendirfunction works just likeopendirbut instead of taking a file name
and opening a file descriptor for the directory the caller is required to provide a


Chapter 14: File System Interface 407

```
file descriptor. This file descriptor is then used in subsequent uses of the returned
directory stream object.
The caller must make sure the file descriptor is associated with a directory and it
allows reading.
If thefdopendircall returns successfully the file descriptor is now under the control
of the system. It can be used in the same way the descriptor implicitly created by
opendircan be used but the program must not close the descriptor.
In case the function is unsuccessful it returns a null pointer and the file descriptor
remains to be usable by the program. The followingerrnoerror conditions are defined
for this function:
```
```
EBADF The file descriptor is not valid.
```
```
ENOTDIR The file descriptor is not associated with a directory.
```
```
EINVAL The descriptor does not allow reading the directory content.
```
```
ENOMEM Not enough memory available.
```
In some situations it can be desirable to get hold of the file descriptor which is created
by theopendircall. For instance, to switch the current working directory to the directory
just read thefchdirfunction could be used. Historically theDIRtype was exposed and
programs could access the fields. This does not happen in the GNU C Library. Instead a
separate function is provided to allow access.

int dirfd (DIR *dirstream) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functiondirfdreturns the file descriptor associated with the directory stream
dirstream. This descriptor can be used until the directory is closed withclosedir.
If the directory stream implementation is not using file descriptors the return value
is-1.

## 14.2.3 Reading and Closing a Directory Stream................

This section describes how to read directory entries from a directory stream, and how to
close the stream when you are done with it. All the symbols are declared in the header file
dirent.h.

struct dirent * readdir (DIR *dirstream) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function reads the next entry from the directory. It normally returns a pointer
to a structure containing information about the file. This structure is associated with
thedirstreamhandle and can be rewritten by a subsequent call.
Portability Note: On some systemsreaddirmay not return entries for.and..,
even though these are always valid file names in any directory. SeeSection 11.2.2
[File Name Resolution], page 264.


Chapter 14: File System Interface 408

```
If there are no more entries in the directory or an error is detected,readdirreturns
a null pointer. The followingerrnoerror conditions are defined for this function:
EBADF Thedirstreamargument is not valid.
To distinguish between an end-of-directory condition or an error, you must seterrno
to zero before callingreaddir. To avoid entering an infinite loop, you should stop
reading from the directory after the first error.
Caution:The pointer returned byreaddirpoints to a buffer within theDIRobject.
The data in that buffer will be overwritten by the next call toreaddir. You must
take care, for instance, to copy thed_namestring if you need it later.
Because of this, it is not safe to share aDIRobject among multiple threads, unless you
use your own locking to ensure that no thread callsreaddirwhile another thread
is still using the data from the previous call. In the GNU C Library, it is safe to
callreaddirfrom multiple threads as long as each thread uses its ownDIRobject.
POSIX.1-2008 does not require this to be safe, but we are not aware of any operating
systems where it does not work.
readdir_rallows you to provide your own buffer for thestruct dirent, but it is
less portable thanreaddir, and has problems with very long filenames (see below).
We recommend you usereaddir, but do not shareDIRobjects.
```
int readdir_r(DIR *dirstream, struct dirent *entry, struct dirent [Function]
**result)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function is a version ofreaddirwhich performs internal locking. Likereaddirit
returns the next entry from the directory. To prevent conflicts between simultaneously
running threads the result is stored inside theentryobject.
Portability Note:readdir_ris deprecated. It is recommended to usereaddirinstead
ofreaddir_rfor the following reasons:

- On systems which do not defineNAME_MAX, it may not be possible to usereaddir_
    rsafely because the caller does not specify the length of the buffer for the direc-
    tory entry.
- On some systems,readdir_rcannot read directory entries with very long names.
    If such a name is encountered, the GNU C Library implementation ofreaddir_r
    returns with an error code ofENAMETOOLONGafter the final directory entry has
    been read. On other systems,readdir_rmay return successfully, but thed_name
    member may not be NUL-terminated or may be truncated.
- POSIX-1.2008 does not guarantee thatreaddiris thread-safe, even when access
    to the samedirstreamis serialized. But in current implementations (including the
    GNU C Library), it is safe to callreaddirconcurrently on differentdirstreams,
    so there is no need to usereaddir_rin most multi-threaded programs. In the
    rare case that multiple threads need to read from the samedirstream, it is still
    better to usereaddirand external synchronization.
- It is expected that future versions of POSIX will obsoletereaddir_rand mandate
    the level of thread safety forreaddirwhich is provided by the GNU C Library
    and other implementations today.


Chapter 14: File System Interface 409

```
Normallyreaddir_rreturns zero and sets*resulttoentry. If there are no more
entries in the directory or an error is detected,readdir_rsets*resultto a null
pointer and returns a nonzero error code, also stored inerrno, as described for
readdir.
It is also important to look at the definition of thestruct direnttype. Simply
passing a pointer to an object of this type for the second parameter ofreaddir_r
might not be enough. Some systems don¡¯t define thed_nameelement sufficiently long.
In this case the user has to provide additional space. There must be room for at least
NAME_MAX + 1characters in thed_namearray. Code to callreaddir_rcould look like
this:
union
{
struct dirent d;
char b[offsetof (struct dirent, d_name) + NAME_MAX + 1];
} u;
```
```
if (readdir_r (dir, &u.d, &res) == 0)
...
```
To support large filesystems on 32-bit machines there are LFS variants of the last two
functions.

struct dirent64 * readdir64 (DIR *dirstream) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thereaddir64function is just like the readdirfunction except that it returns a
pointer to a record of typestruct dirent64. Some of the members of this data type
(notablyd_ino) might have a different size to allow large filesystems.
In all other aspects this function is equivalent toreaddir.

int readdir64_r (DIR *dirstream, struct dirent64 *entry, struct [Function]
dirent64 **result)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The deprecatedreaddir64_rfunction is equivalent to thereaddir_rfunction except
that it takes parameters of base typestruct dirent64instead ofstruct direntin
the second and third position. The same precautions mentioned in the documentation
ofreaddir_ralso apply here.

int closedir (DIR *dirstream) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap lock/hurd|AC-Unsafe mem fd lock/hurd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function closes the directory streamdirstream. It returns 0 on success and-1
on failure.
The followingerrnoerror conditions are defined for this function:

```
EBADF Thedirstreamargument is not valid.
```

Chapter 14: File System Interface 410

## 14.2.4 Simple Program to List a Directory.....................

Here¡¯s a simple program that prints the names of the files in the current working directory:

```
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
```
```
int
main (void)
{
DIR *dp;
struct dirent *ep;
```
```
dp = opendir ("./");
if (dp != NULL)
{
while (ep = readdir (dp))
puts (ep->d_name);
(void) closedir (dp);
}
else
perror ("Couldn't open the directory");
```
return 0;
}
The order in which files appear in a directory tends to be fairly random. A more useful
program would sort the entries (perhaps by alphabetizing them) before printing them; see
Section 14.2.6 [Scanning the Content of a Directory], page 411, andSection 9.3 [Array Sort
Function], page 229.

## 14.2.5 Random Access in a Directory Stream..................

This section describes how to reread parts of a directory that you have already read from
an open directory stream. All the symbols are declared in the header filedirent.h.

void rewinddir(DIR *dirstream) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Therewinddirfunction is used to reinitialize the directory streamdirstream, so that
if you callreaddirit returns information about the first entry in the directory again.
This function also notices if files have been added or removed to the directory since it
was opened withopendir. (Entries for these files might or might not be returned by
readdirif they were added or removed since you last calledopendirorrewinddir.)

long int telldir (DIR *dirstream) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap/bsd lock/bsd|AC-Unsafe mem/bsd
lock/bsd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thetelldirfunction returns the file position of the directory streamdirstream. You
can use this value withseekdirto restore the directory stream to that position.

void seekdir (DIR *dirstream, long intpos) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap/bsd lock/bsd|AC-Unsafe mem/bsd
lock/bsd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 14: File System Interface 411

```
Theseekdirfunction sets the file position of the directory streamdirstreamtopos.
The valueposmust be the result of a previous call totelldiron this particular
stream; closing and reopening the directory can invalidate values returned bytelldir.
```
## 14.2.6 Scanning the Content of a Directory....................

A higher-level interface to the directory handling functions is thescandirfunction. With
its help one can select a subset of the entries in a directory, possibly sort them and get a
list of names as the result.

int scandir(const char *dir, struct dirent ***namelist, int [Function]
(*selector)(const struct dirent *), int(*cmp)(const struct dirent **,
const struct dirent **))
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thescandirfunction scans the contents of the directory selected bydir. The result in
*namelistis an array of pointers to structures of typestruct direntwhich describe
all selected directory entries and which is allocated usingmalloc. Instead of always
getting all directory entries returned, the user supplied functionselectorcan be used
to decide which entries are in the result. Only the entries for whichselectorreturns
a non-zero value are selected.
Finally the entries in *namelist are sorted using the user-supplied functioncmp.
The arguments passed to thecmpfunction are of typestruct dirent **, therefore
one cannot directly use thestrcmporstrcollfunctions; instead see the functions
alphasortandversionsortbelow.
The return value of the function is the number of entries placed in *namelist. If it
is-1an error occurred (either the directory could not be opened for reading or the
malloc call failed) and the global variableerrnocontains more information on the
error.

As described above, the fourth argument to thescandirfunction must be a pointer to
a sorting function. For the convenience of the programmer the GNU C Library contains
implementations of functions which are very helpful for this purpose.

int alphasort(const struct dirent **a, const struct dirent **b) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The alphasort function behaves like the strcoll function (see Section 5.7
[String/Array Comparison], page 113). The difference is that the arguments are not
string pointers but instead they are of typestruct dirent **.
The return value ofalphasortis less than, equal to, or greater than zero depending
on the order of the two entriesaandb.

int versionsort (const struct dirent **a, const struct dirent **b) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Theversionsortfunction is likealphasortexcept that it uses the strverscmp
function internally.


Chapter 14: File System Interface 412

If the filesystem supports large files we cannot use thescandiranymore since thedirent
structure might not able to contain all the information. The LFS provides the new type
struct dirent64. To use this we need a new function.

int scandir64(const char *dir, struct dirent64 ***namelist, int [Function]
(*selector)(const struct dirent64 *), int(*cmp)(const struct dirent64
**, const struct dirent64 **))
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thescandir64function works like thescandirfunction except that the directory
entries it returns are described by elements of typestruct dirent64. The function
pointed to byselectoris again used to select the desired entries, except thatselector
now must point to a function which takes astruct dirent64 *parameter.
Similarly thecmpfunction should expect its two arguments to be of typestruct
dirent64 **.

Ascmpis now a function of a different type, the functionsalphasortandversionsort
cannot be supplied for that argument. Instead we provide the two replacement functions
below.

int alphasort64 (const struct dirent64 **a, const struct dirent **b) [Function]
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The alphasort64 function behaves like the strcoll function (see Section 5.7
[String/Array Comparison], page 113). The difference is that the arguments are not
string pointers but instead they are of typestruct dirent64 **.
Return value ofalphasort64is less than, equal to, or greater than zero depending
on the order of the two entriesaandb.

int versionsort64(const struct dirent64 **a, const struct dirent64 [Function]
**b)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
The versionsort64 function is like alphasort64, excepted that it uses the
strverscmpfunction internally.

It is important not to mix the use ofscandirand the 64-bit comparison functions or
vice versa. There are systems on which this works but on others it will fail miserably.

## 14.2.7 Simple Program to List a Directory, Mark II............

Here is a revised version of the directory lister found above (seeSection 14.2.4 [Simple
Program to List a Directory], page 410). Using thescandirfunction we can avoid the
functions which work directly with the directory contents. After the call the returned
entries are available for direct use.

```
#include <stdio.h>
#include <dirent.h>
```

Chapter 14: File System Interface 413

```
static int
one (const struct dirent *unused)
{
return 1;
}
```
```
int
main (void)
{
struct dirent **eps;
int n;
```
```
n = scandir ("./", &eps, one, alphasort);
if (n >= 0)
{
int cnt;
for (cnt = 0; cnt < n; ++cnt)
puts (eps[cnt]->d_name);
}
else
perror ("Couldn't open the directory");
```
```
return 0;
}
```
Note the simple selector function in this example. Since we want to see all directory
entries we always return 1.

## 14.2.8 Low-level Directory Access.............................

The stream-based directory functions are not AS-Safe and cannot be used aftervfork. See
Section 1.2.2.1 [POSIX Safety Concepts], page 2. The functions below provide an alternative
that can be used in these contexts.

Directory data is obtained from a file descriptor, as created by theopenfunction, with
or without theO_DIRECTORYflag. SeeSection 13.1 [Opening and Closing Files], page 342.

ssize_t getdents64(intfd, void *buffer, size tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

```
Thegetdents64function reads at mostlengthbytes of directory entry data from the
file descriptorfdand stores it into the byte array starting atbuffer.
```
```
On success, the function returns the number of bytes written to the buffer. This
number is zero iffdis already at the end of the directory stream. On error, the
function returns-1and setserrnoto the appropriate error code.
```
```
The data is stored as a sequence ofstruct dirent64records, which can be traversed
using thed_reclenmember. The buffer should be large enough to hold the largest
possible directory entry. Note that some file systems support file names longer than
NAME_MAXbytes (e.g., because they support up to 255 Unicode characters), so a buffer
size of at least 1024 is recommended.
```
```
This function is specific to Linux.
```

Chapter 14: File System Interface 414

## 14.3 Working with Directory Trees...............................

The functions described so far for handling the files in a directory have allowed you to either
retrieve the information bit by bit, or to process all the files as a group (seescandir).
Sometimes it is useful to process whole hierarchies of directories and their contained files.
The X/Open specification defines two functions to do this. The simpler form is derived
from an early definition in System V systems and therefore this function is available on
SVID-derived systems. The prototypes and required definitions can be found in theftw.h
header.

There are four functions in this family: ftw,nftwand their 64-bit counterpartsftw64
andnftw64. These functions take as one of their arguments a pointer to a callback function
of the appropriate type.

__ftw_func_t [Data Type]
int (*) (const char *, const struct stat *, int)
The type of callback functions given to theftwfunction. The first parameter points
to the file name, the second parameter to an object of typestruct statwhich is
filled in for the file named in the first parameter.
The last parameter is a flag giving more information about the current file. It can
have the following values:

```
FTW_F The item is either a normal file or a file which does not fit into one of the
following categories. This could be special files, sockets etc.
```
```
FTW_D The item is a directory.
```
```
FTW_NS Thestatcall failed and so the information pointed to by the second
parameter is invalid.
```
```
FTW_DNR The item is a directory which cannot be read.
```
```
FTW_SL The item is a symbolic link. Since symbolic links are normally followed
seeing this value in aftwcallback function means the referenced file does
not exist. The situation fornftwis different.
This value is only available if the program is compiled with _XOPEN_
EXTENDEDdefined before including the first header. The original SVID
systems do not have symbolic links.
```
```
If the sources are compiled with_FILE_OFFSET_BITS == 64this type is in fact__
ftw64_func_tsince this mode changesstruct statto bestruct stat64.
```
For the LFS interface and for use in the functionftw64, the headerftw.hdefines another
function type.

__ftw64_func_t [Data Type]
int (*) (const char *, const struct stat64 *, int)
This type is used just like__ftw_func_tfor the callback function, but this time is
called fromftw64. The second parameter to the function is a pointer to a variable of
typestruct stat64which is able to represent the larger values.


Chapter 14: File System Interface 415

__nftw_func_t [Data Type]
int (*) (const char *, const struct stat *, int, struct FTW *)
The first three arguments are the same as for the__ftw_func_ttype. However for
the third argument some additional values are defined to allow finer differentiation:
FTW_DP The current item is a directory and all subdirectories have already been
visited and reported. This flag is returned instead ofFTW_Dif theFTW_
DEPTHflag is passed tonftw(see below).
FTW_SLN The current item is a stale symbolic link. The file it points to does not
exist.
The last parameter of the callback function is a pointer to a structure with some extra
information as described below.
If the sources are compiled with_FILE_OFFSET_BITS == 64this type is in fact__
nftw64_func_tsince this mode changesstruct statto bestruct stat64.

For the LFS interface there is also a variant of this data type available which has to be
used with thenftw64function.

__nftw64_func_t [Data Type]
int (*) (const char *, const struct stat64 *, int, struct FTW *)
This type is used just like__nftw_func_tfor the callback function, but this time is
called fromnftw64. The second parameter to the function is this time a pointer to a
variable of typestruct stat64which is able to represent the larger values.

struct FTW [Data Type]
The information contained in this structure helps in interpreting the name parameter
and gives some information about the current state of the traversal of the directory
hierarchy.
int base The value is the offset into the string passed in the first parameter to the
callback function of the beginning of the file name. The rest of the string
is the path of the file. This information is especially important if the
FTW_CHDIRflag was set in callingnftwsince then the current directory is
the one the current item is found in.
int level Whilst processing, the code tracks how many directories down it has gone
to find the current file. This nesting level starts at 0 for files in the initial
directory (or is zero for the initial file if a file was passed).

int ftw(const char *filename, ftwfunc tfunc, intdescriptors) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theftwfunction calls the callback function given in the parameterfuncfor every
item which is found in the directory specified byfilenameand all directories below.
The function follows symbolic links if necessary but does not process an item twice.
Iffilenameis not a directory then it itself is the only object returned to the callback
function.
The file name passed to the callback function is constructed by taking thefilename
parameter and appending the names of all passed directories and then the local file


Chapter 14: File System Interface 416

```
name. So the callback function can use this parameter to access the file. ftwalso
callsstatfor the file and passes that information on to the callback function. If this
statcall is not successful the failure is indicated by setting the third argument of the
callback function toFTW_NS. Otherwise it is set according to the description given in
the account of__ftw_func_tabove.
The callback function is expected to return 0 to indicate that no error occurred and
that processing should continue. If an error occurred in the callback function or
it wantsftwto return immediately, the callback function can return a value other
than 0. This is the only correct way to stop the function. The program must not
usesetjmpor similar techniques to continue from another place. This would leave
resources allocated by theftwfunction unfreed.
Thedescriptorsparameter toftwspecifies how many file descriptors it is allowed to
consume. The function runs faster the more descriptors it can use. For each level in
the directory hierarchy at most one descriptor is used, but for very deep ones any limit
on open file descriptors for the process or the system may be exceeded. Moreover,
file descriptor limits in a multi-threaded program apply to all the threads as a group,
and therefore it is a good idea to supply a reasonable limit to the number of open
descriptors.
The return value of theftwfunction is 0 if all callback function calls returned 0 and
all actions performed by theftwsucceeded. If a function call failed (other than calling
staton an item) the function returns?1. If a callback function returns a value other
than 0 this value is returned as the return value offtw.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is in factftw64, i.e., the LFS interface transparently replaces the old
interface.
```
int ftw64 (const char *filename, ftw64functfunc, int [Function]
descriptors)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function is similar toftwbut it can work on filesystems with large files. File
information is reported using a variable of typestruct stat64which is passed by
reference to the callback function.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is available under the nameftw and transparently replaces the old
implementation.

int nftw (const char *filename, nftw functfunc, int [Function]
descriptors, intflag)
Preliminary: |MT-Safe cwd|AS-Unsafe heap|AC-Unsafe mem fd cwd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thenftwfunction works like theftwfunctions. They call the callback functionfunc
for all items found in the directoryfilename and below. At most descriptorsfile
descriptors are consumed during thenftwcall.


Chapter 14: File System Interface 417

```
One difference is that the callback function is of a different type. It is of type
struct FTW *and provides the callback function with the extra information described
above.
A second difference is thatnftwtakes a fourth argument, which is 0 or a bitwise-OR
combination of any of the following values.
FTW_PHYS While traversing the directory symbolic links are not followed. Instead
symbolic links are reported using theFTW_SLvalue for the type parameter
to the callback function. If the file referenced by a symbolic link does not
existFTW_SLNis returned instead.
```
```
FTW_MOUNT
The callback function is only called for items which are on the same
mounted filesystem as the directory given by thefilenameparameter to
nftw.
FTW_CHDIR
If this flag is given the current working directory is changed to the direc-
tory of the reported object before the callback function is called. When
ntfwfinally returns the current directory is restored to its original value.
FTW_DEPTH
If this option is specified then all subdirectories and files within them
are processed before processing the top directory itself (depth-first pro-
cessing). This also means the type flag given to the callback function is
FTW_DPand notFTW_D.
FTW_ACTIONRETVAL
If this option is specified then return values from callbacks are handled
differently. If the callback returnsFTW_CONTINUE, walking continues nor-
mally. FTW_STOPmeans walking stops andFTW_STOPis returned to the
caller. IfFTW_SKIP_SUBTREEis returned by the callback withFTW_Dar-
gument, the subtree is skipped and walking continues with next sibling
of the directory. IfFTW_SKIP_SIBLINGSis returned by the callback, all
siblings of the current entry are skipped and walking continues in its par-
ent. No other return values should be returned from the callbacks if this
option is set. This option is a GNU extension.
```
```
The return value is computed in the same way as forftw. nftwreturns 0 if no
failures occurred and all callback functions returned 0. In case of internal errors,
such as memory problems, the return value is?1 anderrnois set accordingly. If the
return value of a callback invocation was non-zero then that value is returned.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is in factnftw64, i.e., the LFS interface transparently replaces the old
interface.
```
int nftw64(const char *filename, nftw64func tfunc, int [Function]
descriptors, intflag)
Preliminary: |MT-Safe cwd|AS-Unsafe heap|AC-Unsafe mem fd cwd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 14: File System Interface 418

```
This function is similar tonftwbut it can work on filesystems with large files. File
information is reported using a variable of typestruct stat64which is passed by
reference to the callback function.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is available under the namenftwand transparently replaces the old
implementation.
```
## 14.4 Hard Links..................................................

In POSIX systems, one file can have many names at the same time. All of the names are
equally real, and no one of them is preferred to the others.

To add a name to a file, use thelinkfunction. (The new name is also called ahard link
to the file.) Creating a new link to a file does not copy the contents of the file; it simply
makes a new name by which the file can be known, in addition to the file¡¯s existing name
or names.

One file can have names in several directories, so the organization of the file system is
not a strict hierarchy or tree.

In most implementations, it is not possible to have hard links to the same file in multiple
file systems.linkreports an error if you try to make a hard link to the file from another
file system when this cannot be done.

```
The prototype for thelinkfunction is declared in the header fileunistd.h.
```
int link (const char *oldname, const char *newname) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelinkfunction makes a new link to the existing file named byoldname, under the
new namenewname.
This function returns a value of 0 if it is successful and-1on failure. In addition
to the usual file name errors (seeSection 11.2.3 [File Name Errors], page 264) for
botholdnameandnewname, the followingerrnoerror conditions are defined for this
function:

```
EACCES You are not allowed to write to the directory in which the new link is to
be written.
```
```
EEXIST There is already a file namednewname. If you want to replace this link
with a new link, you must remove the old link explicitly first.
```
```
EMLINK There are already too many links to the file named byoldname. (The
maximum number of links to a file isLINK_MAX; seeSection 32.6 [Limits
on File System Capacity], page 903.)
```
```
ENOENT The file named byoldnamedoesn¡¯t exist. You can¡¯t make a link to a file
that doesn¡¯t exist.
```
```
ENOSPC The directory or file system that would contain the new link is full and
cannot be extended.
```

Chapter 14: File System Interface 419

```
EPERM On GNU/Linux and GNU/Hurd systems and some others, you cannot
make links to directories. Many systems allow only privileged users to do
so. This error is used to report the problem.
```
```
EROFS The directory containing the new link can¡¯t be modified because it¡¯s on
a read-only file system.
```
```
EXDEV The directory specified innewnameis on a different file system than the
existing file.
EIO A hardware error occurred while trying to read or write the to filesystem.
```
int linkat(int oldfd, const char *oldname, int newfd, const char [Function]
*newname, int flags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelinkatfunction is analogous to thelinkfunction, except that it identifies its
source and target using a combination of a file descriptor (referring to a directory) and
a pathname. If a pathnames is not absolute, it is resolved relative to the corresponding
file descriptor. The special file descriptorAT_FDCWDdenotes the current directory.
Theflagsargument is a combination of the following flags:
AT_SYMLINK_FOLLOW
If the source path identified byoldfdandoldnameis a symbolic link,
linkatfollows the symbolic link and creates a link to its target. If the
flag is not set, a link for the symbolic link itself is created; this is not
supported by all file systems andlinkatcan fail in this case.

```
AT_EMPTY_PATH
If this flag is specified,oldnamecan be an empty string. In this case,
a new link to the file denoted by the descriptoroldfdis created, which
may have been opened withO_PATHorO_TMPFILE. This flag is a GNU
extension.
```
## 14.5 Symbolic Links..............................................

GNU systems supportsoft linksorsymbolic links. This is a kind of ¡°file¡± that is essentially
a pointer to another file name. Unlike hard links, symbolic links can be made to directories
or across file systems with no restrictions. You can also make a symbolic link to a name
which is not the name of any file. (Opening this link will fail until a file by that name is
created.) Likewise, if the symbolic link points to an existing file which is later deleted, the
symbolic link continues to point to the same file name even though the name no longer
names any file.

The reason symbolic links work the way they do is that special things happen when you
try to open the link. Theopenfunction realizes you have specified the name of a link, reads
the file name contained in the link, and opens that file name instead. Thestatfunction
likewise operates on the file that the symbolic link points to, instead of on the link itself.

By contrast, other operations such as deleting or renaming the file operate on the link
itself. The functionsreadlinkandlstatalso refrain from following symbolic links, because


Chapter 14: File System Interface 420

their purpose is to obtain information about the link.link, the function that makes a hard
link, does too. It makes a hard link to the symbolic link, which one rarely wants.

Some systems have, for some functions operating on files, a limit on how many symbolic
links are followed when resolving a path name. The limit if it exists is published in the
sys/param.hheader file.

int MAXSYMLINKS [Macro]
The macroMAXSYMLINKSspecifies how many symlinks some function will follow before
returningELOOP. Not all functions behave the same and this value is not the same as
that returned for_SC_SYMLOOPbysysconf. In fact, thesysconfresult can indicate
that there is no fixed limit althoughMAXSYMLINKSexists and has a finite value.

```
Prototypes for most of the functions listed in this section are inunistd.h.
```
int symlink(const char *oldname, const char *newname) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesymlinkfunction makes a symbolic link tooldnamenamednewname.
The normal return value fromsymlinkis 0. A return value of-1indicates an error.
In addition to the usual file name syntax errors (seeSection 11.2.3 [File Name Errors],
page 264), the followingerrnoerror conditions are defined for this function:
EEXIST There is already an existing file namednewname.
EROFS The filenewnamewould exist on a read-only file system.
ENOSPC The directory or file system cannot be extended to make the new link.
EIO A hardware error occurred while reading or writing data on the disk.

ssize_t readlink (const char *filename, char *buffer, sizet [Function]
size)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thereadlinkfunction gets the value of the symbolic linkfilename. The file name that
the link points to is copied intobuffer. This file name string isnotnull-terminated;
readlinknormally returns the number of characters copied. Thesize argument
specifies the maximum number of characters to copy, usually the allocation size of
buffer.
If the return value equalssize, you cannot tell whether or not there was room to
return the entire name. So make a bigger buffer and callreadlinkagain. Here is an
example:
char *
readlink_malloc (const char *filename)
{
int size = 100;
char *buffer = NULL;

```
while (1)
{
buffer = (char *) xrealloc (buffer, size);
```

Chapter 14: File System Interface 421

```
int nchars = readlink (filename, buffer, size);
if (nchars < 0)
{
free (buffer);
return NULL;
}
if (nchars < size)
return buffer;
size *= 2;
}
}
A value of-1is returned in case of error. In addition to the usual file name errors (see
Section 11.2.3 [File Name Errors], page 264), the followingerrnoerror conditions are
defined for this function:
```
```
EINVAL The named file is not a symbolic link.
```
```
EIO A hardware error occurred while reading or writing data on the disk.
```
In some situations it is desirable to resolve all the symbolic links to get the real name of
a file where no prefix names a symbolic link which is followed and no filename in the path
is.or... This is for instance desirable if files have to be compared in which case different
names can refer to the same inode.

char * canonicalize_file_name(const char *name) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thecanonicalize_file_namefunction returns the absolute name of the file named
bynamewhich contains no.,..components nor any repeated path separators (/) or
symlinks. The result is passed back as the return value of the function in a block of
memory allocated withmalloc. If the result is not used anymore the memory should
be freed with a call tofree.
If any of the path components are missing the function returns a NULL pointer.
This is also what is returned if the length of the path reaches or exceedsPATH_MAX
characters. In any caseerrnois set accordingly.

```
ENAMETOOLONG
The resulting path is too long. This error only occurs on systems which
have a limit on the file name length.
```
```
EACCES At least one of the path components is not readable.
```
```
ENOENT The input file name is empty.
```
```
ENOENT At least one of the path components does not exist.
```
```
ELOOP More thanMAXSYMLINKSmany symlinks have been followed.
```
```
This function is a GNU extension and is declared instdlib.h.
```
The Unix standard includes a similar function which differs fromcanonicalize_file_
namein that the user has to provide the buffer where the result is placed in.


Chapter 14: File System Interface 422

char * realpath (const char *restrictname, char *restrict [Function]
resolved)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
A call to realpath where the resolved parameter is NULL behaves exactly like
canonicalize_file_name. The function allocates a buffer for the file name and
returns a pointer to it. Ifresolvedis notNULLit points to a buffer into which the
result is copied. It is the callers responsibility to allocate a buffer which is large
enough. On systems which definePATH_MAXthis means the buffer must be large
enough for a pathname of this size. For systems without limitations on the pathname
length the requirement cannot be met and programs should not callrealpathwith
anything butNULLfor the second parameter.
One other difference is that the bufferresolved(if nonzero) will contain the part of
the path component which does not exist or is not readable if the function returns
NULLanderrnois set toEACCESorENOENT.
This function is declared instdlib.h.

The advantage of using this function is that it is more widely available. The drawback
is that it reports failures for long paths on systems which have no limits on the file name
length.

## 14.6 Deleting Files...............................................

You can delete a file withunlinkorremove.

Deletion actually deletes a file name. If this is the file¡¯s only name, then the file is deleted
as well. If the file has other remaining names (seeSection 14.4 [Hard Links], page 418), it
remains accessible under those names.

int unlink(const char *filename) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theunlinkfunction deletes the file namefilename. If this is a file¡¯s sole name, the
file itself is also deleted. (Actually, if any process has the file open when this happens,
deletion is postponed until all processes have closed the file.)
The functionunlinkis declared in the header fileunistd.h.
This function returns 0 on successful completion, and-1on error. In addition to the
usual file name errors (seeSection 11.2.3 [File Name Errors], page 264), the following
errnoerror conditions are defined for this function:
EACCES Write permission is denied for the directory from which the file is to be
removed, or the directory has the sticky bit set and you do not own the
file.
EBUSY This error indicates that the file is being used by the system in such a
way that it can¡¯t be unlinked. For example, you might see this error if the
file name specifies the root directory or a mount point for a file system.
ENOENT The file name to be deleted doesn¡¯t exist.


Chapter 14: File System Interface 423

```
EPERM On some systemsunlinkcannot be used to delete the name of a directory,
or at least can only be used this way by a privileged user. To avoid
such problems, usermdirto delete directories. (On GNU/Linux and
GNU/Hurd systemsunlinkcan never delete the name of a directory.)
```
```
EROFS The directory containing the file name to be deleted is on a read-only file
system and can¡¯t be modified.
```
int rmdir (const char *filename) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thermdirfunction deletes a directory. The directory must be empty before it can
be removed; in other words, it can only contain entries for.and...
In most other respects,rmdirbehaves likeunlink. There are two additionalerrno
error conditions defined forrmdir:
ENOTEMPTY
EEXIST The directory to be deleted is not empty.

```
These two error codes are synonymous; some systems use one, and some use the other.
GNU/Linux and GNU/Hurd systems always useENOTEMPTY.
The prototype for this function is declared in the header fileunistd.h.
```
int remove(const char *filename) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is the ISO C function to remove a file. It works likeunlinkfor files and like
rmdirfor directories.removeis declared instdio.h.

## 14.7 Renaming Files.............................................

Therenamefunction is used to change a file¡¯s name.

int rename(const char *oldname, const char *newname) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Therenamefunction renames the fileoldnametonewname. The file formerly acces-
sible under the nameoldnameis afterwards accessible asnewnameinstead. (If the
file had any other names aside fromoldname, it continues to have those names.)
The directory containing the namenewnamemust be on the same file system as the
directory containing the nameoldname.
One special case forrenameis whenoldnameandnewnameare two names for the
same file. The consistent way to handle this case is to deleteoldname. However,
in this case POSIX requires thatrenamedo nothing and report success¡ªwhich is
inconsistent. We don¡¯t know what your operating system will do.
Ifoldnameis not a directory, then any existing file namednewnameis removed during
the renaming operation. However, ifnewnameis the name of a directory,renamefails
in this case.


Chapter 14: File System Interface 424

```
Ifoldnameis a directory, then eithernewname must not exist or it must name a
directory that is empty. In the latter case, the existing directory namednewnameis
deleted first. The namenewnamemust not specify a subdirectory of the directory
oldnamewhich is being renamed.
One useful feature ofrenameis that the meaning ofnewnamechanges ¡°atomically¡±
from any previously existing file by that name to its new meaning (i.e., the file that
was calledoldname). There is no instant at whichnewname is non-existent ¡°in
between¡± the old meaning and the new meaning. If there is a system crash during
the operation, it is possible for both names to still exist; butnewnamewill always be
intact if it exists at all.
If rename fails, it returns -1. In addition to the usual file name errors (see
Section 11.2.3 [File Name Errors], page 264), the followingerrnoerror conditions
are defined for this function:
EACCES One of the directories containingnewnameoroldnamerefuses write per-
mission; ornewnameandoldnameare directories and write permission
is refused for one of them.
EBUSY A directory named byoldnameornewnameis being used by the system in
a way that prevents the renaming from working. This includes directories
that are mount points for filesystems, and directories that are the current
working directories of processes.
ENOTEMPTY
EEXIST The directorynewnameisn¡¯t empty. GNU/Linux and GNU/Hurd sys-
tems always returnENOTEMPTYfor this, but some other systems return
EEXIST.
EINVAL oldnameis a directory that containsnewname.
EISDIR newnameis a directory but theoldnameisn¡¯t.
EMLINK The parent directory ofnewnamewould have too many links (entries).
ENOENT The fileoldnamedoesn¡¯t exist.
ENOSPC The directory that would containnewnamehas no room for another entry,
and there is no space left in the file system to expand it.
EROFS The operation would involve writing to a directory on a read-only file
system.
EXDEV The two file namesnewnameandoldnameare on different file systems.
```
## 14.8 Creating Directories.........................................

Directories are created with themkdirfunction. (There is also a shell commandmkdir
which does the same thing.)

int mkdir (const char *filename, modetmode) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themkdirfunction creates a new, empty directory with namefilename.


Chapter 14: File System Interface 425

```
The argumentmode specifies the file permissions for the new directory file. See
Section 14.9.5 [The Mode Bits for Access Permission], page 434, for more information
about this.
A return value of 0 indicates successful completion, and-1 indicates failure. In
addition to the usual file name syntax errors (seeSection 11.2.3 [File Name Errors],
page 264), the followingerrnoerror conditions are defined for this function:
```
```
EACCES Write permission is denied for the parent directory in which the new
directory is to be added.
```
```
EEXIST A file namedfilenamealready exists.
```
```
EMLINK The parent directory has too many links (entries).
Well-designed file systems never report this error, because they permit
more links than your disk could possibly hold. However, you must still
take account of the possibility of this error, as it could result from network
access to a file system on another machine.
```
```
ENOSPC The file system doesn¡¯t have enough room to create the new directory.
```
```
EROFS The parent directory of the directory being created is on a read-only file
system and cannot be modified.
```
```
To use this function, your program should include the header filesys/stat.h.
```
## 14.9 File Attributes..............................................

When you issue an ¡®ls -l¡¯ shell command on a file, it gives you information about the size
of the file, who owns it, when it was last modified, etc. These are called thefile attributes,
and are associated with the file itself and not a particular one of its names.

This section contains information about how you can inquire about and modify the
attributes of a file.

## 14.9.1 The meaning of the File Attributes.....................

When you read the attributes of a file, they come back in a structure calledstruct stat.
This section describes the names of the attributes, their data types, and what they mean.
For the functions to read the attributes of a file, seeSection 14.9.2 [Reading the Attributes
of a File], page 429.

```
The header filesys/stat.hdeclares all the symbols defined in this section.
```
struct stat [Data Type]
Thestatstructure type is used to return information about the attributes of a file.
It contains at least the following members:

```
mode_t st_mode
Specifies the mode of the file. This includes file type information (see
Section 14.9.3 [Testing the Type of a File], page 431) and the file per-
mission bits (seeSection 14.9.5 [The Mode Bits for Access Permission],
page 434).
```

Chapter 14: File System Interface 426

```
ino_t st_ino
The file serial number, which distinguishes this file from all other files on
the same device.
```
```
dev_t st_dev
Identifies the device containing the file. Thest_inoandst_dev, taken
together, uniquely identify the file. Thest_devvalue is not necessarily
consistent across reboots or system crashes, however.
```
```
nlink_t st_nlink
The number of hard links to the file. This count keeps track of how many
directories have entries for this file. If the count is ever decremented to
zero, then the file itself is discarded as soon as no process still holds it
open. Symbolic links are not counted in the total.
uid_t st_uid
The user ID of the file¡¯s owner. SeeSection 14.9.4 [File Owner], page 433.
gid_t st_gid
The group ID of the file. SeeSection 14.9.4 [File Owner], page 433.
```
```
off_t st_size
This specifies the size of a regular file in bytes. For files that are really
devices this field isn¡¯t usually meaningful. For symbolic links this specifies
the length of the file name the link refers to.
time_t st_atime
This is the last access time for the file. SeeSection 14.9.9 [File Times],
page 439.
unsigned long int st_atime_usec
This is the fractional part of the last access time for the file. See
Section 14.9.9 [File Times], page 439.
time_t st_mtime
This is the time of the last modification to the contents of the file. See
Section 14.9.9 [File Times], page 439.
unsigned long int st_mtime_usec
This is the fractional part of the time of the last modification to the
contents of the file. SeeSection 14.9.9 [File Times], page 439.
time_t st_ctime
This is the time of the last modification to the attributes of the file. See
Section 14.9.9 [File Times], page 439.
unsigned long int st_ctime_usec
This is the fractional part of the time of the last modification to the
attributes of the file. SeeSection 14.9.9 [File Times], page 439.
blkcnt_t st_blocks
This is the amount of disk space that the file occupies, measured in units
of 512-byte blocks.
```

Chapter 14: File System Interface 427

```
The number of disk blocks is not strictly proportional to the size of the
file, for two reasons: the file system may use some blocks for internal
record keeping; and the file may be sparse¡ªit may have ¡°holes¡± which
contain zeros but do not actually take up space on the disk.
You can tell (approximately) whether a file is sparse by comparing this
value withst_size, like this:
(st.st_blocks * 512 < st.st_size)
This test is not perfect because a file that is just slightly sparse might
not be detected as sparse at all. For practical applications, this is not a
problem.
```
```
unsigned int st_blksize
The optimal block size for reading or writing this file, in bytes. You might
use this size for allocating the buffer space for reading or writing the file.
(This is unrelated tost_blocks.)
```
The extensions for the Large File Support (LFS) require, even on 32-bit machines, types
which can handle file sizes up to 2^63. Therefore a new definition ofstruct statis necessary.

struct stat64 [Data Type]
The members of this type are the same and have the same names as those instruct
stat. The only difference is that the membersst_ino,st_size, andst_blockshave
a different type to support larger values.

```
mode_t st_mode
Specifies the mode of the file. This includes file type information (see
Section 14.9.3 [Testing the Type of a File], page 431) and the file per-
mission bits (seeSection 14.9.5 [The Mode Bits for Access Permission],
page 434).
```
```
ino64_t st_ino
The file serial number, which distinguishes this file from all other files on
the same device.
```
```
dev_t st_dev
Identifies the device containing the file. Thest_inoandst_dev, taken
together, uniquely identify the file. Thest_devvalue is not necessarily
consistent across reboots or system crashes, however.
```
```
nlink_t st_nlink
The number of hard links to the file. This count keeps track of how many
directories have entries for this file. If the count is ever decremented to
zero, then the file itself is discarded as soon as no process still holds it
open. Symbolic links are not counted in the total.
```
```
uid_t st_uid
The user ID of the file¡¯s owner. SeeSection 14.9.4 [File Owner], page 433.
```
```
gid_t st_gid
The group ID of the file. SeeSection 14.9.4 [File Owner], page 433.
```

Chapter 14: File System Interface 428

```
off64_t st_size
This specifies the size of a regular file in bytes. For files that are really
devices this field isn¡¯t usually meaningful. For symbolic links this specifies
the length of the file name the link refers to.
time_t st_atime
This is the last access time for the file. SeeSection 14.9.9 [File Times],
page 439.
unsigned long int st_atime_usec
This is the fractional part of the last access time for the file. See
Section 14.9.9 [File Times], page 439.
time_t st_mtime
This is the time of the last modification to the contents of the file. See
Section 14.9.9 [File Times], page 439.
unsigned long int st_mtime_usec
This is the fractional part of the time of the last modification to the
contents of the file. SeeSection 14.9.9 [File Times], page 439.
time_t st_ctime
This is the time of the last modification to the attributes of the file. See
Section 14.9.9 [File Times], page 439.
unsigned long int st_ctime_usec
This is the fractional part of the time of the last modification to the
attributes of the file. SeeSection 14.9.9 [File Times], page 439.
blkcnt64_t st_blocks
This is the amount of disk space that the file occupies, measured in units
of 512-byte blocks.
unsigned int st_blksize
The optimal block size for reading of writing this file, in bytes. You might
use this size for allocating the buffer space for reading of writing the file.
(This is unrelated tost_blocks.)
```
Some of the file attributes have special data type names which exist specifically for those
attributes. (They are all aliases for well-known integer types that you know and love.) These
typedef names are defined in the header filesys/types.has well as insys/stat.h. Here
is a list of them.

mode_t [Data Type]
This is an integer data type used to represent file modes. In the GNU C Library, this
is an unsigned type no narrower thanunsigned int.

ino_t [Data Type]
This is an unsigned integer type used to represent file serial numbers. (In Unix jargon,
these are sometimes calledinode numbers.) In the GNU C Library, this type is no
narrower thanunsigned int.
If the source is compiled with_FILE_OFFSET_BITS == 64this type is transparently
replaced byino64_t.


Chapter 14: File System Interface 429

ino64_t [Data Type]
This is an unsigned integer type used to represent file serial numbers for the use in
LFS. In the GNU C Library, this type is no narrower thanunsigned int.
When compiling with_FILE_OFFSET_BITS == 64this type is available under the name
ino_t.

dev_t [Data Type]
This is an arithmetic data type used to represent file device numbers. In the GNU C
Library, this is an integer type no narrower thanint.

nlink_t [Data Type]
This is an integer type used to represent file link counts.

blkcnt_t [Data Type]
This is a signed integer type used to represent block counts. In the GNU C Library,
this type is no narrower thanint.
If the source is compiled with_FILE_OFFSET_BITS == 64this type is transparently
replaced byblkcnt64_t.

blkcnt64_t [Data Type]
This is a signed integer type used to represent block counts for the use in LFS. In the
GNU C Library, this type is no narrower thanint.
When compiling with_FILE_OFFSET_BITS == 64this type is available under the name
blkcnt_t.

## 14.9.2 Reading the Attributes of a File........................

To examine the attributes of files, use the functionsstat,fstatandlstat. They return
the attribute information in astruct statobject. All three functions are declared in the
header filesys/stat.h.

int stat (const char *filename, struct stat *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thestatfunction returns information about the attributes of the file named by
filenamein the structure pointed to bybuf.
Iffilenameis the name of a symbolic link, the attributes you get describe the file
that the link points to. If the link points to a nonexistent file name, thenstatfails
reporting a nonexistent file.
The return value is 0 if the operation is successful, or-1on failure. In addition to the
usual file name errors (seeSection 11.2.3 [File Name Errors], page 264, the following
errnoerror conditions are defined for this function:

```
ENOENT The file named byfilenamedoesn¡¯t exist.
```
```
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in fact
stat64since the LFS interface transparently replaces the normal implementation.
```

Chapter 14: File System Interface 430

int stat64(const char *filename, struct stat64 *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tostatbut it is also able to work on files larger than 2^31
bytes on 32-bit systems. To be able to do this the result is stored in a variable of
typestruct stat64to whichbuf must point.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the namestatand so transparently replaces the interface for small files
on 32-bit machines.

int fstat (intfiledes, struct stat *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefstatfunction is likestat, except that it takes an open file descriptor as an
argument instead of a file name. SeeChapter 13 [Low-Level Input/Output], page 342.
Likestat,fstatreturns 0 on success and-1on failure. The followingerrnoerror
conditions are defined forfstat:

```
EBADF Thefiledesargument is not a valid file descriptor.
```
```
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in fact
fstat64since the LFS interface transparently replaces the normal implementation.
```
int fstat64(intfiledes, struct stat64 *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tofstatbut is able to work on large files on 32-bit platforms.
For large files the file descriptorfiledesshould be obtained byopen64orcreat64.
Thebufpointer points to a variable of typestruct stat64which is able to represent
the larger values.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the namefstatand so transparently replaces the interface for small files
on 32-bit machines.

int lstat (const char *filename, struct stat *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelstatfunction is likestat, except that it does not follow symbolic links. If
filenameis the name of a symbolic link,lstatreturns information about the link
itself; otherwiselstatworks likestat. SeeSection 14.5 [Symbolic Links], page 419.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is in fact
lstat64since the LFS interface transparently replaces the normal implementation.

int lstat64(const char *filename, struct stat64 *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 14: File System Interface 431

```
This function is similar tolstatbut it is also able to work on files larger than 2^31
bytes on 32-bit systems. To be able to do this the result is stored in a variable of
typestruct stat64to whichbuf must point.
When the sources are compiled with_FILE_OFFSET_BITS == 64this function is avail-
able under the namelstatand so transparently replaces the interface for small files
on 32-bit machines.
```
## 14.9.3 Testing the Type of a File..............................

Thefile mode, stored in thest_modefield of the file attributes, contains two kinds of
information: the file type code, and the access permission bits. This section discusses only
the type code, which you can use to tell whether the file is a directory, socket, symbolic
link, and so on. For details about access permissions seeSection 14.9.5 [The Mode Bits for
Access Permission], page 434.

There are two ways you can access the file type information in a file mode. Firstly,
for each file type there is apredicate macrowhich examines a given file mode and returns
whether it is of that type or not. Secondly, you can mask out the rest of the file mode to
leave just the file type code, and compare this against constants for each of the supported
file types.

All of the symbols listed in this section are defined in the header filesys/stat.h.
The following predicate macros test the type of a file, given the valuemwhich is the
st_modefield returned bystaton that file:

int S_ISDIR(modetm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a directory.

int S_ISCHR(modetm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a character special file (a device like a
terminal).

int S_ISBLK(modetm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a block special file (a device like a disk).

int S_ISREG(modetm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a regular file.

int S_ISFIFO (mode tm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a FIFO special file, or a pipe. SeeChapter 15
[Pipes and FIFOs], page 450.


Chapter 14: File System Interface 432

int S_ISLNK(modetm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a symbolic link. SeeSection 14.5 [Symbolic
Links], page 419.

int S_ISSOCK (mode tm) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns non-zero if the file is a socket. SeeChapter 16 [Sockets], page 455.

An alternate non-POSIX method of testing the file type is supported for compatibility
with BSD. The mode can be bitwise AND-ed withS_IFMTto extract the file type code, and
compared to the appropriate constant. For example,
S_ISCHR (mode)

is equivalent to:

```
((mode& S_IFMT) == S_IFCHR)
```
int S_IFMT [Macro]
This is a bit mask used to extract the file type code from a mode value.

```
These are the symbolic names for the different file type codes:
```
S_IFDIR This is the file type constant of a directory file.

S_IFCHR This is the file type constant of a character-oriented device file.

S_IFBLK This is the file type constant of a block-oriented device file.

S_IFREG This is the file type constant of a regular file.

S_IFLNK This is the file type constant of a symbolic link.

S_IFSOCK This is the file type constant of a socket.

S_IFIFO This is the file type constant of a FIFO or pipe.

The POSIX.1b standard introduced a few more objects which possibly can be imple-
mented as objects in the filesystem. These are message queues, semaphores, and shared
memory objects. To allow differentiating these objects from other files the POSIX standard
introduced three new test macros. But unlike the other macros they do not take the value
of thest_modefield as the parameter. Instead they expect a pointer to the wholestruct
statstructure.

int S_TYPEISMQ(struct stat *s) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If the system implements POSIX message queues as distinct objects and the file is
a message queue object, this macro returns a non-zero value. In all other cases the
result is zero.


Chapter 14: File System Interface 433

int S_TYPEISSEM (struct stat *s) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If the system implements POSIX semaphores as distinct objects and the file is a
semaphore object, this macro returns a non-zero value. In all other cases the result
is zero.

int S_TYPEISSHM (struct stat *s) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If the system implements POSIX shared memory objects as distinct objects and the
file is a shared memory object, this macro returns a non-zero value. In all other cases
the result is zero.

## 14.9.4 File Owner.............................................

Every file has anownerwhich is one of the registered user names defined on the system.
Each file also has agroupwhich is one of the defined groups. The file owner can often be
useful for showing you who edited the file (especially when you edit with GNU Emacs), but
its main purpose is for access control.

The file owner and group play a role in determining access because the file has one set
of access permission bits for the owner, another set that applies to users who belong to the
file¡¯s group, and a third set of bits that applies to everyone else. SeeSection 14.9.6 [How
Your Access to a File is Decided], page 436, for the details of how access is decided based
on this data.

When a file is created, its owner is set to the effective user ID of the process that creates
it (seeSection 30.2 [The Persona of a Process], page 845). The file¡¯s group ID may be set to
either the effective group ID of the process, or the group ID of the directory that contains
the file, depending on the system where the file is stored. When you access a remote file
system, it behaves according to its own rules, not according to the system your program is
running on. Thus, your program must be prepared to encounter either kind of behavior no
matter what kind of system you run it on.

You can change the owner and/or group owner of an existing file using thechownfunc-
tion. This is the primitive for thechownandchgrpshell commands.

```
The prototype for this function is declared inunistd.h.
```
int chown (const char *filename, uidtowner, gid tgroup) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thechownfunction changes the owner of the filefilenametoowner, and its group
owner togroup.
Changing the owner of the file on certain systems clears the set-user-ID and set-group-
ID permission bits. (This is because those bits may not be appropriate for the new
owner.) Other file permission bits are not changed.
The return value is 0 on success and-1on failure. In addition to the usual file name
errors (seeSection 11.2.3 [File Name Errors], page 264), the followingerrnoerror
conditions are defined for this function:


Chapter 14: File System Interface 434

```
EPERM This process lacks permission to make the requested change.
Only privileged users or the file¡¯s owner can change the file¡¯s group. On
most file systems, only privileged users can change the file owner; some
file systems allow you to change the owner if you are currently the owner.
When you access a remote file system, the behavior you encounter is
determined by the system that actually holds the file, not by the system
your program is running on.
SeeSection 32.7 [Optional Features in File Support], page 904, for infor-
mation about the_POSIX_CHOWN_RESTRICTEDmacro.
EROFS The file is on a read-only file system.
```
int fchown(intfiledes, uidtowner, gidtgroup) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is likechown, except that it changes the owner of the open file with descriptor
filedes.
The return value fromfchownis 0 on success and-1on failure. The followingerrno
error codes are defined for this function:
EBADF Thefiledesargument is not a valid file descriptor.
EINVAL Thefiledesargument corresponds to a pipe or socket, not an ordinary
file.
EPERM This process lacks permission to make the requested change. For details
seechmodabove.
EROFS The file resides on a read-only file system.

## 14.9.5 The Mode Bits for Access Permission...................

Thefile mode, stored in thest_modefield of the file attributes, contains two kinds of
information: the file type code, and the access permission bits. This section discusses only
the access permission bits, which control who can read or write the file. SeeSection 14.9.3
[Testing the Type of a File], page 431, for information about the file type code.

All of the symbols listed in this section are defined in the header filesys/stat.h.
These symbolic constants are defined for the file mode bits that control access permission
for the file:

S_IRUSR
S_IREAD Read permission bit for the owner of the file. On many systems this bit is
0400.S_IREADis an obsolete synonym provided for BSD compatibility.

S_IWUSR
S_IWRITE Write permission bit for the owner of the file. Usually 0200. S_IWRITEis an
obsolete synonym provided for BSD compatibility.

S_IXUSR
S_IEXEC Execute (for ordinary files) or search (for directories) permission bit for the
owner of the file. Usually 0100. S_IEXECis an obsolete synonym provided for
BSD compatibility.


Chapter 14: File System Interface 435

S_IRWXU This is equivalent to ¡®(S_IRUSR | S_IWUSR | S_IXUSR)¡¯.

S_IRGRP Read permission bit for the group owner of the file. Usually 040.

S_IWGRP Write permission bit for the group owner of the file. Usually 020.

S_IXGRP Execute or search permission bit for the group owner of the file. Usually 010.

S_IRWXG This is equivalent to ¡®(S_IRGRP | S_IWGRP | S_IXGRP)¡¯.

S_IROTH Read permission bit for other users. Usually 04.

S_IWOTH Write permission bit for other users. Usually 02.

S_IXOTH Execute or search permission bit for other users. Usually 01.

S_IRWXO This is equivalent to ¡®(S_IROTH | S_IWOTH | S_IXOTH)¡¯.

S_ISUID This is the set-user-ID on execute bit, usually 04000. SeeSection 30.4 [How
an Application Can Change Persona], page 846.

S_ISGID This is the set-group-ID on execute bit, usually 02000. SeeSection 30.4 [How
an Application Can Change Persona], page 846.

S_ISVTX This is thestickybit, usually 01000.

```
For a directory it gives permission to delete a file in that directory only if you
own that file. Ordinarily, a user can either delete all the files in a directory
or cannot delete any of them (based on whether the user has write permission
for the directory). The same restriction applies¡ªyou must have both write
permission for the directory and own the file you want to delete. The one
exception is that the owner of the directory can delete any file in the directory,
no matter who owns it (provided the owner has given himself write permission
for the directory). This is commonly used for the/tmpdirectory, where anyone
may create files but not delete files created by other users.
Originally the sticky bit on an executable file modified the swapping policies
of the system. Normally, when a program terminated, its pages in core were
immediately freed and reused. If the sticky bit was set on the executable file,
the system kept the pages in core for a while as if the program were still running.
This was advantageous for a program likely to be run many times in succession.
This usage is obsolete in modern systems. When a program terminates, its pages
always remain in core as long as there is no shortage of memory in the system.
When the program is next run, its pages will still be in core if no shortage arose
since the last run.
On some modern systems where the sticky bit has no useful meaning for an
executable file, you cannot set the bit at all for a non-directory. If you try,chmod
fails withEFTYPE; seeSection 14.9.7 [Assigning File Permissions], page 436.
Some systems (particularly SunOS) have yet another use for the sticky bit. If
the sticky bit is set on a file that isnotexecutable, it means the opposite: never
cache the pages of this file at all. The main use of this is for the files on an
NFS server machine which are used as the swap area of diskless client machines.
The idea is that the pages of the file will be cached in the client¡¯s memory, so
it is a waste of the server¡¯s memory to cache them a second time. With this
```

Chapter 14: File System Interface 436

```
usage the sticky bit also implies that the filesystem may fail to record the file¡¯s
modification time onto disk reliably (the idea being that no-one cares for a swap
file).
This bit is only available on BSD systems (and those derived from them).
Therefore one has to use the_GNU_SOURCEfeature select macro, or not define
any feature test macros, to get the definition (seeSection 1.3.4 [Feature Test
Macros], page 15).
```
The actual bit values of the symbols are listed in the table above so you can decode file
mode values when debugging your programs. These bit values are correct for most systems,
but they are not guaranteed.

Warning: Writing explicit numbers for file permissions is bad practice. Not only is it
not portable, it also requires everyone who reads your program to remember what the bits
mean. To make your program clean use the symbolic names.

## 14.9.6 How Your Access to a File is Decided...................

Recall that the operating system normally decides access permission for a file based on
the effective user and group IDs of the process and its supplementary group IDs, together
with the file¡¯s owner, group and permission bits. These concepts are discussed in detail in
Section 30.2 [The Persona of a Process], page 845.

If the effective user ID of the process matches the owner user ID of the file, then per-
missions for read, write, and execute/search are controlled by the corresponding ¡°user¡± (or
¡°owner¡±) bits. Likewise, if any of the effective group ID or supplementary group IDs of
the process matches the group owner ID of the file, then permissions are controlled by the
¡°group¡± bits. Otherwise, permissions are controlled by the ¡°other¡± bits.

Privileged users, like ¡®root¡¯, can access any file regardless of its permission bits. As a
special case, for a file to be executable even by a privileged user, at least one of its execute
bits must be set.

## 14.9.7 Assigning File Permissions..............................

The primitive functions for creating files (for example,openormkdir) take amode ar-
gument, which specifies the file permissions to give the newly created file. This mode is
modified by the process¡¯sfile creation mask, orumask, before it is used.

The bits that are set in the file creation mask identify permissions that are always to be
disabled for newly created files. For example, if you set all the ¡°other¡± access bits in the
mask, then newly created files are not accessible at all to processes in the ¡°other¡± category,
even if themodeargument passed to the create function would permit such access. In other
words, the file creation mask is the complement of the ordinary access permissions you want
to grant.

Programs that create files typically specify amodeargument that includes all the permis-
sions that make sense for the particular file. For an ordinary file, this is typically read and
write permission for all classes of users. These permissions are then restricted as specified
by the individual user¡¯s own file creation mask.

To change the permission of an existing file given its name, callchmod. This function
uses the specified permission bits and ignores the file creation mask.


Chapter 14: File System Interface 437

In normal use, the file creation mask is initialized by the user¡¯s login shell (using the
umaskshell command), and inherited by all subprocesses. Application programs normally
don¡¯t need to worry about the file creation mask. It will automatically do what it is supposed
to do.

When your program needs to create a file and bypass the umask for its access permissions,
the easiest way to do this is to usefchmodafter opening the file, rather than changing the
umask. In fact, changing the umask is usually done only by shells. They use theumask
function.

```
The functions in this section are declared insys/stat.h.
```
mode_t umask (mode tmask) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theumaskfunction sets the file creation mask of the current process tomask, and
returns the previous value of the file creation mask.
Here is an example showing how to read the mask withumaskwithout changing it
permanently:
mode_t
read_umask (void)
{
mode_t mask = umask (0);
umask (mask);
return mask;
}
However, on GNU/Hurd systems it is better to usegetumaskif you just want to read
the mask value, because it is reentrant.

mode_t getumask (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Return the current value of the file creation mask for the current process. This
function is a GNU extension and is only available on GNU/Hurd systems.

int chmod (const char *filename, modetmode) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thechmodfunction sets the access permission bits for the file named byfilenameto
mode.
Iffilenameis a symbolic link,chmodchanges the permissions of the file pointed to by
the link, not those of the link itself.
This function returns 0 if successful and-1if not. In addition to the usual file name
errors (seeSection 11.2.3 [File Name Errors], page 264), the followingerrnoerror
conditions are defined for this function:
ENOENT The named file doesn¡¯t exist.
EPERM This process does not have permission to change the access permissions
of this file. Only the file¡¯s owner (as judged by the effective user ID of
the process) or a privileged user can change them.


Chapter 14: File System Interface 438

```
EROFS The file resides on a read-only file system.
EFTYPE modehas theS_ISVTXbit (the ¡°sticky bit¡±) set, and the named file is
not a directory. Some systems do not allow setting the sticky bit on
non-directory files, and some do (and only some of those assign a useful
meaning to the bit for non-directory files).
You only getEFTYPEon systems where the sticky bit has no useful mean-
ing for non-directory files, so it is always safe to just clear the bit inmode
and callchmodagain. SeeSection 14.9.5 [The Mode Bits for Access Per-
mission], page 434, for full details on the sticky bit.
```
int fchmod(intfiledes, modetmode) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is likechmod, except that it changes the permissions of the currently open file
given byfiledes.
The return value fromfchmodis 0 on success and-1on failure. The followingerrno
error codes are defined for this function:

```
EBADF Thefiledesargument is not a valid file descriptor.
EINVAL Thefiledesargument corresponds to a pipe or socket, or something else
that doesn¡¯t really have access permissions.
```
```
EPERM This process does not have permission to change the access permissions
of this file. Only the file¡¯s owner (as judged by the effective user ID of
the process) or a privileged user can change them.
```
```
EROFS The file resides on a read-only file system.
```
## 14.9.8 Testing Permission to Access a File.....................

In some situations it is desirable to allow programs to access files or devices even if this
is not possible with the permissions granted to the user. One possible solution is to set
the setuid-bit of the program file. If such a program is started theeffectiveuser ID of the
process is changed to that of the owner of the program file. So to allow write access to files
like/etc/passwd, which normally can be written only by the super-user, the modifying
program will have to be owned byrootand the setuid-bit must be set.

But besides the files the program is intended to change the user should not be allowed
to access any file to which s/he would not have access anyway. The program therefore must
explicitly check whetherthe userwould have the necessary access to a file, before it reads
or writes the file.

To do this, use the functionaccess, which checks for access permission based on the
process¡¯srealuser ID rather than the effective user ID. (The setuid feature does not alter
the real user ID, so it reflects the user who actually ran the program.)

There is another way you could check this access, which is easy to describe, but very
hard to use. This is to examine the file mode bits and mimic the system¡¯s own access
computation. This method is undesirable because many systems have additional access
control features; your program cannot portably mimic them, and you would not want to


Chapter 14: File System Interface 439

try to keep track of the diverse features that different systems have. Usingaccessis simple
and automatically does whatever is appropriate for the system you are using.

accessisonlyappropriate to use in setuid programs. A non-setuid program will always
use the effective ID rather than the real ID.

```
The symbols in this section are declared inunistd.h.
```
int access(const char *filename, inthow) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theaccessfunction checks to see whether the file named byfilenamecan be accessed
in the way specified by thehowargument. The howargument either can be the
bitwise OR of the flagsR_OK,W_OK,X_OK, or the existence testF_OK.
This function uses therealuser and group IDs of the calling process, rather than the
effectiveIDs, to check for access permission. As a result, if you use the function from
asetuid orsetgidprogram (seeSection 30.4 [How an Application Can Change
Persona], page 846), it gives information relative to the user who actually ran the
program.
The return value is 0 if the access is permitted, and-1otherwise. (In other words,
treated as a predicate function,accessreturns true if the requested access isdenied.)
In addition to the usual file name errors (see Section 11.2.3 [File Name Errors],
page 264), the followingerrnoerror conditions are defined for this function:
EACCES The access specified byhowis denied.
ENOENT The file doesn¡¯t exist.
EROFS Write permission was requested for a file on a read-only file system.

These macros are defined in the header fileunistd.hfor use as thehowargument to
theaccessfunction. The values are integer constants.

int R_OK [Macro]
Flag meaning test for read permission.

int W_OK [Macro]
Flag meaning test for write permission.

int X_OK [Macro]
Flag meaning test for execute/search permission.

int F_OK [Macro]
Flag meaning test for existence of the file.

## 14.9.9 File Times.............................................

Each file has three time stamps associated with it: its access time, its modification time,
and its attribute modification time. These correspond to thest_atime,st_mtime, and
st_ctimemembers of thestatstructure; seeSection 14.9 [File Attributes], page 425.

All of these times are represented in calendar time format, astime_tobjects. This data
type is defined intime.h. For more information about representation and manipulation of
time values, seeSection 21.5 [Calendar Time], page 651.


Chapter 14: File System Interface 440

Reading from a file updates its access time attribute, and writing updates its modification
time. When a file is created, all three time stamps for that file are set to the current time.
In addition, the attribute change time and modification time fields of the directory that
contains the new entry are updated.

Adding a new name for a file with thelinkfunction updates the attribute change time
field of the file being linked, and both the attribute change time and modification time
fields of the directory containing the new name. These same fields are affected if a file name
is deleted withunlink,removeorrmdir. Renaming a file withrenameaffects only the
attribute change time and modification time fields of the two parent directories involved,
and not the times for the file being renamed.

Changing the attributes of a file (for example, withchmod) updates its attribute change
time field.

You can also change some of the time stamps of a file explicitly using theutime
function¡ªall except the attribute change time. You need to include the header fileutime.h
to use this facility.

struct utimbuf [Data Type]
Theutimbufstructure is used with theutimefunction to specify new access and
modification times for a file. It contains the following members:
time_t actime
This is the access time for the file.
time_t modtime
This is the modification time for the file.

int utime (const char *filename, const struct utimbuf *times) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to modify the file times associated with the file namedfilename.
Iftimesis a null pointer, then the access and modification times of the file are set to
the current time. Otherwise, they are set to the values from theactimeandmodtime
members (respectively) of theutimbufstructure pointed to bytimes.
The attribute modification time for the file is set to the current time in either case
(since changing the time stamps is itself a modification of the file attributes).
Theutimefunction returns 0 if successful and-1on failure. In addition to the usual
file name errors (seeSection 11.2.3 [File Name Errors], page 264), the followingerrno
error conditions are defined for this function:
EACCES There is a permission problem in the case where a null pointer was passed
as thetimesargument. In order to update the time stamp on the file,
you must either be the owner of the file, have write permission for the
file, or be a privileged user.
ENOENT The file doesn¡¯t exist.
EPERM If thetimesargument is not a null pointer, you must either be the owner
of the file or be a privileged user.
EROFS The file lives on a read-only file system.


Chapter 14: File System Interface 441

Each of the three time stamps has a corresponding microsecond part, which extends its
resolution. These fields are calledst_atime_usec,st_mtime_usec, andst_ctime_usec;
each has a value between 0 and 999,999, which indicates the time in microseconds. They
correspond to thetv_usecfield of atimevalstructure; seeSection 21.2 [Time Types],
page 647.

Theutimesfunction is likeutime, but also lets you specify the fractional part of the
file times. The prototype for this function is in the header filesys/time.h.

int utimes(const char *filename, const struct timevaltvp[ 2 ]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function sets the file access and modification times of the filefilename. The new
file access time is specified bytvp[0], and the new modification time bytvp[1].
Similar toutime, iftvpis a null pointer then the access and modification times of
the file are set to the current time. This function comes from BSD.
The return values and error conditions are the same as for theutimefunction.

int lutimes(const char *filename, const struct timevaltvp[ 2 ]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is likeutimes, except that it does not follow symbolic links. Iffilename
is the name of a symbolic link,lutimessets the file access and modification times
of the symbolic link special file itself (as seen bylstat; seeSection 14.5 [Symbolic
Links], page 419) whileutimessets the file access and modification times of the file
the symbolic link refers to. This function comes from FreeBSD, and is not available
on all platforms (if not available, it will fail withENOSYS).
The return values and error conditions are the same as for theutimefunction.

int futimes(intfd, const struct timevaltvp[ 2 ]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is likeutimes, except that it takes an open file descriptor as an argument
instead of a file name. SeeChapter 13 [Low-Level Input/Output], page 342. This
function comes from FreeBSD, and is not available on all platforms (if not available,
it will fail withENOSYS).
Likeutimes,futimesreturns 0 on success and-1on failure. The followingerrno
error conditions are defined forfutimes:
EACCES There is a permission problem in the case where a null pointer was passed
as thetimesargument. In order to update the time stamp on the file,
you must either be the owner of the file, have write permission for the
file, or be a privileged user.
EBADF Thefiledesargument is not a valid file descriptor.
EPERM If thetimesargument is not a null pointer, you must either be the owner
of the file or be a privileged user.
EROFS The file lives on a read-only file system.


Chapter 14: File System Interface 442

## 14.9.10 File Size..............................................

Normally file sizes are maintained automatically. A file begins with a size of 0 and is
automatically extended when data is written past its end. It is also possible to empty a file
completely by anopenorfopencall.

However, sometimes it is necessary toreducethe size of a file. This can be done with
thetruncateandftruncatefunctions. They were introduced in BSD Unix.ftruncate
was later added to POSIX.1.

Some systems allow you to extend a file (creating holes) with these functions. This is
useful when using memory-mapped I/O (seeSection 13.8 [Memory-mapped I/O], page 360),
where files are not automatically extended. However, it is not portable but must be imple-
mented ifmmapallows mapping of files (i.e.,_POSIX_MAPPED_FILESis defined).

Using these functions on anything other than a regular file givesundefinedresults. On
many systems, such a call will appear to succeed, without actually accomplishing anything.

int truncate (const char *filename, offtlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thetruncatefunction changes the size offilenametolength. Iflengthis shorter
than the previous length, data at the end will be lost. The file must be writable by
the user to perform this operation.
Iflengthis longer, holes will be added to the end. However, some systems do not
support this feature and will leave the file unchanged.
When the source file is compiled with_FILE_OFFSET_BITS == 64thetruncatefunc-
tion is in facttruncate64and the typeoff_thas 64 bits which makes it possible to
handle files up to 2^63 bytes in length.
The return value is 0 for success, or?1 for an error. In addition to the usual file
name errors, the following errors may occur:
EACCES The file is a directory or not writable.
EINVAL lengthis negative.
EFBIG The operation would extend the file beyond the limits of the operating
system.
EIO A hardware I/O error occurred.
EPERM The file is"append-only"or"immutable".
EINTR The operation was interrupted by a signal.

int truncate64(const char *name, off64 tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to thetruncatefunction. The difference is that thelength
argument is 64 bits wide even on 32 bits machines, which allows the handling of files
with sizes up to 2^63 bytes.
When the source file is compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine
this function is actually available under the nametruncateand so transparently
replaces the 32 bits interface.


Chapter 14: File System Interface 443

int ftruncate(intfd, off tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is liketruncate, but it works on a file descriptorfdfor an opened file instead of
a file name to identify the object. The file must be opened for writing to successfully
carry out the operation.
The POSIX standard leaves it implementation defined what happens if the specified
newlengthof the file is bigger than the original size. Theftruncatefunction might
simply leave the file alone and do nothing or it can increase the size to the desired
size. In this later case the extended area should be zero-filled. So usingftruncateis
no reliable way to increase the file size but if it is possible it is probably the fastest
way. The function also operates on POSIX shared memory segments if these are
implemented by the system.
ftruncateis especially useful in combination withmmap. Since the mapped region
must have a fixed size one cannot enlarge the file by writing something beyond the
last mapped page. Instead one has to enlarge the file itself and then remap the file
with the new size. The example below shows how this works.
When the source file is compiled with_FILE_OFFSET_BITS == 64theftruncatefunc-
tion is in factftruncate64and the typeoff_thas 64 bits which makes it possible
to handle files up to 2^63 bytes in length.
The return value is 0 for success, or?1 for an error. The following errors may occur:
EBADF fddoes not correspond to an open file.
EACCES fdis a directory or not open for writing.
EINVAL lengthis negative.
EFBIG The operation would extend the file beyond the limits of the operating
system.
EIO A hardware I/O error occurred.
EPERM The file is"append-only"or"immutable".
EINTR The operation was interrupted by a signal.

int ftruncate64 (intid, off64tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar to theftruncatefunction. The difference is that thelength
argument is 64 bits wide even on 32 bits machines which allows the handling of files
with sizes up to 2^63 bytes.
When the source file is compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine
this function is actually available under the nameftruncateand so transparently
replaces the 32 bits interface.

As announced here is a little example of how to useftruncatein combination with
mmap:
int fd;


Chapter 14: File System Interface 444

```
void *start;
size_t len;
```
int
add (off_t at, void *block, size_t size)
{
if (at + size > len)
{
/* Resize the file and remap. */
size_t ps = sysconf (_SC_PAGESIZE);
size_t ns = (at + size + ps - 1) & ~(ps - 1);
void *np;
if (ftruncate (fd, ns) < 0)
return -1;
np = mmap (NULL, ns, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
if (np == MAP_FAILED)
return -1;
start = np;
len = ns;
}
memcpy ((char *) start + at, block, size);
return 0;
}
The functionaddwrites a block of memory at an arbitrary position in the file. If the
current size of the file is too small it is extended. Note that it is extended by a whole
number of pages. This is a requirement ofmmap. The program has to keep track of the real
size, and when it has finished a finalftruncatecall should set the real size of the file.

## 14.9.11 Storage Allocation....................................

Most file systems support allocating large files in a non-contiguous fashion: the file is
split intofragmentswhich are allocated sequentially, but the fragments themselves can be
scattered across the disk. File systems generally try to avoid such fragmentation because
it decreases performance, but if a file gradually increases in size, there might be no other
option than to fragment it. In addition, many file systems supportsparse fileswithholes:
regions of null bytes for which no backing storage has been allocated by the file system.
When the holes are finally overwritten with data, fragmentation can occur as well.

Explicit allocation of storage for yet-unwritten parts of the file can help the system to
avoid fragmentation. Additionally, if storage pre-allocation fails, it is possible to report the
out-of-disk error early, often without filling up the entire disk. However, due to dedupli-
cation, copy-on-write semantics, and file compression, such pre-allocation may not reliably
prevent the out-of-disk-space error from occurring later. Checking for write errors is still
required, and writes to memory-mapped regions created withmmapcan still result inSIGBUS.

int posix_fallocate (intfd, offtoffset, offtlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Allocate backing store for the region oflengthbytes starting at byteoffsetin the file
for the descriptorfd. The file length is increased to ¡®length+offset¡¯ if necessary.
fdmust be a regular file opened for writing, orEBADFis returned. If there is insufficient
disk space to fulfill the allocation request,ENOSPCis returned.


Chapter 14: File System Interface 445

```
Note: Iffallocateis not available (because the file system does not support it),
posix_fallocateis emulated, which has the following drawbacks:
```
- It is very inefficient because all file system blocks in the requested range need to
    be examined (even if they have been allocated before) and potentially rewritten.
    In contrast, with proper fallocatesupport (see below), the file system can
    examine the internal file allocation data structures and eliminate holes directly,
    maybe even using unwritten extents (which are pre-allocated but uninitialized
    on disk).
- There is a race condition if another thread or process modifies the underlying file
    in the to-be-allocated area. Non-null bytes could be overwritten with null bytes.
- Iffdhas been opened with theO_WRONLYflag, the function will fail with anerrno
    value ofEBADF.
- Iffdhas been opened with theO_APPENDflag, the function will fail with anerrno
    value ofEBADF.
- Iflengthis zero,ftruncateis used to increase the file size as requested, with-
    out allocating file system blocks. There is a race condition which means that
    ftruncatecan accidentally truncate the file if it has been extended concurrently.

```
On Linux, if an application does not benefit from emulation or if the emulation is
harmful due to its inherent race conditions, the application can use the Linux-specific
fallocatefunction, with a zero flag argument. For thefallocatefunction, the
GNU C Library does not perform allocation emulation if the file system does not
support allocation. Instead, anEOPNOTSUPPis returned to the caller.
```
int posix_fallocate64(intfd, off64 toffset, off64 tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is a variant ofposix_fallocate64which accepts 64-bit file offsets on
all platforms.

## 14.10 Making Special Files.......................................

Themknodfunction is the primitive for making special files, such as files that correspond
to devices. The GNU C Library includes this function for compatibility with BSD.

```
The prototype formknodis declared insys/stat.h.
```
int mknod (const char *filename, modetmode, devtdev) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themknodfunction makes a special file with namefilename. Themodespecifies the
mode of the file, and may include the various special file bits, such asS_IFCHR(for a
character special file) orS_IFBLK(for a block special file). SeeSection 14.9.3 [Testing
the Type of a File], page 431.
Thedevargument specifies which device the special file refers to. Its exact interpre-
tation depends on the kind of special file being created.


Chapter 14: File System Interface 446

```
The return value is 0 on success and-1on error. In addition to the usual file name
errors (seeSection 11.2.3 [File Name Errors], page 264), the followingerrnoerror
conditions are defined for this function:
EPERM The calling process is not privileged. Only the superuser can create spe-
cial files.
ENOSPC The directory or file system that would contain the new file is full and
cannot be extended.
EROFS The directory containing the new file can¡¯t be modified because it¡¯s on a
read-only file system.
EEXIST There is already a file namedfilename. If you want to replace this file,
you must remove the old file explicitly first.
```
## 14.11 Temporary Files...........................................

If you need to use a temporary file in your program, you can use thetmpfilefunction to
open it. Or you can use thetmpnam(better: tmpnam_r) function to provide a name for a
temporary file and then you can open it in the usual way withfopen.

Thetempnamfunction is liketmpnambut lets you choose what directory temporary files
will go in, and something about what their file names will look like. Important for multi-
threaded programs is thattempnamis reentrant, whiletmpnamis not since it returns a
pointer to a static buffer.

```
These facilities are declared in the header filestdio.h.
```
FILE * tmpfile(void) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe mem fd lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function creates a temporary binary file for update mode, as if by callingfopen
with mode"wb+". The file is deleted automatically when it is closed or when the
program terminates. (On some other ISO C systems the file may fail to be deleted if
the program terminates abnormally).
This function is reentrant.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is in facttmpfile64, i.e., the LFS interface transparently replaces the
old interface.

FILE * tmpfile64 (void) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe mem fd lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar totmpfile, but the stream it returns a pointer to was opened
usingtmpfile64. Therefore this stream can be used for files larger than 2^31 bytes on
32-bit machines.
Please note that the return type is stillFILE *. There is no specialFILEtype for the
LFS interface.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32 bits machine this
function is available under the nametmpfileand so transparently replaces the old
interface.


Chapter 14: File System Interface 447

char * tmpnam(char *result) [Function]
Preliminary: |MT-Unsafe race:tmpnam/!result |AS-Unsafe | AC-Safe |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function constructs and returns a valid file name that does not refer to any
existing file. If theresultargument is a null pointer, the return value is a pointer to
an internal static string, which might be modified by subsequent calls and therefore
makes this function non-reentrant. Otherwise, theresultargument should be a pointer
to an array of at leastL_tmpnamcharacters, and the result is written into that array.
It is possible fortmpnam to fail if you call it too many times without removing
previously-created files. This is because the limited length of the temporary file names
gives room for only a finite number of different names. Iftmpnamfails it returns a
null pointer.
Warning:Between the time the pathname is constructed and the file is created an-
other process might have created a file with the same name usingtmpnam, leading to
a possible security hole. The implementation generates names which can hardly be
predicted, but when opening the file you should use theO_EXCLflag. Usingtmpfile
ormkstempis a safe way to avoid this problem.

char * tmpnam_r (char *result) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is nearly identical to thetmpnamfunction, except that ifresultis a null
pointer it returns a null pointer.
This guarantees reentrancy because the non-reentrant situation oftmpnam cannot
happen here.
Warning: This function has the same security problems astmpnam.

int L_tmpnam [Macro]
The value of this macro is an integer constant expression that represents the minimum
size of a string large enough to hold a file name generated by thetmpnamfunction.

int TMP_MAX [Macro]
The macroTMP_MAXis a lower bound for how many temporary names you can create
withtmpnam. You can rely on being able to calltmpnamat least this many times
before it might fail saying you have made too many temporary file names.
With the GNU C Library, you can create a very large number of temporary file names.
If you actually created the files, you would probably run out of disk space before you
ran out of names. Some other systems have a fixed, small limit on the number of
temporary files. The limit is never less than 25.

char * tempnam(const char *dir, const char *prefix) [Function]
Preliminary:|MT-Safe env|AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function generates a unique temporary file name. Ifprefixis not a null pointer,
up to five characters of this string are used as a prefix for the file name. The return
value is a string newly allocated withmalloc, so you should release its storage with
freewhen it is no longer needed.


Chapter 14: File System Interface 448

```
Because the string is dynamically allocated this function is reentrant.
The directory prefix for the temporary file name is determined by testing each of the
following in sequence. The directory must exist and be writable.
```
- The environment variableTMPDIR, if it is defined. For security reasons this only
    happens if the program is not SUID or SGID enabled.
- Thedirargument, if it is not a null pointer.
- The value of theP_tmpdirmacro.
- The directory/tmp.
This function is defined for SVID compatibility.
Warning:Between the time the pathname is constructed and the file is created an-
other process might have created a file with the same name usingtempnam, leading to
a possible security hole. The implementation generates names which can hardly be
predicted, but when opening the file you should use theO_EXCLflag. Usingtmpfile
ormkstempis a safe way to avoid this problem.

char * P_tmpdir [SVID Macro]
This macro is the name of the default directory for temporary files.

Older Unix systems did not have the functions just described. Instead they usedmktemp
andmkstemp. Both of these functions work by modifying a file name template string you
pass. The last six characters of this string must be ¡®XXXXXX¡¯. These six ¡®X¡¯s are replaced
with six characters which make the whole string a unique file name. Usually the template
string is something like ¡®/tmp/prefixXXXXXX¡¯, and each program uses a uniqueprefix.

NB:Becausemktempandmkstempmodify the template string, youmust notpass string
constants to them. String constants are normally in read-only storage, so your program
would crash whenmktempormkstemp tried to modify the string. These functions are
declared in the header filestdlib.h.

char * mktemp(char *template) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themktempfunction generates a unique file name by modifyingtemplateas described
above. If successful, it returnstemplateas modified. Ifmktempcannot find a unique
file name, it makestemplatean empty string and returns that. Iftemplatedoes not
end with ¡®XXXXXX¡¯,mktempreturns a null pointer.
Warning:Between the time the pathname is constructed and the file is created an-
other process might have created a file with the same name usingmktemp, leading to
a possible security hole. The implementation generates names which can hardly be
predicted, but when opening the file you should use theO_EXCLflag. Usingmkstemp
is a safe way to avoid this problem.

int mkstemp(char *template) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themkstemp function generates a unique file name just asmktemp does, but it
also opens the file for you withopen(seeSection 13.1 [Opening and Closing Files],


Chapter 14: File System Interface 449

```
page 342). If successful, it modifiestemplatein place and returns a file descriptor for
that file open for reading and writing. Ifmkstempcannot create a uniquely-named
file, it returns-1. Iftemplatedoes not end with ¡®XXXXXX¡¯,mkstempreturns-1and
does not modifytemplate.
The file is opened using mode 0600. If the file is meant to be used by other users this
mode must be changed explicitly.
```
Unlikemktemp,mkstempis actually guaranteed to create a unique file that cannot possi-
bly clash with any other program trying to create a temporary file. This is because it works
by callingopenwith theO_EXCLflag, which says you want to create a new file and get an
error if the file already exists.

char * mkdtemp(char *template) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themkdtempfunction creates a directory with a unique name. If it succeeds, it
overwritestemplatewith the name of the directory, and returnstemplate. As with
mktempandmkstemp,templateshould be a string ending with ¡®XXXXXX¡¯.
Ifmkdtempcannot create an uniquely named directory, it returnsNULLand setserrno
appropriately. Iftemplatedoes not end with ¡®XXXXXX¡¯,mkdtempreturnsNULLand does
not modifytemplate.errnowill be set toEINVALin this case.
The directory is created using mode 0700.

The directory created bymkdtempcannot clash with temporary files or directories created
by other users. This is because directory creation always works likeopenwithO_EXCL. See
Section 14.8 [Creating Directories], page 424.

```
Themkdtempfunction comes from OpenBSD.
```

### 450

## 15 Pipes and FIFOs....................................

Apipeis a mechanism for interprocess communication; data written to the pipe by one
process can be read by another process. The data is handled in a first-in, first-out (FIFO)
order. The pipe has no name; it is created for one use and both ends must be inherited
from the single process which created the pipe.

AFIFO special fileis similar to a pipe, but instead of being an anonymous, temporary
connection, a FIFO has a name or names like any other file. Processes open the FIFO by
name in order to communicate through it.

A pipe or FIFO has to be open at both ends simultaneously. If you read from a pipe or
FIFO file that doesn¡¯t have any processes writing to it (perhaps because they have all closed
the file, or exited), the read returns end-of-file. Writing to a pipe or FIFO that doesn¡¯t have
a reading process is treated as an error condition; it generates aSIGPIPEsignal, and fails
with error codeEPIPEif the signal is handled or blocked.

Neither pipes nor FIFO special files allow file positioning. Both reading and writing
operations happen sequentially; reading from the beginning of the file and writing at the
end.

## 15.1 Creating a Pipe.............................................

The primitive for creating a pipe is thepipefunction. This creates both the reading and
writing ends of the pipe. It is not very useful for a single process to use a pipe to talk to
itself. In typical use, a process creates a pipe just before it forks one or more child processes
(seeSection 26.4 [Creating a Process], page 805). The pipe is then used for communication
either between the parent or child processes, or between two sibling processes.

```
Thepipefunction is declared in the header fileunistd.h.
```
int pipe (intfiledes[ 2 ]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thepipefunction creates a pipe and puts the file descriptors for the reading and
writing ends of the pipe (respectively) intofiledes[0]andfiledes[1].
An easy way to remember that the input end comes first is that file descriptor 0 is
standard input, and file descriptor 1 is standard output.
If successful,pipereturns a value of 0. On failure,-1is returned. The following
errnoerror conditions are defined for this function:

```
EMFILE The process has too many files open.
ENFILE There are too many open files in the entire system. SeeSection 2.2 [Error
Codes], page 24, for more information aboutENFILE. This error never
occurs on GNU/Hurd systems.
```
Here is an example of a simple program that creates a pipe. This program uses thefork
function (seeSection 26.4 [Creating a Process], page 805) to create a child process. The
parent process writes data to the pipe, which is read by the child process.


Chapter 15: Pipes and FIFOs 451

```
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
```
```
/*Read characters from the pipe and echo them tostdout.*/
```
```
void
read_from_pipe (int file)
{
FILE *stream;
int c;
stream = fdopen (file, "r");
while ((c = fgetc (stream)) != EOF)
putchar (c);
fclose (stream);
}
```
```
/*Write some random text to the pipe.*/
```
```
void
write_to_pipe (int file)
{
FILE *stream;
stream = fdopen (file, "w");
fprintf (stream, "hello, world!\n");
fprintf (stream, "goodbye, world!\n");
fclose (stream);
}
```
```
int
main (void)
{
pid_t pid;
int mypipe[2];
```
```
/*Create the pipe.*/
if (pipe (mypipe))
{
fprintf (stderr, "Pipe failed.\n");
return EXIT_FAILURE;
}
```
```
/*Create the child process. */
pid = fork ();
if (pid == (pid_t) 0)
{
/*This is the child process.
Close other end first.*/
close (mypipe[1]);
read_from_pipe (mypipe[0]);
return EXIT_SUCCESS;
}
else if (pid < (pid_t) 0)
{
/*The fork failed.*/
fprintf (stderr, "Fork failed.\n");
return EXIT_FAILURE;
```

Chapter 15: Pipes and FIFOs 452

```
}
else
{
/*This is the parent process.
Close other end first.*/
close (mypipe[0]);
write_to_pipe (mypipe[1]);
return EXIT_SUCCESS;
}
}
```
## 15.2 Pipe to a Subprocess........................................

A common use of pipes is to send data to or receive data from a program being run as a
subprocess. One way of doing this is by using a combination ofpipe(to create the pipe),
fork(to create the subprocess),dup2(to force the subprocess to use the pipe as its standard
input or output channel), andexec(to execute the new program). Or, you can usepopen
andpclose.

The advantage of usingpopenandpcloseis that the interface is much simpler and easier
to use. But it doesn¡¯t offer as much flexibility as using the low-level functions directly.

FILE * popen (const char *command, const char *mode) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap corrupt|AC-Unsafe corrupt lock fd mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thepopenfunction is closely related to thesystemfunction; seeSection 26.1 [Running
a Command], page 803. It executes the shell commandcommandas a subprocess.
However, instead of waiting for the command to complete, it creates a pipe to the
subprocess and returns a stream that corresponds to that pipe.
If you specify amodeargument of"r", you can read from the stream to retrieve
data from the standard output channel of the subprocess. The subprocess inherits its
standard input channel from the parent process.
Similarly, if you specify amodeargument of"w", you can write to the stream to send
data to the standard input channel of the subprocess. The subprocess inherits its
standard output channel from the parent process.
In the event of an errorpopenreturns a null pointer. This might happen if the pipe
or stream cannot be created, if the subprocess cannot be forked, or if the program
cannot be executed.

int pclose(FILE *stream) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap plugin corrupt lock|AC-Unsafe corrupt
lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thepclosefunction is used to close a stream created bypopen. It waits for the child
process to terminate and returns its status value, as for thesystemfunction.

Here is an example showing how to usepopenandpclose to filter output through
another program, in this case the paging programmore.

```
#include <stdio.h>
#include <stdlib.h>
```

Chapter 15: Pipes and FIFOs 453

```
void
write_data (FILE * stream)
{
int i;
for (i = 0; i < 100; i++)
fprintf (stream, "%d\n", i);
if (ferror (stream))
{
fprintf (stderr, "Output to stream failed.\n");
exit (EXIT_FAILURE);
}
}
```
```
int
main (void)
{
FILE *output;
```
```
output = popen ("more", "w");
if (!output)
{
fprintf (stderr,
"incorrect parameters or too many files.\n");
return EXIT_FAILURE;
}
write_data (output);
if (pclose (output) != 0)
{
fprintf (stderr,
"Could not run more or other error.\n");
}
return EXIT_SUCCESS;
}
```
## 15.3 FIFO Special Files..........................................

A FIFO special file is similar to a pipe, except that it is created in a different way. Instead
of being an anonymous communications channel, a FIFO special file is entered into the file
system by callingmkfifo.

Once you have created a FIFO special file in this way, any process can open it for reading
or writing, in the same way as an ordinary file. However, it has to be open at both ends
simultaneously before you can proceed to do any input or output operations on it. Opening
a FIFO for reading normally blocks until some other process opens the same FIFO for
writing, and vice versa.

```
Themkfifofunction is declared in the header filesys/stat.h.
```
int mkfifo(const char *filename, modetmode) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Themkfifo function makes a FIFO special file with namefilename. The mode
argument is used to set the file¡¯s permissions; seeSection 14.9.7 [Assigning File Per-
missions], page 436.


Chapter 15: Pipes and FIFOs 454

```
The normal, successful return value frommkfifois 0. In the case of an error,-1
is returned. In addition to the usual file name errors (seeSection 11.2.3 [File Name
Errors], page 264), the followingerrnoerror conditions are defined for this function:
EEXIST The named file already exists.
ENOSPC The directory or file system cannot be extended.
```
```
EROFS The directory that would contain the file resides on a read-only file system.
```
## 15.4 Atomicity of Pipe I/O.......................................

Reading or writing pipe data isatomicif the size of data written is not greater thanPIPE_
BUF. This means that the data transfer seems to be an instantaneous unit, in that nothing
else in the system can observe a state in which it is partially complete. Atomic I/O may
not begin right away (it may need to wait for buffer space or for data), but once it does
begin it finishes immediately.

Reading or writing a larger amount of data may not be atomic; for example, output
data from other processes sharing the descriptor may be interspersed. Also, oncePIPE_BUF
characters have been written, further writes will block until some characters are read.

SeeSection 32.6 [Limits on File System Capacity], page 903, for information about the
PIPE_BUFparameter.


### 455

## 16 Sockets.......................................

## 16 Sockets............................................

This chapter describes the GNU facilities for interprocess communication using sockets.

Asocketis a generalized interprocess communication channel. Like a pipe, a socket
is represented as a file descriptor. Unlike pipes sockets support communication between
unrelated processes, and even between processes running on different machines that com-
municate over a network. Sockets are the primary means of communicating with other
machines;telnet,rlogin,ftp,talkand the other familiar network programs use sockets.

Not all operating systems support sockets. In the GNU C Library, the header file
sys/socket.hexists regardless of the operating system, and the socket functions always
exist, but if the system does not really support sockets these functions always fail.

Incomplete: We do not currently document the facilities for broadcast messages or for
configuring Internet interfaces. The reentrant functions and some newer functions that are
related to IPv6 aren¡¯t documented either so far.

## 16.1 Socket Concepts.............................................

When you create a socket, you must specify the style of communication you want to use
and the type of protocol that should implement it. Thecommunication styleof a socket
defines the user-level semantics of sending and receiving data on the socket. Choosing a
communication style specifies the answers to questions such as these:

- What are the units of data transmission?Some communication styles regard the data
    as a sequence of bytes with no larger structure; others group the bytes into records
    (which are known in this context aspackets).
- Can data be lost during normal operation?Some communication styles guarantee that
    all the data sent arrives in the order it was sent (barring system or network crashes);
    other styles occasionally lose data as a normal part of operation, and may sometimes
    deliver packets more than once or in the wrong order.
    Designing a program to use unreliable communication styles usually involves taking
    precautions to detect lost or misordered packets and to retransmit data as needed.
- Is communication entirely with one partner? Some communication styles are like a
    telephone call¡ªyou make aconnectionwith one remote socket and then exchange data
    freely. Other styles are like mailing letters¡ªyou specify a destination address for each
    message you send.
You must also choose anamespacefor naming the socket. A socket name (¡°address¡±) is
meaningful only in the context of a particular namespace. In fact, even the data type to use
for a socket name may depend on the namespace. Namespaces are also called ¡°domains¡±,
but we avoid that word as it can be confused with other usage of the same term. Each
namespace has a symbolic name that starts with ¡®PF_¡¯. A corresponding symbolic name
starting with ¡®AF_¡¯ designates the address format for that namespace.

Finally you must choose theprotocolto carry out the communication. The protocol
determines what low-level mechanism is used to transmit and receive data. Each protocol
is valid for a particular namespace and communication style; a namespace is sometimes
called aprotocol familybecause of this, which is why the namespace names start with
¡®PF_¡¯.


Chapter 16: Sockets 456

The rules of a protocol apply to the data passing between two programs, perhaps on
different computers; most of these rules are handled by the operating system and you need
not know about them. What you do need to know about protocols is this:

- In order to have communication between two sockets, they must specify thesame
    protocol.
- Each protocol is meaningful with particular style/namespace combinations and cannot
    be used with inappropriate combinations. For example, the TCP protocol fits only the
    byte stream style of communication and the Internet namespace.
- For each combination of style and namespace there is adefault protocol, which you can
    request by specifying 0 as the protocol number. And that¡¯s what you should normally
    do¡ªuse the default.
Throughout the following description at various places variables/parameters to denote
sizes are required. And here the trouble starts. In the first implementations the type of these
variables was simplyint. On most machines at that time anintwas 32 bits wide, which
created ade factostandard requiring 32-bit variables. This is important since references to
variables of this type are passed to the kernel.

Then the POSIX people came and unified the interface with the words"all size values
are of typesize_t". On 64-bit machinessize_tis 64 bits wide, so pointers to variables
were no longer possible.

The Unix98 specification provides a solution by introducing a typesocklen_t. This
type is used in all of the cases that POSIX changed to usesize_t. The only requirement of
this type is that it be an unsigned type of at least 32 bits. Therefore, implementations which
require that references to 32-bit variables be passed can be as happy as implementations
which use 64-bit values.

## 16.2 Communication Styles.......................................

The GNU C Library includes support for several different kinds of sockets, each with dif-
ferent characteristics. This section describes the supported socket types. The symbolic
constants listed here are defined insys/socket.h.

int SOCK_STREAM [Macro]
TheSOCK_STREAMstyle is like a pipe (seeChapter 15 [Pipes and FIFOs], page 450).
It operates over a connection with a particular remote socket and transmits data
reliably as a stream of bytes.
Use of this style is covered in detail inSection 16.9 [Using Sockets with Connections],
page 482.

int SOCK_DGRAM [Macro]
TheSOCK_DGRAMstyle is used for sending individually-addressed packets unreliably.
It is the diametrical opposite ofSOCK_STREAM.
Each time you write data to a socket of this kind, that data becomes one packet.
SinceSOCK_DGRAMsockets do not have connections, you must specify the recipient
address with each packet.
The only guarantee that the system makes about your requests to transmit data is
that it will try its best to deliver each packet you send. It may succeed with the sixth


Chapter 16: Sockets 457

```
packet after failing with the fourth and fifth packets; the seventh packet may arrive
before the sixth, and may arrive a second time after the sixth.
The typical use forSOCK_DGRAMis in situations where it is acceptable to simply re-send
a packet if no response is seen in a reasonable amount of time.
SeeSection 16.10 [Datagram Socket Operations], page 493, for detailed information
about how to use datagram sockets.
```
int SOCK_RAW [Macro]
This style provides access to low-level network protocols and interfaces. Ordinary
user programs usually have no need to use this style.

## 16.3 Socket Addresses............................................

The name of a socket is normally called anaddress. The functions and symbols for dealing
with socket addresses were named inconsistently, sometimes using the term ¡°name¡± and
sometimes using ¡°address¡±. You can regard these terms as synonymous where sockets are
concerned.

A socket newly created with thesocketfunction has no address. Other processes can
find it for communication only if you give it an address. We call thisbindingthe address
to the socket, and the way to do it is with thebindfunction.

You need only be concerned with the address of a socket if other processes are to find
it and start communicating with it. You can specify an address for other sockets, but
this is usually pointless; the first time you send data from a socket, or use it to initiate a
connection, the system assigns an address automatically if you have not specified one.

Occasionally a client needs to specify an address because the server discriminates based
on address; for example, the rsh and rlogin protocols look at the client¡¯s socket address
and only bypass passphrase checking if it is less thanIPPORT_RESERVED(seeSection 16.6.3
[Internet Ports], page 473).

The details of socket addresses vary depending on what namespace you are using. See
Section 16.5 [The Local Namespace], page 461, orSection 16.6 [The Internet Namespace],
page 463, for specific information.

Regardless of the namespace, you use the same functionsbindandgetsocknameto set
and examine a socket¡¯s address. These functions use a phony data type,struct sockaddr
*, to accept the address. In practice, the address lives in a structure of some other data
type appropriate to the address format you are using, but you cast its address tostruct
sockaddr *when you pass it tobind.

## 16.3.1 Address Formats.......................................

The functions bindandgetsocknameuse the generic data typestruct sockaddr *to
represent a pointer to a socket address. You can¡¯t use this data type effectively to interpret
an address or construct one; for that, you must use the proper data type for the socket¡¯s
namespace.

Thus, the usual practice is to construct an address of the proper namespace-specific type,
then cast a pointer tostruct sockaddr *when you callbindorgetsockname.


Chapter 16: Sockets 458

The one piece of information that you can get from thestruct sockaddrdata type is
theaddress format designator. This tells you which data type to use to understand the
address fully.

```
The symbols in this section are defined in the header filesys/socket.h.
```
struct sockaddr [Data Type]
Thestruct sockaddrtype itself has the following members:

```
short int sa_family
This is the code for the address format of this address. It identifies the
format of the data which follows.
```
```
char sa_data[14]
This is the actual socket address data, which is format-dependent. Its
length also depends on the format, and may well be more than 14. The
length 14 ofsa_datais essentially arbitrary.
```
Each address format has a symbolic name which starts with ¡®AF_¡¯. Each of them corre-
sponds to a ¡®PF_¡¯ symbol which designates the corresponding namespace. Here is a list of
address format names:

AF_LOCAL This designates the address format that goes with the local namespace. (PF_
LOCALis the name of that namespace.) SeeSection 16.5.2 [Details of Local
Namespace], page 461, for information about this address format.

AF_UNIX This is a synonym for AF_LOCAL. Although AF_LOCAL is mandated by
POSIX.1g,AF_UNIXis portable to more systems. AF_UNIXwas the traditional
name stemming from BSD, so even most POSIX systems support it. It is also
the name of choice in the Unix98 specification. (The same is true forPF_UNIX
vs.PF_LOCAL).

AF_FILE This is another synonym forAF_LOCAL, for compatibility. (PF_FILEis likewise
a synonym forPF_LOCAL.)

AF_INET This designates the address format that goes with the Internet namespace.
(PF_INETis the name of that namespace.) SeeSection 16.6.1 [Internet Socket
Address Formats], page 464.

AF_INET6 This is similar toAF_INET, but refers to the IPv6 protocol. (PF_INET6is the
name of the corresponding namespace.)

AF_UNSPEC
This designates no particular address format. It is used only in rare cases,
such as to clear out the default destination address of a ¡°connected¡± datagram
socket. SeeSection 16.10.1 [Sending Datagrams], page 494.
The corresponding namespace designator symbolPF_UNSPECexists for com-
pleteness, but there is no reason to use it in a program.

sys/socket.hdefines symbols starting with ¡®AF_¡¯ for many different kinds of networks,
most or all of which are not actually implemented. We will document those that really work
as we receive information about how to use them.


Chapter 16: Sockets 459

## 16.3.2 Setting the Address of a Socket.........................

Use thebindfunction to assign an address to a socket. The prototype forbindis in
the header filesys/socket.h. For examples of use, seeSection 16.5.3 [Example of Local-
Namespace Sockets], page 462, or seeSection 16.6.7 [Internet Socket Example], page 478.

int bind (intsocket, struct sockaddr *addr, socklen tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thebindfunction assigns an address to the socket socket. Theaddr andlength
arguments specify the address; the detailed format of the address depends on the
namespace. The first part of the address is always the format designator, which
specifies a namespace, and says that the address is in the format of that namespace.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:
EBADF Thesocketargument is not a valid file descriptor.

```
ENOTSOCK The descriptorsocketis not a socket.
EADDRNOTAVAIL
The specified address is not available on this machine.
EADDRINUSE
Some other socket is already using the specified address.
EINVAL The socketsocketalready has an address.
```
```
EACCES You do not have permission to access the requested address. (In the
Internet domain, only the super-user is allowed to specify a port number
in the range 0 throughIPPORT_RESERVEDminus one; seeSection 16.6.3
[Internet Ports], page 473.)
Additional conditions may be possible depending on the particular namespace of the
socket.
```
## 16.3.3 Reading the Address of a Socket........................

Use the functiongetsocknameto examine the address of an Internet socket. The prototype
for this function is in the header filesys/socket.h.

int getsockname (intsocket, struct sockaddr *addr, socklen t [Function]
*length-ptr)
Preliminary: |MT-Safe |AS-Safe |AC-Safe mem/hurd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thegetsocknamefunction returns information about the address of the socketsocket
in the locations specified by theaddrandlength-ptrarguments. Note that thelength-
ptris a pointer; you should initialize it to be the allocation size ofaddr, and on return
it contains the actual size of the address data.
The format of the address data depends on the socket namespace. The length of
the information is usually fixed for a given namespace, so normally you can know
exactly how much space is needed and can provide that much. The usual practice is


Chapter 16: Sockets 460

```
to allocate a place for the value using the proper data type for the socket¡¯s namespace,
then cast its address tostruct sockaddr *to pass it togetsockname.
The return value is 0 on success and-1on error. The followingerrnoerror conditions
are defined for this function:
EBADF Thesocketargument is not a valid file descriptor.
ENOTSOCK The descriptorsocketis not a socket.
ENOBUFS There are not enough internal buffers available for the operation.
```
You can¡¯t read the address of a socket in the file namespace. This is consistent with the
rest of the system; in general, there¡¯s no way to find a file¡¯s name from a descriptor for that
file.

## 16.4 Interface Naming............................................

Each network interface has a name. This usually consists of a few letters that relate to the
type of interface, which may be followed by a number if there is more than one interface
of that type. Examples might belo(the loopback interface) andeth0(the first Ethernet
interface).

Although such names are convenient for humans, it would be clumsy to have to use them
whenever a program needs to refer to an interface. In such situations an interface is referred
to by itsindex, which is an arbitrarily-assigned small positive integer.

The following functions, constants and data types are declared in the header file
net/if.h.

size_t IFNAMSIZ [Constant]
This constant defines the maximum buffer size needed to hold an interface name,
including its terminating zero byte.

unsigned int if_nametoindex (const char *ifname) [Function]
Preliminary:|MT-Safe |AS-Unsafe lock|AC-Unsafe lock fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function yields the interface index corresponding to a particular name. If no
interface exists with the name given, it returns 0.

char * if_indextoname(unsigned intifindex, char *ifname) [Function]
Preliminary:|MT-Safe |AS-Unsafe lock|AC-Unsafe lock fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function maps an interface index to its corresponding name. The returned name
is placed in the buffer pointed to byifname, which must be at leastIFNAMSIZbytes in
length. If the index was invalid, the function¡¯s return value is a null pointer, otherwise
it isifname.

struct if_nameindex [Data Type]
This data type is used to hold the information about a single interface. It has the
following members:
unsigned int if_index;
This is the interface index.


Chapter 16: Sockets 461

```
char *if_name
This is the null-terminated index name.
```
struct if_nameindex * if_nameindex (void) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap lock/hurd|AC-Unsafe lock/hurd fd mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns an array ofif_nameindexstructures, one for every interface
that is present. The end of the list is indicated by a structure with an interface of 0
and a null name pointer. If an error occurs, this function returns a null pointer.
The returned structure must be freed withif_freenameindexafter use.

void if_freenameindex(struct ifnameindex *ptr) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function frees the structure returned by an earlier call toif_nameindex.

## 16.5 The Local Namespace.......................................

This section describes the details of the local namespace, whose symbolic name (required
when you create a socket) isPF_LOCAL. The local namespace is also known as ¡°Unix domain
sockets¡±. Another name is file namespace since socket addresses are normally implemented
as file names.

## 16.5.1 Local Namespace Concepts.............................

In the local namespace socket addresses are file names. You can specify any file name you
want as the address of the socket, but you must have write permission on the directory
containing it. It¡¯s common to put these files in the/tmpdirectory.

One peculiarity of the local namespace is that the name is only used when opening the
connection; once open the address is not meaningful and may not exist.

Another peculiarity is that you cannot connect to such a socket from another machine¨C
not even if the other machine shares the file system which contains the name of the socket.
You can see the socket in a directory listing, but connecting to it never succeeds. Some
programs take advantage of this, such as by asking the client to send its own process ID, and
using the process IDs to distinguish between clients. However, we recommend you not use
this method in protocols you design, as we might someday permit connections from other
machines that mount the same file systems. Instead, send each new client an identifying
number if you want it to have one.

After you close a socket in the local namespace, you should delete the file name from the
file system. Useunlinkorremoveto do this; seeSection 14.6 [Deleting Files], page 422.

The local namespace supports just one protocol for any communication style; it is pro-
tocol number 0.

## 16.5.2 Details of Local Namespace.............................

To create a socket in the local namespace, use the constantPF_LOCALas thenamespace
argument tosocketorsocketpair. This constant is defined insys/socket.h.


Chapter 16: Sockets 462

int PF_LOCAL [Macro]
This designates the local namespace, in which socket addresses are local names, and
its associated family of protocols.PF_LOCALis the macro used by POSIX.1g.

int PF_UNIX [Macro]
This is a synonym forPF_LOCAL, for compatibility¡¯s sake.

int PF_FILE [Macro]
This is a synonym forPF_LOCAL, for compatibility¡¯s sake.

The structure for specifying socket names in the local namespace is defined in the header
filesys/un.h:

struct sockaddr_un [Data Type]
This structure is used to specify local namespace socket addresses. It has the following
members:
short int sun_family
This identifies the address family or format of the socket address. You
should store the valueAF_LOCALto designate the local namespace. See
Section 16.3 [Socket Addresses], page 457.
char sun_path[108]
This is the file name to use.
Incomplete: Why is 108 a magic number? RMS suggests making this
a zero-length array and tweaking the following example to usealloca
to allocate an appropriate amount of storage based on the length of the
filename.

You should compute thelengthparameter for a socket address in the local namespace as
the sum of the size of thesun_familycomponent and the string length (notthe allocation
size!) of the file name string. This can be done using the macroSUN_LEN:

int SUN_LEN(struct sockaddrun * ptr) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro computes the length of the socket address in the local namespace.

## 16.5.3 Example of Local-Namespace Sockets...................

Here is an example showing how to create and name a socket in the local namespace.

```
#include <stddef.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
```
```
int
make_named_socket (const char *filename)
```

Chapter 16: Sockets 463

```
{
struct sockaddr_un name;
int sock;
size_t size;
```
```
/*Create the socket.*/
sock = socket (PF_LOCAL, SOCK_DGRAM, 0);
if (sock < 0)
{
perror ("socket");
exit (EXIT_FAILURE);
}
```
```
/*Bind a name to the socket.*/
name.sun_family = AF_LOCAL;
strncpy (name.sun_path, filename, sizeof (name.sun_path));
name.sun_path[sizeof (name.sun_path) - 1] = '\0';
```
```
/*The size of the address is
the offset of the start of the filename,
plus its length (not including the terminating null byte).
Alternatively you can just do:
size = SUNLEN (&name);
*/
size = (offsetof (struct sockaddr_un, sun_path)
+ strlen (name.sun_path));
```
```
if (bind (sock, (struct sockaddr *) &name, size) < 0)
{
perror ("bind");
exit (EXIT_FAILURE);
}
```
```
return sock;
}
```
## 16.6 The Internet Namespace....................................

This section describes the details of the protocols and socket naming conventions used in
the Internet namespace.

Originally the Internet namespace used only IP version 4 (IPv4). With the growing
number of hosts on the Internet, a new protocol with a larger address space was necessary:
IP version 6 (IPv6). IPv6 introduces 128-bit addresses (IPv4 has 32-bit addresses) and
other features, and will eventually replace IPv4.

To create a socket in the IPv4 Internet namespace, use the symbolic namePF_INETof
this namespace as thenamespaceargument tosocketorsocketpair. For IPv6 addresses
you need the macroPF_INET6. These macros are defined insys/socket.h.

int PF_INET [Macro]
This designates the IPv4 Internet namespace and associated family of protocols.

int PF_INET6 [Macro]
This designates the IPv6 Internet namespace and associated family of protocols.

```
A socket address for the Internet namespace includes the following components:
```

Chapter 16: Sockets 464

- The address of the machine you want to connect to. Internet addresses can be specified
    in several ways; these are discussed inSection 16.6.1 [Internet Socket Address Formats],
    page 464,Section 16.6.2 [Host Addresses], page 465,andSection 16.6.2.4 [Host Names],
    page 469.
- A port number for that machine. SeeSection 16.6.3 [Internet Ports], page 473.

You must ensure that the address and port number are represented in a canonical for-
mat callednetwork byte order. SeeSection 16.6.5 [Byte Order Conversion], page 476, for
information about this.

## 16.6.1 Internet Socket Address Formats.......................

In the Internet namespace, for both IPv4 (AF_INET) and IPv6 (AF_INET6), a socket address
consists of a host address and a port on that host. In addition, the protocol you choose
serves effectively as a part of the address because local port numbers are meaningful only
within a particular protocol.

The data types for representing socket addresses in the Internet namespace are defined
in the header filenetinet/in.h.

struct sockaddr_in [Data Type]
This is the data type used to represent socket addresses in the Internet namespace.
It has the following members:

```
sa_family_t sin_family
This identifies the address family or format of the socket address. You
should store the valueAF_INETin this member. The address family is
stored in host byte order. SeeSection 16.3 [Socket Addresses], page 457.
```
```
struct in_addr sin_addr
This is the IPv4 address. SeeSection 16.6.2 [Host Addresses], page 465,
andSection 16.6.2.4 [Host Names], page 469, for how to get a value to
store here. The IPv4 address is stored in network byte order.
```
```
unsigned short int sin_port
This is the port number. SeeSection 16.6.3 [Internet Ports], page 473.
The port number is stored in network byte order.
```
When you callbindorgetsockname, you should specifysizeof (struct sockaddr_in)
as thelengthparameter if you are using an IPv4 Internet namespace socket address.

struct sockaddr_in6 [Data Type]
This is the data type used to represent socket addresses in the IPv6 namespace. It
has the following members:

```
sa_family_t sin6_family
This identifies the address family or format of the socket address. You
should store the value ofAF_INET6in this member. SeeSection 16.3
[Socket Addresses], page 457. The address family is stored in host byte
order.
```

Chapter 16: Sockets 465

```
struct in6_addr sin6_addr
This is the IPv6 address of the host machine. SeeSection 16.6.2 [Host
Addresses], page 465, andSection 16.6.2.4 [Host Names], page 469, for
how to get a value to store here. The address is stored in network byte
order.
uint32_t sin6_flowinfo
This combines the IPv6 traffic class and flow label values, as found in
the IPv6 header. This field is stored in network byte order. Only the 28
lower bits (of the number in network byte order) are used; the remainig
bits must be zero. The lower 20 bits are the flow label, and bits 20 to 27
are the the traffic class. Typically, this field is zero.
uint32_t sin6_scope_id
For link-local addresses, this identifies the interface on which this address
is valid. The scope ID is stored in host byte order. Typically, this field is
zero.
uint16_t sin6_port
This is the port number. SeeSection 16.6.3 [Internet Ports], page 473.
The port number is stored in network byte order.
```
## 16.6.2 Host Addresses.........................................

Each computer on the Internet has one or moreInternet addresses, numbers which identify
that computer among all those on the Internet. Users typically write IPv4 numeric host
addresses as sequences of four numbers, separated by periods, as in ¡®128.52.46.32¡¯, and
IPv6 numeric host addresses as sequences of up to eight numbers separated by colons, as
in ¡®5f03:1200:836f:c100::1¡¯.

Each computer also has one or morehost names, which are strings of words separated
by periods, as in ¡®www.gnu.org¡¯.

Programs that let the user specify a host typically accept both numeric addresses and
host names. To open a connection a program needs a numeric address, and so must convert
a host name to the numeric address it stands for.

## 16.6.2.1 Internet Host Addresses...........................

An IPv4 Internet host address is a number containing four bytes of data. Historically
these are divided into two parts, anetwork number and alocal network address number
within that network. In the mid-1990s classless addresses were introduced which changed
this behavior. Since some functions implicitly expect the old definitions, we first describe
the class-based network and will then describe classless addresses. IPv6 uses only classless
addresses and therefore the following paragraphs don¡¯t apply.

The class-based IPv4 network number consists of the first one, two or three bytes; the
rest of the bytes are the local address.

IPv4 network numbers are registered with the Network Information Center (NIC), and
are divided into three classes¡ªA, B and C. The local network address numbers of individual
machines are registered with the administrator of the particular network.

Class A networks have single-byte numbers in the range 0 to 127. There are only a
small number of Class A networks, but they can each support a very large number of hosts.


Chapter 16: Sockets 466

Medium-sized Class B networks have two-byte network numbers, with the first byte in the
range 128 to 191. Class C networks are the smallest; they have three-byte network numbers,
with the first byte in the range 192-255. Thus, the first 1, 2, or 3 bytes of an Internet address
specify a network. The remaining bytes of the Internet address specify the address within
that network.

The Class A network 0 is reserved for broadcast to all networks. In addition, the host
number 0 within each network is reserved for broadcast to all hosts in that network. These
uses are obsolete now but for compatibility reasons you shouldn¡¯t use network 0 and host
number 0.

The Class A network 127 is reserved for loopback; you can always use the Internet
address ¡®127.0.0.1¡¯ to refer to the host machine.

Since a single machine can be a member of multiple networks, it can have multiple
Internet host addresses. However, there is never supposed to be more than one machine
with the same host address.

```
There are four forms of thestandard numbers-and-dots notationfor Internet addresses:
```
a.b.c.d This specifies all four bytes of the address individually and is the commonly
used representation.

a.b.c The last part of the address,c, is interpreted as a 2-byte quantity. This is
useful for specifying host addresses in a Class B network with network address
numbera.b.

a.b The last part of the address,b, is interpreted as a 3-byte quantity. This is
useful for specifying host addresses in a Class A network with network address
numbera.

a If only one part is given, this corresponds directly to the host address number.

Within each part of the address, the usual C conventions for specifying the radix apply.
In other words, a leading ¡®0x¡¯ or ¡®0X¡¯ implies hexadecimal radix; a leading ¡® 0 ¡¯ implies octal;
and otherwise decimal radix is assumed.

Classless Addresses

IPv4 addresses (and IPv6 addresses also) are now considered classless; the distinction be-
tween classes A, B and C can be ignored. Instead an IPv4 host address consists of a 32-bit
address and a 32-bit mask. The mask contains set bits for the network part and cleared
bits for the host part. The network part is contiguous from the left, with the remaining
bits representing the host. As a consequence, the netmask can simply be specified as the
number of set bits. Classes A, B and C are just special cases of this general rule. For
example, class A addresses have a netmask of ¡®255.0.0.0¡¯ or a prefix length of 8.

Classless IPv4 network addresses are written in numbers-and-dots notation with the
prefix length appended and a slash as separator. For example the class A network 10 is
written as ¡®10.0.0.0/8¡¯.

IPv6 Addresses

IPv6 addresses contain 128 bits (IPv4 has 32 bits) of data. A host address is usually
written as eight 16-bit hexadecimal numbers that are separated by colons. Two colons are


Chapter 16: Sockets 467

used to abbreviate strings of consecutive zeros. For example, the IPv6 loopback address
¡®0:0:0:0:0:0:0:1¡¯ can just be written as ¡®::1¡¯.

## 16.6.2.2 Host Address Data Type..........................

IPv4 Internet host addresses are represented in some contexts as integers (typeuint32_t).
In other contexts, the integer is packaged inside a structure of typestruct in_addr. It
would be better if the usage were made consistent, but it is not hard to extract the integer
from the structure or put the integer into a structure.

You will find older code that usesunsigned long intfor IPv4 Internet host addresses
instead ofuint32_torstruct in_addr. Historicallyunsigned long intwas a 32-bit num-
ber but with 64-bit machines this has changed. Usingunsigned long intmight break the
code if it is used on machines where this type doesn¡¯t have 32 bits.uint32_tis specified
by Unix98 and guaranteed to have 32 bits.

IPv6 Internet host addresses have 128 bits and are packaged inside a structure of type
struct in6_addr.

The following basic definitions for Internet addresses are declared in the header file
netinet/in.h:

struct in_addr [Data Type]
This data type is used in certain contexts to contain an IPv4 Internet host address.
It has just one field, nameds_addr, which records the host address number as an
uint32_t.

uint32_t INADDR_LOOPBACK [Macro]
You can use this constant to stand for ¡°the address of this machine,¡± instead of finding
its actual address. It is the IPv4 Internet address ¡®127.0.0.1¡¯, which is usually called
¡®localhost¡¯. This special constant saves you the trouble of looking up the address of
your own machine. Also, the system usually implementsINADDR_LOOPBACKspecially,
avoiding any network traffic for the case of one machine talking to itself.

uint32_t INADDR_ANY [Macro]
You can use this constant to stand for ¡°any incoming address¡± when binding to an
address. SeeSection 16.3.2 [Setting the Address of a Socket], page 459. This is the
usual address to give in thesin_addrmember ofstruct sockaddr_inwhen you
want to accept Internet connections.

uint32_t INADDR_BROADCAST [Macro]
This constant is the address you use to send a broadcast message.

uint32_t INADDR_NONE [Macro]
This constant is returned by some functions to indicate an error.

struct in6_addr [Data Type]
This data type is used to store an IPv6 address. It stores 128 bits of data, which can
be accessed (via a union) in a variety of ways.

struct in6_addr in6addr_loopback [Constant]
This constant is the IPv6 address ¡®::1¡¯, the loopback address. See above for a de-
scription of what this means. The macroIN6ADDR_LOOPBACK_INITis provided to
allow you to initialize your own variables to this value.


Chapter 16: Sockets 468

struct in6_addr in6addr_any [Constant]
This constant is the IPv6 address ¡®::¡¯, the unspecified address. See above for a
description of what this means. The macroIN6ADDR_ANY_INITis provided to allow
you to initialize your own variables to this value.

## 16.6.2.3 Host Address Functions............................

These additional functions for manipulating Internet addresses are declared in the header
filearpa/inet.h. They represent Internet addresses in network byte order, and network
numbers and local-address-within-network numbers in host byte order. SeeSection 16.6.5
[Byte Order Conversion], page 476, for an explanation of network and host byte order.

int inet_aton(const char *name, struct inaddr *addr) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function converts the IPv4 Internet host addressname from the standard
numbers-and-dots notation into binary data and stores it in thestruct in_addr
thataddrpoints to.inet_atonreturns nonzero if the address is valid, zero if not.

uint32_t inet_addr(const char *name) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function converts the IPv4 Internet host addressname from the standard
numbers-and-dots notation into binary data. If the input is not valid,inet_addr
returns INADDR_NONE. This is an obsolete interface to inet_aton, described
immediately above. It is obsolete because INADDR_NONE is a valid address
(255.255.255.255), andinet_atonprovides a cleaner way to indicate error return.

uint32_t inet_network(const char *name) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function extracts the network number from the address name, given in the
standard numbers-and-dots notation. The returned address is in host order. If the
input is not valid,inet_networkreturns-1.
The function works only with traditional IPv4 class A, B and C network types. It
doesn¡¯t work with classless addresses and shouldn¡¯t be used anymore.

char * inet_ntoa (struct inaddraddr) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe race|AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function converts the IPv4 Internet host addressaddrto a string in the standard
numbers-and-dots notation. The return value is a pointer into a statically-allocated
buffer. Subsequent calls will overwrite the same buffer, so you should copy the string
if you need to save it.
In multi-threaded programs each thread has its own statically-allocated buffer. But
still subsequent calls ofinet_ntoain the same thread will overwrite the result of the
last call.
Instead ofinet_ntoathe newer functioninet_ntopwhich is described below should
be used since it handles both IPv4 and IPv6 addresses.


Chapter 16: Sockets 469

struct in_addr inet_makeaddr(uint32 tnet, uint32tlocal) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function makes an IPv4 Internet host address by combining the network number
netwith the local-address-within-network numberlocal.

uint32_t inet_lnaof (struct inaddraddr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the local-address-within-network part of the Internet host ad-
dressaddr.
The function works only with traditional IPv4 class A, B and C network types. It
doesn¡¯t work with classless addresses and shouldn¡¯t be used anymore.

uint32_t inet_netof (struct inaddraddr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the network number part of the Internet host addressaddr.
The function works only with traditional IPv4 class A, B and C network types. It
doesn¡¯t work with classless addresses and shouldn¡¯t be used anymore.

int inet_pton(intaf, const char *cp, void *buf) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function converts an Internet address (either IPv4 or IPv6) from presentation
(textual) to network (binary) format. af should be eitherAF_INETorAF_INET6, as
appropriate for the type of address being converted. cp is a pointer to the input
string, andbuf is a pointer to a buffer for the result. It is the caller¡¯s responsibility
to make sure the buffer is large enough.

const char * inet_ntop (intaf, const void *cp, char *buf, [Function]
socklentlen)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function converts an Internet address (either IPv4 or IPv6) from network (bi-
nary) to presentation (textual) form. af should be eitherAF_INETorAF_INET6, as
appropriate.cpis a pointer to the address to be converted.buf should be a pointer
to a buffer to hold the result, andlenis the length of this buffer. The return value
from the function will be this buffer address.

## 16.6.2.4 Host Names.......................................

Besides the standard numbers-and-dots notation for Internet addresses, you can also refer
to a host by a symbolic name. The advantage of a symbolic name is that it is usually easier
to remember. For example, the machine with Internet address ¡®158.121.106.19¡¯ is also
known as ¡®alpha.gnu.org¡¯; and other machines in the ¡®gnu.org¡¯ domain can refer to it
simply as ¡®alpha¡¯.


Chapter 16: Sockets 470

Internally, the system uses a database to keep track of the mapping between host names
and host numbers. This database is usually either the file/etc/hostsor an equivalent
provided by a name server. The functions and other symbols for accessing this database
are declared innetdb.h. They are BSD features, defined unconditionally if you include
netdb.h.

struct hostent [Data Type]
This data type is used to represent an entry in the hosts database. It has the following
members:
char *h_name
This is the ¡°official¡± name of the host.
char **h_aliases
These are alternative names for the host, represented as a null-terminated
vector of strings.
int h_addrtype
This is the host address type; in practice, its value is always eitherAF_
INETorAF_INET6, with the latter being used for IPv6 hosts. In principle
other kinds of addresses could be represented in the database as well as
Internet addresses; if this were done, you might find a value in this field
other thanAF_INETorAF_INET6. SeeSection 16.3 [Socket Addresses],
page 457.
int h_length
This is the length, in bytes, of each address.
char **h_addr_list
This is the vector of addresses for the host. (Recall that the host might
be connected to multiple networks and have different addresses on each
one.) The vector is terminated by a null pointer.

```
char *h_addr
This is a synonym forh_addr_list[0]; in other words, it is the first host
address.
```
As far as the host database is concerned, each address is just a block of memoryh_
lengthbytes long. But in other contexts there is an implicit assumption that you can
convert IPv4 addresses to astruct in_addror anuint32_t. Host addresses in astruct
hostentstructure are always given in network byte order; seeSection 16.6.5 [Byte Order
Conversion], page 476.

You can usegethostbyname,gethostbyname2orgethostbyaddr to search the hosts
database for information about a particular host. The information is returned in a statically-
allocated structure; you must copy the information if you need to save it across calls. You
can also usegetaddrinfoandgetnameinfoto obtain this information.

struct hostent * gethostbyname (const char *name) [Function]
Preliminary: |MT-Unsafe race:hostbyname env locale|AS-Unsafe dlopen plugin
corrupt heap lock|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.


Chapter 16: Sockets 471

```
Thegethostbynamefunction returns information about the host namedname. If the
lookup fails, it returns a null pointer.
```
struct hostent * gethostbyname2(const char *name, intaf) [Function]
Preliminary: |MT-Unsafe race:hostbyname2 env locale|AS-Unsafe dlopen plugin
corrupt heap lock|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thegethostbyname2function is likegethostbyname, but allows the caller to specify
the desired address family (e.g.AF_INETorAF_INET6) of the result.

struct hostent * gethostbyaddr (const void *addr, socklent [Function]
length, intformat)
Preliminary: |MT-Unsafe race:hostbyaddr env locale|AS-Unsafe dlopen plugin
corrupt heap lock|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thegethostbyaddrfunction returns information about the host with Internet ad-
dressaddr. The parameteraddris not really a pointer to char - it can be a pointer to
an IPv4 or an IPv6 address. Thelengthargument is the size (in bytes) of the address
ataddr.formatspecifies the address format; for an IPv4 Internet address, specify a
value ofAF_INET; for an IPv6 Internet address, useAF_INET6.
If the lookup fails,gethostbyaddrreturns a null pointer.

If the name lookup bygethostbyname orgethostbyaddrfails, you can find out the
reason by looking at the value of the variableh_errno. (It would be cleaner design for
these functions to seterrno, but use ofh_errnois compatible with other systems.)

```
Here are the error codes that you may find inh_errno:
```
HOST_NOT_FOUND
No such host is known in the database.

TRY_AGAIN
This condition happens when the name server could not be contacted. If you
try again later, you may succeed then.

NO_RECOVERY
A non-recoverable error occurred.

NO_ADDRESS
The host database contains an entry for the name, but it doesn¡¯t have an
associated Internet address.
The lookup functions above all have one thing in common: they are not reentrant and
therefore unusable in multi-threaded applications. Therefore provides the GNU C Library
a new set of functions which can be used in this context.

int gethostbyname_r (const char *restrictname, struct hostent [Function]
*restrictresult_buf, char *restrictbuf, sizetbuflen, struct hostent
**restrictresult, int *restricth_errnop)
Preliminary: |MT-Safe env locale|AS-Unsafe dlopen plugin corrupt heap lock
|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.


Chapter 16: Sockets 472

```
Thegethostbyname_rfunction returns information about the host named name.
The caller must pass a pointer to an object of typestruct hostentin theresultbuf
parameter. In addition the function may need extra buffer space and the caller must
pass a pointer and the size of the buffer in thebuf andbuflenparameters.
```
```
A pointer to the buffer, in which the result is stored, is available in*resultafter the
function call successfully returned. The buffer passed as thebuf parameter can be
freed only once the caller has finished with the result hostent struct, or has copied
it including all the other memory that it points to. If an error occurs or if no entry
is found, the pointer*resultis a null pointer. Success is signalled by a zero return
value. If the function failed the return value is an error number. In addition to the
errors defined forgethostbynameit can also beERANGE. In this case the call should
be repeated with a larger buffer. Additional error information is not stored in the
global variableh_errnobut instead in the object pointed to byherrnop.
```
```
Here¡¯s a small example:
struct hostent *
gethostname (char *host)
{
struct hostent *hostbuf, *hp;
size_t hstbuflen;
char *tmphstbuf;
int res;
int herr;
```
```
hostbuf = malloc (sizeof (struct hostent));
hstbuflen = 1024;
tmphstbuf = malloc (hstbuflen);
```
```
while ((res = gethostbyname_r (host, hostbuf, tmphstbuf, hstbuflen,
&hp, &herr)) == ERANGE)
{
/* Enlarge the buffer. */
hstbuflen *= 2;
tmphstbuf = realloc (tmphstbuf, hstbuflen);
}
```
```
free (tmphstbuf);
/* Check for errors. */
if (res || hp == NULL)
return NULL;
return hp;
}
```
int gethostbyname2_r(const char *name, intaf, struct hostent [Function]
*restrictresult_buf, char *restrictbuf, sizetbuflen, struct hostent
**restrictresult, int *restricth_errnop)
Preliminary: |MT-Safe env locale|AS-Unsafe dlopen plugin corrupt heap lock
|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.

```
Thegethostbyname2_rfunction is likegethostbyname_r, but allows the caller to
specify the desired address family (e.g.AF_INETorAF_INET6) for the result.
```

Chapter 16: Sockets 473

int gethostbyaddr_r (const void *addr, socklentlength, int [Function]
format, struct hostent *restrictresult_buf, char *restrictbuf, size t
buflen, struct hostent **restrictresult, int *restricth_errnop)
Preliminary: |MT-Safe env locale|AS-Unsafe dlopen plugin corrupt heap lock
|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegethostbyaddr_rfunction returns information about the host with Internet
addressaddr. The parameteraddris not really a pointer to char - it can be a pointer
to an IPv4 or an IPv6 address. Thelengthargument is the size (in bytes) of the
address ataddr. formatspecifies the address format; for an IPv4 Internet address,
specify a value ofAF_INET; for an IPv6 Internet address, useAF_INET6.
Similar to thegethostbyname_rfunction, the caller must provide buffers for the
result and memory used internally. In case of success the function returns zero.
Otherwise the value is an error number whereERANGEhas the special meaning that
the caller-provided buffer is too small.

You can also scan the entire hosts database one entry at a time usingsethostent,
gethostentandendhostent. Be careful when using these functions because they are not
reentrant.

void sethostent (intstayopen) [Function]
Preliminary: |MT-Unsafe race:hostent env locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function opens the hosts database to begin scanning it. You can then call
gethostentto read the entries.
If thestayopenargument is nonzero, this sets a flag so that subsequent calls to
gethostbynameorgethostbyaddrwill not close the database (as they usually would).
This makes for more efficiency if you call those functions several times, by avoiding
reopening the database for each call.

struct hostent * gethostent (void) [Function]
Preliminary: | MT-Unsafe race:hostent race:hostentbuf env locale | AS-Unsafe
dlopen plugin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function returns the next entry in the hosts database. It returns a null pointer
if there are no more entries.

void endhostent (void) [Function]
Preliminary: |MT-Unsafe race:hostent env locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function closes the hosts database.

## 16.6.3 Internet Ports..........................................

A socket address in the Internet namespace consists of a machine¡¯s Internet address plus
aport numberwhich distinguishes the sockets on a given machine (for a given protocol).
Port numbers range from 0 to 65,535.


Chapter 16: Sockets 474

Port numbers less thanIPPORT_RESERVEDare reserved for standard servers, such as
fingerandtelnet. There is a database that keeps track of these, and you can use the
getservbynamefunction to map a service name onto a port number; seeSection 16.6.4 [The
Services Database], page 474.

If you write a server that is not one of the standard ones defined in the database, you
must choose a port number for it. Use a number greater thanIPPORT_USERRESERVED; such
numbers are reserved for servers and won¡¯t ever be generated automatically by the system.
Avoiding conflicts with servers being run by other users is up to you.

When you use a socket without specifying its address, the system generates a port
number for it. This number is betweenIPPORT_RESERVEDandIPPORT_USERRESERVED.

On the Internet, it is actually legitimate to have two different sockets with the same
port number, as long as they never both try to communicate with the same socket address
(host address plus port number). You shouldn¡¯t duplicate a port number except in special
circumstances where a higher-level protocol requires it. Normally, the system won¡¯t let you
do it;bindnormally insists on distinct port numbers. To reuse a port number, you must
set the socket optionSO_REUSEADDR. SeeSection 16.12.2 [Socket-Level Options], page 499.

```
These macros are defined in the header filenetinet/in.h.
```
int IPPORT_RESERVED [Macro]
Port numbers less thanIPPORT_RESERVEDare reserved for superuser use.

int IPPORT_USERRESERVED [Macro]
Port numbers greater than or equal toIPPORT_USERRESERVEDare reserved for explicit
use; they will never be allocated automatically.

## 16.6.4 The Services Database..................................

The database that keeps track of ¡°well-known¡± services is usually either the file
/etc/servicesor an equivalent from a name server. You can use these utilities, declared
innetdb.h, to access the services database.

struct servent [Data Type]
This data type holds information about entries from the services database. It has the
following members:

```
char *s_name
This is the ¡°official¡± name of the service.
char **s_aliases
These are alternate names for the service, represented as an array of
strings. A null pointer terminates the array.
```
```
int s_port
This is the port number for the service. Port numbers are given in network
byte order; seeSection 16.6.5 [Byte Order Conversion], page 476.
```
```
char *s_proto
This is the name of the protocol to use with this service. SeeSection 16.6.6
[Protocols Database], page 477.
```

Chapter 16: Sockets 475

To get information about a particular service, use thegetservbynameorgetservbyport
functions. The information is returned in a statically-allocated structure; you must copy
the information if you need to save it across calls.

struct servent * getservbyname (const char *name, const char [Function]
*proto)
Preliminary: |MT-Unsafe race:servbyname locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegetservbyname function returns information about the service namedname
using protocolproto. If it can¡¯t find such a service, it returns a null pointer.
This function is useful for servers as well as for clients; servers use it to determine
which port they should listen on (seeSection 16.9.2 [Listening for Connections],
page 483).

struct servent * getservbyport (intport, const char *proto) [Function]
Preliminary: |MT-Unsafe race:servbyport locale |AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegetservbyportfunction returns information about the service at portportusing
protocolproto. If it can¡¯t find such a service, it returns a null pointer.

You can also scan the services database usingsetservent,getserventandendservent.
Be careful when using these functions because they are not reentrant.

void setservent (intstayopen) [Function]
Preliminary: |MT-Unsafe race:servent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function opens the services database to begin scanning it.
If thestayopenargument is nonzero, this sets a flag so that subsequent calls to
getservbynameorgetservbyportwill not close the database (as they usually would).
This makes for more efficiency if you call those functions several times, by avoiding
reopening the database for each call.

struct servent * getservent (void) [Function]
Preliminary: |MT-Unsafe race:servent race:serventbuf locale |AS-Unsafe dlopen
plugin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns the next entry in the services database. If there are no more
entries, it returns a null pointer.

void endservent (void) [Function]
Preliminary: |MT-Unsafe race:servent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function closes the services database.


Chapter 16: Sockets 476

## 16.6.5 Byte Order Conversion.................................

Different kinds of computers use different conventions for the ordering of bytes within a
word. Some computers put the most significant byte within a word first (this is called
¡°big-endian¡± order), and others put it last (¡°little-endian¡± order).

So that machines with different byte order conventions can communicate, the Internet
protocols specify a canonical byte order convention for data transmitted over the network.
This is known asnetwork byte order.

When establishing an Internet socket connection, you must make sure that the data
in thesin_portandsin_addrmembers of thesockaddr_instructure are represented in
network byte order. If you are encoding integer data in the messages sent through the socket,
you should convert this to network byte order too. If you don¡¯t do this, your program may
fail when running on or talking to other kinds of machines.

If you usegetservbynameandgethostbynameorinet_addrto get the port number
and host address, the values are already in network byte order, and you can copy them
directly into thesockaddr_instructure.

Otherwise, you have to convert the values explicitly. Usehtonsandntohsto convert
values for thesin_portmember. Use htonlandntohlto convert IPv4 addresses for
thesin_addrmember. (Remember,struct in_addris equivalent touint32_t.) These
functions are declared innetinet/in.h.

uint16_t htons(uint16thostshort) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function converts theuint16_tintegerhostshortfrom host byte order to network
byte order.

uint16_t ntohs(uint16tnetshort) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function converts theuint16_tintegernetshortfrom network byte order to host
byte order.

uint32_t htonl(uint32thostlong) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function converts theuint32_tintegerhostlongfrom host byte order to network
byte order.
This is used for IPv4 Internet addresses.

uint32_t ntohl(uint32tnetlong) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function converts theuint32_tintegernetlongfrom network byte order to host
byte order.
This is used for IPv4 Internet addresses.


Chapter 16: Sockets 477

## 16.6.6 Protocols Database.....................................

The communications protocol used with a socket controls low-level details of how data are
exchanged. For example, the protocol implements things like checksums to detect errors
in transmissions, and routing instructions for messages. Normal user programs have little
reason to mess with these details directly.

The default communications protocol for the Internet namespace depends on the com-
munication style. For stream communication, the default is TCP (¡°transmission control
protocol¡±). For datagram communication, the default is UDP (¡°user datagram protocol¡±).
For reliable datagram communication, the default is RDP (¡°reliable datagram protocol¡±).
You should nearly always use the default.

Internet protocols are generally specified by a name instead of a number. The network
protocols that a host knows about are stored in a database. This is usually either derived
from the file/etc/protocols, or it may be an equivalent provided by a name server. You
look up the protocol number associated with a named protocol in the database using the
getprotobynamefunction.

Here are detailed descriptions of the utilities for accessing the protocols database. These
are declared innetdb.h.

struct protoent [Data Type]
This data type is used to represent entries in the network protocols database. It has
the following members:
char *p_name
This is the official name of the protocol.
char **p_aliases
These are alternate names for the protocol, specified as an array of strings.
The last element of the array is a null pointer.
int p_proto
This is the protocol number (in host byte order); use this member as the
protocolargument tosocket.
You can usegetprotobynameandgetprotobynumberto search the protocols database
for a specific protocol. The information is returned in a statically-allocated structure; you
must copy the information if you need to save it across calls.

struct protoent * getprotobyname(const char *name) [Function]
Preliminary:|MT-Unsafe race:protobyname locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegetprotobynamefunction returns information about the network protocol named
name. If there is no such protocol, it returns a null pointer.

struct protoent * getprotobynumber (intprotocol) [Function]
Preliminary: |MT-Unsafe race:protobynumber locale|AS-Unsafe dlopen plugin
heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetprotobynumberfunction returns information about the network protocol with
numberprotocol. If there is no such protocol, it returns a null pointer.


Chapter 16: Sockets 478

You can also scan the whole protocols database one protocol at a time by using
setprotoent, getprotoent andendprotoent. Be careful when using these functions
because they are not reentrant.

void setprotoent (intstayopen) [Function]
Preliminary:|MT-Unsafe race:protoent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function opens the protocols database to begin scanning it.
If thestayopenargument is nonzero, this sets a flag so that subsequent calls to
getprotobynameorgetprotobynumberwill not close the database (as they usually
would). This makes for more efficiency if you call those functions several times, by
avoiding reopening the database for each call.

struct protoent * getprotoent(void) [Function]
Preliminary:|MT-Unsafe race:protoent race:protoentbuf locale|AS-Unsafe dlopen
plugin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns the next entry in the protocols database. It returns a null
pointer if there are no more entries.

void endprotoent (void) [Function]
Preliminary:|MT-Unsafe race:protoent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function closes the protocols database.

## 16.6.7 Internet Socket Example................................

Here is an example showing how to create and name a socket in the Internet namespace.
The newly created socket exists on the machine that the program is running on. Rather
than finding and using the machine¡¯s Internet address, this example specifiesINADDR_ANY
as the host address; the system replaces that with the machine¡¯s actual address.

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
```
```
int
make_socket (uint16_t port)
{
int sock;
struct sockaddr_in name;
```
```
/*Create the socket.*/
sock = socket (PF_INET, SOCK_STREAM, 0);
if (sock < 0)
{
perror ("socket");
exit (EXIT_FAILURE);
```

Chapter 16: Sockets 479

```
}
```
```
/*Give the socket a name.*/
name.sin_family = AF_INET;
name.sin_port = htons (port);
name.sin_addr.s_addr = htonl (INADDR_ANY);
if (bind (sock, (struct sockaddr *) &name, sizeof (name)) < 0)
{
perror ("bind");
exit (EXIT_FAILURE);
}
```
```
return sock;
}
```
Here is another example, showing how you can fill in asockaddr_instructure, given a
host name string and a port number:

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
```
```
void
init_sockaddr (struct sockaddr_in *name,
const char *hostname,
uint16_t port)
{
struct hostent *hostinfo;
```
```
name->sin_family = AF_INET;
name->sin_port = htons (port);
hostinfo = gethostbyname (hostname);
if (hostinfo == NULL)
{
fprintf (stderr, "Unknown host %s.\n", hostname);
exit (EXIT_FAILURE);
}
name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
}
```
## 16.7 Other Namespaces..........................................

Certain other namespaces and associated protocol families are supported but not docu-
mented yet because they are not often used.PF_NSrefers to the Xerox Network Software
protocols. PF_ISOstands for Open Systems Interconnect. PF_CCITTrefers to protocols
from CCITT.socket.hdefines these symbols and others naming protocols not actually
implemented.

PF_IMPLINKis used for communicating between hosts and Internet Message Processors.
For information on this andPF_ROUTE, an occasionally-used local area routing protocol, see
the GNU Hurd Manual (to appear in the future).


Chapter 16: Sockets 480

## 16.8 Opening and Closing Sockets................................

This section describes the actual library functions for opening and closing sockets. The
same functions work for all namespaces and connection styles.

## 16.8.1 Creating a Socket......................................

The primitive for creating a socket is thesocketfunction, declared insys/socket.h.

int socket(intnamespace, intstyle, intprotocol) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function creates a socket and specifies communication stylestyle, which should be
one of the socket styles listed inSection 16.2 [Communication Styles], page 456. The
namespaceargument specifies the namespace; it must bePF_LOCAL(seeSection 16.5
[The Local Namespace], page 461) orPF_INET(seeSection 16.6 [The Internet Names-
pace], page 463). protocoldesignates the specific protocol (seeSection 16.1 [Socket
Concepts], page 455); zero is usually right forprotocol.
The return value fromsocketis the file descriptor for the new socket, or-1in case
of error. The followingerrnoerror conditions are defined for this function:

```
EPROTONOSUPPORT
Theprotocolorstyleis not supported by thenamespacespecified.
```
```
EMFILE The process already has too many file descriptors open.
```
```
ENFILE The system already has too many file descriptors open.
EACCES The process does not have the privilege to create a socket of the specified
styleorprotocol.
```
```
ENOBUFS The system ran out of internal buffer space.
```
```
The file descriptor returned by thesocketfunction supports both read and write
operations. However, like pipes, sockets do not support file positioning operations.
```
For examples of how to call thesocketfunction, seeSection 16.5.3 [Example of Local-
Namespace Sockets], page 462, orSection 16.6.7 [Internet Socket Example], page 478.

## 16.8.2 Closing a Socket........................................

When you have finished using a socket, you can simply close its file descriptor withclose;
seeSection 13.1 [Opening and Closing Files], page 342. If there is still data waiting to be
transmitted over the connection, normallyclosetries to complete this transmission. You
can control this behavior using theSO_LINGERsocket option to specify a timeout period;
seeSection 16.12 [Socket Options], page 499.

You can also shut down only reception or transmission on a connection by calling
shutdown, which is declared insys/socket.h.

int shutdown (intsocket, inthow) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 16: Sockets 481

```
Theshutdownfunction shuts down the connection of socketsocket. The argument
howspecifies what action to perform:
0 Stop receiving data for this socket. If further data arrives, reject it.
1 Stop trying to transmit data from this socket. Discard any data waiting
to be sent. Stop looking for acknowledgement of data already sent; don¡¯t
retransmit it if it is lost.
2 Stop both reception and transmission.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:
EBADF socketis not a valid file descriptor.
ENOTSOCK socketis not a socket.
ENOTCONN socketis not connected.
```
## 16.8.3 Socket Pairs............................................

Asocket pairconsists of a pair of connected (but unnamed) sockets. It is very similar to
a pipe and is used in much the same way. Socket pairs are created with thesocketpair
function, declared insys/socket.h. A socket pair is much like a pipe; the main difference
is that the socket pair is bidirectional, whereas the pipe has one input-only end and one
output-only end (seeChapter 15 [Pipes and FIFOs], page 450).

int socketpair(intnamespace, intstyle, intprotocol, int [Function]
filedes[ 2 ])
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function creates a socket pair, returning the file descriptors infiledes[0]and
filedes[1]. The socket pair is a full-duplex communications channel, so that both
reading and writing may be performed at either end.
Thenamespace,styleandprotocolarguments are interpreted as for thesocketfunc-
tion.styleshould be one of the communication styles listed inSection 16.2 [Commu-
nication Styles], page 456. Thenamespaceargument specifies the namespace, which
must beAF_LOCAL(seeSection 16.5 [The Local Namespace], page 461); protocol
specifies the communications protocol, but zero is the only meaningful value.
Ifstylespecifies a connectionless communication style, then the two sockets you get
are notconnected, strictly speaking, but each of them knows the other as the default
destination address, so they can send packets to each other.
Thesocketpairfunction returns 0 on success and-1on failure. The followingerrno
error conditions are defined for this function:
EMFILE The process has too many file descriptors open.
EAFNOSUPPORT
The specified namespace is not supported.
EPROTONOSUPPORT
The specified protocol is not supported.


Chapter 16: Sockets 482

### EOPNOTSUPP

```
The specified protocol does not support the creation of socket pairs.
```
## 16.9 Using Sockets with Connections.............................

The most common communication styles involve making a connection to a particular other
socket, and then exchanging data with that socket over and over. Making a connection is
asymmetric; one side (theclient) acts to request a connection, while the other side (the
server) makes a socket and waits for the connection request.

- Section 16.9.1 [Making a Connection], page 482, describes what the client program
    must do to initiate a connection with a server.
- Section 16.9.2 [Listening for Connections], page 483,andSection 16.9.3 [Accepting
    Connections], page 484,describe what the server program must do to wait for and act
    upon connection requests from clients.
- Section 16.9.5 [Transferring Data], page 485, describes how data are transferred through
    the connected socket.

## 16.9.1 Making a Connection...................................

In making a connection, the client makes a connection while the server waits for and accepts
the connection. Here we discuss what the client program must do with theconnectfunction,
which is declared insys/socket.h.

int connect(intsocket, struct sockaddr *addr, socklentlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theconnectfunction initiates a connection from the socket with file descriptorsocket
to the socket whose address is specified by theaddr andlengtharguments. (This
socket is typically on another machine, and it must be already set up as a server.) See
Section 16.3 [Socket Addresses], page 457, for information about how these arguments
are interpreted.
Normally,connectwaits until the server responds to the request before it returns.
You can set nonblocking mode on the socketsocketto makeconnectreturn immedi-
ately without waiting for the response. SeeSection 13.15 [File Status Flags], page 387,
for information about nonblocking mode.
The normal return value fromconnectis 0. If an error occurs,connectreturns-1.
The followingerrnoerror conditions are defined for this function:

```
EBADF The socketsocketis not a valid file descriptor.
```
```
ENOTSOCK File descriptorsocketis not a socket.
```
```
EADDRNOTAVAIL
The specified address is not available on the remote machine.
```
```
EAFNOSUPPORT
The namespace of theaddris not supported by this socket.
```
```
EISCONN The socketsocketis already connected.
```

Chapter 16: Sockets 483

### ETIMEDOUT

```
The attempt to establish the connection timed out.
ECONNREFUSED
The server has actively refused to establish the connection.
ENETUNREACH
The network of the givenaddrisn¡¯t reachable from this host.
```
```
EADDRINUSE
The socket address of the givenaddris already in use.
EINPROGRESS
The socketsocketis non-blocking and the connection could not be estab-
lished immediately. You can determine when the connection is completely
established withselect; seeSection 13.9 [Waiting for Input or Output],
page 366. Anotherconnectcall on the same socket, before the connection
is completely established, will fail withEALREADY.
EALREADY The socketsocketis non-blocking and already has a pending connection
in progress (seeEINPROGRESSabove).
```
```
This function is defined as a cancellation point in multi-threaded programs, so one
has to be prepared for this and make sure that allocated resources (like memory, file
descriptors, semaphores or whatever) are freed even if the thread is canceled.
```
## 16.9.2 Listening for Connections...............................

Now let us consider what the server process must do to accept connections on a socket. First
it must use thelistenfunction to enable connection requests on the socket, and then accept
each incoming connection with a call toaccept(seeSection 16.9.3 [Accepting Connections],
page 484). Once connection requests are enabled on a server socket, theselectfunction
reports when the socket has a connection ready to be accepted (seeSection 13.9 [Waiting
for Input or Output], page 366).

Thelisten function is not allowed for sockets using connectionless communication
styles.

You can write a network server that does not even start running until a connection to it
is requested. SeeSection 16.11.1 [inetdServers], page 497.

In the Internet namespace, there are no special protection mechanisms for controlling
access to a port; any process on any machine can make a connection to your server. If
you want to restrict access to your server, make it examine the addresses associated with
connection requests or implement some other handshaking or identification protocol.

In the local namespace, the ordinary file protection bits control who has access to connect
to the socket.

int listen(intsocket, intn) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelistenfunction enables the socketsocketto accept connections, thus making it
a server socket.


Chapter 16: Sockets 484

```
The argumentnspecifies the length of the queue for pending connections. When the
queue fills, new clients attempting to connect fail withECONNREFUSEDuntil the server
callsacceptto accept a connection from the queue.
Thelistenfunction returns 0 on success and-1on failure. The followingerrno
error conditions are defined for this function:
```
```
EBADF The argumentsocketis not a valid file descriptor.
```
```
ENOTSOCK The argumentsocketis not a socket.
```
```
EOPNOTSUPP
The socketsocketdoes not support this operation.
```
## 16.9.3 Accepting Connections.................................

When a server receives a connection request, it can complete the connection by accepting
the request. Use the functionacceptto do this.

A socket that has been established as a server can accept connection requests from
multiple clients. The server¡¯s original socketdoes not become part of the connection; instead,
accept makes a new socket which participates in the connection. acceptreturns the
descriptor for this socket. The server¡¯s original socket remains available for listening for
further connection requests.

The number of pending connection requests on a server socket is finite. If connection
requests arrive from clients faster than the server can act upon them, the queue can fill
up and additional requests are refused with anECONNREFUSEDerror. You can specify the
maximum length of this queue as an argument to thelistenfunction, although the system
may also impose its own internal limit on the length of this queue.

int accept(intsocket, struct sockaddr *addr, socklent [Function]
*length_ptr)
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to accept a connection request on the server socketsocket.
Theacceptfunction waits if there are no connections pending, unless the socket
sockethas nonblocking mode set. (You can useselectto wait for a pending connec-
tion, with a nonblocking socket.) SeeSection 13.15 [File Status Flags], page 387, for
information about nonblocking mode.
Theaddrandlength-ptrarguments are used to return information about the name
of the client socket that initiated the connection. SeeSection 16.3 [Socket Addresses],
page 457, for information about the format of the information.
Accepting a connection does not makesocketpart of the connection. Instead, it
creates a new socket which becomes connected. The normal return value ofaccept
is the file descriptor for the new socket.
Afteraccept, the original socketsocketremains open and unconnected, and continues
listening until you close it. You can accept further connections withsocketby calling
acceptagain.


Chapter 16: Sockets 485

```
If an error occurs,acceptreturns-1. The followingerrnoerror conditions are defined
for this function:
EBADF Thesocketargument is not a valid file descriptor.
ENOTSOCK The descriptorsocketargument is not a socket.
EOPNOTSUPP
The descriptorsocketdoes not support this operation.
EWOULDBLOCK
sockethas nonblocking mode set, and there are no pending connections
immediately available.
This function is defined as a cancellation point in multi-threaded programs, so one
has to be prepared for this and make sure that allocated resources (like memory, file
descriptors, semaphores or whatever) are freed even if the thread is canceled.
```
Theaccept function is not allowed for sockets using connectionless communication
styles.

## 16.9.4 Who is Connected to Me?..............................

int getpeername (intsocket, struct sockaddr *addr, socklen t [Function]
*length-ptr)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetpeernamefunction returns the address of the socket thatsocketis connected
to; it stores the address in the memory space specified byaddrandlength-ptr. It
stores the length of the address in*length-ptr.
SeeSection 16.3 [Socket Addresses], page 457, for information about the format of
the address. In some operating systems,getpeernameworks only for sockets in the
Internet domain.
The return value is 0 on success and-1on error. The followingerrnoerror conditions
are defined for this function:
EBADF The argumentsocketis not a valid file descriptor.
ENOTSOCK The descriptorsocketis not a socket.
ENOTCONN The socketsocketis not connected.
ENOBUFS There are not enough internal buffers available.

## 16.9.5 Transferring Data......................................

Once a socket has been connected to a peer, you can use the ordinaryreadandwrite
operations (seeSection 13.2 [Input and Output Primitives], page 345) to transfer data. A
socket is a two-way communications channel, so read and write operations can be performed
at either end.

There are also some I/O modes that are specific to socket operations. In order to specify
these modes, you must use therecvandsendfunctions instead of the more genericread
andwritefunctions. Therecvandsendfunctions take an additional argument which you


Chapter 16: Sockets 486

can use to specify various flags to control special I/O modes. For example, you can specify
theMSG_OOBflag to read or write out-of-band data, theMSG_PEEKflag to peek at input, or
theMSG_DONTROUTEflag to control inclusion of routing information on output.

## 16.9.5.1 Sending Data......................................

Thesendfunction is declared in the header filesys/socket.h. If yourflagsargument is
zero, you can just as well usewriteinstead ofsend; seeSection 13.2 [Input and Output
Primitives], page 345. If the socket was connected but the connection has broken, you get
aSIGPIPEsignal for any use ofsendorwrite(seeSection 24.2.7 [Miscellaneous Signals],
page 723).

ssize_t send (intsocket, const void *buffer, sizetsize, int [Function]
flags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesendfunction is likewrite, but with the additional flagsflags. The possible
values offlagsare described inSection 16.9.5.3 [Socket Data Options], page 487.
This function returns the number of bytes transmitted, or-1on failure. If the socket
is nonblocking, thensend(likewrite) can return after sending just part of the data.
SeeSection 13.15 [File Status Flags], page 387, for information about nonblocking
mode.
Note, however, that a successful return value merely indicates that the message has
been sent without error, not necessarily that it has been received without error.
The followingerrnoerror conditions are defined for this function:
EBADF Thesocketargument is not a valid file descriptor.
EINTR The operation was interrupted by a signal before any data was sent. See
Section 24.5 [Primitives Interrupted by Signals], page 741.
ENOTSOCK The descriptorsocketis not a socket.
EMSGSIZE The socket type requires that the message be sent atomically, but the
message is too large for this to be possible.
EWOULDBLOCK
Nonblocking mode has been set on the socket, and the write operation
would block. (Normally sendblocks until the operation can be com-
pleted.)
ENOBUFS There is not enough internal buffer space available.
ENOTCONN You never connected this socket.
EPIPE This socket was connected but the connection is now broken. In this case,
sendgenerates aSIGPIPEsignal first; if that signal is ignored or blocked,
or if its handler returns, thensendfails withEPIPE.
This function is defined as a cancellation point in multi-threaded programs, so one
has to be prepared for this and make sure that allocated resources (like memory, file
descriptors, semaphores or whatever) are freed even if the thread is canceled.


Chapter 16: Sockets 487

## 16.9.5.2 Receiving Data....................................

Therecvfunction is declared in the header filesys/socket.h. If yourflagsargument is
zero, you can just as well usereadinstead ofrecv; seeSection 13.2 [Input and Output
Primitives], page 345.

ssize_t recv (intsocket, void *buffer, sizetsize, intflags) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Therecvfunction is likeread, but with the additional flagsflags. The possible values
offlagsare described inSection 16.9.5.3 [Socket Data Options], page 487.
If nonblocking mode is set forsocket, and no data are available to be read,recvfails
immediately rather than waiting. SeeSection 13.15 [File Status Flags], page 387, for
information about nonblocking mode.
This function returns the number of bytes received, or-1on failure. The following
errnoerror conditions are defined for this function:
EBADF Thesocketargument is not a valid file descriptor.

```
ENOTSOCK The descriptorsocketis not a socket.
EWOULDBLOCK
Nonblocking mode has been set on the socket, and the read operation
would block. (Normally,recvblocks until there is input available to be
read.)
```
```
EINTR The operation was interrupted by a signal before any data was read. See
Section 24.5 [Primitives Interrupted by Signals], page 741.
ENOTCONN You never connected this socket.
This function is defined as a cancellation point in multi-threaded programs, so one
has to be prepared for this and make sure that allocated resources (like memory, file
descriptors, semaphores or whatever) are freed even if the thread is canceled.
```
## 16.9.5.3 Socket Data Options...............................

Theflagsargument tosendandrecvis a bit mask. You can bitwise-OR the values of the
following macros together to obtain a value for this argument. All are defined in the header
filesys/socket.h.

int MSG_OOB [Macro]
Send or receive out-of-band data. SeeSection 16.9.8 [Out-of-Band Data], page 491.

int MSG_PEEK [Macro]
Look at the data but don¡¯t remove it from the input queue. This is only meaningful
with input functions such asrecv, not withsend.

int MSG_DONTROUTE [Macro]
Don¡¯t include routing information in the message. This is only meaningful with
output operations, and is usually only of interest for diagnostic or routing programs.
We don¡¯t try to explain it here.


Chapter 16: Sockets 488

## 16.9.6 Byte Stream Socket Example...........................

Here is an example client program that makes a connection for a byte stream socket in the
Internet namespace. It doesn¡¯t do anything particularly interesting once it has connected
to the server; it just sends a text string to the server and exits.

This program usesinit_sockaddrto set up the socket address; seeSection 16.6.7 [In-
ternet Socket Example], page 478.

```
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
```
```
#define PORT 5555
#define MESSAGE "Yow!!! Are we having fun yet?!?"
#define SERVERHOST "www.gnu.org"
```
```
void
write_to_server (int filedes)
{
int nbytes;
```
```
nbytes = write (filedes, MESSAGE, strlen (MESSAGE) + 1);
if (nbytes < 0)
{
perror ("write");
exit (EXIT_FAILURE);
}
}
```
```
int
main (void)
{
extern void init_sockaddr (struct sockaddr_in *name,
const char *hostname,
uint16_t port);
int sock;
struct sockaddr_in servername;
```
```
/*Create the socket.*/
sock = socket (PF_INET, SOCK_STREAM, 0);
if (sock < 0)
{
perror ("socket (client)");
exit (EXIT_FAILURE);
}
```
```
/*Connect to the server.*/
init_sockaddr (&servername, SERVERHOST, PORT);
if (0 > connect (sock,
(struct sockaddr *) &servername,
sizeof (servername)))
```

Chapter 16: Sockets 489

```
{
perror ("connect (client)");
exit (EXIT_FAILURE);
}
```
```
/*Send data to the server.*/
write_to_server (sock);
close (sock);
exit (EXIT_SUCCESS);
}
```
## 16.9.7 Byte Stream Connection Server Example...............

The server end is much more complicated. Since we want to allow multiple clients to be
connected to the server at the same time, it would be incorrect to wait for input from a
single client by simply callingreadorrecv. Instead, the right thing to do is to useselect
(seeSection 13.9 [Waiting for Input or Output], page 366) to wait for input on all of the
open sockets. This also allows the server to deal with additional connection requests.

This particular server doesn¡¯t do anything interesting once it has gotten a message from
a client. It does close the socket for that client when it detects an end-of-file condition
(resulting from the client shutting down its end of the connection).

This program usesmake_socketto set up the socket address; seeSection 16.6.7 [Internet
Socket Example], page 478.

```
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
```
```
#define PORT 5555
#define MAXMSG 512
```
```
int
read_from_client (int filedes)
{
char buffer[MAXMSG];
int nbytes;
```
```
nbytes = read (filedes, buffer, MAXMSG);
if (nbytes < 0)
{
/*Read error.*/
perror ("read");
exit (EXIT_FAILURE);
}
else if (nbytes == 0)
/*End-of-file.*/
return -1;
else
{
/*Data read.*/
fprintf (stderr, "Server: got message: `%s'\n", buffer);
```

Chapter 16: Sockets 490

```
return 0;
}
}
```
```
int
main (void)
{
extern int make_socket (uint16_t port);
int sock;
fd_set active_fd_set, read_fd_set;
int i;
struct sockaddr_in clientname;
size_t size;
```
```
/*Create the socket and set it up to accept connections.*/
sock = make_socket (PORT);
if (listen (sock, 1) < 0)
{
perror ("listen");
exit (EXIT_FAILURE);
}
```
```
/*Initialize the set of active sockets.*/
FD_ZERO (&active_fd_set);
FD_SET (sock, &active_fd_set);
```
```
while (1)
{
/*Block until input arrives on one or more active sockets.*/
read_fd_set = active_fd_set;
if (select (FD_SETSIZE, &read_fd_set, NULL, NULL, NULL) < 0)
{
perror ("select");
exit (EXIT_FAILURE);
}
```
```
/*Service all the sockets with input pending.*/
for (i = 0; i < FD_SETSIZE; ++i)
if (FD_ISSET (i, &read_fd_set))
{
if (i == sock)
{
/*Connection request on original socket.*/
int new;
size = sizeof (clientname);
new = accept (sock,
(struct sockaddr *) &clientname,
&size);
if (new < 0)
{
perror ("accept");
exit (EXIT_FAILURE);
}
fprintf (stderr,
"Server: connect from host %s, port %hd.\n",
inet_ntoa (clientname.sin_addr),
ntohs (clientname.sin_port));
FD_SET (new, &active_fd_set);
```

Chapter 16: Sockets 491

```
}
else
{
/*Data arriving on an already-connected socket.*/
if (read_from_client (i) < 0)
{
close (i);
FD_CLR (i, &active_fd_set);
}
}
}
}
}
```
## 16.9.8 Out-of-Band Data......................................

Streams with connections permitout-of-band data that is delivered with higher priority
than ordinary data. Typically the reason for sending out-of-band data is to send notice of
an exceptional condition. To send out-of-band data usesend, specifying the flagMSG_OOB
(seeSection 16.9.5.1 [Sending Data], page 486).

Out-of-band data are received with higher priority because the receiving process need
not read it in sequence; to read the next available out-of-band data, userecvwith the
MSG_OOBflag (seeSection 16.9.5.2 [Receiving Data], page 487). Ordinary read operations
do not read out-of-band data; they read only ordinary data.

When a socket finds that out-of-band data are on their way, it sends aSIGURGsignal
to the owner process or process group of the socket. You can specify the owner using
theF_SETOWNcommand to thefcntlfunction; seeSection 13.19 [Interrupt-Driven Input],
page 400. You must also establish a handler for this signal, as described inChapter 24
[Signal Handling], page 714, in order to take appropriate action such as reading the out-of-
band data.

Alternatively, you can test for pending out-of-band data, or wait until there is out-
of-band data, using theselectfunction; it can wait for an exceptional condition on the
socket. SeeSection 13.9 [Waiting for Input or Output], page 366, for more information
aboutselect.

Notification of out-of-band data (whether withSIGURGor withselect) indicates that
out-of-band data are on the way; the data may not actually arrive until later. If you try to
read the out-of-band data before it arrives,recvfails with anEWOULDBLOCKerror.

Sending out-of-band data automatically places a ¡°mark¡± in the stream of ordinary data,
showing where in the sequence the out-of-band data ¡°would have been¡±. This is useful when
the meaning of out-of-band data is ¡°cancel everything sent so far¡±. Here is how you can
test, in the receiving process, whether any ordinary data was sent before the mark:
success = ioctl (socket, SIOCATMARK, &atmark);
Theintegervariableatmarkis set to a nonzero value if the socket¡¯s read pointer has
reached the ¡°mark¡±.

```
Here¡¯s a function to discard any ordinary data preceding the out-of-band mark:
int
discard_until_mark (int socket)
{
while (1)
```

Chapter 16: Sockets 492

```
{
/*This is not an arbitrary limit; any size will do. */
char buffer[1024];
int atmark, success;
```
```
/*If we have reached the mark, return. */
success = ioctl (socket, SIOCATMARK, &atmark);
if (success < 0)
perror ("ioctl");
if (result)
return;
```
/*Otherwise, read a bunch of ordinary data and discard it.
This is guaranteed not to read past the mark
if it starts before the mark. */
success = read (socket, buffer, sizeof buffer);
if (success < 0)
perror ("read");
}
}
If you don¡¯t want to discard the ordinary data preceding the mark, you may need to
read some of it anyway, to make room in internal system buffers for the out-of-band data. If
you try to read out-of-band data and get anEWOULDBLOCKerror, try reading some ordinary
data (saving it so that you can use it when you want it) and see if that makes room. Here
is an example:
struct buffer
{
char *buf;
int size;
struct buffer *next;
};

```
/*Read the out-of-band data from SOCKET and return it
as a ¡®struct buffer¡¯, which records the address of the data
and its size.
```
```
It may be necessary to read some ordinary data
in order to make room for the out-of-band data.
If so, the ordinary data are saved as a chain of buffers
found in the ¡®next¡¯ field of the value. */
```
```
struct buffer *
read_oob (int socket)
{
struct buffer *tail = 0;
struct buffer *list = 0;
```
```
while (1)
{
/*This is an arbitrary limit.
Does anyone know how to do this without a limit? */
#define BUF_SZ 1024
char *buf = (char *) xmalloc (BUF_SZ);
int success;
int atmark;
```
```
/*Try again to read the out-of-band data. */
```

Chapter 16: Sockets 493

```
success = recv (socket, buf, BUF_SZ, MSG_OOB);
if (success >= 0)
{
/*We got it, so return it. */
struct buffer *link
= (struct buffer *) xmalloc (sizeof (struct buffer));
link->buf = buf;
link->size = success;
link->next = list;
return link;
}
```
```
/*If we fail, see if we are at the mark. */
success = ioctl (socket, SIOCATMARK, &atmark);
if (success < 0)
perror ("ioctl");
if (atmark)
{
/*At the mark; skipping past more ordinary data cannot help.
So just wait a while. */
sleep (1);
continue;
}
```
```
/*Otherwise, read a bunch of ordinary data and save it.
This is guaranteed not to read past the mark
if it starts before the mark. */
success = read (socket, buf, BUF_SZ);
if (success < 0)
perror ("read");
```
```
/*Save this data in the buffer list. */
{
struct buffer *link
= (struct buffer *) xmalloc (sizeof (struct buffer));
link->buf = buf;
link->size = success;
```
```
/* Add the new link to the end of the list. */
if (tail)
tail->next = link;
else
list = link;
tail = link;
}
}
}
```
## 16.10 Datagram Socket Operations...............................

This section describes how to use communication styles that don¡¯t use connections (styles
SOCK_DGRAMandSOCK_RDM). Using these styles, you group data into packets and each packet
is an independent communication. You specify the destination for each packet individually.

Datagram packets are like letters: you send each one independently with its own desti-
nation address, and they may arrive in the wrong order or not at all.


Chapter 16: Sockets 494

Thelistenandacceptfunctions are not allowed for sockets using connectionless com-
munication styles.

16.10.1 Sending Datagrams

The normal way of sending data on a datagram socket is by using thesendtofunction,
declared insys/socket.h.

You can callconnecton a datagram socket, but this only specifies a default destination
for further data transmission on the socket. When a socket has a default destination you can
usesend(seeSection 16.9.5.1 [Sending Data], page 486) or evenwrite(seeSection 13.2
[Input and Output Primitives], page 345) to send a packet there. You can cancel the
default destination by callingconnectusing an address format ofAF_UNSPECin theaddr
argument. SeeSection 16.9.1 [Making a Connection], page 482, for more information about
theconnectfunction.

ssize_t sendto(intsocket, const void *buffer, sizetsize, int [Function]
flags, struct sockaddr *addr, socklentlength)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesendtofunction transmits the data in thebufferthrough the socketsocketto the
destination address specified by theaddrandlengtharguments. Thesizeargument
specifies the number of bytes to be transmitted.
Theflagsare interpreted the same way as forsend; seeSection 16.9.5.3 [Socket Data
Options], page 487.
The return value and error conditions are also the same as forsend, but you cannot
rely on the system to detect errors and report them; the most common error is that
the packet is lost or there is no-one at the specified address to receive it, and the
operating system on your machine usually does not know this.
It is also possible for one call tosendtoto report an error owing to a problem related
to a previous call.
This function is defined as a cancellation point in multi-threaded programs, so one
has to be prepared for this and make sure that allocated resources (like memory, file
descriptors, semaphores or whatever) are freed even if the thread is canceled.

## 16.10.2 Receiving Datagrams..................................

Therecvfromfunction reads a packet from a datagram socket and also tells you where it
was sent from. This function is declared insys/socket.h.

ssize_t recvfrom (intsocket, void *buffer, sizetsize, int [Function]
flags, struct sockaddr *addr, socklent *length-ptr)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Therecvfromfunction reads one packet from the socketsocketinto the bufferbuffer.
Thesizeargument specifies the maximum number of bytes to be read.
If the packet is longer thansizebytes, then you get the firstsizebytes of the packet
and the rest of the packet is lost. There¡¯s no way to read the rest of the packet. Thus,
when you use a packet protocol, you must always know how long a packet to expect.


Chapter 16: Sockets 495

```
Theaddrandlength-ptrarguments are used to return the address where the packet
came from. SeeSection 16.3 [Socket Addresses], page 457. For a socket in the local
domain the address information won¡¯t be meaningful, since you can¡¯t read the address
of such a socket (seeSection 16.5 [The Local Namespace], page 461). You can specify
a null pointer as theaddrargument if you are not interested in this information.
Theflagsare interpreted the same way as forrecv(seeSection 16.9.5.3 [Socket Data
Options], page 487). The return value and error conditions are also the same as for
recv.
This function is defined as a cancellation point in multi-threaded programs, so one
has to be prepared for this and make sure that allocated resources (like memory, file
descriptors, semaphores or whatever) are freed even if the thread is canceled.
```
You can use plain recv(seeSection 16.9.5.2 [Receiving Data], page 487) instead of
recvfromif you don¡¯t need to find out who sent the packet (either because you know where
it should come from or because you treat all possible senders alike). Evenreadcan be used
if you don¡¯t want to specifyflags(seeSection 13.2 [Input and Output Primitives], page 345).

## 16.10.3 Datagram Socket Example............................

Here is a set of example programs that send messages over a datagram stream in the local
namespace. Both the client and server programs use themake_named_socketfunction that
was presented inSection 16.5.3 [Example of Local-Namespace Sockets], page 462, to create
and name their sockets.

First, here is the server program. It sits in a loop waiting for messages to arrive, bouncing
each message back to the sender. Obviously this isn¡¯t a particularly useful program, but it
does show the general ideas involved.

```
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/un.h>
```
```
#define SERVER "/tmp/serversocket"
#define MAXMSG 512
```
```
int
main (void)
{
int sock;
char message[MAXMSG];
struct sockaddr_un name;
size_t size;
int nbytes;
```
```
/*Remove the filename first, it¡¯s ok if the call fails*/
unlink (SERVER);
```
```
/*Make the socket, then loop endlessly.*/
sock = make_named_socket (SERVER);
while (1)
{
/*Wait for a datagram.*/
```

Chapter 16: Sockets 496

```
size = sizeof (name);
nbytes = recvfrom (sock, message, MAXMSG, 0,
(struct sockaddr *) & name, &size);
if (nbytes < 0)
{
perror ("recfrom (server)");
exit (EXIT_FAILURE);
}
```
```
/*Give a diagnostic message.*/
fprintf (stderr, "Server: got message: %s\n", message);
```
```
/*Bounce the message back to the sender.*/
nbytes = sendto (sock, message, nbytes, 0,
(struct sockaddr *) & name, size);
if (nbytes < 0)
{
perror ("sendto (server)");
exit (EXIT_FAILURE);
}
}
}
```
## 16.10.4 Example of Reading Datagrams.......................

Here is the client program corresponding to the server above.

It sends a datagram to the server and then waits for a reply. Notice that the socket for
the client (as well as for the server) in this example has to be given a name. This is so
that the server can direct a message back to the client. Since the socket has no associated
connection state, the only way the server can do this is by referencing the name of the
client.

```
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/un.h>
```
```
#define SERVER "/tmp/serversocket"
#define CLIENT "/tmp/mysocket"
#define MAXMSG 512
#define MESSAGE "Yow!!! Are we having fun yet?!?"
```
```
int
main (void)
{
extern int make_named_socket (const char *name);
int sock;
char message[MAXMSG];
struct sockaddr_un name;
size_t size;
int nbytes;
```
```
/*Make the socket.*/
sock = make_named_socket (CLIENT);
```

Chapter 16: Sockets 497

```
/*Initialize the server socket address.*/
name.sun_family = AF_LOCAL;
strcpy (name.sun_path, SERVER);
size = strlen (name.sun_path) + sizeof (name.sun_family);
```
```
/*Send the datagram.*/
nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,
(struct sockaddr *) & name, size);
if (nbytes < 0)
{
perror ("sendto (client)");
exit (EXIT_FAILURE);
}
```
```
/*Wait for a reply.*/
nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);
if (nbytes < 0)
{
perror ("recfrom (client)");
exit (EXIT_FAILURE);
}
```
```
/*Print a diagnostic message.*/
fprintf (stderr, "Client: got message: %s\n", message);
```
/*Clean up.*/
remove (CLIENT);
close (sock);
}
Keep in mind that datagram socket communications are unreliable. In this example, the
client program waits indefinitely if the message never reaches the server or if the server¡¯s
response never comes back. It¡¯s up to the user running the program to kill and restart it
if desired. A more automatic solution could be to useselect(seeSection 13.9 [Waiting
for Input or Output], page 366) to establish a timeout period for the reply, and in case of
timeout either re-send the message or shut down the socket and exit.

## 16.11 TheinetdDaemon........................................

We¡¯ve explained above how to write a server program that does its own listening. Such a
server must already be running in order for anyone to connect to it.

Another way to provide a service on an Internet port is to let the daemon programinetd
do the listening. inetdis a program that runs all the time and waits (usingselect) for
messages on a specified set of ports. When it receives a message, it accepts the connection (if
the socket style calls for connections) and then forks a child process to run the corresponding
server program. You specify the ports and their programs in the file/etc/inetd.conf.

## 16.11.1 inetdServers.........................................

Writing a server program to be run byinetdis very simple. Each time someone requests
a connection to the appropriate port, a new server process starts. The connection already
exists at this time; the socket is available as the standard input descriptor and as the
standard output descriptor (descriptors 0 and 1) in the server process. Thus the server
program can begin reading and writing data right away. Often the program needs only the


Chapter 16: Sockets 498

ordinary I/O facilities; in fact, a general-purpose filter program that knows nothing about
sockets can work as a byte stream server run byinetd.

You can also useinetdfor servers that use connectionless communication styles. For
these servers,inetddoes not try to accept a connection since no connection is possible. It
just starts the server program, which can read the incoming datagram packet from descriptor

0. The server program can handle one request and then exit, or you can choose to write it
to keep reading more requests until no more arrive, and then exit. You must specify which
of these two techniques the server uses when you configureinetd.

## 16.11.2 Configuringinetd.....................................

The file/etc/inetd.conftellsinetdwhich ports to listen to and what server programs to
run for them. Normally each entry in the file is one line, but you can split it onto multiple
lines provided all but the first line of the entry start with whitespace. Lines that start with
¡®#¡¯ are comments.

Here are two standard entries in/etc/inetd.conf:
ftp stream tcp nowait root /libexec/ftpd ftpd
talk dgram udp wait root /libexec/talkd talkd
An entry has this format:
service style protocol wait username program arguments
Theservicefield says which service this program provides. It should be the name of a
service defined in/etc/services.inetdusesserviceto decide which port to listen on for
this entry.

The fieldsstyleandprotocolspecify the communication style and the protocol to use
for the listening socket. The style should be the name of a communication style, converted
to lower case and with ¡®SOCK_¡¯ deleted¡ªfor example, ¡®stream¡¯ or ¡®dgram¡¯.protocolshould
be one of the protocols listed in/etc/protocols. The typical protocol names are ¡®tcp¡¯ for
byte stream connections and ¡®udp¡¯ for unreliable datagrams.

Thewaitfield should be either ¡®wait¡¯ or ¡®nowait¡¯. Use ¡®wait¡¯ ifstyleis a connectionless
style and the server, once started, handles multiple requests as they come in. Use ¡®nowait¡¯
ifinetdshould start a new process for each message or request that comes in. Ifstyleuses
connections, thenwaitmustbe ¡®nowait¡¯.

useris the user name that the server should run as. inetdruns as root, so it can set
the user ID of its children arbitrarily. It¡¯s best to avoid using ¡®root¡¯ foruserif you can; but
some servers, such as Telnet and FTP, read a username and passphrase themselves. These
servers need to be root initially so they can log in as commanded by the data coming over
the network.

programtogether witharguments specifies the command to run to start the server.
programshould be an absolute file name specifying the executable file to run. arguments
consists of any number of whitespace-separated words, which become the command-line
arguments ofprogram. The first word inarguments is argument zero, which should by
convention be the program name itself (sans directories).

If you edit/etc/inetd.conf, you can tellinetdto reread the file and obey its new
contents by sending theinetdprocess theSIGHUPsignal. You¡¯ll have to usepsto determine
the process ID of theinetdprocess as it is not fixed.


Chapter 16: Sockets 499

## 16.12 Socket Options.............................................

This section describes how to read or set various options that modify the behavior of sockets
and their underlying communications protocols.

When you are manipulating a socket option, you must specify whichlevelthe option
pertains to. This describes whether the option applies to the socket interface, or to a
lower-level communications protocol interface.

## 16.12.1 Socket Option Functions..............................

Here are the functions for examining and modifying socket options. They are declared in
sys/socket.h.

int getsockopt(intsocket, intlevel, intoptname, void *optval, [Function]
socklent *optlen-ptr)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetsockoptfunction gets information about the value of optionoptnameat level
levelfor socketsocket.
The option value is stored in the buffer thatoptvalpoints to. Before the call, you
should supply in*optlen-ptrthe size of this buffer; on return, it contains the number
of bytes of information actually stored in the buffer.
Most options interpret theoptvalbuffer as a singleintvalue.
The actual return value ofgetsockoptis 0 on success and-1on failure. The following
errnoerror conditions are defined:
EBADF Thesocketargument is not a valid file descriptor.
ENOTSOCK The descriptorsocketis not a socket.

```
ENOPROTOOPT
Theoptnamedoesn¡¯t make sense for the givenlevel.
```
int setsockopt(intsocket, intlevel, intoptname, const void [Function]
*optval, socklen toptlen)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to set the socket optionoptnameat levellevelfor socketsocket.
The value of the option is passed in the bufferoptvalof sizeoptlen.
The return value and error codes forsetsockoptare the same as forgetsockopt.

## 16.12.2 Socket-Level Options..................................

int SOL_SOCKET [Constant]
Use this constant as thelevelargument togetsockoptorsetsockoptto manipulate
the socket-level options described in this section.

Here is a table of socket-level option names; all are defined in the header filesys/socket.h.

SO_DEBUG


Chapter 16: Sockets 500

```
This option toggles recording of debugging information in the underlying pro-
tocol modules. The value has typeint; a nonzero value means ¡°yes¡±.
```
SO_REUSEADDR
This option controls whetherbind(seeSection 16.3.2 [Setting the Address of a
Socket], page 459) should permit reuse of local addresses for this socket. If you
enable this option, you can actually have two sockets with the same Internet
port number; but the system won¡¯t allow you to use the two identically-named
sockets in a way that would confuse the Internet. The reason for this option is
that some higher-level Internet protocols, including FTP, require you to keep
reusing the same port number.
The value has typeint; a nonzero value means ¡°yes¡±.

SO_KEEPALIVE
This option controls whether the underlying protocol should periodically trans-
mit messages on a connected socket. If the peer fails to respond to these mes-
sages, the connection is considered broken. The value has typeint; a nonzero
value means ¡°yes¡±.

SO_DONTROUTE
This option controls whether outgoing messages bypass the normal message
routing facilities. If set, messages are sent directly to the network interface
instead. The value has typeint; a nonzero value means ¡°yes¡±.

SO_LINGER
This option specifies what should happen when the socket of a type that
promises reliable delivery still has untransmitted messages when it is closed;
seeSection 16.8.2 [Closing a Socket], page 480. The value has typestruct
linger.

```
struct linger [Data Type]
This structure type has the following members:
```
```
int l_onoff
This field is interpreted as a boolean. If nonzero, close
blocks until the data are transmitted or the timeout period
has expired.
```
```
int l_linger
This specifies the timeout period, in seconds.
```
SO_BROADCAST
This option controls whether datagrams may be broadcast from the socket. The
value has typeint; a nonzero value means ¡°yes¡±.

SO_OOBINLINE
If this option is set, out-of-band data received on the socket is placed in the
normal input queue. This permits it to be read usingreadorrecvwithout
specifying theMSG_OOBflag. SeeSection 16.9.8 [Out-of-Band Data], page 491.
The value has typeint; a nonzero value means ¡°yes¡±.


Chapter 16: Sockets 501

### SO_SNDBUF

```
This option gets or sets the size of the output buffer. The value is asize_t,
which is the size in bytes.
```
SO_RCVBUF
This option gets or sets the size of the input buffer. The value is asize_t,
which is the size in bytes.

SO_STYLE
SO_TYPE This option can be used withgetsockoptonly. It is used to get the socket¡¯s
communication style. SO_TYPEis the historical name, andSO_STYLEis the
preferred name in GNU. The value has typeint and its value designates a
communication style; seeSection 16.2 [Communication Styles], page 456.

SO_ERROR

```
This option can be used withgetsockoptonly. It is used to reset the error
status of the socket. The value is anint, which represents the previous error
status.
```
## 16.13 Networks Database.........................................

Many systems come with a database that records a list of networks known to the system
developer. This is usually kept either in the file/etc/networksor in an equivalent from
a name server. This data base is useful for routing programs such asroute, but it is not
useful for programs that simply communicate over the network. We provide functions to
access this database, which are declared innetdb.h.

struct netent [Data Type]
This data type is used to represent information about entries in the networks database.
It has the following members:

```
char *n_name
This is the ¡°official¡± name of the network.
```
```
char **n_aliases
These are alternative names for the network, represented as a vector of
strings. A null pointer terminates the array.
```
```
int n_addrtype
This is the type of the network number; this is always equal toAF_INET
for Internet networks.
```
```
unsigned long int n_net
This is the network number. Network numbers are returned in host byte
order; seeSection 16.6.5 [Byte Order Conversion], page 476.
```
Use thegetnetbynameorgetnetbyaddrfunctions to search the networks database for
information about a specific network. The information is returned in a statically-allocated
structure; you must copy the information if you need to save it.


Chapter 16: Sockets 502

struct netent * getnetbyname(const char *name) [Function]
Preliminary: |MT-Unsafe race:netbyname env locale|AS-Unsafe dlopen plugin
heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetnetbynamefunction returns information about the network namedname. It
returns a null pointer if there is no such network.

struct netent * getnetbyaddr(uint32 tnet, inttype) [Function]
Preliminary: |MT-Unsafe race:netbyaddr locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegetnetbyaddrfunction returns information about the network of typetypewith
numbernet. You should specify a value ofAF_INETfor thetypeargument for Internet
networks.
getnetbyaddrreturns a null pointer if there is no such network.

You can also scan the networks database usingsetnetent,getnetentandendnetent.
Be careful when using these functions because they are not reentrant.

void setnetent(intstayopen) [Function]
Preliminary: |MT-Unsafe race:netent env locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function opens and rewinds the networks database.
If thestayopenargument is nonzero, this sets a flag so that subsequent calls to
getnetbynameorgetnetbyaddrwill not close the database (as they usually would).
This makes for more efficiency if you call those functions several times, by avoiding
reopening the database for each call.

struct netent * getnetent(void) [Function]
Preliminary:|MT-Unsafe race:netent race:netentbuf env locale|AS-Unsafe dlopen
plugin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns the next entry in the networks database. It returns a null
pointer if there are no more entries.

void endnetent(void) [Function]
Preliminary: |MT-Unsafe race:netent env locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function closes the networks database.


### 503

## 17 Low-Level Terminal Interface...............

## 17 Low-Level Terminal Interface..........................

This chapter describes functions that are specific to terminal devices. You can use these
functions to do things like turn off input echoing; set serial line characteristics such as line
speed and flow control; and change which characters are used for end-of-file, command-line
editing, sending signals, and similar control functions.

Most of the functions in this chapter operate on file descriptors. SeeChapter 13 [Low-
Level Input/Output], page 342, for more information about what a file descriptor is and
how to open a file descriptor for a terminal device.

## 17.1 Identifying Terminals........................................

The functions described in this chapter only work on files that correspond to terminal
devices. You can find out whether a file descriptor is associated with a terminal by using
theisattyfunction.

```
Prototypes for the functions in this section are declared in the header fileunistd.h.
```
int isatty(intfiledes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns 1 iffiledesis a file descriptor associated with an open terminal
device, and 0 otherwise.

If a file descriptor is associated with a terminal, you can get its associated file name
using thettynamefunction. See also thectermidfunction, described inSection 28.6.1
[Identifying the Controlling Terminal], page 831.

char * ttyname(intfiledes) [Function]
Preliminary:|MT-Unsafe race:ttyname|AS-Unsafe heap lock|AC-Unsafe lock fd
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
If the file descriptorfiledesis associated with a terminal device, thettynamefunction
returns a pointer to a statically-allocated, null-terminated string containing the file
name of the terminal file. The value is a null pointer if the file descriptor isn¡¯t
associated with a terminal, or the file name cannot be determined.

int ttyname_r(intfiledes, char *buf, sizetlen) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thettyname_rfunction is similar to thettynamefunction except that it places its
result into the user-specified buffer starting atbuf with lengthlen.
The normal return value fromttyname_ris 0. Otherwise an error number is re-
turned to indicate the error. The followingerrnoerror conditions are defined for this
function:
EBADF Thefiledesargument is not a valid file descriptor.
ENOTTY Thefiledesis not associated with a terminal.
ERANGE The buffer lengthlenis too small to store the string to be returned.


Chapter 17: Low-Level Terminal Interface 504

```
ENODEV Thefiledesis associated with a terminal device that is a slave pseudo-
terminal, but the file name associated with that device could not be
determined. This is a GNU extension.
```
## 17.2 I/O Queues.................................................

Many of the remaining functions in this section refer to the input and output queues of a
terminal device. These queues implement a form of bufferingwithin the kernelindependent
of the buffering implemented by I/O streams (seeChapter 12 [Input/Output on Streams],
page 266).

Theterminal input queueis also sometimes referred to as itstypeahead buffer. It holds
the characters that have been received from the terminal but not yet read by any process.

The size of the input queue is described by theMAX_INPUTand_POSIX_MAX_INPUTpa-
rameters; seeSection 32.6 [Limits on File System Capacity], page 903. You are guaranteed
a queue size of at leastMAX_INPUT, but the queue might be larger, and might even dynam-
ically change size. If input flow control is enabled by setting theIXOFFinput mode bit (see
Section 17.4.4 [Input Modes], page 508), the terminal driver transmits STOP and START
characters to the terminal when necessary to prevent the queue from overflowing. Other-
wise, input may be lost if it comes in too fast from the terminal. In canonical mode, all
input stays in the queue until a newline character is received, so the terminal input queue
can fill up when you type a very long line. SeeSection 17.3 [Two Styles of Input: Canonical
or Not], page 504.

Theterminal output queueis like the input queue, but for output; it contains characters
that have been written by processes, but not yet transmitted to the terminal. If output flow
control is enabled by setting theIXONinput mode bit (seeSection 17.4.4 [Input Modes],
page 508), the terminal driver obeys START and STOP characters sent by the terminal to
stop and restart transmission of output.

Clearingthe terminal input queue means discarding any characters that have been re-
ceived but not yet read. Similarly, clearing the terminal output queue means discarding
any characters that have been written but not yet transmitted.

## 17.3 Two Styles of Input: Canonical or Not.......................

POSIX systems support two basic modes of input: canonical and noncanonical.

Incanonical input processingmode, terminal input is processed in lines terminated by
newline ('\n'), EOF, or EOL characters. No input can be read until an entire line has been
typed by the user, and thereadfunction (seeSection 13.2 [Input and Output Primitives],
page 345) returns at most a single line of input, no matter how many bytes are requested.

In canonical input mode, the operating system provides input editing facilities: some
characters are interpreted specially to perform editing operations within the current line
of text, such as ERASE and KILL. SeeSection 17.4.9.1 [Characters for Input Editing],
page 517.

The constants_POSIX_MAX_CANONandMAX_CANONparameterize the maximum number
of bytes which may appear in a single line of canonical input. SeeSection 32.6 [Limits on
File System Capacity], page 903. You are guaranteed a maximum line length of at least


Chapter 17: Low-Level Terminal Interface 505

MAX_CANONbytes, but the maximum might be larger, and might even dynamically change
size.

In noncanonical input processing mode, characters are not grouped into lines, and
ERASE and KILL processing is not performed. The granularity with which bytes are read in
noncanonical input mode is controlled by the MIN and TIME settings. SeeSection 17.4.10
[Noncanonical Input], page 521.

Most programs use canonical input mode, because this gives the user a way to edit
input line by line. The usual reason to use noncanonical mode is when the program accepts
single-character commands or provides its own editing facilities.

The choice of canonical or noncanonical input is controlled by theICANONflag in the
c_lflagmember ofstruct termios. SeeSection 17.4.7 [Local Modes], page 512.

## 17.4 Terminal Modes.............................................

This section describes the various terminal attributes that control how input and output
are done. The functions, data structures, and symbolic constants are all declared in the
header filetermios.h.

Don¡¯t confuse terminal attributes with file attributes. A device special file which is
associated with a terminal has file attributes as described inSection 14.9 [File Attributes],
page 425. These are unrelated to the attributes of the terminal device itself, which are
discussed in this section.

## 17.4.1 Terminal Mode Data Types.............................

The entire collection of attributes of a terminal is stored in a structure of typestruct
termios. This structure is used with the functionstcgetattrandtcsetattrto read and
set the attributes.

struct termios [Data Type]
Astruct termiosrecords all the I/O attributes of a terminal. The structure includes
at least the following members:
tcflag_t c_iflag
A bit mask specifying flags for input modes; see Section 17.4.4 [Input
Modes], page 508.
tcflag_t c_oflag
A bit mask specifying flags for output modes; seeSection 17.4.5 [Output
Modes], page 510.
tcflag_t c_cflag
A bit mask specifying flags for control modes; seeSection 17.4.6 [Control
Modes], page 511.
tcflag_t c_lflag
A bit mask specifying flags for local modes; seeSection 17.4.7 [Local
Modes], page 512.
cc_t c_cc[NCCS]
An array specifying which characters are associated with various control
functions; seeSection 17.4.9 [Special Characters], page 516.


Chapter 17: Low-Level Terminal Interface 506

```
Thestruct termiosstructure also contains members which encode input and output
transmission speeds, but the representation is not specified. SeeSection 17.4.8 [Line
Speed], page 515, for how to examine and store the speed values.
```
The following sections describe the details of the members of thestruct termiosstruc-
ture.

tcflag_t [Data Type]
This is an unsigned integer type used to represent the various bit masks for terminal
flags.

cc_t [Data Type]
This is an unsigned integer type used to represent characters associated with various
terminal control functions.

int NCCS [Macro]
The value of this macro is the number of elements in thec_ccarray.

## 17.4.2 Terminal Mode Functions...............................

int tcgetattr(intfiledes, struct termios *termios-p) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to examine the attributes of the terminal device with file de-
scriptorfiledes. The attributes are returned in the structure thattermios-ppoints
to.
If successful,tcgetattrreturns 0. A return value of?1 indicates an error. The
followingerrnoerror conditions are defined for this function:
EBADF Thefiledesargument is not a valid file descriptor.
ENOTTY Thefiledesis not associated with a terminal.

int tcsetattr(intfiledes, intwhen, const struct termios [Function]
*termios-p)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function sets the attributes of the terminal device with file descriptorfiledes.
The new attributes are taken from the structure thattermios-ppoints to.
Thewhenargument specifies how to deal with input and output already queued. It
can be one of the following values:
TCSANOW Make the change immediately.
TCSADRAIN
Make the change after waiting until all queued output has been written.
You should usually use this option when changing parameters that affect
output.
TCSAFLUSH
This is likeTCSADRAIN, but also discards any queued input.


Chapter 17: Low-Level Terminal Interface 507

```
TCSASOFT This is a flag bit that you can add to any of the above alternatives. Its
meaning is to inhibit alteration of the state of the terminal hardware. It
is a BSD extension; it is only supported on BSD systems and GNU/Hurd
systems.
UsingTCSASOFTis exactly the same as setting theCIGNOREbit in the
c_cflagmember of the structuretermios-ppoints to. SeeSection 17.4.6
[Control Modes], page 511, for a description ofCIGNORE.
If this function is called from a background process on its controlling terminal, nor-
mally all processes in the process group are sent aSIGTTOUsignal, in the same way
as if the process were trying to write to the terminal. The exception is if the calling
process itself is ignoring or blockingSIGTTOUsignals, in which case the operation is
performed and no signal is sent. SeeChapter 28 [Job Control], page 817.
If successful,tcsetattrreturns 0. A return value of?1 indicates an error. The
followingerrnoerror conditions are defined for this function:
```
```
EBADF Thefiledesargument is not a valid file descriptor.
ENOTTY Thefiledesis not associated with a terminal.
```
```
EINVAL Either the value of thewhenargument is not valid, or there is something
wrong with the data in thetermios-pargument.
```
Althoughtcgetattrandtcsetattrspecify the terminal device with a file descriptor,
the attributes are those of the terminal device itself and not of the file descriptor. This
means that the effects of changing terminal attributes are persistent; if another process
opens the terminal file later on, it will see the changed attributes even though it doesn¡¯t
have anything to do with the open file descriptor you originally specified in changing the
attributes.

Similarly, if a single process has multiple or duplicated file descriptors for the same
terminal device, changing the terminal attributes affects input and output to all of these
file descriptors. This means, for example, that you can¡¯t open one file descriptor or stream
to read from a terminal in the normal line-buffered, echoed mode; and simultaneously
have another file descriptor for the same terminal that you use to read from it in single-
character, non-echoed mode. Instead, you have to explicitly switch the terminal back and
forth between the two modes.

## 17.4.3 Setting Terminal Modes Properly.......................

When you set terminal modes, you should calltcgetattrfirst to get the current modes of
the particular terminal device, modify only those modes that you are really interested in,
and store the result withtcsetattr.

It¡¯s a bad idea to simply initialize astruct termiosstructure to a chosen set of at-
tributes and pass it directly totcsetattr. Your program may be run years from now, on
systems that support members not documented in this manual. The way to avoid setting
these members to unreasonable values is to avoid changing them.

What¡¯s more, different terminal devices may require different mode settings in order to
function properly. So you should avoid blindly copying attributes from one terminal device
to another.


Chapter 17: Low-Level Terminal Interface 508

When a member contains a collection of independent flags, as thec_iflag,c_oflag
andc_cflagmembers do, even setting the entire member is a bad idea, because particular
operating systems have their own flags. Instead, you should start with the current value
of the member and alter only the flags whose values matter in your program, leaving any
other flags unchanged.

Here is an example of how to set one flag (ISTRIP) in thestruct termiosstructure
while properly preserving all the other data in the structure:

```
int
set_istrip (int desc, int value)
{
struct termios settings;
int result;
```
```
result = tcgetattr (desc, &settings);
if (result < 0)
{
perror ("error in tcgetattr");
return 0;
}
settings.c_iflag &= ~ISTRIP;
if (value)
settings.c_iflag |= ISTRIP;
result = tcsetattr (desc, TCSANOW, &settings);
if (result < 0)
{
perror ("error in tcsetattr");
return 0;
}
return 1;
}
```
## 17.4.4 Input Modes...........................................

This section describes the terminal attribute flags that control fairly low-level aspects of
input processing: handling of parity errors, break signals, flow control, andRETandLFD
characters.

All of these flags are bits in thec_iflagmember of thestruct termiosstructure. The
member is an integer, and you change flags using the operators&,|and^. Don¡¯t try to
specify the entire value forc_iflag¡ªinstead, change only specific flags and leave the rest
untouched (seeSection 17.4.3 [Setting Terminal Modes Properly], page 507).

tcflag_t INPCK [Macro]
If this bit is set, input parity checking is enabled. If it is not set, no checking at all
is done for parity errors on input; the characters are simply passed through to the
application.

```
Parity checking on input processing is independent of whether parity detection and
generation on the underlying terminal hardware is enabled; seeSection 17.4.6 [Control
Modes], page 511. For example, you could clear theINPCKinput mode flag and set
thePARENBcontrol mode flag to ignore parity errors on input, but still generate parity
on output.
```

Chapter 17: Low-Level Terminal Interface 509

```
If this bit is set, what happens when a parity error is detected depends on whether
theIGNPARorPARMRKbits are set. If neither of these bits are set, a byte with a parity
error is passed to the application as a'\0'character.
```
tcflag_t IGNPAR [Macro]
If this bit is set, any byte with a framing or parity error is ignored. This is only useful
ifINPCKis also set.

tcflag_t PARMRK [Macro]
If this bit is set, input bytes with parity or framing errors are marked when passed
to the program. This bit is meaningful only whenINPCKis set andIGNPARis not set.
The way erroneous bytes are marked is with two preceding bytes, 377 and 0. Thus, the
program actually reads three bytes for one erroneous byte received from the terminal.
If a valid byte has the value 0377 , andISTRIP(see below) is not set, the program
might confuse it with the prefix that marks a parity error. So a valid byte 0377 is
passed to the program as two bytes,0377 0377, in this case.

tcflag_t ISTRIP [Macro]
If this bit is set, valid input bytes are stripped to seven bits; otherwise, all eight bits
are available for programs to read.

tcflag_t IGNBRK [Macro]
If this bit is set, break conditions are ignored.
Abreak conditionis defined in the context of asynchronous serial data transmission
as a series of zero-value bits longer than a single byte.

tcflag_t BRKINT [Macro]
If this bit is set andIGNBRKis not set, a break condition clears the terminal input and
output queues and raises aSIGINTsignal for the foreground process group associated
with the terminal.
If neitherBRKINTnorIGNBRKare set, a break condition is passed to the application as
a single'\0'character ifPARMRKis not set, or otherwise as a three-character sequence
'\377','\0','\0'.

tcflag_t IGNCR [Macro]
If this bit is set, carriage return characters ('\r') are discarded on input. Discarding
carriage return may be useful on terminals that send both carriage return and linefeed
when you type theRETkey.

tcflag_t ICRNL [Macro]
If this bit is set andIGNCRis not set, carriage return characters ('\r') received as
input are passed to the application as newline characters ('\n').

tcflag_t INLCR [Macro]
If this bit is set, newline characters ('\n') received as input are passed to the appli-
cation as carriage return characters ('\r').


Chapter 17: Low-Level Terminal Interface 510

tcflag_t IXOFF [Macro]
If this bit is set, start/stop control on input is enabled. In other words, the computer
sends STOP and START characters as necessary to prevent input from coming in
faster than programs are reading it. The idea is that the actual terminal hardware
that is generating the input data responds to a STOP character by suspending trans-
mission, and to a START character by resuming transmission. SeeSection 17.4.9.3
[Special Characters for Flow Control], page 519.

tcflag_t IXON [Macro]
If this bit is set, start/stop control on output is enabled. In other words, if the
computer receives a STOP character, it suspends output until a START character
is received. In this case, the STOP and START characters are never passed to the
application program. If this bit is not set, then START and STOP can be read
as ordinary characters. SeeSection 17.4.9.3 [Special Characters for Flow Control],
page 519.

tcflag_t IXANY [Macro]
If this bit is set, any input character restarts output when output has been suspended
with the STOP character. Otherwise, only the START character restarts output.
This is a BSD extension; it exists only on BSD systems and GNU/Linux and
GNU/Hurd systems.

tcflag_t IMAXBEL [Macro]
If this bit is set, then filling up the terminal input buffer sends a BEL character (code
007 ) to the terminal to ring the bell.
This is a BSD extension.

## 17.4.5 Output Modes.........................................

This section describes the terminal flags and fields that control how output characters are
translated and padded for display. All of these are contained in thec_oflagmember of the
struct termiosstructure.

Thec_oflagmember itself is an integer, and you change the flags and fields using the
operators&,|, and^. Don¡¯t try to specify the entire value forc_oflag¡ªinstead, change
only specific flags and leave the rest untouched (seeSection 17.4.3 [Setting Terminal Modes
Properly], page 507).

tcflag_t OPOST [Macro]
If this bit is set, output data is processed in some unspecified way so that it is dis-
played appropriately on the terminal device. This typically includes mapping newline
characters ('\n') onto carriage return and linefeed pairs.
If this bit isn¡¯t set, the characters are transmitted as-is.

```
The following three bits are effective only ifOPOSTis set.
```
tcflag_t ONLCR [Macro]
If this bit is set, convert the newline character on output into a pair of characters,
carriage return followed by linefeed.


Chapter 17: Low-Level Terminal Interface 511

tcflag_t OXTABS [Macro]
If this bit is set, convert tab characters on output into the appropriate number of
spaces to emulate a tab stop every eight columns. This bit exists only on BSD
systems and GNU/Hurd systems; on GNU/Linux systems it is available asXTABS.

tcflag_t ONOEOT [Macro]
If this bit is set, discardC-dcharacters (code 004 ) on output. These characters
cause many dial-up terminals to disconnect. This bit exists only on BSD systems and
GNU/Hurd systems.

## 17.4.6 Control Modes.........................................

This section describes the terminal flags and fields that control parameters usually associ-
ated with asynchronous serial data transmission. These flags may not make sense for other
kinds of terminal ports (such as a network connection pseudo-terminal). All of these are
contained in thec_cflagmember of thestruct termiosstructure.

Thec_cflagmember itself is an integer, and you change the flags and fields using the
operators&,|, and^. Don¡¯t try to specify the entire value forc_cflag¡ªinstead, change
only specific flags and leave the rest untouched (seeSection 17.4.3 [Setting Terminal Modes
Properly], page 507).

tcflag_t CLOCAL [Macro]
If this bit is set, it indicates that the terminal is connected ¡°locally¡± and that the
modem status lines (such as carrier detect) should be ignored.
On many systems if this bit is not set and you callopenwithout theO_NONBLOCKflag
set,openblocks until a modem connection is established.
If this bit is not set and a modem disconnect is detected, aSIGHUPsignal is sent to
the controlling process group for the terminal (if it has one). Normally, this causes
the process to exit; seeChapter 24 [Signal Handling], page 714. Reading from the
terminal after a disconnect causes an end-of-file condition, and writing causes anEIO
error to be returned. The terminal device must be closed and reopened to clear the
condition.

tcflag_t HUPCL [Macro]
If this bit is set, a modem disconnect is generated when all processes that have the
terminal device open have either closed the file or exited.

tcflag_t CREAD [Macro]
If this bit is set, input can be read from the terminal. Otherwise, input is discarded
when it arrives.

tcflag_t CSTOPB [Macro]
If this bit is set, two stop bits are used. Otherwise, only one stop bit is used.

tcflag_t PARENB [Macro]
If this bit is set, generation and detection of a parity bit are enabled. SeeSection 17.4.4
[Input Modes], page 508, for information on how input parity errors are handled.
If this bit is not set, no parity bit is added to output characters, and input characters
are not checked for correct parity.


Chapter 17: Low-Level Terminal Interface 512

tcflag_t PARODD [Macro]
This bit is only useful ifPARENBis set. IfPARODDis set, odd parity is used, otherwise
even parity is used.

The control mode flags also includes a field for the number of bits per character. You
can use theCSIZEmacro as a mask to extract the value, like this: settings.c_cflag &
CSIZE.

tcflag_t CSIZE [Macro]
This is a mask for the number of bits per character.

tcflag_t CS5 [Macro]
This specifies five bits per byte.

tcflag_t CS6 [Macro]
This specifies six bits per byte.

tcflag_t CS7 [Macro]
This specifies seven bits per byte.

tcflag_t CS8 [Macro]
This specifies eight bits per byte.

The following four bits are BSD extensions; these exist only on BSD systems and
GNU/Hurd systems.

tcflag_t CCTS_OFLOW [Macro]
If this bit is set, enable flow control of output based on the CTS wire (RS232 protocol).

tcflag_t CRTS_IFLOW [Macro]
If this bit is set, enable flow control of input based on the RTS wire (RS232 protocol).

tcflag_t MDMBUF [Macro]
If this bit is set, enable carrier-based flow control of output.

tcflag_t CIGNORE [Macro]
If this bit is set, it says to ignore the control modes and line speed values entirely.
This is only meaningful in a call totcsetattr.
The c_cflag member and the line speed values returned by cfgetispeed and
cfgetospeedwill be unaffected by the call.CIGNOREis useful if you want to set all
the software modes in the other members, but leave the hardware details inc_cflag
unchanged. (This is how theTCSASOFTflag totcsettattrworks.)
This bit is never set in the structure filled in bytcgetattr.

## 17.4.7 Local Modes...........................................

This section describes the flags for thec_lflagmember of thestruct termiosstructure.
These flags generally control higher-level aspects of input processing than the input modes
flags described inSection 17.4.4 [Input Modes], page 508, such as echoing, signals, and the
choice of canonical or noncanonical input.


Chapter 17: Low-Level Terminal Interface 513

Thec_lflagmember itself is an integer, and you change the flags and fields using the
operators&,|, and^. Don¡¯t try to specify the entire value forc_lflag¡ªinstead, change
only specific flags and leave the rest untouched (seeSection 17.4.3 [Setting Terminal Modes
Properly], page 507).

tcflag_t ICANON [Macro]
This bit, if set, enables canonical input processing mode. Otherwise, input is pro-
cessed in noncanonical mode. SeeSection 17.3 [Two Styles of Input: Canonical or
Not], page 504.

tcflag_t ECHO [Macro]
If this bit is set, echoing of input characters back to the terminal is enabled.

tcflag_t ECHOE [Macro]
If this bit is set, echoing indicates erasure of input with the ERASE character by
erasing the last character in the current line from the screen. Otherwise, the character
erased is re-echoed to show what has happened (suitable for a printing terminal).
This bit only controls the display behavior; theICANONbit by itself controls actual
recognition of the ERASE character and erasure of input, without whichECHOEis
simply irrelevant.

tcflag_t ECHOPRT [Macro]
This bit, likeECHOE, enables display of the ERASE character in a way that is geared to
a hardcopy terminal. When you type the ERASE character, a ¡®\¡¯ character is printed
followed by the first character erased. Typing the ERASE character again just prints
the next character erased. Then, the next time you type a normal character, a ¡®/¡¯
character is printed before the character echoes.
This is a BSD extension, and exists only in BSD systems and GNU/Linux and
GNU/Hurd systems.

tcflag_t ECHOK [Macro]
This bit enables special display of the KILL character by moving to a new line after
echoing the KILL character normally. The behavior ofECHOKE(below) is nicer to
look at.
If this bit is not set, the KILL character echoes just as it would if it were not the
KILL character. Then it is up to the user to remember that the KILL character has
erased the preceding input; there is no indication of this on the screen.
This bit only controls the display behavior; theICANONbit by itself controls actual
recognition of the KILL character and erasure of input, without whichECHOKis simply
irrelevant.

tcflag_t ECHOKE [Macro]
This bit is similar toECHOK. It enables special display of the KILL character by
erasing on the screen the entire line that has been killed. This is a BSD extension,
and exists only in BSD systems and GNU/Linux and GNU/Hurd systems.

tcflag_t ECHONL [Macro]
If this bit is set and theICANONbit is also set, then the newline ('\n') character is
echoed even if theECHObit is not set.


Chapter 17: Low-Level Terminal Interface 514

tcflag_t ECHOCTL [Macro]
If this bit is set and theECHObit is also set, echo control characters with ¡®^¡¯ followed
by the corresponding text character. Thus, control-A echoes as ¡®^A¡¯. This is usually
the preferred mode for interactive input, because echoing a control character back to
the terminal could have some undesired effect on the terminal.
This is a BSD extension, and exists only in BSD systems and GNU/Linux and
GNU/Hurd systems.

tcflag_t ISIG [Macro]
This bit controls whether the INTR, QUIT, and SUSP characters are recognized. The
functions associated with these characters are performed if and only if this bit is set.
Being in canonical or noncanonical input mode has no effect on the interpretation of
these characters.
You should use caution when disabling recognition of these characters. Programs that
cannot be interrupted interactively are very user-unfriendly. If you clear this bit, your
program should provide some alternate interface that allows the user to interactively
send the signals associated with these characters, or to escape from the program.
SeeSection 17.4.9.2 [Characters that Cause Signals], page 518.

tcflag_t IEXTEN [Macro]
POSIX.1 givesIEXTENimplementation-defined meaning, so you cannot rely on this
interpretation on all systems.
On BSD systems and GNU/Linux and GNU/Hurd systems, it enables the LNEXT
and DISCARD characters. SeeSection 17.4.9.4 [Other Special Characters], page 520.

tcflag_t NOFLSH [Macro]
Normally, the INTR, QUIT, and SUSP characters cause input and output queues for
the terminal to be cleared. If this bit is set, the queues are not cleared.

tcflag_t TOSTOP [Macro]
If this bit is set and the system supports job control, thenSIGTTOUsignals are gener-
ated by background processes that attempt to write to the terminal. SeeSection 28.3
[Access to the Controlling Terminal], page 818.

The following bits are BSD extensions; they exist only on BSD systems and GNU/Hurd
systems.

tcflag_t ALTWERASE [Macro]
This bit determines how far the WERASE character should erase. The WERASE
character erases back to the beginning of a word; the question is, where do words
begin?
If this bit is clear, then the beginning of a word is a nonwhitespace character fol-
lowing a whitespace character. If the bit is set, then the beginning of a word is an
alphanumeric character or underscore following a character which is none of those.
SeeSection 17.4.9.1 [Characters for Input Editing], page 517, for more information
about the WERASE character.


Chapter 17: Low-Level Terminal Interface 515

tcflag_t FLUSHO [Macro]
This is the bit that toggles when the user types the DISCARD character. While this
bit is set, all output is discarded. SeeSection 17.4.9.4 [Other Special Characters],
page 520.

tcflag_t NOKERNINFO [Macro]
Setting this bit disables handling of the STATUS character. SeeSection 17.4.9.4
[Other Special Characters], page 520.

tcflag_t PENDIN [Macro]
If this bit is set, it indicates that there is a line of input that needs to be reprinted.
Typing the REPRINT character sets this bit; the bit remains set until reprinting is
finished. SeeSection 17.4.9.1 [Characters for Input Editing], page 517.

## 17.4.8 Line Speed.............................................

The terminal line speed tells the computer how fast to read and write data on the terminal.

If the terminal is connected to a real serial line, the terminal speed you specify actually
controls the line¡ªif it doesn¡¯t match the terminal¡¯s own idea of the speed, communication
does not work. Real serial ports accept only certain standard speeds. Also, particular
hardware may not support even all the standard speeds. Specifying a speed of zero hangs
up a dialup connection and turns off modem control signals.

If the terminal is not a real serial line (for example, if it is a network connection), then
the line speed won¡¯t really affect data transmission speed, but some programs will use it to
determine the amount of padding needed. It¡¯s best to specify a line speed value that matches
the actual speed of the actual terminal, but you can safely experiment with different values
to vary the amount of padding.

There are actually two line speeds for each terminal, one for input and one for output.
You can set them independently, but most often terminals use the same speed for both
directions.

The speed values are stored in thestruct termiosstructure, but don¡¯t try to access
them in thestruct termiosstructure directly. Instead, you should use the following func-
tions to read and store them:

speed_t cfgetospeed (const struct termios *termios-p) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the output line speed stored in the structure*termios-p.

speed_t cfgetispeed (const struct termios *termios-p) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the input line speed stored in the structure*termios-p.

int cfsetospeed (struct termios *termios-p, speedtspeed) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 17: Low-Level Terminal Interface 516

```
This function storesspeed in*termios-pas the output speed. The normal return
value is 0; a value of?1 indicates an error. Ifspeed is not a speed,cfsetospeed
returns?1.
```
int cfsetispeed (struct termios *termios-p, speedtspeed) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function storesspeedin*termios-pas the input speed. The normal return
value is 0; a value of?1 indicates an error. Ifspeed is not a speed,cfsetospeed
returns?1.

int cfsetspeed(struct termios *termios-p, speed tspeed) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function storesspeedin*termios-pas both the input and output speeds. The
normal return value is 0; a value of?1 indicates an error. Ifspeedis not a speed,
cfsetspeedreturns?1. This function is an extension in 4.4 BSD.

speed_t [Data Type]
Thespeed_ttype is an unsigned integer data type used to represent line speeds.

The functionscfsetospeedandcfsetispeedreport errors only for speed values that
the system simply cannot handle. If you specify a speed value that is basically acceptable,
then those functions will succeed. But they do not check that a particular hardware device
can actually support the specified speeds¡ªin fact, they don¡¯t know which device you plan
to set the speed for. If you usetcsetattrto set the speed of a particular device to a value
that it cannot handle,tcsetattrreturns?1.

Portability note: In the GNU C Library, the functions above accept speeds measured
in bits per second as input, and return speed values measured in bits per second. Other
libraries require speeds to be indicated by special codes. For POSIX.1 portability, you must
use one of the following symbols to represent the speed; their precise numeric values are
system-dependent, but each name has a fixed meaning: B110stands for 110 bps,B300for
300 bps, and so on. There is no portable way to represent any speed but these, but these
are the only speeds that typical serial lines can support.
B0 B50 B75 B110 B134 B150 B200
B300 B600 B1200 B1800 B2400 B4800
B9600 B19200 B38400 B57600 B115200
B230400 B460800
BSD defines two additional speed symbols as aliases: EXTAis an alias forB19200and
EXTBis an alias forB38400. These aliases are obsolete.

## 17.4.9 Special Characters......................................

In canonical input, the terminal driver recognizes a number of special characters which
perform various control functions. These include the ERASE character (usuallyDEL) for
editing input, and other editing characters. The INTR character (normallyC-c) for sending
aSIGINTsignal, and other signal-raising characters, may be available in either canonical or
noncanonical input mode. All these characters are described in this section.


Chapter 17: Low-Level Terminal Interface 517

The particular characters used are specified in thec_ccmember of thestruct termios
structure. This member is an array; each element specifies the character for a particular
role. Each element has a symbolic constant that stands for the index of that element¡ªfor
example,VINTRis the index of the element that specifies the INTR character, so storing
'='intermios.c_cc[VINTR]specifies ¡®=¡¯ as the INTR character.

On some systems, you can disable a particular special character function by specifying
the value_POSIX_VDISABLEfor that role. This value is unequal to any possible character
code. SeeSection 32.7 [Optional Features in File Support], page 904, for more information
about how to tell whether the operating system you are using supports_POSIX_VDISABLE.

## 17.4.9.1 Characters for Input Editing.......................

These special characters are active only in canonical input mode. SeeSection 17.3 [Two
Styles of Input: Canonical or Not], page 504.

int VEOF [Macro]
This is the subscript for the EOF character in the special control character array.
termios.c_cc[VEOF]holds the character itself.
The EOF character is recognized only in canonical input mode. It acts as a line
terminator in the same way as a newline character, but if the EOF character is typed
at the beginning of a line it causesreadto return a byte count of zero, indicating
end-of-file. The EOF character itself is discarded.
Usually, the EOF character isC-d.

int VEOL [Macro]
This is the subscript for the EOL character in the special control character array.
termios.c_cc[VEOL]holds the character itself.
The EOL character is recognized only in canonical input mode. It acts as a line
terminator, just like a newline character. The EOL character is not discarded; it is
read as the last character in the input line.
You don¡¯t need to use the EOL character to makeRETend a line. Just set the ICRNL
flag. In fact, this is the default state of affairs.

int VEOL2 [Macro]
This is the subscript for the EOL2 character in the special control character array.
termios.c_cc[VEOL2]holds the character itself.
The EOL2 character works just like the EOL character (see above), but it can be a
different character. Thus, you can specify two characters to terminate an input line,
by setting EOL to one of them and EOL2 to the other.
The EOL2 character is a BSD extension; it exists only on BSD systems and
GNU/Linux and GNU/Hurd systems.

int VERASE [Macro]
This is the subscript for the ERASE character in the special control character array.
termios.c_cc[VERASE]holds the character itself.
The ERASE character is recognized only in canonical input mode. When the user
types the erase character, the previous character typed is discarded. (If the terminal


Chapter 17: Low-Level Terminal Interface 518

```
generates multibyte character sequences, this may cause more than one byte of input
to be discarded.) This cannot be used to erase past the beginning of the current line
of text. The ERASE character itself is discarded.
Usually, the ERASE character isDEL.
```
int VWERASE [Macro]
This is the subscript for the WERASE character in the special control character array.
termios.c_cc[VWERASE]holds the character itself.
The WERASE character is recognized only in canonical mode. It erases an entire
word of prior input, and any whitespace after it; whitespace characters before the
word are not erased.
The definition of a ¡°word¡± depends on the setting of theALTWERASEmode; see
Section 17.4.7 [Local Modes], page 512.
If theALTWERASEmode is not set, a word is defined as a sequence of any characters
except space or tab.
If theALTWERASEmode is set, a word is defined as a sequence of characters containing
only letters, numbers, and underscores, optionally followed by one character that is
not a letter, number, or underscore.
The WERASE character is usuallyC-w.
This is a BSD extension.

int VKILL [Macro]
This is the subscript for the KILL character in the special control character array.
termios.c_cc[VKILL]holds the character itself.
The KILL character is recognized only in canonical input mode. When the user types
the kill character, the entire contents of the current line of input are discarded. The
kill character itself is discarded too.
The KILL character is usuallyC-u.

int VREPRINT [Macro]
This is the subscript for the REPRINT character in the special control character
array.termios.c_cc[VREPRINT]holds the character itself.
The REPRINT character is recognized only in canonical mode. It reprints the current
input line. If some asynchronous output has come while you are typing, this lets you
see the line you are typing clearly again.
The REPRINT character is usuallyC-r.
This is a BSD extension.

## 17.4.9.2 Characters that Cause Signals.....................

These special characters may be active in either canonical or noncanonical input mode, but
only when theISIGflag is set (seeSection 17.4.7 [Local Modes], page 512).

int VINTR [Macro]
This is the subscript for the INTR character in the special control character array.
termios.c_cc[VINTR]holds the character itself.


Chapter 17: Low-Level Terminal Interface 519

```
The INTR (interrupt) character raises aSIGINTsignal for all processes in the fore-
ground job associated with the terminal. The INTR character itself is then discarded.
SeeChapter 24 [Signal Handling], page 714, for more information about signals.
Typically, the INTR character isC-c.
```
int VQUIT [Macro]
This is the subscript for the QUIT character in the special control character array.
termios.c_cc[VQUIT]holds the character itself.
The QUIT character raises aSIGQUITsignal for all processes in the foreground job
associated with the terminal. The QUIT character itself is then discarded. See
Chapter 24 [Signal Handling], page 714, for more information about signals.
Typically, the QUIT character isC-\.

int VSUSP [Macro]
This is the subscript for the SUSP character in the special control character array.
termios.c_cc[VSUSP]holds the character itself.
The SUSP (suspend) character is recognized only if the implementation supports job
control (seeChapter 28 [Job Control], page 817). It causes aSIGTSTPsignal to be
sent to all processes in the foreground job associated with the terminal. The SUSP
character itself is then discarded. SeeChapter 24 [Signal Handling], page 714, for
more information about signals.
Typically, the SUSP character isC-z.

Few applications disable the normal interpretation of the SUSP character. If your pro-
gram does this, it should provide some other mechanism for the user to stop the job. When
the user invokes this mechanism, the program should send aSIGTSTPsignal to the process
group of the process, not just to the process itself. SeeSection 24.6.2 [Signaling Another
Process], page 743.

int VDSUSP [Macro]
This is the subscript for the DSUSP character in the special control character array.
termios.c_cc[VDSUSP]holds the character itself.
The DSUSP (suspend) character is recognized only if the implementation supports
job control (seeChapter 28 [Job Control], page 817). It sends aSIGTSTPsignal,
like the SUSP character, but not right away¡ªonly when the program tries to read
it as input. Not all systems with job control support DSUSP; only BSD-compatible
systems do (including GNU/Hurd systems).
SeeChapter 24 [Signal Handling], page 714, for more information about signals.
Typically, the DSUSP character isC-y.

## 17.4.9.3 Special Characters for Flow Control................

These special characters may be active in either canonical or noncanonical input mode,
but their use is controlled by the flagsIXONandIXOFF(seeSection 17.4.4 [Input Modes],
page 508).


Chapter 17: Low-Level Terminal Interface 520

int VSTART [Macro]
This is the subscript for the START character in the special control character array.
termios.c_cc[VSTART]holds the character itself.
The START character is used to support theIXONandIXOFFinput modes. IfIXONis
set, receiving a START character resumes suspended output; the START character
itself is discarded. IfIXANYis set, receiving any character at all resumes suspended
output; the resuming character is not discarded unless it is the START character. If
IXOFFis set, the system may also transmit START characters to the terminal.
The usual value for the START character isC-q. You may not be able to change this
value¡ªthe hardware may insist on usingC-qregardless of what you specify.

int VSTOP [Macro]
This is the subscript for the STOP character in the special control character array.
termios.c_cc[VSTOP]holds the character itself.
The STOP character is used to support theIXONandIXOFFinput modes. IfIXONis
set, receiving a STOP character causes output to be suspended; the STOP character
itself is discarded. IfIXOFFis set, the system may also transmit STOP characters to
the terminal, to prevent the input queue from overflowing.
The usual value for the STOP character isC-s. You may not be able to change this
value¡ªthe hardware may insist on usingC-sregardless of what you specify.

## 17.4.9.4 Other Special Characters..........................

int VLNEXT [Macro]
This is the subscript for the LNEXT character in the special control character array.
termios.c_cc[VLNEXT]holds the character itself.
The LNEXT character is recognized only whenIEXTENis set, but in both canonical
and noncanonical mode. It disables any special significance of the next character the
user types. Even if the character would normally perform some editing function or
generate a signal, it is read as a plain character. This is the analogue of theC-q
command in Emacs. ¡°LNEXT¡± stands for ¡°literal next.¡±
The LNEXT character is usuallyC-v.
This character is available on BSD systems and GNU/Linux and GNU/Hurd systems.

int VDISCARD [Macro]
This is the subscript for the DISCARD character in the special control character
array.termios.c_cc[VDISCARD]holds the character itself.
The DISCARD character is recognized only whenIEXTENis set, but in both canonical
and noncanonical mode. Its effect is to toggle the discard-output flag. When this flag
is set, all program output is discarded. Setting the flag also discards all output
currently in the output buffer. Typing any other character resets the flag.
This character is available on BSD systems and GNU/Linux and GNU/Hurd systems.

int VSTATUS [Macro]
This is the subscript for the STATUS character in the special control character array.
termios.c_cc[VSTATUS]holds the character itself.


Chapter 17: Low-Level Terminal Interface 521

```
The STATUS character¡¯s effect is to print out a status message about how the current
process is running.
The STATUS character is recognized only in canonical mode, and only ifNOKERNINFO
is not set.
This character is available only on BSD systems and GNU/Hurd systems.
```
## 17.4.10 Noncanonical Input...................................

In noncanonical input mode, the special editing characters such as ERASE and KILL are
ignored. The system facilities for the user to edit input are disabled in noncanonical mode,
so that all input characters (unless they are special for signal or flow-control purposes) are
passed to the application program exactly as typed. It is up to the application program to
give the user ways to edit the input, if appropriate.

Noncanonical mode offers special parameters called MIN and TIME for controlling
whether and how long to wait for input to be available. You can even use them to avoid
ever waiting¡ªto return immediately with whatever input is available, or with no input.

The MIN and TIME are stored in elements of thec_ccarray, which is a member of
thestruct termiosstructure. Each element of this array has a particular role, and each
element has a symbolic constant that stands for the index of that element.VMINandVTIME
are the names for the indices in the array of the MIN and TIME slots.

int VMIN [Macro]
This is the subscript for the MIN slot in thec_ccarray. Thus,termios.c_cc[VMIN]
is the value itself.
The MIN slot is only meaningful in noncanonical input mode; it specifies the minimum
number of bytes that must be available in the input queue in order forreadto return.

int VTIME [Macro]
This is the subscript for the TIME slot in the c_ccarray. Thus, termios.c_
cc[VTIME]is the value itself.
The TIME slot is only meaningful in noncanonical input mode; it specifies how long
to wait for input before returning, in units of 0.1 seconds.

The MIN and TIME values interact to determine the criterion for whenreadshould
return; their precise meanings depend on which of them are nonzero. There are four possible
cases:

- Both TIME and MIN are nonzero.
    In this case, TIME specifies how long to wait after each input character to see if more
    input arrives. After the first character received,readkeeps waiting until either MIN
    bytes have arrived in all, or TIME elapses with no further input.
    readalways blocks until the first character arrives, even if TIME elapses first. read
    can return more than MIN characters if more than MIN happen to be in the queue.
- Both MIN and TIME are zero.
    In this case,readalways returns immediately with as many characters as are available
    in the queue, up to the number requested. If no input is immediately available,read
    returns a value of zero.


Chapter 17: Low-Level Terminal Interface 522

- MIN is zero but TIME has a nonzero value.
    In this case,readwaits for time TIME for input to become available; the availability
    of a single byte is enough to satisfy the read request and causereadto return. When
    it returns, it returns as many characters as are available, up to the number requested.
    If no input is available before the timer expires,readreturns a value of zero.
- TIME is zero but MIN has a nonzero value.
    In this case,readwaits until at least MIN bytes are available in the queue. At that
    time,readreturns as many characters as are available, up to the number requested.
    readcan return more than MIN characters if more than MIN happen to be in the
    queue.

What happens if MIN is 50 and you ask to read just 10 bytes? Normally,readwaits until
there are 50 bytes in the buffer (or, more generally, the wait condition described above is
satisfied), and then reads 10 of them, leaving the other 40 buffered in the operating system
for a subsequent call toread.

Portability note:On some systems, the MIN and TIME slots are actually the same as
the EOF and EOL slots. This causes no serious problem because the MIN and TIME slots
are used only in noncanonical input and the EOF and EOL slots are used only in canonical
input, but it isn¡¯t very clean. The GNU C Library allocates separate slots for these uses.

void cfmakeraw(struct termios *termios-p) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function provides an easy way to set up*termios-pfor what has traditionally
been called ¡°raw mode¡± in BSD. This uses noncanonical input, and turns off most
processing to give an unmodified channel to the terminal.
It does exactly this:
termios-p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
|INLCR|IGNCR|ICRNL|IXON);
termios-p->c_oflag &= ~OPOST;
termios-p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
termios-p->c_cflag &= ~(CSIZE|PARENB);
termios-p->c_cflag |= CS8;

## 17.5 BSD Terminal Modes.......................................

The usual way to get and set terminal modes is with the functions described inSection 17.4
[Terminal Modes], page 505. However, on some systems you can use the BSD-derived
functions in this section to do some of the same things. On many systems, these functions
do not exist. Even with the GNU C Library, the functions simply fail witherrno=ENOSYS
with many kernels, including Linux.

```
The symbols used in this section are declared insgtty.h.
```
struct sgttyb [Data Type]
This structure is an input or output parameter list forgttyandstty.

```
char sg_ispeed
Line speed for input
```

Chapter 17: Low-Level Terminal Interface 523

```
char sg_ospeed
Line speed for output
char sg_erase
Erase character
char sg_kill
Kill character
```
```
int sg_flags
Various flags
```
int gtty (intfiledes, struct sgttyb *attributes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function gets the attributes of a terminal.
gttysets *attributesto describe the terminal attributes of the terminal which is open
with file descriptorfiledes.

int stty (intfiledes, const struct sgttyb *attributes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function sets the attributes of a terminal.
sttysets the terminal attributes of the terminal which is open with file descriptor
filedesto those described by *attributes.

## 17.6 Line Control Functions......................................

These functions perform miscellaneous control actions on terminal devices. As regards
terminal access, they are treated like doing output: if any of these functions is used by
a background process on its controlling terminal, normally all processes in the process
group are sent aSIGTTOUsignal. The exception is if the calling process itself is ignoring or
blockingSIGTTOUsignals, in which case the operation is performed and no signal is sent.
SeeChapter 28 [Job Control], page 817.

int tcsendbreak (intfiledes, intduration) [Function]
Preliminary: |MT-Unsafe race:tcattr(filedes)/bsd|AS-Unsafe |AC-Unsafe cor-
rupt/bsd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function generates a break condition by transmitting a stream of zero bits on
the terminal associated with the file descriptorfiledes. The duration of the break is
controlled by thedurationargument. If zero, the duration is between 0.25 and 0.5
seconds. The meaning of a nonzero value depends on the operating system.
This function does nothing if the terminal is not an asynchronous serial data port.
The return value is normally zero. In the event of an error, a value of?1 is returned.
The followingerrnoerror conditions are defined for this function:
EBADF Thefiledesis not a valid file descriptor.

```
ENOTTY Thefiledesis not associated with a terminal device.
```

Chapter 17: Low-Level Terminal Interface 524

int tcdrain(intfiledes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thetcdrainfunction waits until all queued output to the terminalfiledeshas been
transmitted.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timetcdrainis called. If the thread gets canceled these resources
stay allocated until the program ends. To avoid this calls totcdrain should be
protected using cancellation handlers.
The return value is normally zero. In the event of an error, a value of?1 is returned.
The followingerrnoerror conditions are defined for this function:

```
EBADF Thefiledesis not a valid file descriptor.
```
```
ENOTTY Thefiledesis not associated with a terminal device.
```
```
EINTR The operation was interrupted by delivery of a signal. SeeSection 24.5
[Primitives Interrupted by Signals], page 741.
```
int tcflush(intfiledes, intqueue) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thetcflushfunction is used to clear the input and/or output queues associated with
the terminal filefiledes. Thequeueargument specifies which queue(s) to clear, and
can be one of the following values:

```
TCIFLUSH
Clear any input data received, but not yet read.
```
```
TCOFLUSH
Clear any output data written, but not yet transmitted.
```
```
TCIOFLUSH
Clear both queued input and output.
```
```
The return value is normally zero. In the event of an error, a value of?1 is returned.
The followingerrnoerror conditions are defined for this function:
```
```
EBADF Thefiledesis not a valid file descriptor.
```
```
ENOTTY Thefiledesis not associated with a terminal device.
```
```
EINVAL A bad value was supplied as thequeueargument.
```
```
It is unfortunate that this function is namedtcflush, because the term ¡°flush¡± is
normally used for quite another operation¡ªwaiting until all output is transmitted¡ª
and using it for discarding input or output would be confusing. Unfortunately, the
nametcflushcomes from POSIX and we cannot change it.
```

Chapter 17: Low-Level Terminal Interface 525

int tcflow(intfiledes, intaction) [Function]
Preliminary: |MT-Unsafe race:tcattr(filedes)/bsd|AS-Unsafe |AC-Safe |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thetcflow function is used to perform operations relating to XON/XOFF flow
control on the terminal file specified byfiledes.
Theactionargument specifies what operation to perform, and can be one of the
following values:
TCOOFF Suspend transmission of output.
TCOON Restart transmission of output.
TCIOFF Transmit a STOP character.
TCION Transmit a START character.
For more information about the STOP and START characters, seeSection 17.4.9
[Special Characters], page 516.
The return value is normally zero. In the event of an error, a value of?1 is returned.
The followingerrnoerror conditions are defined for this function:
EBADF Thefiledesis not a valid file descriptor.
ENOTTY Thefiledesis not associated with a terminal device.
EINVAL A bad value was supplied as theactionargument.

## 17.7 Noncanonical Mode Example................................

Here is an example program that shows how you can set up a terminal device to read single
characters in noncanonical input mode, without echo.

```
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
```
```
/*Use this variable to remember original terminal attributes.*/
```
```
struct termios saved_attributes;
```
```
void
reset_input_mode (void)
{
tcsetattr (STDIN_FILENO, TCSANOW, &saved_attributes);
}
```
```
void
set_input_mode (void)
{
struct termios tattr;
char *name;
```
```
/*Make sure stdin is a terminal.*/
if (!isatty (STDIN_FILENO))
{
```

Chapter 17: Low-Level Terminal Interface 526

```
fprintf (stderr, "Not a terminal.\n");
exit (EXIT_FAILURE);
}
```
```
/*Save the terminal attributes so we can restore them later.*/
tcgetattr (STDIN_FILENO, &saved_attributes);
atexit (reset_input_mode);
```
```
/*Set the funny terminal modes.*/
tcgetattr (STDIN_FILENO, &tattr);
tattr.c_lflag &= ~(ICANON|ECHO); /*Clear ICANON and ECHO.*/
tattr.c_cc[VMIN] = 1;
tattr.c_cc[VTIME] = 0;
tcsetattr (STDIN_FILENO, TCSAFLUSH, &tattr);
}
```
```
int
main (void)
{
char c;
```
```
set_input_mode ();
```
```
while (1)
{
read (STDIN_FILENO, &c, 1);
if (c == '\004') /*C-d*/
break;
else
putchar (c);
}
```
return EXIT_SUCCESS;
}
This program is careful to restore the original terminal modes before exiting or termi-
nating with a signal. It uses theatexitfunction (seeSection 25.7.3 [Cleanups on Exit],
page 800) to make sure this is done byexit.

The shell is supposed to take care of resetting the terminal modes when a process is
stopped or continued; seeChapter 28 [Job Control], page 817. But some existing shells do
not actually do this, so you may wish to establish handlers for job control signals that reset
terminal modes. The above example does so.

## 17.8 Reading Passphrases........................................

When reading in a passphrase, it is desirable to avoid displaying it on the screen, to help
keep it secret. The following function handles this in a convenient way.

char * getpass(const char *prompt) [Function]
Preliminary: |MT-Unsafe term|AS-Unsafe heap lock corrupt|AC-Unsafe term
lock corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
getpassoutputsprompt, then reads a string in from the terminal without echoing it.
It tries to connect to the real terminal,/dev/tty, if possible, to encourage users not
to put plaintext passphrases in files; otherwise, it usesstdinandstderr. getpass
also disables the INTR, QUIT, and SUSP characters on the terminal using theISIG


Chapter 17: Low-Level Terminal Interface 527

```
terminal attribute (seeSection 17.4.7 [Local Modes], page 512). The terminal is
flushed before and aftergetpass, so that characters of a mistyped passphrase are not
accidentally visible.
```
```
In other C libraries,getpassmay only return the firstPASS_MAXbytes of a passphrase.
The GNU C Library has no limit, soPASS_MAXis undefined.
```
```
The prototype for this function is in unistd.h. PASS_MAXwould be defined in
limits.h.
```
This precise set of operations may not suit all possible situations. In this case, it is
recommended that users write their owngetpasssubstitute. For instance, a very simple
substitute is as follows:

```
#include <termios.h>
#include <stdio.h>
```
```
ssize_t
my_getpass (char **lineptr, size_t *n, FILE *stream)
{
struct termios old, new;
int nread;
```
```
/*Turn echoing off and fail if we can¡¯t.*/
if (tcgetattr (fileno (stream), &old) != 0)
return -1;
new = old;
new.c_lflag &= ~ECHO;
if (tcsetattr (fileno (stream), TCSAFLUSH, &new) != 0)
return -1;
```
```
/*Read the passphrase*/
nread = getline (lineptr, n, stream);
```
```
/*Restore terminal.*/
(void) tcsetattr (fileno (stream), TCSAFLUSH, &old);
```
```
return nread;
}
```
The substitute takes the same parameters asgetline(seeSection 12.9 [Line-Oriented
Input], page 283); the user must print any prompt desired.

## 17.9 Pseudo-Terminals...........................................

Apseudo-terminalis a special interprocess communication channel that acts like a terminal.
One end of the channel is called themasterside ormaster pseudo-terminal device, the other
side is called theslaveside. Data written to the master side is received by the slave side as
if it was the result of a user typing at an ordinary terminal, and data written to the slave
side is sent to the master side as if it was written on an ordinary terminal.

Pseudo terminals are the way programs likextermandemacsimplement their terminal
emulation functionality.


Chapter 17: Low-Level Terminal Interface 528

## 17.9.1 Allocating Pseudo-Terminals...........................

This subsection describes functions for allocating a pseudo-terminal, and for making this
pseudo-terminal available for actual use. These functions are declared in the header file
stdlib.h.

int getpt (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetptfunction returns a new file descriptor for the next available master pseudo-
terminal. The normal return value fromgetptis a non-negative integer file descriptor.
In the case of an error, a value of?1 is returned instead. The followingerrno
conditions are defined for this function:

```
ENOENT There are no free master pseudo-terminals available.
This function is a GNU extension.
```
int grantpt(intfiledes) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegrantpt function changes the ownership and access permission of the slave
pseudo-terminal device corresponding to the master pseudo-terminal device associ-
ated with the file descriptorfiledes. The owner is set from the real user ID of the
calling process (seeSection 30.2 [The Persona of a Process], page 845), and the group
is set to a special group (typicallytty) or from the real group ID of the calling process.
The access permission is set such that the file is both readable and writable by the
owner and only writable by the group.
On some systems this function is implemented by invoking a specialsetuidroot
program (seeSection 30.4 [How an Application Can Change Persona], page 846). As
a consequence, installing a signal handler for theSIGCHLDsignal (seeSection 24.2.5
[Job Control Signals], page 721) may interfere with a call tograntpt.
The normal return value fromgrantptis 0; a value of?1 is returned in case of failure.
The followingerrnoerror conditions are defined for this function:
EBADF Thefiledesargument is not a valid file descriptor.

```
EINVAL Thefiledes argument is not associated with a master pseudo-terminal
device.
EACCES The slave pseudo-terminal device corresponding to the master associated
withfiledescould not be accessed.
```
int unlockpt (intfiledes) [Function]
Preliminary: | MT-Safe | AS-Unsafe heap/bsd | AC-Unsafe mem fd | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theunlockptfunction unlocks the slave pseudo-terminal device corresponding to the
master pseudo-terminal device associated with the file descriptorfiledes. On many
systems, the slave can only be opened after unlocking, so portable applications should
always callunlockptbefore trying to open the slave.


Chapter 17: Low-Level Terminal Interface 529

```
The normal return value fromunlockptis 0; a value of?1 is returned in case of
failure. The followingerrnoerror conditions are defined for this function:
EBADF Thefiledesargument is not a valid file descriptor.
EINVAL Thefiledes argument is not associated with a master pseudo-terminal
device.
```
char * ptsname(intfiledes) [Function]
Preliminary: |MT-Unsafe race:ptsname|AS-Unsafe heap/bsd|AC-Unsafe mem
fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
If the file descriptorfiledesis associated with a master pseudo-terminal device, the
ptsnamefunction returns a pointer to a statically-allocated, null-terminated string
containing the file name of the associated slave pseudo-terminal file. This string
might be overwritten by subsequent calls toptsname.

int ptsname_r(intfiledes, char *buf, sizetlen) [Function]
Preliminary: | MT-Safe | AS-Unsafe heap/bsd | AC-Unsafe mem fd | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theptsname_rfunction is similar to theptsnamefunction except that it places its
result into the user-specified buffer starting atbuf with lengthlen.
This function is a GNU extension.

```
Typical usage of these functions is illustrated by the following example:
int
open_pty_pair (int *amaster, int *aslave)
{
int master, slave;
char *name;
```
```
master = getpt ();
if (master < 0)
return 0;
```
```
if (grantpt (master) < 0 || unlockpt (master) < 0)
goto close_master;
name = ptsname (master);
if (name == NULL)
goto close_master;
```
```
slave = open (name, O_RDWR);
if (slave == -1)
goto close_master;
```
```
*amaster = master;
*aslave = slave;
return 1;
```
```
close_slave:
close (slave);
```
```
close_master:
close (master);
return 0;
}
```

Chapter 17: Low-Level Terminal Interface 530

## 17.9.2 Opening a Pseudo-Terminal Pair.......................

These functions, derived from BSD, are available in the separatelibutil library, and
declared inpty.h.

int openpty(int *amaster, int *aslave, char *name, const struct [Function]
termios *termp, const struct winsize *winp)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function allocates and opens a pseudo-terminal pair, returning the file descriptor
for the master in*amaster, and the file descriptor for the slave in*aslave. If the
argumentnameis not a null pointer, the file name of the slave pseudo-terminal device
is stored in*name. Iftermpis not a null pointer, the terminal attributes of the slave
are set to the ones specified in the structure thattermppoints to (seeSection 17.4
[Terminal Modes], page 505). Likewise, ifwinpis not a null pointer, the screen size
of the slave is set to the values specified in the structure thatwinppoints to.
The normal return value fromopenptyis 0; a value of?1 is returned in case of failure.
The followingerrnoconditions are defined for this function:
ENOENT There are no free pseudo-terminal pairs available.
Warning:Using theopenptyfunction withnamenot set toNULLisvery dangerous
because it provides no protection against overflowing the stringname. You should
use thettynamefunction on the file descriptor returned in*slaveto find out the file
name of the slave pseudo-terminal device instead.

int forkpty(int *amaster, char *name, const struct termios [Function]
*termp, const struct winsize *winp)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar to theopenptyfunction, but in addition, forks a new pro-
cess (seeSection 26.4 [Creating a Process], page 805) and makes the newly opened
slave pseudo-terminal device the controlling terminal (seeSection 28.2 [Controlling
Terminal of a Process], page 818) for the child process.
If the operation is successful, there are then both parent and child processes and both
seeforkptyreturn, but with different values: it returns a value of 0 in the child
process and returns the child¡¯s process ID in the parent process.
If the allocation of a pseudo-terminal pair or the process creation failed,forkpty
returns a value of?1 in the parent process.
Warning: Theforkptyfunction has the same problems with respect to thename
argument asopenpty.


### 531

## 18 Syslog........................................

## 18 Syslog.............................................

This chapter describes facilities for issuing and logging messages of system administration
interest. This chapter has nothing to do with programs issuing messages to their own
users or keeping private logs (One would typically do that with the facilities described in
Chapter 12 [Input/Output on Streams], page 266).

Most systems have a facility called ¡°Syslog¡± that allows programs to submit messages
of interest to system administrators and can be configured to pass these messages on in
various ways, such as printing on the console, mailing to a particular person, or recording
in a log file for future reference.

```
A program uses the facilities in this chapter to submit such messages.
```
## 18.1 Overview of Syslog..........................................

System administrators have to deal with lots of different kinds of messages from a plethora
of subsystems within each system, and usually lots of systems as well. For example, an FTP
server might report every connection it gets. The kernel might report hardware failures on
a disk drive. A DNS server might report usage statistics at regular intervals.

Some of these messages need to be brought to a system administrator¡¯s attention im-
mediately. And it may not be just any system administrator ¨C there may be a particular
system administrator who deals with a particular kind of message. Other messages just
need to be recorded for future reference if there is a problem. Still others may need to have
information extracted from them by an automated process that generates monthly reports.

To deal with these messages, most Unix systems have a facility called"Syslog."It is
generally based on a daemon called ¡°Syslogd¡± Syslogd listens for messages on a Unix do-
main socket named/dev/log. Based on classification information in the messages and its
configuration file (usually/etc/syslog.conf), Syslogd routes them in various ways. Some
of the popular routings are:

- Write to the system console
- Mail to a specific user
- Write to a log file
- Pass to another daemon
- Discard

Syslogd can also handle messages from other systems. It listens on thesyslogUDP
port as well as the local socket for messages.

Syslog can handle messages from the kernel itself. But the kernel doesn¡¯t write to
/dev/log; rather, another daemon (sometimes called ¡°Klogd¡±) extracts messages from the
kernel and passes them on to Syslog as any other process would (and it properly identifies
them as messages from the kernel).

Syslog can even handle messages that the kernel issued before Syslogd or Klogd was
running. A Linux kernel, for example, stores startup messages in a kernel message ring and
they are normally still there when Klogd later starts up. Assuming Syslogd is running by
the time Klogd starts, Klogd then passes everything in the message ring to it.


Chapter 18: Syslog 532

In order to classify messages for disposition, Syslog requires any process that submits a
message to it to provide two pieces of classification information with it:

facility This identifies who submitted the message. There are a small number of facili-
ties defined. The kernel, the mail subsystem, and an FTP server are examples
of recognized facilities. For the complete list, SeeSection 18.2.2 [syslog, vsys-
log], page 534. Keep in mind that these are essentially arbitrary classifications.
"Mail subsystem"doesn¡¯t have any more meaning than the system administra-
tor gives to it.

priority This tells how important the content of the message is. Examples of defined
priority values are: debug, informational, warning and critical. For the complete
list, seeSection 18.2.2 [syslog, vsyslog], page 534. Except for the fact that the
priorities have a defined order, the meaning of each of these priorities is entirely
determined by the system administrator.
A ¡°facility/priority¡± is a number that indicates both the facility and the priority.
Warning: This terminology is not universal. Some people use ¡°level¡± to refer to the
priority and ¡°priority¡± to refer to the combination of facility and priority. A Linux kernel
has a concept of a message ¡°level,¡± which corresponds both to a Syslog priority and to a
Syslog facility/priority (It can be both because the facility code for the kernel is zero, and
that makes priority and facility/priority the same value).

The GNU C Library provides functions to submit messages to Syslog. They do it by
writing to the/dev/logsocket. SeeSection 18.2 [Submitting Syslog Messages], page 532.

The GNU C Library functions only work to submit messages to the Syslog facility on
the same system. To submit a message to the Syslog facility on another system, use the
socket I/O functions to write a UDP datagram to thesyslogUDP port on that system.
SeeChapter 16 [Sockets], page 455.

## 18.2 Submitting Syslog Messages.................................

The GNU C Library provides functions to submit messages to the Syslog facility:

These functions only work to submit messages to the Syslog facility on the same system.
To submit a message to the Syslog facility on another system, use the socket I/O functions to
write a UDP datagram to thesyslogUDP port on that system. SeeChapter 16 [Sockets],
page 455.

## 18.2.1 openlog................................................

The symbols referred to in this section are declared in the filesyslog.h.

void openlog (const char *ident, intoption, intfacility) [Function]
Preliminary:|MT-Safe |AS-Unsafe lock|AC-Unsafe lock fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
openlogopens or reopens a connection to Syslog in preparation for submitting mes-
sages.
identis an arbitrary identification string which futuresysloginvocations will prefix
to each message. This is intended to identify the source of the message, and people
conventionally set it to the name of the program that will submit the messages.


Chapter 18: Syslog 533

```
Ifidentis NULL, or ifopenlogis not called, the default identification string used in
Syslog messages will be the program name, taken from argv[0].
Please note that the string pointeridentwill be retained internally by the Syslog
routines. You must not free the memory thatidentpoints to. It is also dangerous to
pass a reference to an automatic variable since leaving the scope would mean ending
the lifetime of the variable. If you want to change theidentstring, you must call
openlogagain; overwriting the string pointed to byidentis not thread-safe.
You can cause the Syslog routines to drop the reference toident and go back to
the default string (the program name taken from argv[0]), by callingcloselog: See
Section 18.2.3 [closelog], page 536.
In particular, if you are writing code for a shared library that might get loaded and
then unloaded (e.g. a PAM module), and you useopenlog, you must callcloselog
before any point where your library might get unloaded, as in this example:
#include <syslog.h>
```
```
void
shared_library_function (void)
{
openlog ("mylibrary", option, priority);
```
```
syslog (LOG_INFO, "shared library has been invoked");
```
```
closelog ();
}
Without the call tocloselog, future invocations ofsyslogby the program using
the shared library may crash, if the library gets unloaded and the memory containing
the string"mylibrary"becomes unmapped. This is a limitation of the BSD syslog
interface.
openlogmay or may not open the/dev/logsocket, depending onoption. If it does,
it tries to open it and connect it as a stream socket. If that doesn¡¯t work, it tries to
open it and connect it as a datagram socket. The socket has the ¡°Close on Exec¡±
attribute, so the kernel will close it if the process performs an exec.
You don¡¯t have to useopenlog. If you callsyslogwithout having calledopenlog,
syslogjust opens the connection implicitly and uses defaults for the information in
identandoptions.
optionsis a bit string, with the bits as defined by the following single bit masks:
```
```
LOG_PERROR
If on,openlogsets up the connection so that anysyslogon this con-
nection writes its message to the calling process¡¯ Standard Error stream
in addition to submitting it to Syslog. If off,syslogdoes not write the
message to Standard Error.
```
```
LOG_CONS If on,openlogsets up the connection so that asyslogon this connection
that fails to submit a message to Syslog writes the message instead to
system console. If off,syslogdoes not write to the system console (but
of course Syslog may write messages it receives to the console).
```

Chapter 18: Syslog 534

```
LOG_PID When on,openlogsets up the connection so that asyslogon this con-
nection inserts the calling process¡¯ Process ID (PID) into the message.
When off,openlogdoes not insert the PID.
```
```
LOG_NDELAY
When on,openlogopens and connects the/dev/logsocket. When off,
a futuresyslogcall must open and connect the socket.
Portability note: In early systems, the sense of this bit was exactly the
opposite.
LOG_ODELAY
This bit does nothing. It exists for backward compatibility.
```
```
If any other bit inoptionsis on, the result is undefined.
facilityis the default facility code for this connection. Asyslogon this connection
that specifies default facility causes this facility to be associated with the message.
Seesyslogfor possible values. A value of zero means the default, which isLOG_USER.
If a Syslog connection is already open when you callopenlog,openlog¡°reopens¡± the
connection. Reopening is like opening except that if you specify zero for the default
facility code, the default facility code simply remains unchanged and if you specify
LOGNDELAY and the socket is already open and connected,openlogjust leaves it
that way.
```
## 18.2.2 syslog, vsyslog..........................................

The symbols referred to in this section are declared in the filesyslog.h.

void syslog(intfacility_priority, const char *format,.. .) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
syslogsubmits a message to the Syslog facility. It does this by writing to the Unix
domain socket/dev/log.
syslog submits the message with the facility and priority indicated by facil-
itypriority. The macroLOG_MAKEPRIgenerates a facility/priority from a facility and
a priority, as in the following example:
LOG_MAKEPRI(LOG_USER, LOG_WARNING)
The possible values for the facility code are (macros):

```
LOG_USER A miscellaneous user process
LOG_MAIL Mail
```
```
LOG_DAEMON
A miscellaneous system daemon
LOG_AUTH Security (authorization)
```
```
LOG_SYSLOG
Syslog
```
```
LOG_LPR Central printer
```

Chapter 18: Syslog 535

```
LOG_NEWS Network news (e.g. Usenet)
LOG_UUCP UUCP
LOG_CRON Cron and At
LOG_AUTHPRIV
Private security (authorization)
LOG_FTP Ftp server
LOG_LOCAL0
Locally defined
LOG_LOCAL1
Locally defined
LOG_LOCAL2
Locally defined
LOG_LOCAL3
Locally defined
LOG_LOCAL4
Locally defined
LOG_LOCAL5
Locally defined
LOG_LOCAL6
Locally defined
LOG_LOCAL7
Locally defined
Results are undefined if the facility code is anything else.
NB:syslogrecognizes one other facility code: that of the kernel. But you can¡¯t
specify that facility code with these functions. If you try, it looks the same tosyslog
as if you are requesting the default facility. But you wouldn¡¯t want to anyway, because
any program that uses the GNU C Library is not the kernel.
You can use just a priority code asfacilitypriority. In that case,syslogassumes the
default facility established when the Syslog connection was opened. SeeSection 18.2.5
[Syslog Example], page 537.
The possible values for the priority code are (macros):
LOG_EMERG
The message says the system is unusable.
LOG_ALERT
Action on the message must be taken immediately.
LOG_CRIT The message states a critical condition.
LOG_ERR The message describes an error.
LOG_WARNING
The message is a warning.
```

Chapter 18: Syslog 536

### LOG_NOTICE

```
The message describes a normal but important event.
```
```
LOG_INFO The message is purely informational.
```
```
LOG_DEBUG
The message is only for debugging purposes.
```
```
Results are undefined if the priority code is anything else.
If the process does not presently have a Syslog connection open (i.e., it did not call
openlog),syslogimplicitly opens the connection the same asopenlogwould, with
the following defaults for information that would otherwise be included in anopenlog
call: The default identification string is the program name. The default default facility
isLOG_USER. The default for all the connection options inoptionsis as if those bits
were off.syslogleaves the Syslog connection open.
If the/dev/logsocket is not open and connected,syslogopens and connects it, the
same asopenlogwith theLOG_NDELAYoption would.
syslogleaves/dev/logopen and connected unless its attempt to send the message
failed, in which casesyslogcloses it (with the hope that a future implicit open will
restore the Syslog connection to a usable state).
Example:
```
```
#include <syslog.h>
syslog (LOG_MAKEPRI(LOG_LOCAL1, LOG_ERROR),
"Unable to make network connection to %s. Error=%m", host);
```
void vsyslog (intfacility_priority, const char *format, va list [Function]
arglist)
Preliminary:|MT-Safe env locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This is functionally identical tosyslog, with the BSD style variable length argument.

## 18.2.3 closelog................................................

The symbols referred to in this section are declared in the filesyslog.h.

void closelog(void) [Function]
Preliminary:|MT-Safe |AS-Unsafe lock|AC-Unsafe lock fd|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
closelogcloses the current Syslog connection, if there is one. This includes closing
the/dev/logsocket, if it is open. closelogalso sets the identification string for
Syslog messages back to the default, ifopenlogwas called with a non-NULL argument
toident. The default identification string is the program name taken from argv[0].
If you are writing shared library code that usesopenlogto generate custom syslog
output, you should usecloselogto drop the GNU C Library¡¯s internal reference to
theidentpointer when you are done. Please read the section onopenlogfor more
information: SeeSection 18.2.1 [openlog], page 532.


Chapter 18: Syslog 537

```
closelogdoes not flush any buffers. You do not have to callcloselogbefore re-
opening a Syslog connection withopenlog. Syslog connections are automatically
closed on exec or exit.
```
## 18.2.4 setlogmask.............................................

The symbols referred to in this section are declared in the filesyslog.h.

int setlogmask(intmask) [Function]
Preliminary: | MT-Unsafe race:LogMask | AS-Unsafe | AC-Safe | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
setlogmasksets a mask (the ¡°logmask¡±) that determines which futuresyslogcalls
shall be ignored. If a program has not calledsetlogmask,syslogdoesn¡¯t ignore any
calls. You can usesetlogmaskto specify that messages of particular priorities shall
be ignored in the future.
Asetlogmaskcall overrides any previoussetlogmaskcall.
Note that the logmask exists entirely independently of opening and closing of Syslog
connections.
Setting the logmask has a similar effect to, but is not the same as, configuring Syslog.
The Syslog configuration may cause Syslog to discard certain messages it receives,
but the logmask causes certain messages never to get submitted to Syslog in the first
place.
maskis a bit string with one bit corresponding to each of the possible message pri-
orities. If the bit is on,sysloghandles messages of that priority normally. If it is
off,syslogdiscards messages of that priority. Use the message priority macros de-
scribed inSection 18.2.2 [syslog, vsyslog], page 534,and theLOG_MASKto construct
an appropriatemaskvalue, as in this example:
LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ERROR)
or
~(LOG_MASK(LOG_INFO))
There is also aLOG_UPTOmacro, which generates a mask with the bits on for a certain
priority and all priorities above it:
LOG_UPTO(LOG_ERROR)
The unfortunate naming of the macro is due to the fact that internally, higher numbers
are used for lower message priorities.

## 18.2.5 Syslog Example........................................

Here is an example ofopenlog,syslog, andcloselog:

This example sets the logmask so that debug and informational messages get discarded
without ever reaching Syslog. So the secondsyslogin the example does nothing.
#include <syslog.h>

```
setlogmask (LOG_UPTO (LOG_NOTICE));
```
```
openlog ("exampleprog", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
```
```
syslog (LOG_NOTICE, "Program started by User %d", getuid ());
```

Chapter 18: Syslog 538

```
syslog (LOG_INFO, "A tree falls in a forest");
```
```
closelog ();
```

### 539

## 19 Mathematics.......................................

This chapter contains information about functions for performing mathematical computa-
tions, such as trigonometric functions. Most of these functions have prototypes declared in
the header filemath.h. The complex-valued functions are defined incomplex.h.

All mathematical functions which take a floating-point argument have three variants,
one each fordouble,float, andlong doublearguments. Thedoubleversions are mostly
defined in ISO C89. Thefloatandlong doubleversions are from the numeric extensions
to C included in ISO C99.

Which of the three versions of a function should be used depends on the situation. For
most calculations, thefloatfunctions are the fastest. On the other hand, thelong double
functions have the highest precision.doubleis somewhere in between. It is usually wise to
pick the narrowest type that can accommodate your data. Not all machines have a distinct
long doubletype; it may be the same asdouble.

The GNU C Library also provides_FloatNand_FloatNxtypes. These types are defined
in ISO/IEC TS 18661-3, which extends ISO C and defines floating-point types that are not
machine-dependent. When such a type, such as_Float128, is supported by the GNU C
Library, extra variants for most of the mathematical functions provided fordouble,float,
andlong doubleare also provided for the supported type. Throughout this manual, the
_FloatNand_FloatNxvariants of these functions are described along with the double,
float, andlong doublevariants and they come from ISO/IEC TS 18661-3, unless explic-
itly stated otherwise.

Support for_FloatNor_FloatNxtypes is provided for_Float32, _Float64and_
Float32xon all platforms. It is also provided for_Float128and_Float64xon powerpc64le
(PowerPC 64-bits little-endian), x8664, x86, ia64, aarch64, alpha, mips64, riscv, s390 and
sparc.

## 19.1 Predefined Mathematical Constants.........................

The headermath.hdefines several useful mathematical constants. All values are defined as
preprocessor macros starting withM_. The values provided are:

M_E The base of natural logarithms.

M_LOG2E The logarithm to base 2 ofM_E.

M_LOG10E The logarithm to base 10 ofM_E.

M_LN2 The natural logarithm of 2.

M_LN10 The natural logarithm of 10.

M_PI Pi, the ratio of a circle¡¯s circumference to its diameter.

M_PI_2 Pi divided by two.

M_PI_4 Pi divided by four.

M_1_PI The reciprocal of pi (1/pi)

M_2_PI Two times the reciprocal of pi.


Chapter 19: Mathematics 540

### M_2_SQRTPI

```
Two times the reciprocal of the square root of pi.
```
M_SQRT2 The square root of two.

M_SQRT1_2
The reciprocal of the square root of two (also the square root of 1/2).
These constants come from the Unix98 standard and were also available in 4.4BSD;
therefore they are only defined if_XOPEN_SOURCE=500, or a more general feature select
macro, is defined. The default set of features includes these constants. SeeSection 1.3.4
[Feature Test Macros], page 15.

All values are of typedouble. As an extension, the GNU C Library also defines these
constants with typelong double. Thelong doublemacros have a lowercase ¡®l¡¯ appended
to their names: M_El,M_PIl, and so forth. These are only available if_GNU_SOURCEis
defined.

Likewise, the GNU C Library also defines these constants with the types_FloatNand
_FloatNxfor the machines that have support for such types enabled (seeChapter 19 [Math-
ematics], page 539) and if_GNU_SOURCEis defined. When available, the macros names are
appended with ¡®fN¡¯ or ¡®fNx¡¯, such as ¡®f128¡¯ for the type_Float128.

Note: Some programs use a constant namedPI which has the same value asM_PI.
This constant is not standard; it may have appeared in some old AT&T headers, and is
mentioned in Stroustrup¡¯s book on C++. It infringes on the user¡¯s name space, so the GNU
C Library does not define it. Fixing programs written to expect it is simple: replacePI
withM_PIthroughout, or put ¡®-DPI=M_PI¡¯ on the compiler command line.

## 19.2 Trigonometric Functions.....................................

These are the familiarsin,cos, andtanfunctions. The arguments to all of these functions
are in units of radians; recall that pi radians equals 180 degrees.

The math library normally definesM_PIto adoubleapproximation of pi. If strict ISO
and/or POSIX compliance are requested this constant is not defined, but you can easily
define it yourself:
#define M_PI 3.14159265358979323846264338327

You can also compute the value of pi with the expressionacos (-1.0).

double sin(doublex) [Function]
float sinf(floatx) [Function]
long double sinl (long doublex) [Function]
_FloatN sinfN( FloatN x) [Function]
_FloatNx sinfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the sine ofx, wherexis given in radians. The return value is
in the range-1to 1.

double cos(doublex) [Function]
float cosf(floatx) [Function]


Chapter 19: Mathematics 541

long double cosl (long doublex) [Function]
_FloatN cosfN( FloatN x) [Function]
_FloatNx cosfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the cosine ofx, wherexis given in radians. The return value
is in the range-1to 1.

double tan(doublex) [Function]
float tanf(floatx) [Function]
long double tanl (long doublex) [Function]
_FloatN tanfN( FloatN x) [Function]
_FloatNx tanfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the tangent ofx, wherexis given in radians.
Mathematically, the tangent function has singularities at odd multiples of pi/2. If the
argumentxis too close to one of these singularities,tanwill signal overflow.

In many applications wheresinandcosare used, the sine and cosine of the same angle
are needed at the same time. It is more efficient to compute them simultaneously, so the
library provides a function to do that.

void sincos(doublex, double *sinx, double *cosx) [Function]
void sincosf (floatx, float *sinx, float *cosx) [Function]
void sincosl (long doublex, long double *sinx, long double *cosx) [Function]
_FloatN sincosfN (FloatN x, FloatN*sinx, FloatN*cosx) [Function]
_FloatNx sincosfNx( FloatNxx, FloatNx *sinx, FloatNx *cosx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the sine ofxin*sinxand the cosine ofxin*cosx, wherex
is given in radians. Both values,*sinxand*cosx, are in the range of-1to 1.
All these functions, including the_FloatNand_FloatNxvariants, are GNU exten-
sions. Portable programs should be prepared to cope with their absence.

ISO C99 defines variants of the trig functions which work on complex numbers. The
GNU C Library provides these functions, but they are only useful if your compiler supports
the new complex types defined by the standard. (As of this writing GCC supports complex
numbers, but there are bugs in the implementation.)

complex double csin (complex doublez) [Function]
complex float csinf (complex floatz) [Function]
complex long double csinl(complex long doublez) [Function]
complex _FloatN csinfN (complex FloatN z) [Function]
complex _FloatNx csinfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 19: Mathematics 542

```
These functions return the complex sine ofz. The mathematical definition of the
complex sine is
```
```
sin(z) =
```
### 1

```
2 i
```
```
(ezi?e?zi)
```
complex double ccos (complex doublez) [Function]
complex float ccosf (complex floatz) [Function]
complex long double ccosl(complex long doublez) [Function]
complex _FloatN ccosfN (complex FloatN z) [Function]
complex _FloatNx ccosfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the complex cosine ofz. The mathematical definition of the
complex cosine is

```
cos(z) =
```
### 1

### 2

```
(ezi+e?zi)
```
complex double ctan (complex doublez) [Function]
complex float ctanf (complex floatz) [Function]
complex long double ctanl(complex long doublez) [Function]
complex _FloatN ctanfN (complex FloatN z) [Function]
complex _FloatNx ctanfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the complex tangent ofz. The mathematical definition of the
complex tangent is

```
tan(z) =?i¡¤
```
```
ezi?e?zi
ezi+e?zi
```
```
The complex tangent has poles atpi/2 + 2n, wherenis an integer.ctanmay signal
overflow ifzis too close to a pole.
```
## 19.3 Inverse Trigonometric Functions.............................

These are the usual arcsine, arccosine and arctangent functions, which are the inverses of
the sine, cosine and tangent functions respectively.

double asin(doublex) [Function]
float asinf(floatx) [Function]
long double asinl(long doublex) [Function]
_FloatN asinfN( FloatN x) [Function]
_FloatNx asinfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 19: Mathematics 543

```
These functions compute the arcsine ofx¡ªthat is, the value whose sine isx. The
value is in units of radians. Mathematically, there are infinitely many such values;
the one actually returned is the one between-pi/2andpi/2(inclusive).
The arcsine function is defined mathematically only over the domain-1to 1. Ifxis
outside the domain,asinsignals a domain error.
```
double acos(doublex) [Function]
float acosf(floatx) [Function]
long double acosl(long doublex) [Function]
_FloatN acosfN( FloatN x) [Function]
_FloatNx acosfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the arccosine ofx¡ªthat is, the value whose cosine isx. The
value is in units of radians. Mathematically, there are infinitely many such values;
the one actually returned is the one between 0 andpi(inclusive).
The arccosine function is defined mathematically only over the domain-1to 1. Ifx
is outside the domain,acossignals a domain error.

double atan(doublex) [Function]
float atanf(floatx) [Function]
long double atanl(long doublex) [Function]
_FloatN atanfN( FloatN x) [Function]
_FloatNx atanfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the arctangent ofx¡ªthat is, the value whose tangent is
x. The value is in units of radians. Mathematically, there are infinitely many such
values; the one actually returned is the one between-pi/2andpi/2(inclusive).

double atan2 (doubley, doublex) [Function]
float atan2f (floaty, floatx) [Function]
long double atan2l(long doubley, long doublex) [Function]
_FloatN atan2fN (FloatN y, FloatN x) [Function]
_FloatNx atan2fNx( FloatNxy, FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function computes the arctangent ofy/x, but the signs of both arguments are
used to determine the quadrant of the result, andxis permitted to be zero. The
return value is given in radians and is in the range-pitopi, inclusive.
Ifxandyare coordinates of a point in the plane,atan2returns the signed angle
between the line from the origin to that point and the x-axis. Thus,atan2is useful
for converting Cartesian coordinates to polar coordinates. (To compute the radial
coordinate, usehypot; seeSection 19.4 [Exponentiation and Logarithms], page 544.)
If bothxandyare zero,atan2returns zero.

```
ISO C99 defines complex versions of the inverse trig functions.
```

Chapter 19: Mathematics 544

complex double casin(complex doublez) [Function]
complex float casinf(complex floatz) [Function]
complex long double casinl (complex long doublez) [Function]
complex _FloatN casinfN (complex FloatN z) [Function]
complex _FloatNx casinfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the complex arcsine ofz¡ªthat is, the value whose sine isz.
The value returned is in radians.
Unlike the real-valued functions,casinis defined for all values ofz.

complex double cacos(complex doublez) [Function]
complex float cacosf(complex floatz) [Function]
complex long double cacosl (complex long doublez) [Function]
complex _FloatN cacosfN (complex FloatN z) [Function]
complex _FloatNx cacosfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the complex arccosine ofz¡ªthat is, the value whose cosine
isz. The value returned is in radians.
Unlike the real-valued functions,cacosis defined for all values ofz.

complex double catan(complex doublez) [Function]
complex float catanf(complex floatz) [Function]
complex long double catanl (complex long doublez) [Function]
complex _FloatN catanfN (complex FloatN z) [Function]
complex _FloatNx catanfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the complex arctangent ofz¡ªthat is, the value whose tan-
gent isz. The value is in units of radians.

## 19.4 Exponentiation and Logarithms.............................

double exp(doublex) [Function]
float expf(floatx) [Function]
long double expl (long doublex) [Function]
_FloatN expfN( FloatN x) [Function]
_FloatNx expfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions computee(the base of natural logarithms) raised to the powerx.
If the magnitude of the result is too large to be representable,expsignals overflow.

double exp2(doublex) [Function]
float exp2f(floatx) [Function]


Chapter 19: Mathematics 545

long double exp2l(long doublex) [Function]
_FloatN exp2fN( FloatN x) [Function]
_FloatNx exp2fNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute 2 raised to the powerx. Mathematically,exp2 (x)is the
same asexp (x * log (2)).

double exp10 (doublex) [Function]
float exp10f (floatx) [Function]
long double exp10l(long doublex) [Function]
_FloatN exp10fN (FloatN x) [Function]
_FloatNx exp10fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute 10 raised to the powerx. Mathematically,exp10 (x)is the
same asexp (x * log (10)).
Theexp10functions are from TS 18661-4:2015.

double log(doublex) [Function]
float logf(floatx) [Function]
long double logl (long doublex) [Function]
_FloatN logfN( FloatN x) [Function]
_FloatNx logfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the natural logarithm ofx.exp (log (x))equalsx, exactly
in mathematics and approximately in C.
Ifxis negative,logsignals a domain error. Ifxis zero, it returns negative infinity;
ifxis too close to zero, it may signal overflow.

double log10 (doublex) [Function]
float log10f (floatx) [Function]
long double log10l(long doublex) [Function]
_FloatN log10fN (FloatN x) [Function]
_FloatNx log10fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the base-10 logarithm ofx. log10 (x)equalslog (x) / log
(10).

double log2(doublex) [Function]
float log2f(floatx) [Function]
long double log2l(long doublex) [Function]
_FloatN log2fN( FloatN x) [Function]
_FloatNx log2fNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 19: Mathematics 546

```
These functions return the base-2 logarithm ofx. log2 (x)equalslog (x) / log
(2).
```
double logb(doublex) [Function]
float logbf(floatx) [Function]
long double logbl(long doublex) [Function]
_FloatN logbfN( FloatN x) [Function]
_FloatNx logbfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions extract the exponent ofxand return it as a floating-point value. If
FLT_RADIXis two,logbis equal tofloor (log2 (x)), except it¡¯s probably faster.
Ifxis de-normalized,logbreturns the exponentxwould have if it were normalized.
Ifxis infinity (positive or negative),logbreturns¡Þ. Ifxis zero,logbreturns¡Þ.
It does not signal.

int ilogb (doublex) [Function]
int ilogbf(floatx) [Function]
int ilogbl(long doublex) [Function]
int ilogbfN( FloatN x) [Function]
int ilogbfNx (FloatNxx) [Function]
long int llogb(doublex) [Function]
long int llogbf (floatx) [Function]
long int llogbl (long doublex) [Function]
long int llogbfN (FloatN x) [Function]
long int llogbfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are equivalent to the correspondinglogbfunctions except that they
return signed integer values. Theilogb,ilogbf, andilogblfunctions are from ISO
C99; thellogb,llogbf,llogblfunctions are from TS 18661-1:2014; theilogbfN,
ilogbfNx,llogbfN, andllogbfNxfunctions are from TS 18661-3:2015.

Since integers cannot represent infinity and NaN,ilogbinstead returns an integer that
can¡¯t be the exponent of a normal floating-point number.math.hdefines constants so you
can check for this.

int FP_ILOGB0 [Macro]
ilogbreturns this value if its argument is 0. The numeric value is eitherINT_MINor
-INT_MAX.
This macro is defined in ISO C99.

long int FP_LLOGB0 [Macro]
llogbreturns this value if its argument is 0. The numeric value is eitherLONG_MIN
or-LONG_MAX.
This macro is defined in TS 18661-1:2014.


Chapter 19: Mathematics 547

int FP_ILOGBNAN [Macro]
ilogbreturns this value if its argument isNaN. The numeric value is eitherINT_MIN
orINT_MAX.
This macro is defined in ISO C99.

long int FP_LLOGBNAN [Macro]
llogbreturns this value if its argument isNaN. The numeric value is eitherLONG_MIN
orLONG_MAX.
This macro is defined in TS 18661-1:2014.

These values are system specific. They might even be the same. The proper way to test
the result ofilogbis as follows:
i = ilogb (f);
if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
{
if (isnan (f))
{
/* Handle NaN. */
}
else if (f == 0.0)
{
/* Handle 0.0. */
}
else
{
/* Some other value with large exponent,
perhaps+Inf. */
}
}

double pow(doublebase, doublepower) [Function]
float powf(floatbase, floatpower) [Function]
long double powl (long doublebase, long doublepower) [Function]
_FloatN powfN( FloatN base, FloatN power) [Function]
_FloatNx powfNx (FloatNxbase, FloatNxpower) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These are general exponentiation functions, returningbaseraised topower.
Mathematically,powwould return a complex number whenbaseis negative andpower
is not an integral value.powcan¡¯t do that, so instead it signals a domain error. pow
may also underflow or overflow the destination type.

double sqrt(doublex) [Function]
float sqrtf(floatx) [Function]
long double sqrtl(long doublex) [Function]
_FloatN sqrtfN( FloatN x) [Function]
_FloatNx sqrtfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the nonnegative square root ofx.


Chapter 19: Mathematics 548

```
Ifxis negative,sqrtsignals a domain error. Mathematically, it should return a
complex number.
```
double cbrt(doublex) [Function]
float cbrtf(floatx) [Function]
long double cbrtl(long doublex) [Function]
_FloatN cbrtfN( FloatN x) [Function]
_FloatNx cbrtfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the cube root ofx. They cannot fail; every representable real
value has a representable real cube root.

double hypot (doublex, doubley) [Function]
float hypotf (floatx, floaty) [Function]
long double hypotl(long doublex, long doubley) [Function]
_FloatN hypotfN (FloatN x, FloatN y) [Function]
_FloatNx hypotfNx( FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions returnsqrt (x*x+y*y). This is the length of the hypotenuse of a
right triangle with sides of lengthxandy, or the distance of the point (x,y) from
the origin. Using this function instead of the direct formula is wise, since the error is
much smaller. See also the functioncabsinSection 20.8.1 [Absolute Value], page 617.

double expm1 (doublex) [Function]
float expm1f (floatx) [Function]
long double expm1l(long doublex) [Function]
_FloatN expm1fN (FloatN x) [Function]
_FloatNx expm1fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return a value equivalent toexp (x) - 1. They are computed in
a way that is accurate even ifxis near zero¡ªa case whereexp (x) - 1would be
inaccurate owing to subtraction of two numbers that are nearly equal.

double log1p (doublex) [Function]
float log1pf (floatx) [Function]
long double log1pl(long doublex) [Function]
_FloatN log1pfN (FloatN x) [Function]
_FloatNx log1pfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return a value equivalent tolog (1 +x). They are computed in a
way that is accurate even ifxis near zero.

```
ISO C99 defines complex variants of some of the exponentiation and logarithm functions.
```

Chapter 19: Mathematics 549

complex double cexp (complex doublez) [Function]
complex float cexpf (complex floatz) [Function]
complex long double cexpl(complex long doublez) [Function]
complex _FloatN cexpfN (complex FloatN z) [Function]
complex _FloatNx cexpfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions returne(the base of natural logarithms) raised to the power ofz.
Mathematically, this corresponds to the value

```
exp(z) =ez=eRez(cos(Imz) +isin(Imz))
```
complex double clog (complex doublez) [Function]
complex float clogf (complex floatz) [Function]
complex long double clogl(complex long doublez) [Function]
complex _FloatN clogfN (complex FloatN z) [Function]
complex _FloatNx clogfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the natural logarithm ofz. Mathematically, this corresponds
to the value

```
log(z) = log|z|+iargz
```
```
cloghas a pole at 0, and will signal overflow ifzequals or is very close to 0. It is
well-defined for all other values ofz.
```
complex double clog10(complex doublez) [Function]
complex float clog10f(complex floatz) [Function]
complex long double clog10l (complex long doublez) [Function]
complex _FloatN clog10fN(complex FloatN z) [Function]
complex _FloatNx clog10fNx (complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the base 10 logarithm of the complex valuez. Mathematically,
this corresponds to the value

```
log 10 (z) = log 10 |z|+iargz/log(10)
```
```
All these functions, including the_FloatNand_FloatNxvariants, are GNU exten-
sions.
```
complex double csqrt(complex doublez) [Function]
complex float csqrtf(complex floatz) [Function]
complex long double csqrtl (complex long doublez) [Function]
complex _FloatN csqrtfN (FloatN z) [Function]


Chapter 19: Mathematics 550

complex _FloatNx csqrtfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the complex square root of the argumentz. Unlike the real-
valued functions, they are defined for all values ofz.

complex double cpow (complex doublebase, complex doublepower) [Function]
complex float cpowf (complex floatbase, complex floatpower) [Function]
complex long double cpowl(complex long doublebase, complex [Function]
long doublepower)
complex _FloatN cpowfN (complex FloatN base, complex FloatN [Function]
power)
complex _FloatNx cpowfNx(complex FloatNxbase, complex [Function]
FloatNxpower)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions returnbaseraised to the power of power. This is equivalent to
cexp (y * clog (x))

## 19.5 Hyperbolic Functions........................................

The functions in this section are related to the exponential functions; seeSection 19.4
[Exponentiation and Logarithms], page 544.

double sinh(doublex) [Function]
float sinhf(floatx) [Function]
long double sinhl(long doublex) [Function]
_FloatN sinhfN( FloatN x) [Function]
_FloatNx sinhfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the hyperbolic sine of x, defined mathematically as
(exp (x) - exp (-x)) / 2. They may signal overflow ifxis too large.

double cosh(doublex) [Function]
float coshf(floatx) [Function]
long double coshl(long doublex) [Function]
_FloatN coshfN( FloatN x) [Function]
_FloatNx coshfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the hyperbolic cosine of x, defined mathematically as
(exp (x) + exp (-x)) / 2. They may signal overflow ifxis too large.

double tanh(doublex) [Function]
float tanhf(floatx) [Function]
long double tanhl(long doublex) [Function]
_FloatN tanhfN( FloatN x) [Function]


Chapter 19: Mathematics 551

_FloatNx tanhfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the hyperbolic tangent of x, defined mathematically as
sinh (x) / cosh (x). They may signal overflow ifxis too large.

```
There are counterparts for the hyperbolic functions which take complex arguments.
```
complex double csinh(complex doublez) [Function]
complex float csinhf(complex floatz) [Function]
complex long double csinhl (complex long doublez) [Function]
complex _FloatN csinhfN (complex FloatN z) [Function]
complex _FloatNx csinhfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the complex hyperbolic sine ofz, defined mathematically as
(exp (z) - exp (-z)) / 2.

complex double ccosh(complex doublez) [Function]
complex float ccoshf(complex floatz) [Function]
complex long double ccoshl (complex long doublez) [Function]
complex _FloatN ccoshfN (complex FloatN z) [Function]
complex _FloatNx ccoshfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the complex hyperbolic cosine ofz, defined mathematically as
(exp (z) + exp (-z)) / 2.

complex double ctanh(complex doublez) [Function]
complex float ctanhf(complex floatz) [Function]
complex long double ctanhl (complex long doublez) [Function]
complex _FloatN ctanhfN (complex FloatN z) [Function]
complex _FloatNx ctanhfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the complex hyperbolic tangent ofz, defined mathematically
ascsinh (z) / ccosh (z).

double asinh (doublex) [Function]
float asinhf (floatx) [Function]
long double asinhl(long doublex) [Function]
_FloatN asinhfN (FloatN x) [Function]
_FloatNx asinhfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the inverse hyperbolic sine ofx¡ªthe value whose hyperbolic
sine isx.


Chapter 19: Mathematics 552

double acosh (doublex) [Function]
float acoshf (floatx) [Function]
long double acoshl(long doublex) [Function]
_FloatN acoshfN (FloatN x) [Function]
_FloatNx acoshfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the inverse hyperbolic cosine ofx¡ªthe value whose hyperbolic
cosine isx. Ifxis less than 1 ,acoshsignals a domain error.

double atanh (doublex) [Function]
float atanhf (floatx) [Function]
long double atanhl(long doublex) [Function]
_FloatN atanhfN (FloatN x) [Function]
_FloatNx atanhfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the inverse hyperbolic tangent ofx¡ªthe value whose hyper-
bolic tangent isx. If the absolute value ofxis greater than 1 ,atanhsignals a domain
error; if it is equal to 1,atanhreturns infinity.

complex double casinh(complex doublez) [Function]
complex float casinhf(complex floatz) [Function]
complex long double casinhl (complex long doublez) [Function]
complex _FloatN casinhfN(complex FloatN z) [Function]
complex _FloatNx casinhfNx (complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the inverse complex hyperbolic sine ofz¡ªthe value whose
complex hyperbolic sine isz.

complex double cacosh(complex doublez) [Function]
complex float cacoshf(complex floatz) [Function]
complex long double cacoshl (complex long doublez) [Function]
complex _FloatN cacoshfN(complex FloatN z) [Function]
complex _FloatNx cacoshfNx (complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the inverse complex hyperbolic cosine ofz¡ªthe value whose
complex hyperbolic cosine isz. Unlike the real-valued functions, there are no restric-
tions on the value ofz.

complex double catanh(complex doublez) [Function]
complex float catanhf(complex floatz) [Function]
complex long double catanhl (complex long doublez) [Function]
complex _FloatN catanhfN(complex FloatN z) [Function]


Chapter 19: Mathematics 553

complex _FloatNx catanhfNx (complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the inverse complex hyperbolic tangent ofz¡ªthe value whose
complex hyperbolic tangent isz. Unlike the real-valued functions, there are no re-
strictions on the value ofz.

## 19.6 Special Functions...........................................

These are some more exotic mathematical functions which are sometimes useful. Currently
they only have real-valued versions.

double erf(doublex) [Function]
float erff(floatx) [Function]
long double erfl (long doublex) [Function]
_FloatN erffN( FloatN x) [Function]
_FloatNx erffNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
erfreturns the error function ofx. The error function is defined as

```
erf(x) =
```
### 2

### ¡Ì

```
¦Ð
```
### ¡¤

```
¡Òx
```
```
0
```
```
e?t
```
```
2
dt
```
double erfc(doublex) [Function]
float erfcf(floatx) [Function]
long double erfcl(long doublex) [Function]
_FloatN erfcfN( FloatN x) [Function]
_FloatNx erfcfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
erfcreturns1.0 - erf(x), but computed in a fashion that avoids round-off error
whenxis large.

double lgamma(doublex) [Function]
float lgammaf(floatx) [Function]
long double lgammal (long doublex) [Function]
_FloatN lgammafN (FloatN x) [Function]
_FloatNx lgammafNx( FloatNxx) [Function]
Preliminary:|MT-Unsafe race:signgam|AS-Unsafe |AC-Safe|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
lgammareturns the natural logarithm of the absolute value of the gamma function of
x. The gamma function is defined as

```
¦£(x) =
```
```
¡Ò¡Þ
```
```
0
```
```
tx?^1 e?tdt
```
```
The sign of the gamma function is stored in the global variablesigngam, which is
declared inmath.h. It is 1 if the intermediate result was positive or zero, or-1if it
was negative.
```

Chapter 19: Mathematics 554

```
To compute the real gamma function you can use thetgammafunction or you can
compute the values as follows:
lgam = lgamma(x);
gam = signgam*exp(lgam);
The gamma function has singularities at the non-positive integers.lgammawill raise
the zero divide exception if evaluated at a singularity.
```
double lgamma_r (doublex, int *signp) [Function]
float lgammaf_r (floatx, int *signp) [Function]
long double lgammal_r(long doublex, int *signp) [Function]
_FloatN lgammafN_r( FloatN x, int *signp) [Function]
_FloatNx lgammafNx_r(FloatNxx, int *signp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
lgamma_ris just likelgamma, but it stores the sign of the intermediate result in
the variable pointed to bysignpinstead of in thesigngamglobal. This means it is
reentrant.
ThelgammafN_randlgammafNx_rfunctions are GNU extensions.

double gamma (doublex) [Function]
float gammaf (floatx) [Function]
long double gammal(long doublex) [Function]
Preliminary:|MT-Unsafe race:signgam|AS-Unsafe |AC-Safe|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
These functions exist for compatibility reasons. They are equivalent tolgammaetc. It
is better to uselgammasince for one the name reflects better the actual computation,
and moreoverlgammais standardized in ISO C99 whilegammais not.

double tgamma(doublex) [Function]
float tgammaf(floatx) [Function]
long double tgammal (long doublex) [Function]
_FloatN tgammafN (FloatN x) [Function]
_FloatNx tgammafNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
tgammaapplies the gamma function tox. The gamma function is defined as

```
¦£(x) =
```
```
¡Ò¡Þ
```
```
0
```
```
tx?^1 e?tdt
```
```
This function was introduced in ISO C99. The_FloatNand_FloatNxvariants were
introduced in ISO/IEC TS 18661-3.
```
double j0 (doublex) [Function]
float j0f (floatx) [Function]
long double j0l (long doublex) [Function]
_FloatN j0fN (FloatN x) [Function]


Chapter 19: Mathematics 555

_FloatNx j0fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
j0returns the Bessel function of the first kind of order 0 ofx. It may signal underflow
ifxis too large.
The_FloatNand_FloatNxvariants are GNU extensions.

double j1 (doublex) [Function]
float j1f (floatx) [Function]
long double j1l (long doublex) [Function]
_FloatN j1fN (FloatN x) [Function]
_FloatNx j1fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
j1returns the Bessel function of the first kind of order 1 ofx. It may signal underflow
ifxis too large.
The_FloatNand_FloatNxvariants are GNU extensions.

double jn (intn, doublex) [Function]
float jnf (intn, floatx) [Function]
long double jnl (intn, long doublex) [Function]
_FloatN jnfN (intn, FloatN x) [Function]
_FloatNx jnfNx(intn, FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
jnreturns the Bessel function of the first kind of ordernofx. It may signal underflow
ifxis too large.
The_FloatNand_FloatNxvariants are GNU extensions.

double y0 (doublex) [Function]
float y0f (floatx) [Function]
long double y0l (long doublex) [Function]
_FloatN y0fN (FloatN x) [Function]
_FloatNx y0fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
y0returns the Bessel function of the second kind of order 0 ofx. It may signal
underflow ifxis too large. Ifxis negative,y0signals a domain error; if it is zero,y0
signals overflow and returns?¡Þ.
The_FloatNand_FloatNxvariants are GNU extensions.

double y1 (doublex) [Function]
float y1f (floatx) [Function]
long double y1l (long doublex) [Function]
_FloatN y1fN (FloatN x) [Function]


Chapter 19: Mathematics 556

_FloatNx y1fNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
y1returns the Bessel function of the second kind of order 1 ofx. It may signal
underflow ifxis too large. Ifxis negative,y1signals a domain error; if it is zero,y1
signals overflow and returns?¡Þ.
The_FloatNand_FloatNxvariants are GNU extensions.

double yn (intn, doublex) [Function]
float ynf (intn, floatx) [Function]
long double ynl (intn, long doublex) [Function]
_FloatN ynfN (intn, FloatN x) [Function]
_FloatNx ynfNx(intn, FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
ynreturns the Bessel function of the second kind of ordern ofx. It may signal
underflow ifxis too large. Ifxis negative,ynsignals a domain error; if it is zero,yn
signals overflow and returns?¡Þ.
The_FloatNand_FloatNxvariants are GNU extensions.

## 19.7 Known Maximum Errors in Math Functions.................

This section lists the known errors of the functions in the math library. Errors are measured
in ¡°units of the last place¡±. This is a measure for the relative error. For a numberzwith
the representationd.d...d¡¤ 2 e(we assume IEEE floating-point numbers with base 2) the
ULP is represented by

```
|d.d...d?(z/ 2 e)|
2 p?^1
```
wherepis the number of bits in the mantissa of the floating-point number representation.
Ideally the error for all functions is always less than 0.5ulps in round-to-nearest mode.
Using rounding bits this is also possible and normally implemented for the basic operations.
Except for certain functions such assqrt,fmaandrintwhose results are fully specified
by reference to corresponding IEEE 754 floating-point operations, and conversions between
strings and floating point, the GNU C Library does not aim for correctly rounded results
for functions in the math library, and does not aim for correctness in whether ¡°inexact¡±
exceptions are raised. Instead, the goals for accuracy of functions without fully specified
results are as follows; some functions have bugs meaning they do not meet these goals in
all cases. In the future, the GNU C Library may provide some other correctly rounding
functions under the names such ascrsinproposed for an extension to ISO C.

- Each function with a floating-point result behaves as if it computes an infinite-precision
    result that is within a few ulp (in both real and complex parts, for functions with com-
    plex results) of the mathematically correct value of the function (interpreted together
    with ISO C or POSIX semantics for the function in question) at the exact value passed
    as the input. Exceptions are raised appropriately for this value and in accordance with


Chapter 19: Mathematics 557

```
IEEE 754 / ISO C / POSIX semantics, and it is then rounded according to the cur-
rent rounding direction to the result that is returned to the user. errnomay also be
set (seeSection 20.5.4 [Error Reporting by Mathematical Functions], page 612). (The
¡°inexact¡± exception may be raised, or not raised, even if this is inconsistent with the
infinite-precision value.)
```
- For the IBMlong doubleformat, as used on PowerPC GNU/Linux, the accuracy goal
    is weaker for input values not exactly representable in 106 bits of precision; it is as if
    the input value is some value within 0.5ulp of the value actually passed, where ¡°ulp¡± is
    interpreted in terms of a fixed-precision 106-bit mantissa, but not necessarily the exact
    value actually passed with discontiguous mantissa bits.
- For the IBMlong doubleformat, functions whose results are fully specified by refer-
    ence to corresponding IEEE 754 floating-point operations have the same accuracy goals
    as other functions, but with the error bound being the same as that for division (3ulp).
    Furthermore, ¡°inexact¡± and ¡°underflow¡± exceptions may be raised for all functions for
    any inputs, even where such exceptions are inconsistent with the returned value, since
    the underlying floating-point arithmetic has that property.
- Functions behave as if the infinite-precision result computed is zero, infinity or NaN if
    and only if that is the mathematically correct infinite-precision result. They behave as
    if the infinite-precision result computed always has the same sign as the mathematically
    correct result.
- If the mathematical result is more than a few ulp above the overflow threshold for the
    current rounding direction, the value returned is the appropriate overflow value for the
    current rounding direction, with the overflow exception raised.
- If the mathematical result has magnitude well below half the least subnormal mag-
    nitude, the returned value is either zero or the least subnormal (in each case, with
    the correct sign), according to the current rounding direction and with the underflow
    exception raised.
- Where the mathematical result underflows (before rounding) and is not exactly rep-
    resentable as a floating-point value, the function does not behave as if the computed
    infinite-precision result is an exact value in the subnormal range. This means that
    the underflow exception is raised other than possibly for cases where the mathematical
    result is very close to the underflow threshold and the function behaves as if it com-
    putes an infinite-precision result that does not underflow. (So there may be spurious
    underflow exceptions in cases where the underflowing result is exact, but not missing
    underflow exceptions in cases where it is inexact.)
- The GNU C Library does not aim for functions to satisfy other properties of the
    underlying mathematical function, such as monotonicity, where not implied by the
    above goals.
- All the above applies to both real and complex parts, for complex functions.
    Therefore many of the functions in the math library have errors. The table lists the
maximum error for each function which is exposed by one of the existing tests in the test
suite. The table tries to cover as much as possible and list the actual maximum error (or
at least a ballpark figure) but this is often not achieved due to the large search space.

The table lists the ULP values for different architectures. Different architectures have
different results since their hardware support for floating-point operations varies and also


Chapter 19: Mathematics 558

the existing hardware support is different. Only the round-to-nearest rounding mode is
covered by this table, and vector versions of functions are not covered. Functions not listed
do not have known errors.


Chapter 19: Mathematics 559

Function AArch64 ARC ARC
soft-float

```
ARM Alpha
```
acosf 1 1 1 1 1
acos - 1 - - -
acosl 1 - - - 1
acosf128 - - - - -
acoshf 2 2 2 2 2
acosh 2 3 2 2 2
acoshl 2 - - - 2
acoshf128 - - - - -
addldoublef - - - - -
addldouble - - - - -
addldoublel - - - - -
addldoublef128- - - - -
asinf 1 1 1 1 1
asin - 1 - - -
asinl 1 - - - 1
asinf128 - - - - -
asinhf 2 2 2 2 2
asinh 2 3 2 2 2
asinhl 3 - - - 3
asinhf128 - - - - -
atanf 1 1 1 1 1
atan 1 1 - - -
atanl 1 - - - 1
atanf128 - - - - -
atan2f 1 2 1 1 1
atan2 - 7 - - -
atan2l 1 - - - 1
atan2f128 - - - - -
atanhf 2 2 2 2 2
atanh 2 2 2 2 2
atanhl 3 - - - 3
atanhf128 - - - - -
cabsf - 1 - - -
cabs 1 1 1 1 1
cabsl 1 - - - 1
cabsf128 - - - - -
cacosf 2 +i 2 2 +i 3 2 +i 2 2 +i 2 2 +i 2
cacos 1 +i 2 2 +i 5 1 +i 2 1 +i 2 1 +i 2
cacosl 2 +i 2 - - - 2 +i 2
cacosf128 - - - - -
cacoshf 2 +i 2 4 +i 2 2 +i 2 2 +i 2 2 +i 2
cacosh 2 +i 1 5 +i 2 2 +i 1 2 +i 1 2 +i 1
cacoshl 2 +i 2 - - - 2 +i 2
cacoshf128 - - - - -


Chapter 19: Mathematics 560

cargf 1 2 1 1 1
carg 1 7 - - -
cargl 2 - - - 2
cargf128 - - - - -
casinf 1 +i 2 1 +i 4 1 +i 2 1 +i 2 1 +i 2
casin 1 +i 2 3 +i 5 1 +i 2 1 +i 2 1 +i 2
casinl 2 +i 2 - - - 2 +i 2
casinf128 - - - - -
casinhf 2 +i 1 4 +i 2 2 +i 1 2 +i 1 2 +i 1
casinh 2 +i 1 5 +i 3 2 +i 1 2 +i 1 2 +i 1
casinhl 2 +i 2 - - - 2 +i 2
casinhf128 - - - - -
catanf 1 +i 1 1 +i 3 1 +i 1 1 +i 1 1 +i 1
catan 1 +i 1 1 +i 3 1 +i 1 1 +i 1 1 +i 1
catanl 1 +i 1 - - - 1 +i 1
catanf128 - - - - -
catanhf 1 +i 1 4 +i 2 1 +i 1 1 +i 1 1 +i 1
catanh 1 +i 1 4 +i 1 1 +i 1 1 +i 1 1 +i 1
catanhl 1 +i 1 - - - 1 +i 1
catanhf128 - - - - -
cbrtf 1 1 1 1 1
cbrt 4 4 4 4 4
cbrtl 1 - - - 1
cbrtf128 - - - - -
ccosf 1 +i 1 3 +i 3 1 +i 1 1 +i 1 1 +i 1
ccos 1 +i 1 3 +i 3 1 +i 1 1 +i 1 1 +i 1
ccosl 1 +i 1 - - - 1 +i 1
ccosf128 - - - - -
ccoshf 1 +i 1 3 +i 3 1 +i 1 1 +i 1 1 +i 1
ccosh 1 +i 1 3 +i 3 1 +i 1 1 +i 1 1 +i 1
ccoshl 1 +i 1 - - - 1 +i 1
ccoshf128 - - - - -
cexpf 1 +i 2 3 +i 3 1 +i 2 1 +i 2 1 +i 2
cexp 2 +i 1 4 +i 4 2 +i 1 2 +i 1 2 +i 1
cexpl 1 +i 1 - - - 1 +i 1
cexpf128 - - - - -
clogf 3 +i 1 4 +i 2 3 +i 1 3 +i 1 3 +i 1
clog 3 +i 1 5 +i 7 3 +i 0 3 +i 0 3 +i 0
clogl 2 +i 1 - - - 2 +i 1
clogf128 - - - - -
clog10f 4 +i 2 5 +i 4 4 +i 2 4 +i 2 4 +i 2
clog10 3 +i 2 6 +i 8 3 +i 2 3 +i 2 3 +i 2
clog10l 2 +i 2 - - - 2 +i 2
clog10f128 - - - - -
cosf 1 1 1 1 1
cos 1 4 1 1 1
cosl 1 - - - 1


Chapter 19: Mathematics 561

cosf128 - - - - -
coshf 2 3 2 2 2
cosh 2 3 2 2 2
coshl 1 - - - 1
coshf128 - - - - -
cpowf 5 +i 2 8 +i 6 5 +i 2 5 +i 2 5 +i 2
cpow 2 +i 0 9 +i 8 2 +i 0 2 +i 0 2 +i 0
cpowl 4 +i 1 - - - 4 +i 1
cpowf128 - - - - -
csinf 1 +i 0 3 +i 3 1 +i 0 1 +i 0 1 +i 0
csin 1 +i 0 3 +i 3 1 +i 0 1 +i 0 1 +i 0
csinl 1 +i 1 - - - 1 +i 1
csinf128 - - - - -
csinhf 1 +i 1 3 +i 3 1 +i 1 1 +i 1 1 +i 1
csinh 0 +i 1 3 +i 3 0 +i 1 0 +i 1 0 +i 1
csinhl 1 +i 1 - - - 1 +i 1
csinhf128 - - - - -
csqrtf 2 +i 2 3 +i 3 2 +i 2 2 +i 2 2 +i 2
csqrt 2 +i 2 4 +i 4 2 +i 2 2 +i 2 2 +i 2
csqrtl 2 +i 2 - - - 2 +i 2
csqrtf128 - - - - -
ctanf 1 +i 2 6 +i 2 1 +i 2 1 +i 2 1 +i 2
ctan 1 +i 2 4 +i 3 1 +i 2 1 +i 2 1 +i 2
ctanl 3 +i 3 - - - 3 +i 3
ctanf128 - - - - -
ctanhf 2 +i 1 2 +i 6 2 +i 2 2 +i 2 2 +i 2
ctanh 2 +i 2 3 +i 4 2 +i 2 2 +i 2 2 +i 2
ctanhl 3 +i 3 - - - 3 +i 3
ctanhf128 - - - - -
divldoublef - - - - -
divldouble - - - - -
divldoublel - - - - -
divldoublef128- - - - -
erff 1 1 1 1 1
erf 1 1 1 1 1
erfl 1 - - - 1
erff128 - - - - -
erfcf 2 5 3 3 3
erfc 2 5 5 5 5
erfcl 2 - - - 2
erfcf128 - - - - -
expf 1 1 1 1 1
exp 1 1 1 1 1
expl 1 - - - 1
expf128 - - - - -
exp10f 1 1 1 1 1
exp10 2 4 2 2 2


Chapter 19: Mathematics 562

exp10l 2 - - - 2
exp10f128 - - - - -
exp2f 1 1 - 1 1
exp2 1 1 1 1 1
exp2l 1 - - - 1
exp2f128 - - - - -
expm1f 1 2 1 1 1
expm1 1 2 1 1 1
expm1l 1 - - - 1
expm1f128 - - - - -
fmaf - - - - -
fma - - - - -
fmal - - - - -
fmaf128 - - - - -
fmodf - - - - -
fmod - - - - -
fmodl - - - - -
fmodf128 - - - - -
gammaf 4 6 7 7 7
gamma 3 7 4 4 4
gammal 5 - - - 5
gammaf128 - - - - -
hypotf - 1 - - -
hypot 1 2 1 1 1
hypotl 1 - - - 1
hypotf128 - - - - -
j0f 8 6 8 8 8
j0 2 4 2 2 2
j0l 2 - - - 2
j0f128 - - - - -
j1f 8 9 9 9 9
j1 2 5 2 2 2
j1l 4 - - - 4
j1f128 - - - - -
jnf 4 8 4 4 4
jn 4 9 4 4 4
jnl 7 - - - 7
jnf128 - - - - -
lgammaf 4 6 7 7 7
lgamma 3 7 4 4 4
lgammal 5 - - - 5
lgammaf128 - - - - -
logf 1 1 - 1 1
log 1 1 - - -
logl 1 - - - 1
logf128 - - - - -
log10f 2 3 2 2 2


Chapter 19: Mathematics 563

log10 2 2 2 2 2
log10l 1 - - - 1
log10f128 - - - - -
log1pf 1 1 1 1 1
log1p 1 1 1 1 1
log1pl 2 - - - 2
log1pf128 - - - - -
log2f 1 1 1 1 1
log2 1 2 2 2 2
log2l 2 - - - 2
log2f128 - - - - -
mulldoublef - - - - -
mulldouble - - - - -
mulldoublel - - - - -
mulldoublef128- - - - -
powf 1 1 - 1 1
pow 1 1 1 1 1
powl 2 - - - 2
powf128 - - - - -
pow10f - - - - -
pow10 - - - - -
pow10l - - - - -
pow10f128 - - - - -
sinf 1 1 1 1 1
sin 1 7 1 1 1
sinl 1 - - - 1
sinf128 - - - - -
sincosf 1 1 1 1 1
sincos 1 1 1 1 1
sincosl 1 - - - 1
sincosf128 - - - - -
sinhf 2 3 2 2 2
sinh 2 3 2 2 2
sinhl 2 - - - 2
sinhf128 - - - - -
sqrtf - - - - -
sqrt - - - - -
sqrtl - - - - -
sqrtf128 - - - - -
subldoublef - - - - -
subldouble - - - - -
subldoublel - - - - -
subldoublef128- - - - -
tanf 1 1 1 1 1
tan - 1 - - -
tanl 1 - - - 1
tanf128 - - - - -


Chapter 19: Mathematics 564

tanhf 2 2 2 2 2
tanh 2 3 2 2 2
tanhl 2 - - - 2
tanhf128 - - - - -
tgammaf 8 9 8 8 8
tgamma 9 9 9 9 9
tgammal 4 - - - 4
tgammaf128 - - - - -
y0f 6 6 8 8 8
y0 2 3 3 3 3
y0l 3 - - - 3
y0f128 - - - - -
y1f 2 6 2 2 2
y1 3 7 3 3 3
y1l 2 - - - 2
y1f128 - - - - -
ynf 3 9 3 3 3
yn 3 9 3 3 3
ynl 5 - - - 5
ynf128 - - - - -

Function CSKY CSKY
soft-float

```
ColdFire Generic HPPA
```
acosf 1 1 - - 1
acos - - - - -
acosl - - - - -
acosf128 - - - - -
acoshf 2 2 - - 2
acosh 2 2 - - 2
acoshl - - - - -
acoshf128 - - - - -
addldoublef - - - - -
addldouble - - - - -
addldoublel - - - - -
addldoublef128- - - - -
asinf 1 1 - - 1
asin - - - - -
asinl - - - - -
asinf128 - - - - -
asinhf 2 2 - - 2
asinh 2 2 - - 2
asinhl - - - - -
asinhf128 - - - - -
atanf 1 1 - - 1
atan - - - - -
atanl - - - - -
atanf128 - - - - -


Chapter 19: Mathematics 565

atan2f 1 1 1 - 1
atan2 - - - - -
atan2l - - - - -
atan2f128 - - - - -
atanhf 2 2 1 - 2
atanh 2 2 - - 2
atanhl - - - - -
atanhf128 - - - - -
cabsf - - - - -
cabs 1 1 - - 1
cabsl - - - - -
cabsf128 - - - - -
cacosf 2 +i 2 2 +i 2 - - 2 +i 2
cacos 1 +i 2 1 +i 2 - - 1 +i 2
cacosl - - - - -
cacosf128 - - - - -
cacoshf 2 +i 2 2 +i 2 0 +i 1 - 2 +i 2
cacosh 2 +i 1 2 +i 1 - - 2 +i 1
cacoshl - - - - -
cacoshf128 - - - - -
cargf 1 1 - - 1
carg - - - - -
cargl - - - - -
cargf128 - - - - -
casinf 1 +i 2 1 +i 2 1 +i 0 - 1 +i 2
casin 1 +i 2 1 +i 2 1 +i 0 - 1 +i 2
casinl - - - - 1 +i 0
casinf128 - - - - -
casinhf 2 +i 1 2 +i 1 1 +i 6 - 2 +i 1
casinh 2 +i 1 2 +i 1 5 +i 3 - 5 +i 3
casinhl - - - - 5 +i 3
casinhf128 - - - - -
catanf 1 +i 1 1 +i 1 0 +i 1 - 1 +i 1
catan 1 +i 1 1 +i 1 0 +i 1 - 1 +i 1
catanl - - - - 0 +i 1
catanf128 - - - - -
catanhf 1 +i 1 1 +i 1 - - 1 +i 1
catanh 1 +i 1 1 +i 1 4 +i 0 - 4 +i 1
catanhl - - - - 4 +i 0
catanhf128 - - - - -
cbrtf 1 1 - - 1
cbrt 4 4 1 - 4
cbrtl - - - - 1
cbrtf128 - - - - -
ccosf 1 +i 1 1 +i 1 1 +i 1 - 1 +i 1
ccos 1 +i 1 1 +i 1 1 +i 0 - 1 +i 1
ccosl - - - - 1 +i 0


Chapter 19: Mathematics 566

ccosf128 - - - - -
ccoshf 1 +i 1 1 +i 1 1 +i 1 - 1 +i 1
ccosh 1 +i 1 1 +i 1 1 +i 0 - 1 +i 1
ccoshl - - - - 1 +i 0
ccoshf128 - - - - -
cexpf 1 +i 2 1 +i 2 1 +i 1 - 1 +i 2
cexp 2 +i 1 2 +i 1 - - 2 +i 1
cexpl - - - - -
cexpf128 - - - - -
clogf 3 +i 1 3 +i 1 1 +i 0 - 3 +i 1
clog 3 +i 0 3 +i 0 - - 3 +i 0
clogl - - - - -
clogf128 - - - - -
clog10f 4 +i 2 4 +i 2 1 +i 1 - 4 +i 2
clog10 3 +i 2 3 +i 2 0 +i 1 - 3 +i 2
clog10l - - - - 0 +i 1
clog10f128 - - - - -
cosf 1 1 1 - 1
cos 1 1 2 - 2
cosl - - - - 2
cosf128 - - - - -
coshf 2 2 - - 2
cosh 2 2 - - 2
coshl - - - - -
coshf128 - - - - -
cpowf 5 +i 2 5 +i 2 4 +i 2 - 5 +i 2
cpow 2 +i 0 2 +i 0 2 +i 2 - 2 +i 2
cpowl - - - - 2 +i 2
cpowf128 - - - - -
csinf 1 +i 0 1 +i 0 - - 1 +i 0
csin 1 +i 0 1 +i 0 - - 1 +i 0
csinl - - - - -
csinf128 - - - - -
csinhf 1 +i 1 1 +i 1 1 +i 1 - 1 +i 1
csinh 0 +i 1 0 +i 1 0 +i 1 - 0 +i 1
csinhl - - - - 0 +i 1
csinhf128 - - - - -
csqrtf 2 +i 2 2 +i 2 1 +i 0 - 2 +i 2
csqrt 2 +i 2 2 +i 2 - - 2 +i 2
csqrtl - - - - -
csqrtf128 - - - - -
ctanf 1 +i 2 1 +i 2 - - 1 +i 2
ctan 1 +i 2 1 +i 2 0 +i 1 - 1 +i 2
ctanl - - - - 0 +i 1
ctanf128 - - - - -
ctanhf 2 +i 2 2 +i 2 2 +i 1 - 2 +i 2
ctanh 2 +i 2 2 +i 2 1 +i 0 - 2 +i 2


Chapter 19: Mathematics 567

ctanhl - - - - 1 +i 0
ctanhf128 - - - - -
divldoublef - - - - -
divldouble - - - - -
divldoublel - - - - -
divldoublef128- - - - -
erff 1 1 - - 1
erf 1 1 1 - 1
erfl - - - - 1
erff128 - - - - -
erfcf 3 3 - - 3
erfc 5 5 1 - 5
erfcl - - - - 1
erfcf128 - - - - -
expf 1 1 - - 1
exp 1 1 - - 1
expl - - - - -
expf128 - - - - -
exp10f - - 2 - 2
exp10 2 2 6 - 6
exp10l - - - - 6
exp10f128 - - - - -
exp2f - 1 - - 1
exp2 1 1 - - 1
exp2l - - - - -
exp2f128 - - - - -
expm1f 1 1 1 - 1
expm1 1 1 1 - 1
expm1l - - - - 1
expm1f128 - - - - -
fmaf - - - - -
fma - - - - -
fmal - - - - -
fmaf128 - - - - -
fmodf - - - - -
fmod - - - - -
fmodl - - - - -
fmodf128 - - - - -
gammaf 7 7 - - 7
gamma 4 4 - - 4
gammal - - - - -
gammaf128 - - - - -
hypotf - - 1 - 1
hypot 1 1 - - 1
hypotl - - - - -
hypotf128 - - - - -
j0f 8 8 2 - 8


Chapter 19: Mathematics 568

j0 2 2 2 - 2
j0l - - - - 2
j0f128 - - - - -
j1f 9 9 2 - 9
j1 2 2 1 - 2
j1l - - - - 1
j1f128 - - - - -
jnf 4 4 4 - 5
jn 4 4 4 - 4
jnl - - - - 4
jnf128 - - - - -
lgammaf 7 7 2 - 7
lgamma 4 4 1 - 4
lgammal - - - - 1
lgammaf128 - - - - -
logf - 1 - - 1
log - - - - -
logl - - - - -
logf128 - - - - -
log10f 2 2 2 - 2
log10 2 2 1 - 2
log10l - - - - 1
log10f128 - - - - -
log1pf 1 1 1 - 1
log1p 1 1 - - 1
log1pl - - - - -
log1pf128 - - - - -
log2f 1 1 - - 1
log2 2 2 - - 2
log2l - - - - -
log2f128 - - - - -
mulldoublef - - - - -
mulldouble - - - - -
mulldoublel - - - - -
mulldoublef128- - - - -
powf - 1 - - 1
pow 1 1 - - 1
powl - - - - -
powf128 - - - - -
pow10f - - - - -
pow10 - 2 - - -
pow10l - - - - -
pow10f128 - - - - -
sinf 1 1 - - 1
sin 1 1 - - 1
sinl - - - - -
sinf128 - - - - -


Chapter 19: Mathematics 569

sincosf - 1 1 - 1
sincos 1 1 1 - 1
sincosl - - - - 1
sincosf128 - - - - -
sinhf 2 2 - - 2
sinh 2 2 - - 2
sinhl - - - - -
sinhf128 - - - - -
sqrtf - - - - -
sqrt - - - - -
sqrtl - - - - -
sqrtf128 - - - - -
subldoublef - - - - -
subldouble - - - - -
subldoublel - - - - -
subldoublef128- - - - -
tanf 1 1 - - 1
tan - - 1 - 1
tanl - - - - 1
tanf128 - - - - -
tanhf 2 2 - - 2
tanh 2 2 - - 2
tanhl - - - - -
tanhf128 - - - - -
tgammaf 8 8 1 - 8
tgamma 9 9 1 - 9
tgammal - - - - 1
tgammaf128 - - - - -
y0f 8 8 1 - 8
y0 3 3 2 - 3
y0l - - - - 2
y0f128 - - - - -
y1f 2 2 2 - 2
y1 3 3 3 - 3
y1l - - - - 3
y1f128 - - - - -
ynf 3 3 2 - 3
yn 3 3 3 - 3
ynl - - - - 3
ynf128 - - - - -

Function IA64 M68k MIPS 32-bit MIPS 64-bit MicroBlaze
acosf - - 1 1 1
acos 1 - - - -
acosl - - - 1 -
acosf128 1 - - - -
acoshf - 1 2 2 2


Chapter 19: Mathematics 570

acosh 1 1 2 2 2
acoshl 1 1 - 2 -
acoshf128 2 - - - -
addldoublef - - - - -
addldouble - - - - -
addldoublel - - - - -
addldoublef128- - - - -
asinf - - 1 1 1
asin - - - - -
asinl - - - 1 -
asinf128 1 - - - -
asinhf - 1 2 2 1
asinh 1 1 2 2 1
asinhl - 1 - 3 -
asinhf128 3 - - - -
atanf - - 1 1 1
atan - - - - -
atanl - - - 1 -
atanf128 1 - - - -
atan2f - 1 1 1 1
atan2 - - - - -
atan2l - 1 - 1 -
atan2f128 1 - - - -
atanhf - - 2 2 2
atanh - - 2 2 2
atanhl - - - 3 -
atanhf128 3 - - - -
cabsf - - - - -
cabs - 1 1 1 1
cabsl - 1 - 1 -
cabsf128 1 - - - -
cacosf 2 +i 2 2 +i 1 2 +i 2 2 +i 2 2 +i 2
cacos 1 +i 2 1 +i 1 1 +i 2 1 +i 2 1 +i 2
cacosl 1 +i 2 1 +i 2 - 2 +i 2 -
cacosf128 2 +i 2 - - - -
cacoshf 2 +i 2 1 +i 2 2 +i 2 2 +i 2 2 +i 2
cacosh 2 +i 1 1 +i 1 2 +i 1 2 +i 1 2 +i 1
cacoshl 2 +i 1 2 +i 1 - 2 +i 2 -
cacoshf128 2 +i 2 - - - -
cargf - 1 1 1 1
carg - - - - -
cargl - 1 - 2 -
cargf128 2 - - - -
casinf 1 +i 2 1 +i 1 1 +i 2 1 +i 2 1 +i 2
casin 1 +i 2 1 +i 1 1 +i 2 1 +i 2 1 +i 2
casinl 1 +i 2 1 +i 2 - 2 +i 2 -
casinf128 2 +i 2 - - - -


Chapter 19: Mathematics 571

casinhf 2 +i 1 1 +i 1 2 +i 1 2 +i 1 2 +i 1
casinh 2 +i 1 1 +i 1 2 +i 1 2 +i 1 2 +i 1
casinhl 2 +i 1 2 +i 1 - 2 +i 2 -
casinhf128 2 +i 2 - - - -
catanf 0 +i 1 0 +i 1 1 +i 1 1 +i 1 1 +i 1
catan 1 +i 1 0 +i 1 1 +i 1 1 +i 1 1 +i 1
catanl 0 +i 1 1 +i 1 - 1 +i 1 -
catanf128 1 +i 1 - - - -
catanhf 1 +i 0 1 +i 0 1 +i 1 1 +i 1 1 +i 1
catanh 1 +i 1 1 +i 0 1 +i 1 1 +i 1 1 +i 1
catanhl 1 +i 0 1 +i 1 - 1 +i 1 -
catanhf128 1 +i 1 - - - -
cbrtf - 1 1 1 1
cbrt - 1 4 4 3
cbrtl - 1 - 1 -
cbrtf128 1 - - - -
ccosf 0 +i 1 - 1 +i 1 1 +i 1 1 +i 1
ccos 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
ccosl 1 +i 1 1 +i 1 - 1 +i 1 -
ccosf128 1 +i 1 - - - -
ccoshf 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
ccosh 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
ccoshl 0 +i 1 0 +i 1 - 1 +i 1 -
ccoshf128 1 +i 1 - - - -
cexpf 1 +i 2 - 1 +i 2 1 +i 2 1 +i 2
cexp 2 +i 1 - 2 +i 1 2 +i 1 2 +i 1
cexpl 1 +i 1 1 +i 1 - 1 +i 1 -
cexpf128 1 +i 1 - - - -
clogf 3 +i 0 2 +i 1 3 +i 1 3 +i 1 3 +i 1
clog 2 +i 1 3 +i 1 3 +i 0 3 +i 0 3 +i 0
clogl 2 +i 1 3 +i 1 - 2 +i 1 -
clogf128 2 +i 1 - - - -
clog10f 4 +i 1 2 +i 1 4 +i 2 4 +i 2 4 +i 2
clog10 3 +i 2 2 +i 1 3 +i 2 3 +i 2 3 +i 2
clog10l 2 +i 1 3 +i 2 - 2 +i 2 -
clog10f128 2 +i 2 - - - -
cosf 1 - 1 1 1
cos 1 1 1 1 -
cosl - - - 1 -
cosf128 1 - - - -
coshf - - 2 2 1
cosh - - 2 2 1
coshl - - - 1 -
coshf128 1 - - - -
cpowf 5 +i 2 3 +i 5 5 +i 2 5 +i 2 4 +i 2
cpow 2 +i 0 1 +i 0 2 +i 0 2 +i 0 2 +i 0
cpowl 3 +i 4 3 +i 1 - 4 +i 1 -


Chapter 19: Mathematics 572

cpowf128 4 +i 1 - - - -
csinf 1 +i 1 - 1 +i 0 1 +i 0 1 +i 0
csin 1 +i 0 - 1 +i 0 1 +i 0 1 +i 0
csinl 1 +i 0 1 +i 0 - 1 +i 1 -
csinf128 1 +i 1 - - - -
csinhf 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
csinh 1 +i 1 - 0 +i 1 0 +i 1 0 +i 1
csinhl 1 +i 1 1 +i 0 - 1 +i 1 -
csinhf128 1 +i 1 - - - -
csqrtf 2 +i 2 1 +i 1 2 +i 2 2 +i 2 2 +i 2
csqrt 2 +i 2 1 +i 1 2 +i 2 2 +i 2 2 +i 2
csqrtl 2 +i 2 2 +i 2 - 2 +i 2 -
csqrtf128 2 +i 2 - - - -
ctanf 1 +i 1 1 +i 1 1 +i 2 1 +i 2 1 +i 1
ctan 1 +i 2 1 +i 1 1 +i 2 1 +i 2 1 +i 2
ctanl 2 +i 2 2 +i 2 - 3 +i 3 -
ctanf128 3 +i 3 - - - -
ctanhf 1 +i 1 1 +i 2 2 +i 2 2 +i 2 1 +i 2
ctanh 2 +i 2 1 +i 1 2 +i 2 2 +i 2 2 +i 2
ctanhl 1 +i 2 2 +i 2 - 3 +i 3 -
ctanhf128 3 +i 3 - - - -
divldoublef - - - - -
divldouble - - - - -
divldoublel - - - - -
divldoublef128- - - - -
erff - 1 1 1 1
erf - - 1 1 1
erfl - 1 - 1 -
erff128 1 - - - -
erfcf - 1 3 3 2
erfc - - 5 5 3
erfcl - 2 - 2 -
erfcf128 2 - - - -
expf 1 - 1 1 1
exp - - 1 1 -
expl - - - 1 -
expf128 1 - - - -
exp10f 1 - 1 1 -
exp10 - - 2 2 2
exp10l - - - 2 -
exp10f128 2 - - - -
exp2f - - 1 1 1
exp2 1 1 1 1 1
exp2l 1 - - 1 -
exp2f128 1 - - - -
expm1f - - 1 1 1
expm1 1 - 1 1 1


Chapter 19: Mathematics 573

expm1l 1 - - 1 -
expm1f128 1 - - - -
fmaf - - - - -
fma - - - - -
fmal - - - - -
fmaf128 - - - - -
fmodf - - - - -
fmod - - - - -
fmodl - - - - -
fmodf128 - - - - -
gammaf 1 1 7 7 4
gamma - - 4 4 4
gammal - 2 - 5 -
gammaf128 - - - - -
hypotf - - - - -
hypot - 1 1 1 1
hypotl - 1 - 1 -
hypotf128 1 - - - -
j0f 8 2 8 8 2
j0 2 1 2 2 2
j0l 2 2 - 2 -
j0f128 2 - - - -
j1f 8 2 9 9 2
j1 2 - 2 2 1
j1l 5 1 - 4 -
j1f128 4 - - - -
jnf 4 2 4 4 4
jn 4 2 4 4 4
jnl 4 4 - 7 -
jnf128 7 - - - -
lgammaf 1 1 7 7 4
lgamma - - 4 4 4
lgammal - 2 - 5 -
lgammaf128 5 - - - -
logf - - 1 1 1
log - - - - -
logl - - - 1 -
logf128 1 - - - -
log10f - - 2 2 2
log10 - - 2 2 2
log10l - - - 1 -
log10f128 1 - - - -
log1pf - - 1 1 1
log1p - - 1 1 1
log1pl - - - 2 -
log1pf128 2 - - - -
log2f - - 1 1 1


Chapter 19: Mathematics 574

log2 - - 2 2 2
log2l - - - 2 -
log2f128 2 - - - -
mulldoublef - - - - -
mulldouble - - - - -
mulldoublel - - - - -
mulldoublef128- - - - -
powf - 7 1 1 1
pow - 1 1 1 -
powl - 9 - 2 -
powf128 2 - - - -
pow10f - - - - -
pow10 - - - - -
pow10l - - - - -
pow10f128 - - - - -
sinf - - 1 1 1
sin 1 1 1 1 -
sinl - - - 1 -
sinf128 1 - - - -
sincosf - - 1 1 1
sincos 1 - 1 1 -
sincosl - - - 1 -
sincosf128 1 - - - -
sinhf - - 2 2 2
sinh - - 2 2 2
sinhl - - - 2 -
sinhf128 2 - - - -
sqrtf - - - - -
sqrt - - - - -
sqrtl - - - - -
sqrtf128 - - - - -
subldoublef - - - - -
subldouble - - - - -
subldoublel - - - - -
subldoublef128- - - - -
tanf - - 1 1 1
tan - - - - -
tanl 1 - - 1 -
tanf128 1 - - - -
tanhf - - 2 2 2
tanh - - 2 2 2
tanhl - - - 2 -
tanhf128 2 - - - -
tgammaf - 4 8 8 4
tgamma - 1 9 9 5
tgammal 1 9 - 4 -
tgammaf128 4 - - - -


Chapter 19: Mathematics 575

y0f 6 1 8 8 1
y0 2 1 3 3 2
y0l 1 1 - 3 -
y0f128 3 - - - -
y1f 2 3 2 2 2
y1 3 1 3 3 3
y1l 2 2 - 2 -
y1f128 2 - - - -
ynf 3 3 3 3 2
yn 3 2 3 3 3
ynl 3 4 - 5 -
ynf128 5 - - - -

Function Nios II PowerPC PowerPC
soft-float

RISC-V RISC-V soft-
float
acosf 1 1 1 1 1
acos - - - - -
acosl - 1 1 1 1
acosf128 - 1 - - -
acoshf 2 2 2 2 2
acosh 2 2 2 2 2
acoshl - 2 1 2 2
acoshf128 - 2 - - -
addldoublef - 1 1 - -
addldouble - 1 1 - -
addldoublel - - - - -
addldoublef128- - - - -
asinf 1 1 1 1 1
asin - - - - -
asinl - 2 2 1 1
asinf128 - 1 - - -
asinhf 2 2 2 2 1
asinh 1 2 2 1 1
asinhl - 2 2 3 3
asinhf128 - 3 - - -
atanf 1 1 1 1 1
atan - 1 - - -
atanl - 1 1 1 1
atanf128 - 1 - - -
atan2f 1 1 1 1 1
atan2 - - - - -
atan2l - 2 2 1 1
atan2f128 - 1 - - -
atanhf 2 2 2 2 2
atanh 2 2 2 2 2
atanhl - 2 2 3 3
atanhf128 - 3 - - -


Chapter 19: Mathematics 576

cabsf - - - - -
cabs 1 1 1 1 1
cabsl - 1 1 1 1
cabsf128 - 1 - - -
cacosf 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
cacos 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
cacosl - 1 +i 2 2 +i 1 2 +i 2 2 +i 2
cacosf128 - 2 +i 2 - - -
cacoshf 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
cacosh 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
cacoshl - 2 +i 1 1 +i 2 2 +i 2 2 +i 2
cacoshf128 - 2 +i 2 - - -
cargf 1 1 1 1 1
carg - 1 - - -
cargl - 2 2 2 2
cargf128 - 2 - - -
casinf 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
casin 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
casinl - 1 +i 2 2 +i 1 2 +i 2 2 +i 2
casinf128 - 2 +i 2 - - -
casinhf 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
casinh 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
casinhl - 2 +i 1 1 +i 2 2 +i 2 2 +i 2
casinhf128 - 2 +i 2 - - -
catanf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
catan 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
catanl - 3 +i 2 3 +i 2 1 +i 1 1 +i 1
catanf128 - 1 +i 1 - - -
catanhf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
catanh 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
catanhl - 2 +i 3 2 +i 3 1 +i 1 1 +i 1
catanhf128 - 1 +i 1 - - -
cbrtf 1 1 1 1 1
cbrt 3 4 4 3 3
cbrtl - 1 1 1 1
cbrtf128 - 1 - - -
ccosf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccos 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccosl - 1 +i 2 1 +i 2 1 +i 1 1 +i 1
ccosf128 - 1 +i 1 - - -
ccoshf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccosh 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccoshl - 1 +i 2 1 +i 2 1 +i 1 1 +i 1
ccoshf128 - 1 +i 1 - - -
cexpf 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
cexp 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
cexpl - 2 +i 2 1 +i 1 1 +i 1 1 +i 1


Chapter 19: Mathematics 577

cexpf128 - 1 +i 1 - - -
clogf 3 +i 1 3 +i 1 3 +i 1 3 +i 1 3 +i 1
clog 3 +i 0 3 +i 1 3 +i 0 3 +i 0 3 +i 0
clogl - 5 +i 2 2 +i 2 2 +i 1 2 +i 1
clogf128 - 2 +i 1 - - -
clog10f 4 +i 2 4 +i 2 4 +i 2 4 +i 2 4 +i 2
clog10 3 +i 2 3 +i 2 3 +i 2 3 +i 2 3 +i 2
clog10l - 3 +i 2 3 +i 2 2 +i 2 2 +i 2
clog10f128 - 2 +i 2 - - -
cosf 1 3 1 1 -
cos 1 1 1 1 1
cosl - 4 4 1 1
cosf128 - 1 - - -
coshf 2 2 2 2 1
cosh 1 2 2 1 1
coshl - 3 3 1 1
coshf128 - 1 - - -
cpowf 5 +i 2 5 +i 2 5 +i 2 5 +i 2 5 +i 2
cpow 2 +i 0 2 +i 0 2 +i 0 2 +i 0 2 +i 0
cpowl - 4 +i 2 4 +i 1 4 +i 1 4 +i 1
cpowf128 - 4 +i 1 - - -
csinf 1 +i 0 1 +i 0 1 +i 0 1 +i 0 1 +i 0
csin 1 +i 0 1 +i 0 1 +i 0 1 +i 0 1 +i 0
csinl - 2 +i 1 2 +i 1 1 +i 1 1 +i 1
csinf128 - 1 +i 1 - - -
csinhf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
csinh 0 +i 1 0 +i 1 0 +i 1 0 +i 1 0 +i 1
csinhl - 1 +i 2 1 +i 2 1 +i 1 1 +i 1
csinhf128 - 1 +i 1 - - -
csqrtf 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
csqrt 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
csqrtl - 1 +i 1 1 +i 1 2 +i 2 2 +i 2
csqrtf128 - 2 +i 2 - - -
ctanf 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
ctan 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
ctanl - 3 +i 2 3 +i 2 3 +i 3 3 +i 3
ctanf128 - 3 +i 3 - - -
ctanhf 2 +i 2 2 +i 1 2 +i 2 2 +i 1 2 +i 2
ctanh 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
ctanhl - 3 +i 3 2 +i 3 3 +i 3 3 +i 3
ctanhf128 - 3 +i 3 - - -
divldoublef - 1 1 - -
divldouble - - - - -
divldoublel - - - - -
divldoublef128- - - - -
erff 1 1 1 1 1
erf 1 1 1 1 1


Chapter 19: Mathematics 578

erfl - 1 1 1 1
erff128 - 1 - - -
erfcf 3 2 3 2 2
erfc 3 2 5 2 3
erfcl - 3 3 2 2
erfcf128 - 2 - - -
expf 1 1 1 1 -
exp - 1 1 - -
expl - 1 1 1 1
expf128 - 1 - - -
exp10f - 1 - - -
exp10 2 2 2 2 2
exp10l - 1 1 2 2
exp10f128 - 2 - - -
exp2f 1 - 1 - -
exp2 1 1 1 1 1
exp2l - 2 1 1 1
exp2f128 - 1 - - -
expm1f 1 1 1 1 1
expm1 1 1 1 1 1
expm1l - 1 1 1 1
expm1f128 - 1 - - -
fmaf - - - - -
fma - - - - -
fmal - 1 1 - -
fmaf128 - - - - -
fmodf - - - - -
fmod - - - - -
fmodl - 1 1 - -
fmodf128 - - - - -
gammaf 7 4 7 3 3
gamma 4 3 4 3 4
gammal - 3 3 5 5
gammaf128 - 5 - - -
hypotf - - - - -
hypot 1 1 1 1 1
hypotl - 1 1 1 1
hypotf128 - 1 - - -
j0f 8 8 8 8 2
j0 2 2 2 2 2
j0l - 2 2 2 2
j0f128 - 2 - - -
j1f 9 8 9 8 2
j1 2 2 2 2 1
j1l - 3 3 4 4
j1f128 - 4 - - -
jnf 4 4 4 4 4


Chapter 19: Mathematics 579

jn 4 4 4 4 4
jnl - 4 4 7 7
jnf128 - 7 - - -
lgammaf 7 4 7 3 3
lgamma 4 3 4 3 4
lgammal - 3 3 5 5
lgammaf128 - 5 - - -
logf 1 1 1 - -
log - 1 - - -
logl - 1 1 1 1
logf128 - 1 - - -
log10f 2 2 2 2 2
log10 2 2 2 2 2
log10l - 1 1 1 1
log10f128 - 1 - - -
log1pf 1 1 1 1 1
log1p 1 1 1 1 1
log1pl - 2 2 2 2
log1pf128 - 2 - - -
log2f 1 1 1 1 1
log2 2 1 2 1 2
log2l - 1 1 2 2
log2f128 - 2 - - -
mulldoublef - 1 1 - -
mulldouble - 1 1 - -
mulldoublel - - - - -
mulldoublef128- - - - -
powf 3 1 1 - -
pow 1 1 1 1 1
powl - 1 1 2 2
powf128 - 2 - - -
pow10f - - - - -
pow10 - - - - -
pow10l - - - - -
pow10f128 - - - - -
sinf 1 1 1 1 -
sin 1 1 1 1 1
sinl - 1 1 1 1
sinf128 - 1 - - -
sincosf 1 1 1 - -
sincos 1 1 1 1 1
sincosl - 1 1 1 1
sincosf128 - 1 - - -
sinhf 2 2 2 2 2
sinh 2 2 2 2 2
sinhl - 3 3 2 2
sinhf128 - 2 - - -


Chapter 19: Mathematics 580

sqrtf - - - - -
sqrt - - - - -
sqrtl - 1 1 - -
sqrtf128 - - - - -
subldoublef - 1 1 - -
subldouble - 1 1 - -
subldoublel - - - - -
subldoublef128- - - - -
tanf 1 3 1 1 1
tan - - - - -
tanl - 2 2 1 1
tanf128 - 1 - - -
tanhf 2 2 2 2 2
tanh 2 2 2 2 2
tanhl - 1 1 2 2
tanhf128 - 2 - - -
tgammaf 8 8 8 8 4
tgamma 5 9 9 5 5
tgammal - 5 4 4 4
tgammaf128 - 4 - - -
y0f 8 6 8 6 1
y0 3 2 3 2 2
y0l - 1 2 3 3
y0f128 - 3 - - -
y1f 2 2 2 2 2
y1 3 3 3 3 3
y1l - 2 2 2 2
y1f128 - 2 - - -
ynf 3 3 3 3 3
yn 3 3 3 3 3
ynl - 2 2 5 5
ynf128 - 5 - - -

Function S/390 SH Sparc i686 ix86
acosf 1 1 1 - -
acos - - - 1 1
acosl 1 - 1 1 1
acosf128 - - - 1 1
acoshf 2 2 2 - -
acosh 2 2 2 1 1
acoshl 2 - 2 2 2
acoshf128 - - - 2 2
addldoublef - - - - -
addldouble - - - - -
addldoublel - - - - -
addldoublef128- - - - -
asinf 1 1 1 - -


Chapter 19: Mathematics 581

asin - - - 1 1
asinl 1 - 1 1 1
asinf128 - - - 1 1
asinhf 2 2 2 - -
asinh 2 2 2 1 1
asinhl 3 - 3 3 3
asinhf128 - - - 3 3
atanf 1 1 1 - -
atan - - - 1 1
atanl 1 - 1 1 1
atanf128 - - - 1 1
atan2f 1 1 1 - -
atan2 - - - 1 1
atan2l 1 - 1 1 1
atan2f128 - - - 1 1
atanhf 2 2 2 - -
atanh 2 2 2 1 1
atanhl 3 - 3 3 3
atanhf128 - - - 3 3
cabsf - - - - -
cabs 1 1 1 1 1
cabsl 1 - 1 1 1
cabsf128 - - - 1 1
cacosf 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
cacos 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
cacosl 2 +i 2 - 2 +i 2 1 +i 2 1 +i 2
cacosf128 - - - 2 +i 2 2 +i 2
cacoshf 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
cacosh 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
cacoshl 2 +i 2 - 2 +i 2 2 +i 1 2 +i 1
cacoshf128 - - - 2 +i 2 2 +i 2
cargf 1 1 1 - -
carg - - - 1 1
cargl 2 - 2 1 1
cargf128 - - - 2 2
casinf 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
casin 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
casinl 2 +i 2 - 2 +i 2 1 +i 2 1 +i 2
casinf128 - - - 2 +i 2 2 +i 2
casinhf 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
casinh 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
casinhl 2 +i 2 - 2 +i 2 2 +i 1 2 +i 1
casinhf128 - - - 2 +i 2 2 +i 2
catanf 1 +i 1 1 +i 1 1 +i 1 0 +i 1 0 +i 1
catan 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
catanl 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
catanf128 - - - 1 +i 1 1 +i 1


Chapter 19: Mathematics 582

catanhf 1 +i 1 1 +i 1 1 +i 1 1 +i 0 1 +i 0
catanh 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
catanhl 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
catanhf128 - - - 1 +i 1 1 +i 1
cbrtf 1 1 1 1 1
cbrt 4 4 4 1 1
cbrtl 1 - 1 3 3
cbrtf128 - - - 1 1
ccosf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccos 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccosl 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
ccosf128 - - - 1 +i 1 1 +i 1
ccoshf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccosh 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
ccoshl 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
ccoshf128 - - - 1 +i 1 1 +i 1
cexpf 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
cexp 2 +i 1 2 +i 1 2 +i 1 2 +i 1 2 +i 1
cexpl 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1
cexpf128 - - - 1 +i 1 1 +i 1
clogf 3 +i 1 3 +i 1 3 +i 1 3 +i 0 3 +i 0
clog 3 +i 0 3 +i 0 3 +i 0 2 +i 1 2 +i 1
clogl 2 +i 1 - 4 +i 1 3 +i 1 3 +i 1
clogf128 - - - 2 +i 1 2 +i 1
clog10f 4 +i 2 4 +i 2 4 +i 2 4 +i 1 4 +i 1
clog10 3 +i 2 3 +i 2 3 +i 2 3 +i 2 3 +i 2
clog10l 2 +i 2 - 4 +i 2 4 +i 2 4 +i 2
clog10f128 - - - 2 +i 2 2 +i 2
cosf 1 1 1 - 1
cos 1 1 1 1 1
cosl 1 - 1 1 1
cosf128 - - - 1 1
coshf 2 2 2 2 2
cosh 2 2 2 1 1
coshl 1 - 1 2 2
coshf128 - - - 1 1
cpowf 5 +i 2 5 +i 2 5 +i 2 5 +i 2 5 +i 2
cpow 2 +i 0 2 +i 0 2 +i 0 2 +i 1 2 +i 0
cpowl 4 +i 1 - 4 +i 1 3 +i 4 3 +i 4
cpowf128 - - - 4 +i 1 4 +i 1
csinf 1 +i 0 1 +i 0 1 +i 0 1 +i 1 1 +i 1
csin 1 +i 0 1 +i 0 1 +i 0 1 +i 1 1 +i 0
csinl 1 +i 1 - 1 +i 1 1 +i 0 1 +i 0
csinf128 - - - 1 +i 1 1 +i 1
csinhf 1 +i 1 1 +i 1 1 +i 1 1 +i 1 1 +i 1
csinh 0 +i 1 0 +i 1 0 +i 1 1 +i 1 0 +i 1
csinhl 1 +i 1 - 1 +i 1 1 +i 1 1 +i 1


Chapter 19: Mathematics 583

csinhf128 - - - 1 +i 1 1 +i 1
csqrtf 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
csqrt 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
csqrtl 2 +i 2 - 2 +i 2 2 +i 2 2 +i 2
csqrtf128 - - - 2 +i 2 2 +i 2
ctanf 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
ctan 1 +i 2 1 +i 2 1 +i 2 1 +i 2 1 +i 2
ctanl 3 +i 3 - 3 +i 3 2 +i 1 2 +i 1
ctanf128 - - - 3 +i 3 3 +i 3
ctanhf 2 +i 1 2 +i 2 2 +i 2 2 +i 2 2 +i 2
ctanh 2 +i 2 2 +i 2 2 +i 2 2 +i 2 2 +i 2
ctanhl 3 +i 3 - 3 +i 3 1 +i 2 1 +i 2
ctanhf128 - - - 3 +i 3 3 +i 3
divldoublef - - - - -
divldouble - - - - -
divldoublel - - - - -
divldoublef128- - - - -
erff 1 1 1 1 1
erf 1 1 1 1 1
erfl 1 - 1 1 1
erff128 - - - 1 1
erfcf 2 2 3 2 3
erfc 2 5 5 3 3
erfcl 2 - 2 3 3
erfcf128 - - - 2 2
expf 1 1 1 1 1
exp 1 1 1 1 1
expl 1 - 1 1 1
expf128 - - - 1 1
exp10f 1 - 1 - -
exp10 2 2 2 1 1
exp10l 2 - 2 1 1
exp10f128 - - - 2 2
exp2f - - 1 - -
exp2 1 1 1 1 1
exp2l 1 - 1 1 1
exp2f128 - - - 1 1
expm1f 1 1 1 - -
expm1 1 1 1 1 1
expm1l 1 - 1 2 2
expm1f128 - - - 1 1
fmaf - - - - -
fma - - - - -
fmal - - - - -
fmaf128 - - - - -
fmodf - - - - -
fmod - - - - -


Chapter 19: Mathematics 584

fmodl - - - - -
fmodf128 - - - - -
gammaf 3 3 7 3 5
gamma 3 4 4 4 4
gammal 5 - 5 4 4
gammaf128 - - - - -
hypotf - - - - -
hypot 1 1 1 1 1
hypotl 1 - 1 1 1
hypotf128 - - - 1 1
j0f 8 8 8 5 8
j0 2 2 2 2 2
j0l 2 - 2 2 2
j0f128 - - - 2 2
j1f 8 8 9 5 9
j1 2 2 2 2 2
j1l 4 - 4 5 5
j1f128 - - - 4 4
jnf 4 4 4 4 4
jn 4 4 4 4 4
jnl 7 - 7 4 4
jnf128 - - - 7 7
lgammaf 3 3 7 3 5
lgamma 3 4 4 4 4
lgammal 5 - 5 4 4
lgammaf128 - - - 5 5
logf - 1 1 - -
log 1 - - 1 1
logl 1 - 1 1 1
logf128 - - - 1 1
log10f 2 2 2 - -
log10 2 2 2 1 1
log10l 1 - 1 1 1
log10f128 - - - 1 1
log1pf 1 1 1 - -
log1p 1 1 1 1 1
log1pl 2 - 2 2 2
log1pf128 - - - 2 2
log2f 1 1 1 1 1
log2 - 2 2 1 1
log2l 2 - 2 1 1
log2f128 - - - 2 2
mulldoublef - - - - -
mulldouble - - - - -
mulldoublel - - - - -
mulldoublef128- - - - -
powf - 1 3 - -


Chapter 19: Mathematics 585

pow 1 1 1 1 1
powl 2 - 2 1 1
powf128 - - - 2 2
pow10f - - - - -
pow10 - - - - -
pow10l - - - - -
pow10f128 - - - - -
sinf 1 1 1 - 1
sin 1 1 1 1 1
sinl 1 - 1 1 1
sinf128 - - - 1 1
sincosf - 1 1 - 1
sincos 1 1 1 1 1
sincosl 1 - 1 1 1
sincosf128 - - - 1 1
sinhf 2 2 2 2 2
sinh 2 2 2 2 2
sinhl 2 - 2 2 2
sinhf128 - - - 2 2
sqrtf - - - - -
sqrt - - - - -
sqrtl - - - - -
sqrtf128 - - - - -
subldoublef - - - - -
subldouble - - - - -
subldoublel - - - - -
subldoublef128- - - - -
tanf 1 1 1 1 1
tan - - - - -
tanl 1 - 1 2 2
tanf128 - - - 1 1
tanhf 2 2 2 2 2
tanh 2 2 2 2 2
tanhl 2 - 2 3 3
tanhf128 - - - 2 2
tgammaf 8 8 8 4 8
tgamma 9 9 9 6 6
tgammal 4 - 4 5 5
tgammaf128 - - - 4 4
y0f 6 6 8 1 8
y0 2 3 3 2 3
y0l 3 - 3 1 1
y0f128 - - - 3 3
y1f 2 2 2 2 2
y1 3 3 3 3 3
y1l 2 - 2 3 2
y1f128 - - - 5 2


Chapter 19: Mathematics 586

ynf 3 3 3 3 3
yn 3 3 3 3 3
ynl 5 - 5 4 4
ynf128 - - - 5 5

Function x86 64
acosf 1
acos -
acosl 1
acosf128 1
acoshf 2
acosh 2
acoshl 2
acoshf128 2
addldoublef -
addldouble -
addldoublel -
addldoublef128-
asinf 1
asin -
asinl 1
asinf128 1
asinhf 2
asinh 2
asinhl 3
asinhf128 3
atanf 1
atan -
atanl 1
atanf128 1
atan2f 1
atan2 -
atan2l 1
atan2f128 1
atanhf 2
atanh 2
atanhl 3
atanhf128 3
cabsf -
cabs 1
cabsl 1
cabsf128 1
cacosf 2 +i 2
cacos 1 +i 2
cacosl 1 +i 2
cacosf128 2 +i 2
cacoshf 2 +i 2


Chapter 19: Mathematics 587

cacosh 2 +i 1
cacoshl 2 +i 1
cacoshf128 2 +i 2
cargf 1
carg -
cargl 1
cargf128 2
casinf 1 +i 2
casin 1 +i 2
casinl 1 +i 2
casinf128 2 +i 2
casinhf 2 +i 1
casinh 2 +i 1
casinhl 2 +i 1
casinhf128 2 +i 2
catanf 1 +i 1
catan 1 +i 1
catanl 1 +i 1
catanf128 1 +i 1
catanhf 1 +i 1
catanh 1 +i 1
catanhl 1 +i 1
catanhf128 1 +i 1
cbrtf 1
cbrt 4
cbrtl 1
cbrtf128 1
ccosf 1 +i 1
ccos 1 +i 1
ccosl 1 +i 1
ccosf128 1 +i 1
ccoshf 1 +i 1
ccosh 1 +i 1
ccoshl 1 +i 1
ccoshf128 1 +i 1
cexpf 1 +i 2
cexp 2 +i 1
cexpl 1 +i 1
cexpf128 1 +i 1
clogf 3 +i 1
clog 3 +i 0
clogl 3 +i 1
clogf128 2 +i 1
clog10f 4 +i 2
clog10 3 +i 2
clog10l 4 +i 2
clog10f128 2 +i 2


Chapter 19: Mathematics 588

cosf 1
cos 1
cosl 1
cosf128 1
coshf 2
cosh 2
coshl 2
coshf128 1
cpowf 5 +i 2
cpow 2 +i 0
cpowl 3 +i 4
cpowf128 4 +i 1
csinf 1 +i 0
csin 1 +i 0
csinl 1 +i 0
csinf128 1 +i 1
csinhf 1 +i 1
csinh 0 +i 1
csinhl 1 +i 1
csinhf128 1 +i 1
csqrtf 2 +i 2
csqrt 2 +i 2
csqrtl 2 +i 2
csqrtf128 2 +i 2
ctanf 1 +i 2
ctan 1 +i 2
ctanl 2 +i 1
ctanf128 3 +i 3
ctanhf 2 +i 2
ctanh 2 +i 2
ctanhl 1 +i 2
ctanhf128 3 +i 3
divldoublef -
divldouble -
divldoublel -
divldoublef128-
erff 1
erf 1
erfl 1
erff128 1
erfcf 3
erfc 5
erfcl 3
erfcf128 2
expf 1
exp 1
expl 1


Chapter 19: Mathematics 589

expf128 1
exp10f 1
exp10 2
exp10l 1
exp10f128 2
exp2f 1
exp2 1
exp2l 1
exp2f128 1
expm1f 1
expm1 1
expm1l 2
expm1f128 1
fmaf -
fma -
fmal -
fmaf128 -
fmodf -
fmod -
fmodl -
fmodf128 -
gammaf 7
gamma 4
gammal 4
gammaf128 -
hypotf -
hypot 1
hypotl 1
hypotf128 1
j0f 8
j0 2
j0l 2
j0f128 2
j1f 9
j1 2
j1l 5
j1f128 4
jnf 4
jn 4
jnl 4
jnf128 7
lgammaf 7
lgamma 4
lgammal 4
lgammaf128 5
logf 1
log 1


Chapter 19: Mathematics 590

logl 1
logf128 1
log10f 2
log10 2
log10l 1
log10f128 1
log1pf 1
log1p 1
log1pl 2
log1pf128 2
log2f 1
log2 2
log2l 1
log2f128 2
mulldoublef -
mulldouble -
mulldoublel -
mulldoublef128-
powf 1
pow 1
powl 1
powf128 2
pow10f -
pow10 -
pow10l -
pow10f128 -
sinf 1
sin 1
sinl 1
sinf128 1
sincosf -
sincos 1
sincosl 1
sincosf128 1
sinhf 2
sinh 2
sinhl 2
sinhf128 2
sqrtf -
sqrt -
sqrtl -
sqrtf128 -
subldoublef -
subldouble -
subldoublel -
subldoublef128-
tanf 1


Chapter 19: Mathematics 591

tan -
tanl 2
tanf128 1
tanhf 2
tanh 2
tanhl 3
tanhf128 2
tgammaf 8
tgamma 9
tgammal 5
tgammaf128 4
y0f 8
y0 3
y0l 1
y0f128 3
y1f 9
y1 6
y1l 3
y1f128 5
ynf 3
yn 3
ynl 4
ynf128 5

## 19.8 Pseudo-Random Numbers...................................

This section describes the GNU facilities for generating a series of pseudo-random numbers.
The numbers generated are not truly random; typically, they form a sequence that repeats
periodically, with a period so large that you can ignore it for ordinary purposes. The random
number generator works by remembering aseedvalue which it uses to compute the next
random number and also to compute a new seed.

Although the generated numbers look unpredictable within one run of a program, the
sequence of numbers isexactly the same from one run to the next. This is because the
initial seed is always the same. This is convenient when you are debugging a program, but
it is unhelpful if you want the program to behave unpredictably. If you want a different
pseudo-random series each time your program runs, you must specify a different seed each
time. For ordinary purposes, basing the seed on the current time works well. For random
numbers in cryptography, seeSection 33.2 [Generating Unpredictable Bytes], page 916.

You can obtain repeatable sequences of numbers on a particular machine type by spec-
ifying the same initial seed value for the random number generator. There is no standard
meaning for a particular seed value; the same seed, used in different C libraries or on
different CPU types, will give you different random numbers.

The GNU C Library supports the standard ISO C random number functions plus two
other sets derived from BSD and SVID. The BSD and ISO C functions provide identical,
somewhat limited functionality. If only a small number of random bits are required, we
recommend you use the ISO C interface,randandsrand. The SVID functions provide a
more flexible interface, which allows better random number generator algorithms, provides


Chapter 19: Mathematics 592

more random bits (up to 48) per call, and can provide random floating-point numbers.
These functions are required by the XPG standard and therefore will be present in all
modern Unix systems.

## 19.8.1 ISO C Random Number Functions......................

This section describes the random number functions that are part of the ISO C standard.

```
To use these facilities, you should include the header filestdlib.hin your program.
```
int RAND_MAX [Macro]
The value of this macro is an integer constant representing the largest value therand
function can return. In the GNU C Library, it is 2147483647 , which is the largest
signed integer representable in 32 bits. In other libraries, it may be as low as 32767.

int rand (void) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Therandfunction returns the next pseudo-random number in the series. The value
ranges from 0 toRAND_MAX.

void srand(unsigned intseed) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function establishesseedas the seed for a new series of pseudo-random numbers.
If you callrandbefore a seed has been established withsrand, it uses the value 1 as
a default seed.
To produce a different pseudo-random series each time your program is run, dosrand
(time (0)).

POSIX.1 extended the C standard functions to support reproducible random numbers
in multi-threaded programs. However, the extension is badly designed and unsuitable for
serious work.

int rand_r(unsigned int *seed) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns a random number in the range 0 toRAND_MAXjust asranddoes.
However, all its state is stored in theseedargument. This means the RNG¡¯s state can
only have as many bits as the typeunsigned inthas. This is far too few to provide
a good RNG.
If your program requires a reentrant RNG, we recommend you use the reentrant
GNU extensions to the SVID random number generator. The POSIX.1 interface
should only be used when the GNU extensions are not available.

## 19.8.2 BSD Random Number Functions.......................

This section describes a set of random number generation functions that are derived from
BSD. There is no advantage to using these functions with the GNU C Library; we support
them for BSD compatibility only.

```
The prototypes for these functions are instdlib.h.
```

Chapter 19: Mathematics 593

long int random (void) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function returns the next pseudo-random number in the sequence. The value
returned ranges from 0 to 2147483647.
NB:Temporarily this function was defined to return aint32_tvalue to indicate that
the return value always contains 32 bits even iflong intis wider. The standard
demands it differently. Users must always be aware of the 32-bit limitation, though.

void srandom (unsigned intseed) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thesrandomfunction sets the state of the random number generator based on the
integerseed. If you supply aseedvalue of 1 , this will causerandomto reproduce the
default set of random numbers.
To produce a different set of pseudo-random numbers each time your program runs,
dosrandom (time (0)).

char * initstate (unsigned intseed, char *state, size tsize) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theinitstatefunction is used to initialize the random number generator state.
The argumentstateis an array ofsizebytes, used to hold the state information. It
is initialized based onseed. The size must be between 8 and 256 bytes, and should
be a power of two. The bigger thestatearray, the better.
The return value is the previous value of the state information array. You can use
this value later as an argument tosetstateto restore that state.

char * setstate (char *state) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thesetstatefunction restores the random number state informationstate. The
argument must have been the result of a previous call toinitstateorsetstate.
The return value is the previous value of the state information array. You can use
this value later as an argument tosetstateto restore that state.
If the function fails the return value isNULL.

The four functions described so far in this section all work on a state which is shared
by all threads. The state is not directly accessible to the user and can only be modified by
these functions. This makes it hard to deal with situations where each thread should have
its own pseudo-random number generator.

The GNU C Library contains four additional functions which contain the state as an
explicit parameter and therefore make it possible to handle thread-local PRNGs. Besides
this there is no difference. In fact, the four functions already discussed are implemented
internally using the following interfaces.

```
Thestdlib.hheader contains a definition of the following type:
```

Chapter 19: Mathematics 594

struct random_data [Data Type]
Objects of typestruct random_datacontain the information necessary to represent
the state of the PRNG. Although a complete definition of the type is present the type
should be treated as opaque.

```
The functions modifying the state follow exactly the already described functions.
```
int random_r (struct randomdata *restrictbuf, int32t *restrict [Function]
result)
Preliminary:|MT-Safe race:buf|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Therandom_rfunction behaves exactly like therandomfunction except that it uses
and modifies the state in the object pointed to by the first parameter instead of the
global state.

int srandom_r(unsigned intseed, struct randomdata *buf) [Function]
Preliminary:|MT-Safe race:buf|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thesrandom_rfunction behaves exactly like thesrandomfunction except that it uses
and modifies the state in the object pointed to by the second parameter instead of
the global state.

int initstate_r (unsigned intseed, char *restrictstatebuf, sizet [Function]
statelen, struct randomdata *restrictbuf)
Preliminary:|MT-Safe race:buf|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theinitstate_rfunction behaves exactly like theinitstatefunction except that
it uses and modifies the state in the object pointed to by the fourth parameter instead
of the global state.

int setstate_r(char *restrictstatebuf, struct randomdata [Function]
*restrictbuf)
Preliminary:|MT-Safe race:buf|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thesetstate_rfunction behaves exactly like thesetstatefunction except that it
uses and modifies the state in the object pointed to by the first parameter instead of
the global state.

## 19.8.3 SVID Random Number Function.......................

The C library on SVID systems contains yet another kind of random number generator
functions. They use a state of 48 bits of data. The user can choose among a collection of
functions which return the random bits in different forms.

Generally there are two kinds of function. The first uses a state of the random number
generator which is shared among several functions and by all threads of the process. The
second requires the user to handle the state.

All functions have in common that they use the same congruential formula with the
same constants. The formula is
Y = (a * X + c) mod m


Chapter 19: Mathematics 595

whereXis the state of the generator at the beginning andY the state at the end.aand
care constants determining the way the generator works. By default they are
a = 0x5DEECE66D = 25214903917
c = 0xb = 11

but they can also be changed by the user.mis of course 2^48 since the state consists of a
48-bit array.

```
The prototypes for these functions are instdlib.h.
```
double drand48(void) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns adoublevalue in the range of0.0to1.0(exclusive). The
random bits are determined by the global state of the random number generator in
the C library.
Since thedoubletype according to IEEE 754 has a 52-bit mantissa this means 4 bits
are not initialized by the random number generator. These are (of course) chosen to
be the least significant bits and they are initialized to 0.

double erand48(unsigned short intxsubi[ 3 ]) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns adoublevalue in the range of0.0to1.0(exclusive), similarly
todrand48. The argument is an array describing the state of the random number
generator.
This function can be called subsequently since it updates the array to guarantee
random numbers. The array should have been initialized before initial use to obtain
reproducible results.

long int lrand48 (void) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelrand48function returns an integer value in the range of 0 to2^31(exclusive).
Even if the size of thelong inttype can take more than 32 bits, no higher numbers
are returned. The random bits are determined by the global state of the random
number generator in the C library.

long int nrand48 (unsigned short intxsubi[ 3 ]) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar to thelrand48function in that it returns a number in the
range of 0 to2^31(exclusive) but the state of the random number generator used to
produce the random bits is determined by the array provided as the parameter to the
function.
The numbers in the array are updated afterwards so that subsequent calls to this
function yield different results (as is expected of a random number generator). The
array should have been initialized before the first call to obtain reproducible results.


Chapter 19: Mathematics 596

long int mrand48 (void) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Themrand48function is similar tolrand48. The only difference is that the numbers
returned are in the range-2^31to2^31(exclusive).

long int jrand48 (unsigned short intxsubi[ 3 ]) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thejrand48function is similar tonrand48. The only difference is that the numbers
returned are in the range-2^31to2^31(exclusive). For thexsubiparameter the
same requirements are necessary.

The internal state of the random number generator can be initialized in several ways.
The methods differ in the completeness of the information provided.

void srand48 (long intseedval) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesrand48function sets the most significant 32 bits of the internal state of the
random number generator to the least significant 32 bits of theseedvalparameter.
The lower 16 bits are initialized to the value0x330E. Even if thelong inttype
contains more than 32 bits only the lower 32 bits are used.
Owing to this limitation, initialization of the state of this function is not very useful.
But it makes it easy to use a construct likesrand48 (time (0)).
A side-effect of this function is that the valuesaandcfrom the internal state, which
are used in the congruential formula, are reset to the default values given above. This
is of importance once the user has called thelcong48function (see below).

unsigned short int * seed48 (unsigned short intseed16v[ 3 ]) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theseed48function initializes all 48 bits of the state of the internal random number
generator from the contents of the parameterseed16v. Here the lower 16 bits of the
first element ofseed16vinitialize the least significant 16 bits of the internal state, the
lower 16 bits ofseed16v[1]initialize the mid-order 16 bits of the state and the 16
lower bits ofseed16v[2]initialize the most significant 16 bits of the state.
Unlikesrand48this function lets the user initialize all 48 bits of the state.
The value returned byseed48is a pointer to an array containing the values of the
internal state before the change. This might be useful to restart the random number
generator at a certain state. Otherwise the value can simply be ignored.
As forsrand48, the valuesaandcfrom the congruential formula are reset to the
default values.

There is one more function to initialize the random number generator which enables
you to specify even more information by allowing you to change the parameters in the
congruential formula.


Chapter 19: Mathematics 597

void lcong48 (unsigned short intparam[ 7 ]) [Function]
Preliminary: |MT-Unsafe race:drand48|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelcong48function allows the user to change the complete state of the random
number generator. Unlikesrand48andseed48, this function also changes the con-
stants in the congruential formula.
From the seven elements in the arrayparamthe least significant 16 bits of the entries
param[0] toparam[2] determine the initial state, the least significant 16 bits of
param[3]toparam[5]determine the 48 bit constantaandparam[6]determines the
16-bit valuec.

All the above functions have in common that they use the global parameters for the
congruential formula. In multi-threaded programs it might sometimes be useful to have
different parameters in different threads. For this reason all the above functions have a
counterpart which works on a description of the random number generator in the user-
supplied buffer instead of the global state.

Please note that it is no problem if several threads use the global state if all threads use
the functions which take a pointer to an array containing the state. The random numbers
are computed following the same loop but if the state in the array is different all threads
will obtain an individual random number generator.

The user-supplied buffer must be of typestruct drand48_data. This type should be
regarded as opaque and not manipulated directly.

int drand48_r(struct drand48 data *buffer, double *result) [Function]
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is equivalent to thedrand48function with the difference that it does not
modify the global random number generator parameters but instead the parameters
in the buffer supplied through the pointerbuffer. The random number is returned in
the variable pointed to byresult.
The return value of the function indicates whether the call succeeded. If the value is
less than 0 an error occurred anderrnois set to indicate the problem.
This function is a GNU extension and should not be used in portable programs.

int erand48_r(unsigned short intxsubi[ 3 ], struct drand48 data [Function]
*buffer, double *result)
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theerand48_rfunction works likeerand48, but in addition it takes an argument
bufferwhich describes the random number generator. The state of the random num-
ber generator is taken from thexsubiarray, the parameters for the congruential
formula from the global random number generator data. The random number is
returned in the variable pointed to byresult.
The return value is non-negative if the call succeeded.
This function is a GNU extension and should not be used in portable programs.


Chapter 19: Mathematics 598

int lrand48_r(struct drand48 data *buffer, long int *result) [Function]
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tolrand48, but in addition it takes a pointer to a buffer
describing the state of the random number generator just likedrand48.
If the return value of the function is non-negative the variable pointed to byresult
contains the result. Otherwise an error occurred.
This function is a GNU extension and should not be used in portable programs.

int nrand48_r(unsigned short intxsubi[ 3 ], struct drand48 data [Function]
*buffer, long int *result)
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thenrand48_rfunction works likenrand48in that it produces a random number in
the range 0 to2^31. But instead of using the global parameters for the congruential
formula it uses the information from the buffer pointed to bybuffer. The state is
described by the values inxsubi.
If the return value is non-negative the variable pointed to byresultcontains the result.
This function is a GNU extension and should not be used in portable programs.

int mrand48_r(struct drand48 data *buffer, long int *result) [Function]
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tomrand48but like the other reentrant functions it uses the
random number generator described by the value in the buffer pointed to bybuffer.
If the return value is non-negative the variable pointed to byresultcontains the result.
This function is a GNU extension and should not be used in portable programs.

int jrand48_r(unsigned short intxsubi[ 3 ], struct drand48 data [Function]
*buffer, long int *result)
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thejrand48_rfunction is similar tojrand48. Like the other reentrant functions
of this function family it uses the congruential formula parameters from the buffer
pointed to bybuffer.
If the return value is non-negative the variable pointed to byresultcontains the result.
This function is a GNU extension and should not be used in portable programs.

Before any of the above functions are used the buffer of typestruct drand48_data
should be initialized. The easiest way to do this is to fill the whole buffer with null bytes,
e.g. by
memset (buffer, '\0', sizeof (struct drand48_data));

Using any of the reentrant functions of this family now will automatically initialize the
random number generator to the default values for the state and the parameters of the
congruential formula.


Chapter 19: Mathematics 599

The other possibility is to use any of the functions which explicitly initialize the buffer.
Though it might be obvious how to initialize the buffer from looking at the parameter to
the function, it is highly recommended to use these functions since the result might not
always be what you expect.

int srand48_r(long intseedval, struct drand48 data *buffer) [Function]
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The description of the random number generator represented by the information
inbufferis initialized similarly to what the functionsrand48 does. The state is
initialized from the parameterseedvaland the parameters for the congruential formula
are initialized to their default values.
If the return value is non-negative the function call succeeded.
This function is a GNU extension and should not be used in portable programs.

int seed48_r (unsigned short intseed16v[ 3 ], struct drand48 data [Function]
*buffer)
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tosrand48_rbut likeseed48it initializes all 48 bits of the
state from the parameterseed16v.
If the return value is non-negative the function call succeeded. It does not return a
pointer to the previous state of the random number generator like theseed48function
does. If the user wants to preserve the state for a later re-run s/he can copy the whole
buffer pointed to bybuffer.
This function is a GNU extension and should not be used in portable programs.

int lcong48_r(unsigned short intparam[ 7 ], struct drand48 data [Function]
*buffer)
Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function initializes all aspects of the random number generator described in
bufferwith the data in param. Here it is especially true that the function does
more than just copying the contents ofparamandbuffer. More work is required
and therefore it is important to use this function rather than initializing the random
number generator directly.
If the return value is non-negative the function call succeeded.
This function is a GNU extension and should not be used in portable programs.

## 19.9 Is Fast Code or Small Code preferred?.......................

If an application uses many floating point functions it is often the case that the cost of
the function calls themselves is not negligible. Modern processors can often execute the
operations themselves very fast, but the function call disrupts the instruction pipeline.

For this reason the GNU C Library provides optimizations for many of the frequently-
used math functions. When GNU CC is used and the user activates the optimizer, several


Chapter 19: Mathematics 600

new inline functions and macros are defined. These new functions and macros have the same
names as the library functions and so are used instead of the latter. In the case of inline
functions the compiler will decide whether it is reasonable to use them, and this decision is
usually correct.

This means that no calls to the library functions may be necessary, and can increase the
speed of generated code significantly. The drawback is that code size will increase, and the
increase is not always negligible.

There are two kinds of inline functions: those that give the same result as the library
functions and others that might not seterrnoand might have a reduced precision and/or
argument range in comparison with the library functions. The latter inline functions are
only available if the flag-ffast-mathis given to GNU CC.

Not all hardware implements the entire IEEE 754 standard, and even if it does there may
be a substantial performance penalty for using some of its features. For example, enabling
traps on some processors forces the FPU to run un-pipelined, which can more than double
calculation time.


### 601

## 20 Arithmetic Functions........................

## 20 Arithmetic Functions.................................

This chapter contains information about functions for doing basic arithmetic operations,
such as splitting a float into its integer and fractional parts or retrieving the imaginary part
of a complex value. These functions are declared in the header filesmath.handcomplex.h.

## 20.1 Integers.....................................................

The C language defines several integer data types: integer, short integer, long integer, and
character, all in both signed and unsigned varieties. The GNU C compiler extends the
language to contain long long integers as well.

The C integer types were intended to allow code to be portable among machines with
different inherent data sizes (word sizes), so each type may have different ranges on different
machines. The problem with this is that a program often needs to be written for a particular
range of integers, and sometimes must be written for a particular size of storage, regardless
of what machine the program runs on.

To address this problem, the GNU C Library contains C type definitions you can use to
declare integers that meet your exact needs. Because the GNU C Library header files are
customized to a specific machine, your program source code doesn¡¯t have to be.

Thesetypedefs are instdint.h.
If you require that an integer be represented in exactly N bits, use one of the following
types, with the obvious mapping to bit size and signedness:

- int8t
- int16t
- int32t
- int64t
- uint8t
- uint16t
- uint32t
- uint64t
    If your C compiler and target machine do not allow integers of a certain size, the corre-
sponding above type does not exist.

If you don¡¯t need a specific storage size, but want the smallest data structure withat
leastN bits, use one of these:

- intleast8 t
- intleast16t
- intleast32t
- intleast64t
- uintleast8 t
- uintleast16t
- uintleast32t
- uintleast64t


Chapter 20: Arithmetic Functions 602

If you don¡¯t need a specific storage size, but want the data structure that allows the
fastest access while having at least N bits (and among data structures with the same access
speed, the smallest one), use one of these:

- intfast8t
- intfast16t
- intfast32t
- intfast64t
- uintfast8t
- uintfast16 t
- uintfast32 t
- uintfast64 t
    If you want an integer with the widest range possible on the platform on which it is
being used, use one of the following. If you use these, you should write code that takes into
account the variable size and range of the integer.
- intmaxt
- uintmaxt
The GNU C Library also provides macros that tell you the maximum and minimum
possible values for each integer data type. The macro names follow these examples:INT32_
MAX,UINT8_MAX,INT_FAST32_MIN,INT_LEAST64_MIN,UINTMAX_MAX,INTMAX_MAX,INTMAX_
MIN. Note that there are no macros for unsigned integer minima. These are always zero.
Similiarly, there are macros such asINTMAX_WIDTHfor the width of these types. Those
macros for integer type widths come from TS 18661-1:2014.

There are similar macros for use with C¡¯s built in integer types which should come with
your C compiler. These are described inSection A.5 [Data Type Measurements], page 956.

Don¡¯t forget you can use the Csizeoffunction with any of these data types to get the
number of bytes of storage each uses.

## 20.2 Integer Division.............................................

This section describes functions for performing integer division. These functions are redun-
dant when GNU CC is used, because in GNU C the ¡®/¡¯ operator always rounds towards
zero. But in other C implementations, ¡®/¡¯ may round differently with negative arguments.
divandldivare useful because they specify how to round the quotient: towards zero. The
remainder has the same sign as the numerator.

These functions are specified to return a result r such that the value
r.quot*denominator+r.remequalsnumerator.

```
To use these facilities, you should include the header filestdlib.hin your program.
```
div_t [Data Type]
This is a structure type used to hold the result returned by thedivfunction. It has
the following members:
int quot The quotient from the division.
int rem The remainder from the division.


Chapter 20: Arithmetic Functions 603

div_t div (intnumerator, intdenominator) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The functiondivcomputes the quotient and remainder from the division ofnumerator
bydenominator, returning the result in a structure of typediv_t.
If the result cannot be represented (as in a division by zero), the behavior is undefined.
Here is an example, albeit not a very useful one.
div_t result;
result = div (20, -6);
Nowresult.quotis-3andresult.remis 2.

ldiv_t [Data Type]
This is a structure type used to hold the result returned by theldivfunction. It has
the following members:

```
long int quot
The quotient from the division.
```
```
long int rem
The remainder from the division.
```
```
(This is identical todiv_texcept that the components are of typelong intrather
thanint.)
```
ldiv_t ldiv(long intnumerator, long intdenominator) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theldivfunction is similar todiv, except that the arguments are of typelong int
and the result is returned as a structure of typeldiv_t.

lldiv_t [Data Type]
This is a structure type used to hold the result returned by thelldivfunction. It
has the following members:

```
long long int quot
The quotient from the division.
```
```
long long int rem
The remainder from the division.
```
```
(This is identical todiv_texcept that the components are of typelong long int
rather thanint.)
```
lldiv_t lldiv(long long intnumerator, long long intdenominator) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thelldivfunction is like thedivfunction, but the arguments are of typelong long
intand the result is returned as a structure of typelldiv_t.
Thelldivfunction was added in ISO C99.


Chapter 20: Arithmetic Functions 604

imaxdiv_t [Data Type]
This is a structure type used to hold the result returned by theimaxdivfunction. It
has the following members:

```
intmax_t quot
The quotient from the division.
```
```
intmax_t rem
The remainder from the division.
```
```
(This is identical todiv_texcept that the components are of typeintmax_trather
thanint.)
```
```
SeeSection 20.1 [Integers], page 601,for a description of theintmax_ttype.
```
imaxdiv_t imaxdiv(intmaxtnumerator, intmaxtdenominator) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

```
Theimaxdivfunction is like thedivfunction, but the arguments are of typeintmax_t
and the result is returned as a structure of typeimaxdiv_t.
```
```
SeeSection 20.1 [Integers], page 601,for a description of theintmax_ttype.
```
```
Theimaxdivfunction was added in ISO C99.
```
## 20.3 Floating Point Numbers.....................................

Most computer hardware has support for two different kinds of numbers: integers
(...? 3 ,? 2 ,? 1 , 0 , 1 , 2 , 3 ...) and floating-point numbers. Floating-point numbers have
three parts: themantissa, theexponent, and thesign bit. The real number represented
by a floating-point value is given by (s??1 : 1)¡¤ 2 e¡¤M wheresis the sign bit,ethe
exponent, and M the mantissa. See Section A.5.3.1 [Floating Point Representation
Concepts], page 959, for details. (It is possible to have a differentbasefor the exponent,
but all modern hardware uses 2.)

Floating-point numbers can represent a finite subset of the real numbers. While this
subset is large enough for most purposes, it is important to remember that the only reals that
can be represented exactly are rational numbers that have a terminating binary expansion
shorter than the width of the mantissa. Even simple fractions such as 1/5 can only be
approximated by floating point.

Mathematical operations and functions frequently need to produce values that are not
representable. Often these values can be approximated closely enough for practical pur-
poses, but sometimes they can¡¯t. Historically there was no way to tell when the results of
a calculation were inaccurate. Modern computers implement the IEEE 754 standard for
numerical computations, which defines a framework for indicating to the program when the
results of calculation are not trustworthy. This framework consists of a set ofexceptions
that indicate why a result could not be represented, and the special valuesinfinityandnot
a number(NaN).


Chapter 20: Arithmetic Functions 605

## 20.4 Floating-Point Number Classification Functions..............

ISO C99 defines macros that let you determine what sort of floating-point number a variable
holds.

int fpclassify(float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is a generic macro which works on all floating-point types and which returns a
value of typeint. The possible values are:

```
FP_NAN The floating-point numberx is ¡°Not a Number¡± (seeSection 20.5.2
[Infinity and NaN], page 609)
```
```
FP_INFINITE
The value ofxis either plus or minus infinity (seeSection 20.5.2 [Infinity
and NaN], page 609)
```
```
FP_ZERO The value ofxis zero. In floating-point formats like IEEE 754, where
zero can be signed, this value is also returned ifxis negative zero.
```
```
FP_SUBNORMAL
Numbers whose absolute value is too small to be represented in the
normal format are represented in an alternate,denormalizedformat (see
Section A.5.3.1 [Floating Point Representation Concepts], page 959).
This format is less precise but can represent values closer to zero.
fpclassifyreturns this value for values ofxin this alternate format.
```
```
FP_NORMAL
This value is returned for all other values ofx. It indicates that there is
nothing special about the number.
```
fpclassifyis most useful if more than one property of a number must be tested. There
are more specific macros which only test one property at a time. Generally these macros
execute faster thanfpclassify, since there is special hardware support for them. You
should therefore use the specific macros whenever possible.

int iscanonical (float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
In some floating-point formats, some values have canonical (preferred) and noncanon-
ical encodings (for IEEE interchange binary formats, all encodings are canonical).
This macro returns a nonzero value ifxhas a canonical encoding. It is from TS
18661-1:2014.
Note that some formats have multiple encodings of a value which are all equally
canonical;iscanonicalreturns a nonzero value for all such encodings. Also, formats
may have encodings that do not correspond to any valid value of the type. In ISO
C terms these aretrap representations; in the GNU C Library,iscanonicalreturns
zero for such encodings.


Chapter 20: Arithmetic Functions 606

int isfinite (float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value ifxis finite: not plus or minus infinity, and not
NaN. It is equivalent to
(fpclassify (x) != FP_NAN && fpclassify (x) != FP_INFINITE)
isfiniteis implemented as a macro which accepts any floating-point type.

int isnormal (float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value ifxis finite and normalized. It is equivalent to
(fpclassify (x) == FP_NORMAL)

int isnan (float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value ifxis NaN. It is equivalent to
(fpclassify (x) == FP_NAN)

int issignaling (float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value ifxis a signaling NaN (sNaN). It is from TS
18661-1:2014.

int issubnormal (float-typex) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value ifxis subnormal. It is from TS 18661-1:2014.

int iszero(float-type x) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value ifxis zero. It is from TS 18661-1:2014.

Another set of floating-point classification functions was provided by BSD. The GNU C
Library also supports these functions; however, we recommend that you use the ISO C99
macros in new code. Those are standard and will be available more widely. Also, since they
are macros, you do not have to worry about the type of their argument.

int isinf (doublex) [Function]
int isinff(floatx) [Function]
int isinfl(long doublex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns-1ifxrepresents negative infinity, 1 ifxrepresents positive
infinity, and 0 otherwise.


Chapter 20: Arithmetic Functions 607

int isnan (doublex) [Function]
int isnanf(floatx) [Function]
int isnanl(long doublex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns a nonzero value ifxis a ¡°not a number¡± value, and zero other-
wise.
NB:Theisnanmacro defined by ISO C99 overrides the BSD function. This is nor-
mally not a problem, because the two routines behave identically. However, if you
really need to get the BSD function for some reason, you can write
(isnan) (x)

int finite(doublex) [Function]
int finitef(floatx) [Function]
int finitel(long doublex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns a nonzero value ifxis neither infinite nor a ¡°not a number¡±
value, and zero otherwise.

```
Portability Note:The functions listed in this section are BSD extensions.
```
## 20.5 Errors in Floating-Point Calculations........................

## 20.5.1 FP Exceptions.........................................

The IEEE 754 standard defines fiveexceptionsthat can occur during a calculation. Each
corresponds to a particular sort of error, such as overflow.

When exceptions occur (when exceptions areraised, in the language of the standard),
one of two things can happen. By default the exception is simply noted in the floating-
pointstatus word, and the program continues as if nothing had happened. The operation
produces a default value, which depends on the exception (see the table below). Your
program can check the status word to find out which exceptions happened.

Alternatively, you can enabletrapsfor exceptions. In that case, when an exception is
raised, your program will receive theSIGFPEsignal. The default action for this signal is
to terminate the program. SeeChapter 24 [Signal Handling], page 714, for how you can
change the effect of the signal.

The exceptions defined in IEEE 754 are:

¡®Invalid Operation¡¯
This exception is raised if the given operands are invalid for the operation to
be performed. Examples are (see IEEE 754, section 7):

1. Addition or subtraction:¡Þ?¡Þ. (But¡Þ+¡Þ=¡Þ).
2. Multiplication: 0¡¤¡Þ.
3. Division: 0/0 or¡Þ/¡Þ.
4. Remainder:xREMy, whereyis zero orxis infinite.


Chapter 20: Arithmetic Functions 608

5. Square root if the operand is less than zero. More generally, any mathe-
    matical function evaluated outside its domain produces this exception.
6. Conversion of a floating-point number to an integer or decimal string, when
    the number cannot be represented in the target format (due to overflow,
    infinity, or NaN).
7. Conversion of an unrecognizable input string.
8. Comparison via predicates involving<or>, when one or other of the
    operands is NaN. You can prevent this exception by using the unordered
    comparison functions instead; seeSection 20.8.6 [Floating-Point Compari-
    son Functions], page 628.

```
If the exception does not trap, the result of the operation is NaN.
```
¡®Division by Zero¡¯
This exception is raised when a finite nonzero number is divided by zero. If
no trap occurs the result is either +¡Þor?¡Þ, depending on the signs of the
operands.

¡®Overflow¡¯
This exception is raised whenever the result cannot be represented as a finite
value in the precision format of the destination. If no trap occurs the result
depends on the sign of the intermediate result and the current rounding mode
(IEEE 754, section 7.3):

1. Round to nearest carries all overflows to¡Þwith the sign of the intermediate
    result.
2. Round toward 0 carries all overflows to the largest representable finite
    number with the sign of the intermediate result.
3. Round toward?¡Þcarries positive overflows to the largest representable
    finite number and negative overflows to?¡Þ.
4. Round toward¡Þcarries negative overflows to the most negative repre-
    sentable finite number and positive overflows to¡Þ.

```
Whenever the overflow exception is raised, the inexact exception is also raised.
```
¡®Underflow¡¯
The underflow exception is raised when an intermediate result is too small to
be calculated accurately, or if the operation¡¯s result rounded to the destination
precision is too small to be normalized.
When no trap is installed for the underflow exception, underflow is signaled
(via the underflow flag) only when both tininess and loss of accuracy have
been detected. If no trap handler is installed the operation continues with an
imprecise small value, or zero if the destination precision cannot hold the small
exact result.

¡®Inexact¡¯ This exception is signalled if a rounded result is not exact (such as when cal-
culating the square root of two) or a result overflows without an overflow trap.


Chapter 20: Arithmetic Functions 609

## 20.5.2 Infinity and NaN.......................................

IEEE 754 floating point numbers can represent positive or negative infinity, andNaN(not
a number). These three values arise from calculations whose result is undefined or cannot
be represented accurately. You can also deliberately set a floating-point variable to any of
them, which is sometimes useful. Some examples of calculations that produce infinity or
NaN:

### 1

### 0

### =¡Þ

```
log 0 =?¡Þ
¡Ì
?1 = NaN
```
When a calculation produces any of these values, an exception also occurs; see
Section 20.5.1 [FP Exceptions], page 607.

The basic operations and math functions all accept infinity and NaN and produce sensible
output. Infinities propagate through calculations as one would expect: for example, 2+¡Þ=
¡Þ, 4/¡Þ= 0, atan (¡Þ) =¦Ð/2. NaN, on the other hand, infects any calculation that involves
it. Unless the calculation would produce the same result no matter what real value replaced
NaN, the result is NaN.

In comparison operations, positive infinity is larger than all values except itself and NaN,
and negative infinity is smaller than all values except itself and NaN. NaN isunordered: it is
not equal to, greater than, or less than anything,including itself.x == xis false if the value
ofxis NaN. You can use this to test whether a value is NaN or not, but the recommended
way to test for NaN is with theisnanfunction (seeSection 20.4 [Floating-Point Number
Classification Functions], page 605). In addition,<,>,<=, and>=will raise an exception
when applied to NaNs.

```
math.hdefines macros that allow you to explicitly set a variable to infinity or NaN.
```
float INFINITY [Macro]
An expression representing positive infinity. It is equal to the value produced by
mathematical operations like1.0 / 0.0.-INFINITYrepresents negative infinity.
You can test whether a floating-point value is infinite by comparing it to this macro.
However, this is not recommended; you should use theisfinitemacro instead. See
Section 20.4 [Floating-Point Number Classification Functions], page 605.
This macro was introduced in the ISO C99 standard.

float NAN [Macro]
An expression representing a value which is ¡°not a number¡±. This macro is a GNU
extension, available only on machines that support the ¡°not a number¡± value¡ªthat
is to say, on all machines that support IEEE floating point.
You can use ¡®#ifdef NAN¡¯ to test whether the machine supports NaN. (Of course, you
must arrange for GNU extensions to be visible, such as by defining_GNU_SOURCE, and
then you must includemath.h.)


Chapter 20: Arithmetic Functions 610

float SNANF [Macro]
double SNAN [Macro]
long double SNANL [Macro]
_FloatN SNANFN [Macro]
_FloatNx SNANFNx [Macro]
These macros, defined by TS 18661-1:2014 and TS 18661-3:2015, are constant expres-
sions for signaling NaNs.

int FE_SNANS_ALWAYS_SIGNAL [Macro]
This macro, defined by TS 18661-1:2014, is defined to 1 infenv.hto indicate that
functions and operations with signaling NaN inputs and floating-point results always
raise the invalid exception and return a quiet NaN, even in cases (such asfmax,
hypotandpow) where a quiet NaN input can produce a non-NaN result. Because
some compiler optimizations may not handle signaling NaNs correctly, this macro is
only defined if compiler support for signaling NaNs is enabled. That support can be
enabled with the GCC option-fsignaling-nans.

IEEE 754 also allows for another unusual value: negative zero. This value is produced
when you divide a positive number by negative infinity, or when a negative result is smaller
than the limits of representation.

## 20.5.3 Examining the FPU status word........................

ISO C99 defines functions to query and manipulate the floating-point status word. You
can use these functions to check for untrapped exceptions when it¡¯s convenient, rather than
worrying about them in the middle of a calculation.

These constants represent the various IEEE 754 exceptions. Not all FPUs report all the
different exceptions. Each constant is defined if and only if the FPU you are compiling for
supports that exception, so you can test for FPU support with ¡®#ifdef¡¯. They are defined
infenv.h.

FE_INEXACT
The inexact exception.

FE_DIVBYZERO
The divide by zero exception.

FE_UNDERFLOW
The underflow exception.

FE_OVERFLOW
The overflow exception.

FE_INVALID
The invalid exception.

The macroFE_ALL_EXCEPTis the bitwise OR of all exception macros which are supported
by the FP implementation.

These functions allow you to clear exception flags, test for exceptions, and save and
restore the set of exceptions flagged.


Chapter 20: Arithmetic Functions 611

int feclearexcept(intexcepts) [Function]
Preliminary: |MT-Safe |AS-Safe !posix|AC-Safe !posix|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function clears all of the supported exception flags indicated byexcepts.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int feraiseexcept(intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function raises the supported exceptions indicated byexcepts. If more than one
exception bit inexceptsis set the order in which the exceptions are raised is undefined
except that overflow (FE_OVERFLOW) or underflow (FE_UNDERFLOW) are raised before
inexact (FE_INEXACT). Whether for overflow or underflow the inexact exception is
also raised is also implementation dependent.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int fesetexcept (intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function sets the supported exception flags indicated by excepts, like
feraiseexcept, but without causing enabled traps to be taken. fesetexceptis
from TS 18661-1:2014.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int fetestexcept (intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Test whether the exception flags indicated by the parameterexceptare currently set.
If any of them are, a nonzero value is returned which specifies which exceptions are
set. Otherwise the result is zero.

To understand these functions, imagine that the status word is an integer variable named
status. feclearexceptis then equivalent to ¡®status &= ~excepts¡¯ andfetestexceptis
equivalent to ¡®(status & excepts)¡¯. The actual implementation may be very different, of
course.

Exception flags are only cleared when the program explicitly requests it, by calling
feclearexcept. If you want to check for exceptions from a set of calculations, you should
clear all the flags first. Here is a simple example of the way to usefetestexcept:
{
double f;
int raised;
feclearexcept (FE_ALL_EXCEPT);
f = compute ();
raised = fetestexcept (FE_OVERFLOW | FE_INVALID);
if (raised & FE_OVERFLOW) { /* ... */ }


Chapter 20: Arithmetic Functions 612

if (raised & FE_INVALID) { /* ... */ }
/* ... */
}
You cannot explicitly set bits in the status word. You can, however, save the entire
status word and restore it later. This is done with the following functions:

int fegetexceptflag (fexceptt *flagp, intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function stores in the variable pointed to byflagpan implementation-defined
value representing the current setting of the exception flags indicated byexcepts.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int fesetexceptflag (const fexcept t *flagp, intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function restores the flags for the exceptions indicated byexceptsto the values
stored in the variable pointed to byflagp.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

Note that the value stored infexcept_tbears no resemblance to the bit mask returned
byfetestexcept. The type may not even be an integer. Do not attempt to modify an
fexcept_tvariable.

int fetestexceptflag(const fexcept t *flagp, intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Test whether the exception flags indicated by the parameterexceptsare set in the
variable pointed to byflagp. If any of them are, a nonzero value is returned which
specifies which exceptions are set. Otherwise the result is zero. fetestexceptflag
is from TS 18661-1:2014.

## 20.5.4 Error Reporting by Mathematical Functions............

Many of the math functions are defined only over a subset of the real or complex numbers.
Even if they are mathematically defined, their result may be larger or smaller than the range
representable by their return type without loss of accuracy. These are known asdomain
errors,overflows, andunderflows, respectively. Math functions do several things when one
of these errors occurs. In this manual we will refer to the complete response assignallinga
domain error, overflow, or underflow.

When a math function suffers a domain error, it raises the invalid exception and returns
NaN. It also setserrnotoEDOM; this is for compatibility with old systems that do not
support IEEE 754 exception handling. Likewise, when overflow occurs, math functions raise
the overflow exception and, in the default rounding mode, return¡Þor?¡Þas appropriate
(in other rounding modes, the largest finite value of the appropriate sign is returned when
appropriate for that rounding mode). They also seterrnotoERANGEif returning¡Þor


Chapter 20: Arithmetic Functions 613

?¡Þ;errnomay or may not be set toERANGEwhen a finite value is returned on overflow.
When underflow occurs, the underflow exception is raised, and zero (appropriately signed)
or a subnormal value, as appropriate for the mathematical result of the function and the
rounding mode, is returned.errnomay be set toERANGE, but this is not guaranteed; it is
intended that the GNU C Library should set it when the underflow is to an appropriately
signed zero, but not necessarily for other underflows.

When a math function has an argument that is a signaling NaN, the GNU C Library does
not consider this a domain error, soerrnois unchanged, but the invalid exception is still
raised (except for a few functions that are specified to handle signaling NaNs differently).

Some of the math functions are defined mathematically to result in a complex value over
parts of their domains. The most familiar example of this is taking the square root of a
negative number. The complex math functions, such ascsqrt, will return the appropriate
complex value in this case. The real-valued functions, such assqrt, will signal a domain
error.

Some older hardware does not support infinities. On that hardware, overflows instead
return a particular very large number (usually the largest representable number). math.h
defines macros you can use to test for overflow on both old and new hardware.

double HUGE_VAL [Macro]
float HUGE_VALF [Macro]
long double HUGE_VALL [Macro]
_FloatN HUGE_VAL_FN [Macro]
_FloatNx HUGE_VAL_FNx [Macro]
An expression representing a particular very large number. On machines that use
IEEE 754 floating point format,HUGE_VALis infinity. On other machines, it¡¯s typically
the largest positive number that can be represented.
Mathematical functions return the appropriately typed version of HUGE_VAL or
?HUGE_VALwhen the result is too large to be represented.

## 20.6 Rounding Modes............................................

Floating-point calculations are carried out internally with extra precision, and then rounded
to fit into the destination type. This ensures that results are as precise as the input data.
IEEE 754 defines four possible rounding modes:

Round to nearest.
This is the default mode. It should be used unless there is a specific need for
one of the others. In this mode results are rounded to the nearest representable
value. If the result is midway between two representable values, the even repre-
sentable is chosen.Evenhere means the lowest-order bit is zero. This rounding
mode prevents statistical bias and guarantees numeric stability: round-off errors
in a lengthy calculation will remain smaller than half ofFLT_EPSILON.

Round toward plus Infinity.
All results are rounded to the smallest representable value which is greater than
the result.


Chapter 20: Arithmetic Functions 614

Round toward minus Infinity.
All results are rounded to the largest representable value which is less than the
result.

Round toward zero.
All results are rounded to the largest representable value whose magnitude is
less than that of the result. In other words, if the result is negative it is rounded
up; if it is positive, it is rounded down.

fenv.hdefines constants which you can use to refer to the various rounding modes. Each
one will be defined if and only if the FPU supports the corresponding rounding mode.

FE_TONEAREST
Round to nearest.

FE_UPWARD
Round toward +¡Þ.

FE_DOWNWARD
Round toward?¡Þ.

FE_TOWARDZERO
Round toward zero.
Underflow is an unusual case. Normally, IEEE 754 floating point numbers are always
normalized (seeSection A.5.3.1 [Floating Point Representation Concepts], page 959). Num-
bers smaller than 2r(whereris the minimum exponent,FLT_MIN_RADIX-1forfloat) cannot
be represented as normalized numbers. Rounding all such numbers to zero or 2rwould cause
some algorithms to fail at 0. Therefore, they are left in denormalized form. That produces
loss of precision, since some bits of the mantissa are stolen to indicate the decimal point.

If a result is too small to be represented as a denormalized number, it is rounded to
zero. However, the sign of the result is preserved; if the calculation was negative, the result
isnegative zero. Negative zero can also result from some operations on infinity, such as
4 /?¡Þ.

At any time, one of the above four rounding modes is selected. You can find out which
one with this function:

int fegetround(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Returns the currently selected rounding mode, represented by one of the values of the
defined rounding mode macros.

To change the rounding mode, use this function:

int fesetround(intround) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Changes the currently selected rounding mode toround. Ifrounddoes not correspond
to one of the supported rounding modes nothing is changed.fesetroundreturns zero
if it changed the rounding mode, or a nonzero value if the mode is not supported.


Chapter 20: Arithmetic Functions 615

You should avoid changing the rounding mode if possible. It can be an expensive oper-
ation; also, some hardware requires you to compile your program differently for it to work.
The resulting code may run slower. See your compiler documentation for details.

## 20.7 Floating-Point Control Functions............................

IEEE 754 floating-point implementations allow the programmer to decide whether traps
will occur for each of the exceptions, by setting bits in thecontrol word. In C, traps result
in the program receiving theSIGFPEsignal; seeChapter 24 [Signal Handling], page 714.

NB:IEEE 754 says that trap handlers are given details of the exceptional situation, and
can set the result value. C signals do not provide any mechanism to pass this information
back and forth. Trapping exceptions in C is therefore not very useful.

It is sometimes necessary to save the state of the floating-point unit while you perform
some calculation. The library provides functions which save and restore the exception flags,
the set of exceptions that generate traps, and the rounding mode. This information is
known as thefloating-point environment.

The functions to save and restore the floating-point environment all use a variable of
typefenv_tto store information. This type is defined infenv.h. Its size and contents
are implementation-defined. You should not attempt to manipulate a variable of this type
directly.

```
To save the state of the FPU, use one of these functions:
```
int fegetenv (fenvt *envp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Store the floating-point environment in the variable pointed to byenvp.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int feholdexcept (fenvt *envp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Store the current floating-point environment in the object pointed to byenvp. Then
clear all exception flags, and set the FPU to trap no exceptions. Not all FPUs
support trapping no exceptions; iffeholdexceptcannot set this mode, it returns
nonzero value. If it succeeds, it returns zero.

The functions which restore the floating-point environment can take these kinds of ar-
guments:

- Pointers tofenv_tobjects, which were initialized previously by a call tofegetenvor
    feholdexcept.
- The special macroFE_DFL_ENVwhich represents the floating-point environment as it
    was available at program start.
- Implementation defined macros with names starting withFE_and having typefenv_t
    *.


Chapter 20: Arithmetic Functions 616

```
If possible, the GNU C Library defines a macroFE_NOMASK_ENVwhich represents an
environment where every exception raised causes a trap to occur. You can test for this
macro using#ifdef. It is only defined if_GNU_SOURCEis defined.
Some platforms might define other predefined environments.
```
To set the floating-point environment, you can use either of these functions:

int fesetenv (const fenvt *envp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the floating-point environment to that described byenvp.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int feupdateenv (const fenvt *envp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Likefesetenv, this function sets the floating-point environment to that described by
envp. However, if any exceptions were flagged in the status word beforefeupdateenv
was called, they remain flagged after the call. In other words, afterfeupdateenvis
called, the status word is the bitwise OR of the previous status word and the one
saved inenvp.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

TS 18661-1:2014 defines additional functions to save and restore floating-point control modes
(such as the rounding mode and whether traps are enabled) while leaving other status (such
as raised flags) unchanged.

The special macroFE_DFL_MODEmay be passed tofesetmode. It represents the floating-
point control modes at program start.

int fegetmode(femode t *modep) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Store the floating-point control modes in the variable pointed to bymodep.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

int fesetmode(const femode t *modep) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the floating-point control modes to those described bymodep.
The function returns zero in case the operation was successful, a non-zero value oth-
erwise.

To control for individual exceptions if raising them causes a trap to occur, you can use the
following two functions.

```
Portability Note:These functions are all GNU extensions.
```

Chapter 20: Arithmetic Functions 617

int feenableexcept(intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function enables traps for each of the exceptions as indicated by the parameter
excepts. The individual exceptions are described inSection 20.5.3 [Examining the
FPU status word], page 610. Only the specified exceptions are enabled, the status of
the other exceptions is not changed.
The function returns the previous enabled exceptions in case the operation was suc-
cessful,-1otherwise.

int fedisableexcept (intexcepts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function disables traps for each of the exceptions as indicated by the parameter
excepts. The individual exceptions are described inSection 20.5.3 [Examining the
FPU status word], page 610. Only the specified exceptions are disabled, the status of
the other exceptions is not changed.
The function returns the previous enabled exceptions in case the operation was suc-
cessful,-1otherwise.

int fegetexcept (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The function returns a bitmask of all currently enabled exceptions. It returns-1in
case of failure.

## 20.8 Arithmetic Functions........................................

The C library provides functions to do basic operations on floating-point numbers. These
include absolute value, maximum and minimum, normalization, bit twiddling, rounding,
and a few others.

## 20.8.1 Absolute Value.........................................

These functions are provided for obtaining theabsolute value(ormagnitude) of a number.
The absolute value of a real numberxis xifx is positive,?x ifxis negative. For a
complex numberz, whose real part isxand whose imaginary part isy, the absolute value
issqrt (x*x+y*y).

Prototypes forabs,labsandllabsare instdlib.h;imaxabsis declared ininttypes.h;
thefabsfunctions are declared inmath.h; thecabsfunctions are declared incomplex.h.

int abs(intnumber) [Function]
long int labs(long intnumber) [Function]
long long int llabs (long long intnumber) [Function]
intmax_t imaxabs (intmaxtnumber) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the absolute value ofnumber.


Chapter 20: Arithmetic Functions 618

```
Most computers use a two¡¯s complement integer representation, in which the ab-
solute value of INT_MIN(the smallest possible int) cannot be represented; thus,
abs (INT_MIN)is not defined.
llabsandimaxdivare new to ISO C99.
SeeSection 20.1 [Integers], page 601,for a description of theintmax_ttype.
```
double fabs(doublenumber) [Function]
float fabsf(floatnumber) [Function]
long double fabsl(long doublenumber) [Function]
_FloatN fabsfN( FloatN number) [Function]
_FloatNx fabsfNx (FloatNxnumber) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the absolute value of the floating-point numbernumber.

double cabs(complex doublez) [Function]
float cabsf(complex floatz) [Function]
long double cabsl(complex long doublez) [Function]
_FloatN cabsfN(complex FloatN z) [Function]
_FloatNx cabsfNx (complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the absolute value of the complex numberz(seeSection 20.9
[Complex Numbers], page 633). The absolute value of a complex number is:
sqrt (creal (z) * creal (z) + cimag (z) * cimag (z))
This function should always be used instead of the direct formula because it takes
special care to avoid losing precision. It may also take advantage of hardware sup-
port for this operation. SeehypotinSection 19.4 [Exponentiation and Logarithms],
page 544.

## 20.8.2 Normalization Functions................................

The functions described in this section are primarily provided as a way to efficiently perform
certain low-level manipulations on floating point numbers that are represented internally
using a binary radix; seeSection A.5.3.1 [Floating Point Representation Concepts], page 959.
These functions are required to have equivalent behavior even if the representation does not
use a radix of 2, but of course they are unlikely to be particularly efficient in those cases.

```
All these functions are declared inmath.h.
```
double frexp (doublevalue, int *exponent) [Function]
float frexpf (floatvalue, int *exponent) [Function]
long double frexpl(long doublevalue, int *exponent) [Function]
_FloatN frexpfN (FloatN value, int *exponent) [Function]
_FloatNx frexpfNx( FloatNxvalue, int *exponent) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are used to split the numbervalueinto a normalized fraction and an
exponent.


Chapter 20: Arithmetic Functions 619

```
If the argumentvalueis not zero, the return value isvaluetimes a power of two, and its
magnitude is always in the range 1/2 (inclusive) to 1 (exclusive). The corresponding
exponent is stored in*exponent; the return value multiplied by 2 raised to this
exponent equals the original numbervalue.
For example,frexp (12.8, &exponent)returns0.8and stores 4 inexponent.
Ifvalueis zero, then the return value is zero and zero is stored in*exponent.
```
double ldexp (doublevalue, intexponent) [Function]
float ldexpf (floatvalue, intexponent) [Function]
long double ldexpl(long doublevalue, intexponent) [Function]
_FloatN ldexpfN (FloatN value, intexponent) [Function]
_FloatNx ldexpfNx( FloatNxvalue, intexponent) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the result of multiplying the floating-point numbervalueby 2
raised to the powerexponent. (It can be used to reassemble floating-point numbers
that were taken apart byfrexp.)
For example,ldexp (0.8, 4)returns12.8.

The following functions, which come from BSD, provide facilities equivalent to those of
ldexpandfrexp. See also the ISO C functionlogbwhich originally also appeared in BSD.
The_FloatNand_FloatNvariants of the following functions come from TS 18661-3:2015.

double scalb (doublevalue, doubleexponent) [Function]
float scalbf (floatvalue, floatexponent) [Function]
long double scalbl(long doublevalue, long doubleexponent) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thescalbfunction is the BSD name forldexp.

double scalbn(doublex, intn) [Function]
float scalbnf(floatx, intn) [Function]
long double scalbnl (long doublex, intn) [Function]
_FloatN scalbnfN (FloatN x, intn) [Function]
_FloatNx scalbnfNx( FloatNxx, intn) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
scalbnis identical to scalb, except that the exponent nis an intinstead of a
floating-point number.

double scalbln(doublex, long intn) [Function]
float scalblnf(floatx, long intn) [Function]
long double scalblnl(long doublex, long intn) [Function]
_FloatN scalblnfN( FloatN x, long intn) [Function]
_FloatNx scalblnfNx (FloatNxx, long intn) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 20: Arithmetic Functions 620

```
scalblnis identical toscalb, except that the exponentnis along intinstead of a
floating-point number.
```
double significand(doublex) [Function]
float significandf(floatx) [Function]
long double significandl(long doublex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
significandreturns the mantissa ofxscaled to the range [1,2). It is equivalent to
scalb (x, (double) -ilogb (x)).
This function exists mainly for use in certain standardized tests of IEEE 754 confor-
mance.

## 20.8.3 Rounding Functions....................................

The functions listed here perform operations such as rounding and truncation of floating-
point values. Some of these functions convert floating point numbers to integer values.
They are all declared inmath.h.

You can also convert floating-point numbers to integers simply by casting them toint.
This discards the fractional part, effectively rounding towards zero. However, this only
works if the result can actually be represented as anint¡ªfor very large numbers, this is
impossible. The functions listed here return the result as adoubleinstead to get around
this problem.

Thefromfpfunctions use the following macros, from TS 18661-1:2014, to specify the
direction of rounding. These correspond to the rounding directions defined in IEEE 754-
2008.

FP_INT_UPWARD
Round toward +¡Þ.

FP_INT_DOWNWARD
Round toward?¡Þ.

FP_INT_TOWARDZERO
Round toward zero.

FP_INT_TONEARESTFROMZERO
Round to nearest, ties round away from zero.

FP_INT_TONEAREST
Round to nearest, ties round to even.

double ceil(doublex) [Function]
float ceilf(floatx) [Function]
long double ceill(long doublex) [Function]
_FloatN ceilfN( FloatN x) [Function]
_FloatNx ceilfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions roundxupwards to the nearest integer, returning that value as a
double. Thus,ceil (1.5)is2.0.


Chapter 20: Arithmetic Functions 621

double floor (doublex) [Function]
float floorf (floatx) [Function]
long double floorl(long doublex) [Function]
_FloatN floorfN (FloatN x) [Function]
_FloatNx floorfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions roundxdownwards to the nearest integer, returning that value as a
double. Thus,floor (1.5)is1.0andfloor (-1.5)is-2.0.

double trunc (doublex) [Function]
float truncf (floatx) [Function]
long double truncl(long doublex) [Function]
_FloatN truncfN (FloatN x) [Function]
_FloatNx truncfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thetruncfunctions roundxtowards zero to the nearest integer (returned in floating-
point format). Thus,trunc (1.5)is1.0andtrunc (-1.5)is-1.0.

double rint(doublex) [Function]
float rintf(floatx) [Function]
long double rintl(long doublex) [Function]
_FloatN rintfN( FloatN x) [Function]
_FloatNx rintfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions roundxto an integer value according to the current rounding mode.
SeeSection A.5.3.2 [Floating Point Parameters], page 961, for information about the
various rounding modes. The default rounding mode is to round to the nearest integer;
some machines support other modes, but round-to-nearest is always used unless you
explicitly select another.
Ifxwas not initially an integer, these functions raise the inexact exception.

double nearbyint (doublex) [Function]
float nearbyintf (floatx) [Function]
long double nearbyintl (long doublex) [Function]
_FloatN nearbyintfN (FloatN x) [Function]
_FloatNx nearbyintfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the same value as therintfunctions, but do not raise the
inexact exception ifxis not an integer.

double round (doublex) [Function]
float roundf (floatx) [Function]
long double roundl(long doublex) [Function]


Chapter 20: Arithmetic Functions 622

_FloatN roundfN (FloatN x) [Function]
_FloatNx roundfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are similar torint, but they round halfway cases away from zero
instead of to the nearest integer (or other current rounding mode).

double roundeven (doublex) [Function]
float roundevenf (floatx) [Function]
long double roundevenl (long doublex) [Function]
_FloatN roundevenfN (FloatN x) [Function]
_FloatNx roundevenfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, are similar toround,
but they round halfway cases to even instead of away from zero.

long int lrint(doublex) [Function]
long int lrintf (floatx) [Function]
long int lrintl (long doublex) [Function]
long int lrintfN (FloatN x) [Function]
long int lrintfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are just likerint, but they return along intinstead of a floating-
point number.

long long int llrint(doublex) [Function]
long long int llrintf(floatx) [Function]
long long int llrintl(long doublex) [Function]
long long int llrintfN (FloatN x) [Function]
long long int llrintfNx (FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are just likerint, but they return along long int instead of a
floating-point number.

long int lround (doublex) [Function]
long int lroundf (floatx) [Function]
long int lroundl (long doublex) [Function]
long int lroundfN( FloatN x) [Function]
long int lroundfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are just likeround, but they return along intinstead of a floating-
point number.


Chapter 20: Arithmetic Functions 623

long long int llround(doublex) [Function]
long long int llroundf (floatx) [Function]
long long int llroundl (long doublex) [Function]
long long int llroundfN (FloatN x) [Function]
long long int llroundfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are just likeround, but they return along long intinstead of a
floating-point number.

intmax_t fromfp (doublex, intround, unsigned intwidth) [Function]
intmax_t fromfpf (floatx, intround, unsigned intwidth) [Function]
intmax_t fromfpl (long doublex, intround, unsigned intwidth) [Function]
intmax_t fromfpfN( FloatN x, intround, unsigned intwidth) [Function]
intmax_t fromfpfNx( FloatNxx, intround, unsigned intwidth) [Function]
uintmax_t ufromfp(doublex, intround, unsigned intwidth) [Function]
uintmax_t ufromfpf(floatx, intround, unsigned intwidth) [Function]
uintmax_t ufromfpl(long doublex, intround, unsigned intwidth) [Function]
uintmax_t ufromfpfN (FloatN x, intround, unsigned intwidth) [Function]
uintmax_t ufromfpfNx(FloatNxx, intround, unsigned intwidth) [Function]
intmax_t fromfpx (doublex, intround, unsigned intwidth) [Function]
intmax_t fromfpxf(floatx, intround, unsigned intwidth) [Function]
intmax_t fromfpxl(long doublex, intround, unsigned intwidth) [Function]
intmax_t fromfpxfN( FloatN x, intround, unsigned intwidth) [Function]
intmax_t fromfpxfNx (FloatNxx, intround, unsigned intwidth) [Function]
uintmax_t ufromfpx(doublex, intround, unsigned intwidth) [Function]
uintmax_t ufromfpxf (floatx, intround, unsigned intwidth) [Function]
uintmax_t ufromfpxl (long doublex, intround, unsigned intwidth) [Function]
uintmax_t ufromfpxfN(FloatN x, intround, unsigned intwidth) [Function]
uintmax_t ufromfpxfNx( FloatNxx, intround, unsigned intwidth) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, convert a floating-point
number to an integer according to the rounding directionround(one of theFP_INT_*
macros). If the integer is outside the range of a signed or unsigned (depending on
the return type of the function) type of widthwidthbits (or outside the range of
the return type, ifwidthis larger), or ifxis infinite or NaN, or ifwidthis zero, a
domain error occurs and an unspecified value is returned. The functions with an ¡®x¡¯
in their names raise the inexact exception when a domain error does not occur and
the argument is not an integer; the other functions do not raise the inexact exception.

double modf(doublevalue, double *integer-part) [Function]
float modff(floatvalue, float *integer-part) [Function]
long double modfl(long doublevalue, long double [Function]
*integer-part)
_FloatN modffN( FloatN value, FloatN*integer-part) [Function]


Chapter 20: Arithmetic Functions 624

_FloatNx modffNx (FloatNxvalue, FloatNx *integer-part) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions break the argumentvalueinto an integer part and a fractional part
(between-1and 1 , exclusive). Their sum equalsvalue. Each of the parts has the
same sign asvalue, and the integer part is always rounded toward zero.
modfstores the integer part in*integer-part, and returns the fractional part. For
example,modf (2.5, &intpart)returns0.5and stores2.0intointpart.

## 20.8.4 Remainder Functions...................................

The functions in this section compute the remainder on division of two floating-point num-
bers. Each is a little different; pick the one that suits your problem.

double fmod(doublenumerator, doubledenominator) [Function]
float fmodf(floatnumerator, floatdenominator) [Function]
long double fmodl(long doublenumerator, long double [Function]
denominator)
_FloatN fmodfN( FloatN numerator, FloatN denominator) [Function]
_FloatNx fmodfNx (FloatNxnumerator, FloatNxdenominator) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions compute the remainder from the division of numerator by
denominator. Specifically, the return value isnumerator-n*denominator, where
nis the quotient ofnumeratordivided bydenominator, rounded towards zero to an
integer. Thus,fmod (6.5, 2.3)returns1.9, which is6.5minus4.6.
The result has the same sign as thenumerator and has magnitude less than the
magnitude of thedenominator.
Ifdenominatoris zero,fmodsignals a domain error.

double remainder (doublenumerator, doubledenominator) [Function]
float remainderf (floatnumerator, floatdenominator) [Function]
long double remainderl (long doublenumerator, long double [Function]
denominator)
_FloatN remainderfN (FloatN numerator, FloatN denominator) [Function]
_FloatNx remainderfNx( FloatNxnumerator, FloatNx [Function]
denominator)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are likefmodexcept that they round the internal quotientnto the
nearest integer instead of towards zero to an integer. For example,remainder (6.5,
2.3)returns-0.4, which is6.5minus6.9.
The absolute value of the result is less than or equal to half the absolute value
of the denominator. The difference between fmod (numerator,denominator)
and remainder (numerator,denominator) is always either denominator, minus
denominator, or zero.
Ifdenominatoris zero,remaindersignals a domain error.


Chapter 20: Arithmetic Functions 625

double drem(doublenumerator, doubledenominator) [Function]
float dremf(floatnumerator, floatdenominator) [Function]
long double dreml(long doublenumerator, long double [Function]
denominator)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is another name forremainder.

## 20.8.5 Setting and modifying single bits of FP values..........

There are some operations that are too complicated or expensive to perform by hand on
floating-point numbers. ISO C99 defines functions to do these operations, which mostly
involve changing single bits.

double copysign (doublex, doubley) [Function]
float copysignf (floatx, floaty) [Function]
long double copysignl(long doublex, long doubley) [Function]
_FloatN copysignfN( FloatN x, FloatN y) [Function]
_FloatNx copysignfNx(FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions returnxbut with the sign ofy. They work even ifxoryare NaN
or zero. Both of these can carry a sign (although not all implementations support it)
and this is one of the few operations that can tell the difference.
copysignnever raises an exception.
This function is defined in IEC 559 (and the appendix with recommended functions
in IEEE 754/IEEE 854).

int signbit(float-typex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
signbitis a generic macro which can work on all floating-point types. It returns a
nonzero value if the value ofxhas its sign bit set.
This is not the same asx < 0.0, because IEEE 754 floating point allows zero to
be signed. The comparison-0.0 < 0.0is false, butsignbit (-0.0)will return a
nonzero value.

double nextafter (doublex, doubley) [Function]
float nextafterf (floatx, floaty) [Function]
long double nextafterl (long doublex, long doubley) [Function]
_FloatN nextafterfN (FloatN x, FloatN y) [Function]
_FloatNx nextafterfNx( FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thenextafterfunction returns the next representable neighbor ofxin the direction
towardsy. The size of the step betweenxand the result depends on the type of the
result. Ifx=ythe function simply returnsy. If either value isNaN,NaNis returned.


Chapter 20: Arithmetic Functions 626

```
Otherwise a value corresponding to the value of the least significant bit in the mantissa
is added or subtracted, depending on the direction. nextafterwill signal overflow
or underflow if the result goes outside of the range of normalized numbers.
This function is defined in IEC 559 (and the appendix with recommended functions
in IEEE 754/IEEE 854).
```
double nexttoward(doublex, long doubley) [Function]
float nexttowardf(floatx, long doubley) [Function]
long double nexttowardl (long doublex, long doubley) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions are identical to the corresponding versions ofnextafterexcept that
their second argument is along double.

double nextup(doublex) [Function]
float nextupf(floatx) [Function]
long double nextupl (long doublex) [Function]
_FloatN nextupfN (FloatN x) [Function]
_FloatNx nextupfNx( FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thenextupfunction returns the next representable neighbor ofxin the direction
of positive infinity. Ifxis the smallest negative subnormal number in the type of
xthe function returns-0. Ifx= 0 the function returns the smallest positive sub-
normal number in the type ofx. Ifxis NaN, NaN is returned. Ifxis +¡Þ, +¡Þis
returned.nextupis from TS 18661-1:2014 and TS 18661-3:2015.nextupnever raises
an exception except for signaling NaNs.

double nextdown (doublex) [Function]
float nextdownf (floatx) [Function]
long double nextdownl(long doublex) [Function]
_FloatN nextdownfN( FloatN x) [Function]
_FloatNx nextdownfNx(FloatNxx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thenextdownfunction returns the next representable neighbor ofxin the direction
of negative infinity. Ifxis the smallest positive subnormal number in the type ofx
the function returns+0. Ifx= 0 the function returns the smallest negative subnormal
number in the type ofx. Ifxis NaN, NaN is returned. Ifxis?¡Þ,?¡Þis returned.
nextdownis from TS 18661-1:2014 and TS 18661-3:2015. nextdownnever raises an
exception except for signaling NaNs.

double nan(const char *tagp) [Function]
float nanf(const char *tagp) [Function]
long double nanl (const char *tagp) [Function]
_FloatN nanfN(const char *tagp) [Function]


Chapter 20: Arithmetic Functions 627

_FloatNx nanfNx (const char *tagp) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thenanfunction returns a representation of NaN, provided that NaN is supported
by the target platform.nan ("n-char-sequence")is equivalent tostrtod ("NAN(n-
char-sequence)").
The argumenttagpis used in an unspecified manner. On IEEE 754 systems, there
are many representations of NaN, andtagpselects one. On other systems it may do
nothing.

int canonicalize (double *cx, const double *x) [Function]
int canonicalizef(float *cx, const float *x) [Function]
int canonicalizel(long double *cx, const long double *x) [Function]
int canonicalizefN( FloatN*cx, const FloatN*x) [Function]
int canonicalizefNx (FloatNx *cx, const FloatNx *x) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
In some floating-point formats, some values have canonical (preferred) and noncanon-
ical encodings (for IEEE interchange binary formats, all encodings are canonical).
These functions, defined by TS 18661-1:2014 and TS 18661-3:2015, attempt to pro-
duce a canonical version of the floating-point value pointed to byx; if that value
is a signaling NaN, they raise the invalid exception and produce a quiet NaN. If a
canonical value is produced, it is stored in the object pointed to bycx, and these
functions return zero. Otherwise (if a canonical value could not be produced because
the object pointed to byxis not a valid representation of any floating-point value),
the object pointed to bycxis unchanged and a nonzero value is returned.
Note that some formats have multiple encodings of a value which are all equally
canonical; when such an encoding is used as an input to this function, any such
encoding of the same value (or of the corresponding quiet NaN, if that value is a
signaling NaN) may be produced as output.

double getpayload(const double *x) [Function]
float getpayloadf(const float *x) [Function]
long double getpayloadl (const long double *x) [Function]
_FloatN getpayloadfN(const FloatN*x) [Function]
_FloatNx getpayloadfNx (const FloatNx *x) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
IEEE 754 defines thepayloadof a NaN to be an integer value encoded in the rep-
resentation of the NaN. Payloads are typically propagated from NaN inputs to the
result of a floating-point operation. These functions, defined by TS 18661-1:2014
and TS 18661-3:2015, return the payload of the NaN pointed to byx(returned as a
positive integer, or positive zero, represented as a floating-point number); ifxis not
a NaN, they return?1. They raise no floating-point exceptions even for signaling
NaNs. (The return value of?1 for an argument that is not a NaN is specified in C2x;
the value was unspecified in TS 18661.)


Chapter 20: Arithmetic Functions 628

int setpayload(double *x, doublepayload) [Function]
int setpayloadf (float *x, floatpayload) [Function]
int setpayloadl (long double *x, long doublepayload) [Function]
int setpayloadfN (FloatN*x, FloatN payload) [Function]
int setpayloadfNx( FloatNx *x, FloatNxpayload) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, defined by TS 18661-1:2014 and TS 18661-3:2015, set the object
pointed to byxto a quiet NaN with payloadpayloadand a zero sign bit and return
zero. Ifpayloadis not a positive-signed integer that is a valid payload for a quiet
NaN of the given type, the object pointed to byxis set to positive zero and a nonzero
value is returned. They raise no floating-point exceptions.

int setpayloadsig(double *x, doublepayload) [Function]
int setpayloadsigf(float *x, floatpayload) [Function]
int setpayloadsigl(long double *x, long doublepayload) [Function]
int setpayloadsigfN (FloatN*x, FloatN payload) [Function]
int setpayloadsigfNx(FloatNx *x, FloatNxpayload) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, defined by TS 18661-1:2014 and TS 18661-3:2015, set the object
pointed to byx to a signaling NaN with payloadpayloadand a zero sign bit and
return zero. Ifpayloadis not a positive-signed integer that is a valid payload for a
signaling NaN of the given type, the object pointed to byxis set to positive zero and
a nonzero value is returned. They raise no floating-point exceptions.

## 20.8.6 Floating-Point Comparison Functions...................

The standard C comparison operators provoke exceptions when one or other of the operands
is NaN. For example,

```
int v = a < 1.0;
```
will raise an exception ifais NaN. (This doesnot happen with==and!=; those merely
return false and true, respectively, when NaN is examined.) Frequently this exception is
undesirable. ISO C99 therefore defines comparison functions that do not raise exceptions
when NaN is examined. All of the functions are implemented as macros which allow their
arguments to be of any floating-point type. The macros are guaranteed to evaluate their
arguments only once. TS 18661-1:2014 adds such a macro for an equality comparison that
does raise an exception for a NaN argument; it also adds functions that provide a total
ordering on all floating-point values, including NaNs, without raising any exceptions even
for signaling NaNs.

int isgreater(real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether the argumentxis greater thany. It is equivalent to
(x) > (y), but no exception is raised ifxoryare NaN.


Chapter 20: Arithmetic Functions 629

int isgreaterequal(real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether the argumentxis greater than or equal toy. It is
equivalent to(x) >= (y), but no exception is raised ifxoryare NaN.

int isless(real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether the argumentxis less thany. It is equivalent to(x)
< (y), but no exception is raised ifxoryare NaN.

int islessequal (real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether the argumentx is less than or equal toy. It is
equivalent to(x) <= (y), but no exception is raised ifxoryare NaN.

int islessgreater(real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether the argumentxis less or greater thany. It is equiv-
alent to(x) < (y) || (x) > (y)(although it only evaluatesxandyonce), but no
exception is raised ifxoryare NaN.
This macro is not equivalent tox!=y, because that expression is true ifxoryare
NaN.

int isunordered (real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether its arguments are unordered. In other words, it is
true ifxoryare NaN, and false otherwise.

int iseqsig(real-floatingx,real-floatingy) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro determines whether its arguments are equal. It is equivalent to(x) ==
(y), but it raises the invalid exception and setserrnotoEDOMif either argument is
a NaN.

int totalorder(const double *x, const double *y) [Function]
int totalorderf (const float *x, const float *y) [Function]
int totalorderl (const long double *x, const long double *y) [Function]
int totalorderfN (const FloatN*x, const FloatN*y) [Function]
int totalorderfNx(const FloatNx *x, const FloatNx *y) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 20: Arithmetic Functions 630

```
These functions determine whether the total order relationship, defined in IEEE 754-
2008, is true for*xand*y, returning nonzero if it is true and zero if it is false. No
exceptions are raised even for signaling NaNs. The relationship is true if they are the
same floating-point value (including sign for zero and NaNs, and payload for NaNs),
or if*xcomes before*yin the following order: negative quiet NaNs, in order of
decreasing payload; negative signaling NaNs, in order of decreasing payload; negative
infinity; finite numbers, in ascending order, with negative zero before positive zero;
positive infinity; positive signaling NaNs, in order of increasing payload; positive quiet
NaNs, in order of increasing payload.
```
int totalordermag(const double *x, const double *y) [Function]
int totalordermagf(const float *x, const float *y) [Function]
int totalordermagl(const long double *x, const long double *y) [Function]
int totalordermagfN (const FloatN*x, const FloatN*y) [Function]
int totalordermagfNx(const FloatNx *x, const FloatNx *y) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions determine whether the total order relationship, defined in IEEE 754-
2008, is true for the absolute values of*xand*y, returning nonzero if it is true and
zero if it is false. No exceptions are raised even for signaling NaNs.

Not all machines provide hardware support for these operations. On machines that
don¡¯t, the macros can be very slow. Therefore, you should not use these functions when
NaN is not a concern.

NB:There are no macrosisequalorisunequal. They are unnecessary, because the==
and!=operators donotthrow an exception if one or both of the operands are NaN.

## 20.8.7 Miscellaneous FP arithmetic functions..................

The functions in this section perform miscellaneous but common operations that are awk-
ward to express with C operators. On some processors these functions can use special
machine instructions to perform these operations faster than the equivalent C code.

double fmin(doublex, doubley) [Function]
float fminf(floatx, floaty) [Function]
long double fminl(long doublex, long doubley) [Function]
_FloatN fminfN( FloatN x, FloatN y) [Function]
_FloatNx fminfNx (FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefminfunction returns the lesser of the two valuesxandy. It is similar to the
expression
((x) < (y)? (x) : (y))
except thatxandyare only evaluated once.
If an argument is NaN, the other argument is returned. If both arguments are NaN,
NaN is returned.


Chapter 20: Arithmetic Functions 631

double fmax(doublex, doubley) [Function]
float fmaxf(floatx, floaty) [Function]
long double fmaxl(long doublex, long doubley) [Function]
_FloatN fmaxfN( FloatN x, FloatN y) [Function]
_FloatNx fmaxfNx (FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefmaxfunction returns the greater of the two valuesxandy.
If an argument is NaN, the other argument is returned. If both arguments are NaN,
NaN is returned.

double fminmag(doublex, doubley) [Function]
float fminmagf(floatx, floaty) [Function]
long double fminmagl(long doublex, long doubley) [Function]
_FloatN fminmagfN( FloatN x, FloatN y) [Function]
_FloatNx fminmagfNx (FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, return whichever of the
two valuesxandyhas the smaller absolute value. If both have the same absolute
value, or either is NaN, they behave the same as thefminfunctions.

double fmaxmag(doublex, doubley) [Function]
float fmaxmagf(floatx, floaty) [Function]
long double fmaxmagl(long doublex, long doubley) [Function]
_FloatN fmaxmagfN( FloatN x, FloatN y) [Function]
_FloatNx fmaxmagfNx (FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014, return whichever of the two valuesxandy
has the greater absolute value. If both have the same absolute value, or either is NaN,
they behave the same as thefmaxfunctions.

double fdim(doublex, doubley) [Function]
float fdimf(floatx, floaty) [Function]
long double fdiml(long doublex, long doubley) [Function]
_FloatN fdimfN( FloatN x, FloatN y) [Function]
_FloatNx fdimfNx (FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefdimfunction returns the positive difference betweenx andy. The positive
difference isx?yifxis greater thany, and 0 otherwise.
Ifx,y, or both are NaN, NaN is returned.

double fma(doublex, doubley, doublez) [Function]
float fmaf(floatx, floaty, floatz) [Function]
long double fmal (long doublex, long doubley, long doublez) [Function]


Chapter 20: Arithmetic Functions 632

_FloatN fmafN( FloatN x, FloatN y, FloatN z) [Function]
_FloatNx fmafNx (FloatNxx, FloatNxy, FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefmafunction performs floating-point multiply-add. This is the operation (x¡¤y)+z,
but the intermediate result is not rounded to the destination type. This can sometimes
improve the precision of a calculation.
This function was introduced because some processors have a special instruction to
perform multiply-add. The C compiler cannot use it directly, because the expression
¡®x*y + z¡¯ is defined to round the intermediate result. fmalets you choose when you
want to round only once.
On processors which do not implement multiply-add in hardware,fmacan be very
slow since it must avoid intermediate rounding.math.hdefines the symbolsFP_FAST_
FMA,FP_FAST_FMAF, andFP_FAST_FMALwhen the corresponding version offmais no
slower than the expression ¡®x*y + z¡¯. In the GNU C Library, this always means the
operation is implemented in hardware.

float fadd(doublex, doubley) [Function]
float faddl(long doublex, long doubley) [Function]
double daddl (long doublex, long doubley) [Function]
_FloatM fMaddfN (FloatN x, FloatN y) [Function]
_FloatM fMaddfNx (FloatNxx, FloatNxy) [Function]
_FloatMx fMxaddfN( FloatN x, FloatN y) [Function]
_FloatMx fMxaddfNx( FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, returnx+y, rounded
once to the return type of the function without any intermediate rounding to the type
of the arguments.

float fsub(doublex, doubley) [Function]
float fsubl(long doublex, long doubley) [Function]
double dsubl (long doublex, long doubley) [Function]
_FloatM fMsubfN (FloatN x, FloatN y) [Function]
_FloatM fMsubfNx (FloatNxx, FloatNxy) [Function]
_FloatMx fMxsubfN( FloatN x, FloatN y) [Function]
_FloatMx fMxsubfNx( FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, returnx?y, rounded
once to the return type of the function without any intermediate rounding to the type
of the arguments.

float fmul(doublex, doubley) [Function]
float fmull(long doublex, long doubley) [Function]
double dmull (long doublex, long doubley) [Function]
_FloatM fMmulfN (FloatN x, FloatN y) [Function]


Chapter 20: Arithmetic Functions 633

_FloatM fMmulfNx (FloatNxx, FloatNxy) [Function]
_FloatMx fMxmulfN( FloatN x, FloatN y) [Function]
_FloatMx fMxmulfNx( FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, returnx?y, rounded
once to the return type of the function without any intermediate rounding to the type
of the arguments.

float fdiv(doublex, doubley) [Function]
float fdivl(long doublex, long doubley) [Function]
double ddivl (long doublex, long doubley) [Function]
_FloatM fMdivfN (FloatN x, FloatN y) [Function]
_FloatM fMdivfNx (FloatNxx, FloatNxy) [Function]
_FloatMx fMxdivfN( FloatN x, FloatN y) [Function]
_FloatMx fMxdivfNx( FloatNxx, FloatNxy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions, from TS 18661-1:2014 and TS 18661-3:2015, returnx/y, rounded
once to the return type of the function without any intermediate rounding to the type
of the arguments.

## 20.9 Complex Numbers..........................................

ISO C99 introduces support for complex numbers in C. This is done with a new type
qualifier,complex. It is a keyword if and only ifcomplex.hhas been included. There
are three complex types, corresponding to the three real types: float complex,double
complex, andlong double complex.

Likewise, on machines that have support for_FloatNor_FloatNxenabled, the complex
types_FloatNcomplexand_FloatNx complex are also available ifcomplex.hhas been
included; seeChapter 19 [Mathematics], page 539.

To construct complex numbers you need a way to indicate the imaginary part of a
number. There is no standard notation for an imaginary floating point constant. Instead,
complex.hdefines two macros that can be used to create complex numbers.

const float complex _Complex_I [Macro]
This macro is a representation of the complex number ¡°0 + 1i¡±. Multiplying a real
floating-point value by_Complex_Igives a complex number whose value is purely
imaginary. You can use this to construct complex constants:
3 .0 + 4. 0 i= 3.0 + 4.0 * _Complex_I
Note that_Complex_I * _Complex_Ihas the value-1, but the type of that value is
complex.

_Complex_Iis a bit of a mouthful. complex.halso defines a shorter name for the same
constant.


Chapter 20: Arithmetic Functions 634

const float complex I [Macro]
This macro has exactly the same value as_Complex_I. Most of the time it is prefer-
able. However, it causes problems if you want to use the identifierIfor something
else. You can safely write
#include <complex.h>
#undef I
if you needIfor your own purposes. (In that case we recommend you also define
some other short name for_Complex_I, such asJ.)

20.10 Projections, Conjugates, and Decomposing of

Complex Numbers

ISO C99 also defines functions that perform basic operations on complex numbers, such as
decomposition and conjugation. The prototypes for all these functions are incomplex.h.
All functions are available in three variants, one for each of the three complex types.

double creal (complex doublez) [Function]
float crealf (complex floatz) [Function]
long double creall(complex long doublez) [Function]
_FloatN crealfN (complex FloatN z) [Function]
_FloatNx crealfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the real part of the complex numberz.

double cimag (complex doublez) [Function]
float cimagf (complex floatz) [Function]
long double cimagl(complex long doublez) [Function]
_FloatN cimagfN (complex FloatN z) [Function]
_FloatNx cimagfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the imaginary part of the complex numberz.

complex double conj (complex doublez) [Function]
complex float conjf (complex floatz) [Function]
complex long double conjl(complex long doublez) [Function]
complex _FloatN conjfN (complex FloatN z) [Function]
complex _FloatNx conjfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the conjugate value of the complex numberz. The conjugate
of a complex number has the same real part and a negated imaginary part. In other
words, ¡®conj(a + bi) = a + -bi¡¯.

double carg(complex doublez) [Function]
float cargf(complex floatz) [Function]
long double cargl(complex long doublez) [Function]


Chapter 20: Arithmetic Functions 635

_FloatN cargfN(complex FloatN z) [Function]
_FloatNx cargfNx (complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the argument of the complex numberz. The argument of a
complex number is the angle in the complex plane between the positive real axis and
a line passing through zero and the number. This angle is measured in the usual
fashion and ranges from?¦Ðto¦Ð.
carghas a branch cut along the negative real axis.

complex double cproj(complex doublez) [Function]
complex float cprojf(complex floatz) [Function]
complex long double cprojl (complex long doublez) [Function]
complex _FloatN cprojfN (complex FloatN z) [Function]
complex _FloatNx cprojfNx(complex FloatNxz) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
These functions return the projection of the complex valuezonto the Riemann sphere.
Values with an infinite imaginary part are projected to positive infinity on the real
axis, even if the real part is NaN. If the real part is infinite, the result is equivalent to
INFINITY + I * copysign (0.0, cimag (z))

## 20.11 Parsing of Numbers........................................

This section describes functions for ¡°reading¡± integer and floating-point numbers from a
string. It may be more convenient in some cases to usesscanf or one of the related
functions; seeSection 12.14 [Formatted Input], page 311. But often you can make a program
more robust by finding the tokens in the string by hand, then converting the numbers one
by one.

## 20.11.1 Parsing of Integers....................................

The ¡®str¡¯ functions are declared instdlib.hand those beginning with ¡®wcs¡¯ are declared in
wchar.h. One might wonder about the use ofrestrictin the prototypes of the functions
in this section. It is seemingly useless but the ISO C standard uses it (for the functions
defined there) so we have to do it as well.

long int strtol (const char *restrictstring, char **restrict [Function]
tailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtol(¡°string-to-long¡±) function converts the initial part ofstringto a signed
integer, which is returned as a value of typelong int.
This function attempts to decomposestringas follows:

- A (possibly empty) sequence of whitespace characters. Which characters are
    whitespace is determined by theisspacefunction (seeSection 4.1 [Classification
    of Characters], page 87). These are discarded.


Chapter 20: Arithmetic Functions 636

- An optional plus or minus sign (¡®+¡¯ or ¡®-¡¯).
- A nonempty sequence of digits in the radix specified bybase.
    Ifbaseis zero, decimal radix is assumed unless the series of digits begins with ¡® 0 ¡¯
    (specifying octal radix), or ¡®0x¡¯ or ¡®0X¡¯ (specifying hexadecimal radix); in other
    words, the same syntax used for integer constants in C.
    Otherwisebasemust have a value between 2 and 36. Ifbaseis 16 , the digits
    may optionally be preceded by ¡®0x¡¯ or ¡®0X¡¯. If base has no legal value the value
    returned is0land the global variableerrnois set toEINVAL.
- Any remaining characters in the string. Iftailptr is not a null pointer,strtol
    stores a pointer to this tail in*tailptr.

```
If the string is empty, contains only whitespace, or does not contain an initial substring
that has the expected syntax for an integer in the specifiedbase, no conversion is
performed. In this case, strtolreturns a value of zero and the value stored in
*tailptris the value ofstring.
In a locale other than the standard"C"locale, this function may recognize additional
implementation-dependent syntax.
If the string has valid syntax for an integer but the value is not representable because
of overflow,strtolreturns eitherLONG_MAXorLONG_MIN(seeSection A.5.2 [Range
of an Integer Type], page 958), as appropriate for the sign of the value. It also sets
errnotoERANGEto indicate there was overflow.
You should not check for errors by examining the return value ofstrtol, because the
string might be a valid representation of0l,LONG_MAX, orLONG_MIN. Instead, check
whethertailptrpoints to what you expect after the number (e.g. '\0'if the string
should end after the number). You also need to clearerrnobefore the call and check
it afterward, in case there was overflow.
There is an example at the end of this section.
```
long int wcstol (const wchart *restrictstring, wchart **restrict [Function]
tailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstolfunction is equivalent to thestrtolfunction in nearly all aspects but
handles wide character strings.
Thewcstolfunction was introduced in Amendment 1 of ISO C90.

unsigned long int strtoul(const char *restrictstring, char [Function]
**restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtoul(¡°string-to-unsigned-long¡±) function is likestrtolexcept it converts to
anunsigned long intvalue. The syntax is the same as described above forstrtol.
The value returned on overflow isULONG_MAX(seeSection A.5.2 [Range of an Integer
Type], page 958).


Chapter 20: Arithmetic Functions 637

```
Ifstring depicts a negative number,strtoulacts the same asstrtolbut casts the
result to an unsigned integer. That means for example thatstrtoulon"-1"returns
ULONG_MAXand an input more negative thanLONG_MINreturns (ULONG_MAX +1) / 2.
strtoulsetserrnotoEINVALifbaseis out of range, orERANGEon overflow.
```
unsigned long int wcstoul(const wchart *restrictstring, [Function]
wchart **restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstoulfunction is equivalent to thestrtoulfunction in nearly all aspects but
handles wide character strings.
Thewcstoulfunction was introduced in Amendment 1 of ISO C90.

long long int strtoll(const char *restrictstring, char **restrict [Function]
tailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtollfunction is likestrtolexcept that it returns along long intvalue,
and accepts numbers with a correspondingly larger range.
If the string has valid syntax for an integer but the value is not representable because
of overflow,strtollreturns eitherLLONG_MAXorLLONG_MIN(seeSection A.5.2 [Range
of an Integer Type], page 958), as appropriate for the sign of the value. It also sets
errnotoERANGEto indicate there was overflow.
Thestrtollfunction was introduced in ISO C99.

long long int wcstoll(const wchart *restrictstring, wchart [Function]
**restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstollfunction is equivalent to thestrtollfunction in nearly all aspects but
handles wide character strings.
Thewcstollfunction was introduced in Amendment 1 of ISO C90.

long long int strtoq(const char *restrictstring, char **restrict [Function]
tailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
strtoq(¡°string-to-quad-word¡±) is the BSD name forstrtoll.

long long int wcstoq(const wchart *restrictstring, wchart [Function]
**restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstoqfunction is equivalent to thestrtoqfunction in nearly all aspects but
handles wide character strings.
Thewcstoqfunction is a GNU extension.


Chapter 20: Arithmetic Functions 638

unsigned long long int strtoull(const char *restrictstring, [Function]
char **restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtoullfunction is related tostrtollthe same waystrtoulis related to
strtol.
Thestrtoullfunction was introduced in ISO C99.

unsigned long long int wcstoull(const wchart *restrict [Function]
string, wchar t **restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstoullfunction is equivalent to thestrtoullfunction in nearly all aspects
but handles wide character strings.
Thewcstoullfunction was introduced in Amendment 1 of ISO C90.

unsigned long long int strtouq (const char *restrictstring, [Function]
char **restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
strtouqis the BSD name forstrtoull.

unsigned long long int wcstouq (const wchart *restrictstring, [Function]
wchart **restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstouqfunction is equivalent to thestrtouqfunction in nearly all aspects but
handles wide character strings.
Thewcstouqfunction is a GNU extension.

intmax_t strtoimax(const char *restrictstring, char **restrict [Function]
tailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtoimaxfunction is likestrtolexcept that it returns aintmax_tvalue, and
accepts numbers of a corresponding range.
If the string has valid syntax for an integer but the value is not representable because
of overflow,strtoimaxreturns eitherINTMAX_MAXorINTMAX_MIN(seeSection 20.1
[Integers], page 601), as appropriate for the sign of the value. It also setserrnoto
ERANGEto indicate there was overflow.
SeeSection 20.1 [Integers], page 601,for a description of theintmax_ttype. The
strtoimaxfunction was introduced in ISO C99.

intmax_t wcstoimax(const wchart *restrictstring, wchar t [Function]
**restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.


Chapter 20: Arithmetic Functions 639

```
Thewcstoimaxfunction is equivalent to thestrtoimaxfunction in nearly all aspects
but handles wide character strings.
Thewcstoimaxfunction was introduced in ISO C99.
```
uintmax_t strtoumax (const char *restrictstring, char **restrict [Function]
tailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtoumaxfunction is related tostrtoimaxthe same way thatstrtoulis related
tostrtol.
SeeSection 20.1 [Integers], page 601,for a description of theintmax_ttype. The
strtoumaxfunction was introduced in ISO C99.

uintmax_t wcstoumax (const wchart *restrictstring, wchart [Function]
**restricttailptr, intbase)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstoumaxfunction is equivalent to thestrtoumaxfunction in nearly all aspects
but handles wide character strings.
Thewcstoumaxfunction was introduced in ISO C99.

long int atol(const char *string) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is similar to thestrtolfunction with abaseargument of 10 , except
that it need not detect overflow errors. Theatolfunction is provided mostly for
compatibility with existing code; usingstrtolis more robust.

int atoi (const char *string) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is likeatol, except that it returns anint. Theatoifunction is also
considered obsolete; usestrtolinstead.

long long int atoll (const char *string) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is similar toatol, except it returns along long int.
Theatollfunction was introduced in ISO C99. It too is obsolete (despite having
just been added); usestrtollinstead.

All the functions mentioned in this section so far do not handle alternative representa-
tions of characters as described in the locale data. Some locales specify thousands separator
and the way they have to be used which can help to make large numbers more readable.
To read such numbers one has to use thescanffunctions with the ¡®'¡¯ flag.


Chapter 20: Arithmetic Functions 640

Here is a function which parses a string as a sequence of integers and returns the sum
of them:
int
sum_ints_from_string (char *string)
{
int sum = 0;

```
while (1) {
char *tail;
int next;
```
```
/*Skip whitespace by hand, to detect the end. */
while (isspace (*string)) string++;
if (*string == 0)
break;
```
```
/*There is more nonwhitespace, */
/*so it ought to be another number. */
errno = 0;
/*Parse it. */
next = strtol (string, &tail, 0);
/*Add it in, if not overflow. */
if (errno)
printf ("Overflow\n");
else
sum += next;
/*Advance past it. */
string = tail;
}
```
```
return sum;
}
```
## 20.11.2 Parsing of Floats......................................

The ¡®str¡¯ functions are declared instdlib.hand those beginning with ¡®wcs¡¯ are declared in
wchar.h. One might wonder about the use ofrestrictin the prototypes of the functions
in this section. It is seemingly useless but the ISO C standard uses it (for the functions
defined there) so we have to do it as well.

double strtod(const char *restrictstring, char **restrict [Function]
tailptr)
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thestrtod (¡°string-to-double¡±) function converts the initial part ofstring to a
floating-point number, which is returned as a value of typedouble.
This function attempts to decomposestringas follows:

- A (possibly empty) sequence of whitespace characters. Which characters are
    whitespace is determined by theisspacefunction (seeSection 4.1 [Classification
    of Characters], page 87). These are discarded.
- An optional plus or minus sign (¡®+¡¯ or ¡®-¡¯).
- A floating point number in decimal or hexadecimal format. The decimal format
    is:


Chapter 20: Arithmetic Functions 641

```
? A nonempty sequence of digits optionally containing a decimal-point
character¡ªnormally ¡®.¡¯, but it depends on the locale (seeSection 7.7.1.1
[Generic Numeric Formatting Parameters], page 189).
? An optional exponent part, consisting of a character ¡®e¡¯ or ¡®E¡¯, an optional
sign, and a sequence of digits.
```
```
The hexadecimal format is as follows:
? A 0x or 0X followed by a nonempty sequence of hexadecimal digits option-
ally containing a decimal-point character¡ªnormally ¡®.¡¯, but it depends on
the locale (seeSection 7.7.1.1 [Generic Numeric Formatting Parameters],
page 189).
? An optional binary-exponent part, consisting of a character ¡®p¡¯ or ¡®P¡¯, an
optional sign, and a sequence of digits.
```
- Any remaining characters in the string. Iftailptris not a null pointer, a pointer
    to this tail of the string is stored in*tailptr.

```
If the string is empty, contains only whitespace, or does not contain an initial substring
that has the expected syntax for a floating-point number, no conversion is performed.
In this case,strtodreturns a value of zero and the value returned in*tailptris the
value ofstring.
In a locale other than the standard"C"or"POSIX"locales, this function may recognize
additional locale-dependent syntax.
If the string has valid syntax for a floating-point number but the value is outside
the range of a double, strtod will signal overflow or underflow as described in
Section 20.5.4 [Error Reporting by Mathematical Functions], page 612.
strtodrecognizes four special input strings. The strings"inf"and"infinity"
are converted to¡Þ, or to the largest representable value if the floating-point format
doesn¡¯t support infinities. You can prepend a"+"or"-"to specify the sign. Case is
ignored when scanning these strings.
The strings"nan"and"nan(chars...)"are converted to NaN. Again, case is ig-
nored. Ifchars.. .are provided, they are used in some unspecified fashion to select a
particular representation of NaN (there can be several).
Since zero is a valid result as well as the value returned on error, you should check
for errors in the same way as forstrtol, by examiningerrnoandtailptr.
```
float strtof (const char *string, char **tailptr) [Function]
long double strtold (const char *string, char **tailptr) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
These functions are analogous tostrtod, but returnfloatandlong doublevalues
respectively. They report errors in the same way asstrtod.strtofcan be substan-
tially faster thanstrtod, but has less precision; conversely,strtoldcan be much
slower but has more precision (on systems wherelong doubleis a separate type).
These functions have been GNU extensions and are new to ISO C99.


Chapter 20: Arithmetic Functions 642

_FloatN strtofN (const char *string, char **tailptr) [Function]
_FloatNx strtofNx(const char *string, char **tailptr) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
These functions are likestrtod, except for the return type.
They were introduced in ISO/IEC TS 18661-3 and are available on machines that
support the related types; seeChapter 19 [Mathematics], page 539.

double wcstod(const wchart *restrictstring, wchart **restrict [Function]
tailptr)
float wcstof (const wchart *string, wchar t **tailptr) [Function]
long double wcstold (const wchart *string, wchart **tailptr) [Function]
_FloatN wcstofN (const wchart *string, wchart **tailptr) [Function]
_FloatNx wcstofNx(const wchar t *string, wchart **tailptr) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thewcstod,wcstof,wcstol,wcstofN, andwcstofNxfunctions are equivalent in
nearly all aspects to thestrtod,strtof,strtold,strtofN, andstrtofNxfunctions,
but they handle wide character strings.
Thewcstodfunction was introduced in Amendment 1 of ISO C90. Thewcstofand
wcstoldfunctions were introduced in ISO C99.
ThewcstofNandwcstofNxfunctions are not in any standard, but are added to
provide completeness for the non-deprecated interface of wide character string to
floating-point conversion functions. They are only available on machines that support
the related types; seeChapter 19 [Mathematics], page 539.

double atof(const char *string) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is similar to thestrtodfunction, except that it need not detect overflow
and underflow errors. Theatoffunction is provided mostly for compatibility with
existing code; usingstrtodis more robust.

The GNU C Library also provides ¡®_l¡¯ versions of these functions, which take an addi-
tional argument, the locale to use in conversion.

```
See alsoSection 20.11.1 [Parsing of Integers], page 635.
```
## 20.12 Printing of Floats..........................................

The ¡®strfrom¡¯ functions are declared instdlib.h.

int strfromd (char *restrictstring, sizetsize, const char [Function]
*restrictformat, doublevalue)
int strfromf (char *restrictstring, sizetsize, const char [Function]
*restrictformat, floatvalue)


Chapter 20: Arithmetic Functions 643

int strfroml (char *restrictstring, sizetsize, const char [Function]
*restrictformat, long doublevalue)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionsstrfromd(¡°string-from-double¡±),strfromf(¡°string-from-float¡±), and
strfroml(¡°string-from-long-double¡±) convert the floating-point numbervalueto a
string of characters and stores them into the area pointed to bystring. The conversion
writes at mostsizecharacters and respects the format specified byformat.
The format string must start with the character ¡®%¡¯. An optional precision follows,
which starts with a period, ¡®.¡¯, and may be followed by a decimal integer, representing
the precision. If a decimal integer is not specified after the period, the precision is
taken to be zero. The character ¡®*¡¯ is not allowed. Finally, the format string ends
with one of the following conversion specifiers: ¡®a¡¯, ¡®A¡¯, ¡®e¡¯, ¡®E¡¯, ¡®f¡¯, ¡®F¡¯, ¡®g¡¯ or ¡®G¡¯
(seeSection 12.12.3 [Table of Output Conversions], page 290). Invalid format strings
result in undefined behavior.
These functions return the number of characters that would have been written to
stringhadsizebeen sufficiently large, not counting the terminating null character.
Thus, the null-terminated output has been completely written if and only if the
returned value is less thansize.
These functions were introduced by ISO/IEC TS 18661-1.

int strfromfN(char *restrictstring, sizetsize, const char [Function]
*restrictformat, FloatN value)
int strfromfNx(char *restrictstring, sizetsize, const char [Function]
*restrictformat, FloatNxvalue)
Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
These functions are likestrfromd, except for the type ofvalue.
They were introduced in ISO/IEC TS 18661-3 and are available on machines that
support the related types; seeChapter 19 [Mathematics], page 539.

## 20.13 Old-fashioned System V number-to-string functions.........

The old System V C library provided three functions to convert numbers to strings, with
unusual and hard-to-use semantics. The GNU C Library also provides these functions and
some natural extensions.

These functions are only available in the GNU C Library and on systems descended from
AT&T Unix. Therefore, unless these functions do precisely what you need, it is better to
usesprintf, which is standard.

```
All these functions are defined instdlib.h.
```
char * ecvt(doublevalue, intndigit, int *decpt, int *neg) [Function]
Preliminary: |MT-Unsafe race:ecvt|AS-Unsafe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
The functionecvtconverts the floating-point numbervalueto a string with at most
ndigitdecimal digits. The returned string contains no decimal point or sign. The


Chapter 20: Arithmetic Functions 644

```
first digit of the string is non-zero (unlessvalueis actually zero) and the last digit is
rounded to nearest.*decptis set to the index in the string of the first digit after the
decimal point.*negis set to a nonzero value ifvalueis negative, zero otherwise.
Ifndigitdecimal digits would exceed the precision of adouble it is reduced to a
system-specific value.
The returned string is statically allocated and overwritten by each call toecvt.
Ifvalueis zero, it is implementation defined whether*decptis 0 or 1.
For example:ecvt (12.3, 5, &d, &n)returns"12300"and setsdto 2 andnto 0.
```
char * fcvt(doublevalue, intndigit, int *decpt, int *neg) [Function]
Preliminary: |MT-Unsafe race:fcvt| AS-Unsafe heap|AC-Unsafe mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The functionfcvtis likeecvt, butndigitspecifies the number of digits after the
decimal point. Ifndigitis less than zero,valueis rounded to thendigit+ 1¡¯th place
to the left of the decimal point. For example, ifndigitis-1,valuewill be rounded to
the nearest 10. Ifndigitis negative and larger than the number of digits to the left
of the decimal point invalue,valuewill be rounded to one significant digit.
Ifndigitdecimal digits would exceed the precision of adouble it is reduced to a
system-specific value.
The returned string is statically allocated and overwritten by each call tofcvt.

char * gcvt(doublevalue, intndigit, char *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
gcvtis functionally equivalent to ¡®sprintf(buf, "%*g", ndigit, value)¡¯. It is pro-
vided only for compatibility¡¯s sake. It returnsbuf.
Ifndigitdecimal digits would exceed the precision of adouble it is reduced to a
system-specific value.

As extensions, the GNU C Library provides versions of these three functions that take
long doublearguments.

char * qecvt (long doublevalue, intndigit, int *decpt, int *neg) [Function]
Preliminary:|MT-Unsafe race:qecvt|AS-Unsafe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function is equivalent toecvtexcept that it takes along doublefor the first
parameter and thatndigitis restricted by the precision of along double.

char * qfcvt (long doublevalue, intndigit, int *decpt, int *neg) [Function]
Preliminary: |MT-Unsafe race:qfcvt|AS-Unsafe heap|AC-Unsafe mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is equivalent tofcvtexcept that it takes along doublefor the first
parameter and thatndigitis restricted by the precision of along double.


Chapter 20: Arithmetic Functions 645

char * qgcvt (long doublevalue, intndigit, char *buf) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is equivalent togcvtexcept that it takes along doublefor the first
parameter and thatndigitis restricted by the precision of along double.

Theecvtandfcvtfunctions, and theirlong doubleequivalents, all return a string
located in a static buffer which is overwritten by the next call to the function. The GNU
C Library provides another set of extended functions which write the converted string into
a user-supplied buffer. These have the conventional_rsuffix.

```
gcvt_ris not necessary, becausegcvtalready uses a user-supplied buffer.
```
int ecvt_r(doublevalue, intndigit, int *decpt, int *neg, char [Function]
*buf, sizetlen)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theecvt_rfunction is the same asecvt, except that it places its result into the
user-specified buffer pointed to bybuf, with lengthlen. The return value is-1in case
of an error and zero otherwise.
This function is a GNU extension.

int fcvt_r(doublevalue, intndigit, int *decpt, int *neg, char [Function]
*buf, sizetlen)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thefcvt_rfunction is the same asfcvt, except that it places its result into the
user-specified buffer pointed to bybuf, with lengthlen. The return value is-1in case
of an error and zero otherwise.
This function is a GNU extension.

int qecvt_r(long doublevalue, intndigit, int *decpt, int *neg, [Function]
char *buf, sizetlen)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theqecvt_rfunction is the same asqecvt, except that it places its result into the
user-specified buffer pointed to bybuf, with lengthlen. The return value is-1in case
of an error and zero otherwise.
This function is a GNU extension.

int qfcvt_r(long doublevalue, intndigit, int *decpt, int *neg, [Function]
char *buf, sizetlen)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theqfcvt_rfunction is the same asqfcvt, except that it places its result into the
user-specified buffer pointed to bybuf, with lengthlen. The return value is-1in case
of an error and zero otherwise.
This function is a GNU extension.


### 646

## 21 Date and Time......................................

This chapter describes functions for manipulating dates and times, including functions for
determining what time it is and conversion between different time representations.

## 21.1 Time Basics.................................................

Discussing time in a technical manual can be difficult because the word ¡°time¡± in English
refers to lots of different things. In this manual, we use a rigorous terminology to avoid
confusion, and the only thing we use the simple word ¡°time¡± for is to talk about the abstract
concept.

Acalendar timeis a point in the time continuum, for example November 4, 1990, at
18:02.5 UTC. Sometimes this is called ¡°absolute time¡±.

We don¡¯t speak of a ¡°date¡±, because that is inherent in a calendar time.
Anintervalis a contiguous part of the time continuum between two calendar times, for
example the hour between 9:00 and 10:00 on July 4, 1980.

Anelapsed timeis the length of an interval, for example, 35 minutes. People sometimes
sloppily use the word ¡°interval¡± to refer to the elapsed time of some interval.

Anamount of timeis a sum of elapsed times, which need not be of any specific intervals.
For example, the amount of time it takes to read a book might be 9 hours, independently
of when and in how many sittings it is read.

Aperiodis the elapsed time of an interval between two events, especially when they are
part of a sequence of regularly repeating events.

Asimple calendar timeis a calendar time represented as an elapsed time since a fixed,
implementation-specific calendar time called theepoch. This representation is convenient
for doing calculations on calendar times, such as finding the elapsed time between two
calendar times. Simple calendar times are independent of time zone; they represent the
same instant in time regardless of where on the globe the computer is.

POSIX says that simple calendar times do not include leap seconds, but some (otherwise
POSIX-conformant) systems can be configured to include leap seconds in simple calendar
times.

Abroken-down timeis a calendar time represented by its components in the Gregorian
calendar: year, month, day, hour, minute, and second. A broken-down time value is relative
to a specific time zone, and so it is also sometimes called alocal time. Broken-down times
are most useful for input and output, as they are easier for people to understand, but more
difficult to calculate with.

CPU timemeasures the amount of time that a single process has actively used a CPU
to perform computations. It does not include the time that process has spent waiting for
external events. The system tracks the CPU time used by each process separately.

Processor timemeasures the amount of timeanyCPU has been in use byanyprocess.
It is a basic system resource, since there¡¯s a limit to how much can exist in any given interval
(the elapsed time of the interval times the number of CPUs in the computer)

People often call this CPU time, but we reserve the latter term in this manual for the
definition above.


Chapter 21: Date and Time 647

## 21.2 Time Types.................................................

ISO C and POSIX define several data types for representing elapsed times, simple calendar
times, and broken-down times.

clock_t [Data Type]
clock_tis used to measure processor and CPU time. It may be an integer or a
floating-point type. Its values are counts ofclock tickssince some arbitrary event in
the past. The number of clock ticks per second is system-specific. SeeSection 21.4
[Processor And CPU Time], page 649, for further detail.

time_t [Data Type]
time_tis the simplest data type used to represent simple calendar time.
In ISO C,time_tcan be either an integer or a floating-point type, and the meaning of
time_tvalues is not specified. The only things a strictly conforming program can do
withtime_tvalues are: pass them todifftimeto get the elapsed time between two
simple calendar times (seeSection 21.3 [Calculating Elapsed Time], page 648), and
pass them to the functions that convert them to broken-down time (seeSection 21.5.3
[Broken-down Time], page 659).
On POSIX-conformant systems,time_tis an integer type and its values represent
the number of seconds elapsed since theepoch, which is 00:00:00 on January 1, 1970,
Coordinated Universal Time.
The GNU C Library additionally guarantees thattime_tis a signed type, and that
all of its functions operate correctly on negativetime_tvalues, which are interpreted
as times before the epoch.

struct timespec [Data Type]
struct timespecrepresents a simple calendar time, or an elapsed time, with sub-
second resolution. It is declared intime.hand has the following members:

```
time_t tv_sec
The number of whole seconds elapsed since the epoch (for a simple cal-
endar time) or since some other starting point (for an elapsed time).
```
```
long int tv_nsec
The number of nanoseconds elapsed since the time given by thetv_sec
member.
Whenstruct timespecvalues are produced by GNU C Library func-
tions, the value in this field will always be greater than or equal to zero,
and less than 1,000,000,000. Whenstruct timespecvalues are supplied
to GNU C Library functions, the value in this field must be in the same
range.
```
struct timeval [Data Type]
struct timevalis an older type for representing a simple calendar time, or an elapsed
time, with sub-second resolution. It is almost the same asstruct timespec, but pro-
vides only microsecond resolution. It is declared insys/time.hand has the following
members:


Chapter 21: Date and Time 648

```
time_t tv_sec
The number of whole seconds elapsed since the epoch (for a simple cal-
endar time) or since some other starting point (for an elapsed time).
long int tv_usec
The number of microseconds elapsed since the time given by thetv_sec
member.
Whenstruct timevalvalues are produced by GNU C Library functions,
the value in this field will always be greater than or equal to zero, and
less than 1,000,000. Whenstruct timevalvalues are supplied to GNU
C Library functions, the value in this field must be in the same range.
```
struct tm [Data Type]
This is the data type used to represent a broken-down time. It has separate fields for
year, month, day, and so on. SeeSection 21.5.3 [Broken-down Time], page 659, for
further details.

## 21.3 Calculating Elapsed Time...................................

Often, one wishes to calculate an elapsed time as the difference between two simple calendar
times. The GNU C Library provides only one function for this purpose.

double difftime (timetend, timetbegin) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thedifftimefunction returns the number of seconds of elapsed time from calendar
timebeginto calendar timeend, as a value of typedouble.
On POSIX-conformant systems, the advantage of using ¡®difftime (end,begin)¡¯
over ¡®end-begin¡¯ is that it will produce the mathematically correct result even if
endandbeginare so far apart that a simple subtraction would overflow. However, if
they are so far apart that adoublecannot exactly represent the difference, the result
will be inexact.
On other systems,time_tvalues might be encoded in a way that prevents subtraction
from working directly, and thendifftimewould be the only way to compute their
difference.

The GNU C Library does not provide any functions for computing the difference between
two values of typestruct timevalorstruct timespec. Here is the recommended way to
do this calculation by hand. It works even on some peculiar operating systems where the
tv_secmember has an unsigned type.

```
/*Subtract the ¡®struct timeval¡¯ values X and Y,
storing the result in RESULT.
Return 1 if the difference is negative, otherwise 0.*/
```
```
int
timeval_subtract (struct timeval *result, struct timeval *x, struct timeval *y)
{
/*Perform the carry for the later subtraction by updatingy.*/
if (x->tv_usec < y->tv_usec) {
```

Chapter 21: Date and Time 649

```
int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
y->tv_usec -= 1000000 * nsec;
y->tv_sec += nsec;
}
if (x->tv_usec - y->tv_usec > 1000000) {
int nsec = (x->tv_usec - y->tv_usec) / 1000000;
y->tv_usec += 1000000 * nsec;
y->tv_sec -= nsec;
}
```
```
/*Compute the time remaining to wait.
tv_usecis certainly positive.*/
result->tv_sec = x->tv_sec - y->tv_sec;
result->tv_usec = x->tv_usec - y->tv_usec;
```
```
/*Return 1 if result is negative.*/
return x->tv_sec < y->tv_sec;
}
```
## 21.4 Processor And CPU Time...................................

If you¡¯re trying to optimize your program or measure its efficiency, it¡¯s very useful to know
how much processor time it uses. For that, calendar time and elapsed times are useless
because a process may spend time waiting for I/O or for other processes to use the CPU.
However, you can get the information with the functions in this section.

CPU time (seeSection 21.1 [Time Basics], page 646) is represented by the data type
clock_t, which is a number ofclock ticks. It gives the total amount of time a process
has actively used a CPU since some arbitrary event. On GNU systems, that event is the
creation of the process. While arbitrary in general, the event is always the same event for
any particular process, so you can always measure how much time on the CPU a particular
computation takes by examining the process¡¯ CPU time before and after the computation.

On GNU/Linux and GNU/Hurd systems, clock_t is equivalent to long int and
CLOCKS_PER_SECis an integer value. But in other systems, bothclock_tand the macro
CLOCKS_PER_SECcan be either integer or floating-point types. Casting CPU time values
todouble, as in the example above, makes sure that operations such as arithmetic and
printing work properly and consistently no matter what the underlying representation is.

Note that the clock can wrap around. On a 32bit system withCLOCKS_PER_SECset to
one million this function will return the same value approximately every 72 minutes.

For additional functions to examine a process¡¯ use of processor time, and to control it,
seeChapter 22 [Resource Usage And Limitation], page 684.

## 21.4.1 CPU Time Inquiry.....................................

To get a process¡¯ CPU time, you can use theclockfunction. This facility is declared in
the header filetime.h.

In typical usage, you call theclockfunction at the beginning and end of the interval
you want to time, subtract the values, and then divide byCLOCKS_PER_SEC(the number of
clock ticks per second) to get processor time, like this:


Chapter 21: Date and Time 650

```
#include <time.h>
```
```
clock_t start, end;
double cpu_time_used;
```
start = clock();
... /*Do the work.*/
end = clock();
cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
Do not use a single CPU time as an amount of time; it doesn¡¯t work that way. Either do
a subtraction as shown above or query processor time directly. SeeSection 21.4.2 [Processor
Time Inquiry], page 650.

Different computers and operating systems vary wildly in how they keep track of CPU
time. It¡¯s common for the internal processor clock to have a resolution somewhere between
a hundredth and millionth of a second.

int CLOCKS_PER_SEC [Macro]
The value of this macro is the number of clock ticks per second measured by the
clockfunction. POSIX requires that this value be one million independent of the
actual resolution.

clock_t clock(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the calling process¡¯ current CPU time. If the CPU time is not
available or cannot be represented,clockreturns the value(clock_t)(-1).

## 21.4.2 Processor Time Inquiry.................................

Thetimesfunction returns information about a process¡¯ consumption of processor time in
astruct tmsobject, in addition to the process¡¯ CPU time. SeeSection 21.1 [Time Basics],
page 646. You should include the header filesys/times.hto use this facility.

struct tms [Data Type]
Thetmsstructure is used to return information about process times. It contains at
least the following members:
clock_t tms_utime
This is the total processor time the calling process has used in executing
the instructions of its program.
clock_t tms_stime
This is the processor time the system has used on behalf of the calling
process.
clock_t tms_cutime
This is the sum of thetms_utimevalues and thetms_cutimevalues of
all terminated child processes of the calling process, whose status has
been reported to the parent process bywaitorwaitpid; seeSection 26.6
[Process Completion], page 809. In other words, it represents the total
processor time used in executing the instructions of all the terminated


Chapter 21: Date and Time 651

```
child processes of the calling process, excluding child processes which
have not yet been reported bywaitorwaitpid.
```
```
clock_t tms_cstime
This is similar totms_cutime, but represents the total processor time
the system has used on behalf of all the terminated child processes of the
calling process.
```
```
All of the times are given in numbers of clock ticks. Unlike CPU time, these are
the actual amounts of time; not relative to any event. SeeSection 26.4 [Creating a
Process], page 805.
```
int CLK_TCK [Macro]
This is an obsolete name for the number of clock ticks per second. Usesysconf
(_SC_CLK_TCK)instead.

clock_t times(struct tms *buffer) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thetimesfunction stores the processor time information for the calling process in
buffer.
The return value is the number of clock ticks since an arbitrary point in the past, e.g.
since system start-up.timesreturns(clock_t)(-1)to indicate failure.

Portability Note:Theclockfunction described inSection 21.4.1 [CPU Time Inquiry],
page 649,is specified by the ISO C standard. Thetimesfunction is a feature of POSIX.1.
On GNU systems, the CPU time is defined to be equivalent to the sum of thetms_utime
andtms_stimefields returned bytimes.

## 21.5 Calendar Time..............................................

This section describes the functions for getting, setting, and manipulating calendar times.

## 21.5.1 Getting the Time.......................................

The GNU C Library provides several functions for getting the current calendar time, with
different levels of resolution.

time_t time(timet *result) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is the simplest function for getting the current calendar time. It returns the calen-
dar time as a value of typetime_t; on POSIX systems, that means it has a resolution
of one second. It uses the same clock as ¡®clock_gettime (CLOCK_REALTIME_COARSE)¡¯,
when the clock is available or ¡®clock_gettime (CLOCK_REALTIME)¡¯ otherwise.
If the argumentresultis not a null pointer, the calendar time value is also stored in
*result.
This function cannot fail.


Chapter 21: Date and Time 652

Some applications need more precise timekeeping than is possible with atime_talone.
Some applications also need more control over what is meant by ¡°the current time.¡± For
these applications, POSIX provides a functionclock_gettimethat can retrieve the time
with up to nanosecond precision, from a variety of different clocks. Clocks can be system-
wide, measuring time the same for all processes; or they can be per-process or per-thread,
measuring CPU time consumed by a particular process, or some other similar resource.
Each clock has its own resolution and epoch. You can find the resolution of a clock with
the functionclock_getres. There is no function to get the epoch for a clock; either it is
fixed and documented, or the clock is not meant to be used to measure absolute times.

clockid_t [Data Type]
The typeclockid_tis used for constants that indicate which of several system clocks
one wishes to use.

```
All systems that support this family of functions will define at least this clock constant:
```
clockid_t CLOCK_REALTIME [Macro]
This clock uses the POSIX epoch, 00:00:00 on January 1, 1970, Coordinated Universal
Time. It is close to, but not necessarily in lock-step with, the clocks oftime(above)
and ofgettimeofday(below).

A second clock constant which is not universal, but still very common, is for a clock
measuringmonotonic time. Monotonic time is useful for measuring elapsed times, because
it guarantees that those measurements are not affected by changes to the system clock.

clockid_t CLOCK_MONOTONIC [Macro]
System-wide clock that continuously measures the advancement of calendar time,
ignoring discontinuous changes to the system¡¯s setting for absolute calendar time.
The epoch for this clock is an unspecified point in the past. The epoch may change
if the system is rebooted or suspended. Therefore,CLOCK_MONOTONICcannot be used
to measure absolute time, only elapsed time.

```
Systems may support more than just these two clocks.
```
int clock_gettime(clockid tclock, struct timespec *ts) [Function]
Get the current time accoding to the clock identified byclock, storing it as seconds
and nanoseconds in*ts. SeeSection 21.2 [Time Types], page 647, for a description
ofstruct timespec.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:

```
EINVAL The clock identified byclockis not supported.
```
clock_gettime reports the time scaled to seconds and nanoseconds, but the actual
resolution of each clock may not be as fine as one nanosecond, and may not be the same for
all clocks. POSIX also provides a function for finding out the actual resolution of a clock:

int clock_getres (clockid tclock, struct timespec *res) [Function]
Get the actual resolution of the clock identified byclock, storing it in*ts.


Chapter 21: Date and Time 653

```
For instance, if the clock hardware forCLOCK_REALTIMEuses a quartz crystal that
oscillates at 32.768 kHz, then its resolution would be 30.518 microseconds, and
¡®clock_getres (CLOCK_REALTIME, &r)¡¯ would setr.tv_secto 0 andr.tv_nsecto
30518.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:
EINVAL The clock identified byclockis not supported.
```
These functions, and the constants that identify particular clocks, are declared intime.h.
Portability Note: On some systems, including systems that use older versions of the
GNU C Library, programs that useclock_gettimeorclock_setresmust be linked with
the-lrtlibrary. This has not been necessary with the GNU C Library since version 2.17.

The GNU C Library also provides an older, but still widely used, function for getting the
current time with a resolution of microseconds. This function is declared insys/time.h.

int gettimeofday (struct timeval *tp, void *tzp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Get the current calendar time, storing it as seconds and microseconds in*tp. See
Section 21.2 [Time Types], page 647, for a description ofstruct timeval. The clock
ofgettimeofdayis close to, but not necessarily in lock-step with, the clocks oftime
and of ¡®clock_gettime (CLOCK_REALTIME)¡¯ (see above).
On some historic systems, iftzpwas not a null pointer, information about a system-
wide time zone would be written to*tzp. This feature is obsolete and not supported
on GNU systems. You should always supply a null pointer for this argument. Instead,
use the facilities described inSection 21.5.7 [Functions and Variables for Time Zones],
page 678,and inSection 21.5.3 [Broken-down Time], page 659,for working with time
zones.
This function cannot fail, and its return value is always 0.
Portability Note:As of the 2008 revision of POSIX, this function is considered obso-
lete. The GNU C Library will continue to provide this function indefinitely, but new
programs should useclock_gettimeinstead.

## 21.5.2 Setting and Adjusting the Time........................

The clock hardware inside a modern computer is quite reliable, but it can still be wrong.
The functions in this section allow one to set the system¡¯s idea of the current calendar time,
and to adjust the rate at which the system counts seconds, so that the calendar time will
both be accurate, and remain accurate.

The functions in this section require special privileges to use. SeeChapter 30 [Users and
Groups], page 845.

int clock_settime(clockid tclock, const struct timespec *ts) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Change the current calendar time, according to the clock identified byclock, to be
the simple calendar time in*ts.


Chapter 21: Date and Time 654

```
Not all of the system¡¯s clocks can be changed. For instance, theCLOCK_REALTIME
clock can be changed (with the appropriate privileges), but theCLOCK_MONOTONIC
clock cannot.
Because simple calendar times are independent of time zone, this function should not
be used when the time zone changes (e.g. if the computer is physically moved from
one zone to another). Instead, use the facilities described inSection 21.5.7 [Functions
and Variables for Time Zones], page 678.
clock_settimecauses the clock to jump forwards or backwards, which can cause a
variety of problems. Changing theCLOCK_REALTIMEclock withclock_settimedoes
not affect when timers expire (seeSection 21.6 [Setting an Alarm], page 679) or when
sleeping processes wake up (seeSection 21.7 [Sleeping], page 682), which avoids some
of the problems. Still, for small changes made while the system is running, it is better
to usentp_adjtime(below) to make a smooth transition from one time to another.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:
```
```
EINVAL The clock identified byclockis not supported or cannot be set at all, or
the simple calendar time in*tsis invalid (for instance,ts->tv_nsecis
negative or greater than 999,999,999).
```
```
EPERM This process does not have the privileges required to set the clock iden-
tified byclock.
```
```
Portability Note: On some systems, including systems that use older versions of the
GNU C Library, programs that useclock_settimemust be linked with the-lrt
library. This has not been necessary with the GNU C Library since version 2.17.
```
For systems that remain up and running for long periods, it is not enough to set the
time once; one should alsodisciplinethe clock so that it does not drift away from the true
calendar time.

Thentp_gettimeandntp_adjtimefunctions provide an interface to monitor and disci-
pline the system clock. For example, you can fine-tune the rate at which the clock ¡°ticks,¡±
and make small adjustments to the current reported calendar time smoothly, by temporarily
speeding up or slowing down the clock.

These functions¡¯ names begin with ¡®ntp_¡¯ because they were designed for use by pro-
grams implementing the Network Time Protocol to synchronize a system¡¯s clock with other
systems¡¯ clocks and/or with external high-precision clock hardware.

```
These functions, and the constants and structures they use, are declared insys/timex.h.
```
struct ntptimeval [Data Type]
This structure is used to report information about the system clock. It contains the
following members:

```
struct timeval time
The current calendar time, as if retrieved bygettimeofday. Thestruct
timevaldata type is described inSection 21.2 [Time Types], page 647.
```

Chapter 21: Date and Time 655

```
long int maxerror
This is the maximum error, measured in microseconds. Unless updated
viantp_adjtimeperiodically, this value will reach some platform-specific
maximum value.
```
```
long int esterror
This is the estimated error, measured in microseconds. This value can be
set byntp_adjtimeto indicate the estimated offset of the system clock
from the true calendar time.
```
int ntp_gettime (struct ntptimeval *tptr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thentp_gettimefunction sets the structure pointed to bytptrto current values.
The elements of the structure afterwards contain the values the timer implementation
in the kernel assumes. They might or might not be correct. If they are not, anntp_
adjtimecall is necessary.
The return value is 0 on success and other values on failure. The followingerrno
error conditions are defined for this function:

```
TIME_ERROR
The precision clock model is not properly set up at the moment, thus
the clock must be considered unsynchronized, and the values should be
treated with care.
```
struct timex [Data Type]
This structure is used to control and monitor the system clock. It contains the
following members:

```
unsigned int modes
This variable controls whether and which values are set. Several symbolic
constants have to be combined with binary or to specify the effective
mode. These constants start withMOD_.
```
```
long int offset
This value indicates the current offset of the system clock from the true
calendar time. The value is given in microseconds. If bitMOD_OFFSETis
set inmodes, the offset (and possibly other dependent values) can be set.
The offset¡¯s absolute value must not exceedMAXPHASE.
long int frequency
This value indicates the difference in frequency between the true calendar
time and the system clock. The value is expressed as scaled PPM (parts
per million, 0.0001%). The scaling is1 << SHIFT_USEC. The value can
be set with bitMOD_FREQUENCY, but the absolute value must not exceed
MAXFREQ.
long int maxerror
This is the maximum error, measured in microseconds. A new value
can be set using bitMOD_MAXERROR. Unless updated viantp_adjtime
```

Chapter 21: Date and Time 656

```
periodically, this value will increase steadily and reach some platform-
specific maximum value.
long int esterror
This is the estimated error, measured in microseconds. This value can be
set using bitMOD_ESTERROR.
int status
This variable reflects the various states of the clock machinery. There are
symbolic constants for the significant bits, starting withSTA_. Some of
these flags can be updated using theMOD_STATUSbit.
long int constant
This value represents the bandwidth or stiffness of the PLL (phase locked
loop) implemented in the kernel. The value can be changed using bitMOD_
TIMECONST.
long int precision
This value represents the accuracy or the maximum error when reading
the system clock. The value is expressed in microseconds.
long int tolerance
This value represents the maximum frequency error of the system clock
in scaled PPM. This value is used to increase themaxerrorevery second.
struct timeval time
The current calendar time.
long int tick
The elapsed time between clock ticks in microseconds. A clock tick is a
periodic timer interrupt on which the system clock is based.
long int ppsfreq
This is the first of a few optional variables that are present only if the
system clock can use a PPS (pulse per second) signal to discipline the
system clock. The value is expressed in scaled PPM and it denotes the
difference in frequency between the system clock and the PPS signal.
long int jitter
This value expresses a median filtered average of the PPS signal¡¯s disper-
sion in microseconds.
int shift This value is a binary exponent for the duration of the PPS calibration
interval, ranging fromPPS_SHIFTtoPPS_SHIFTMAX.
long int stabil
This value represents the median filtered dispersion of the PPS frequency
in scaled PPM.
long int jitcnt
This counter represents the number of pulses where the jitter exceeded
the allowed maximumMAXTIME.
long int calcnt
This counter reflects the number of successful calibration intervals.
```

Chapter 21: Date and Time 657

```
long int errcnt
This counter represents the number of calibration errors (caused by large
offsets or jitter).
long int stbcnt
This counter denotes the number of calibrations where the stability ex-
ceeded the threshold.
```
int ntp_adjtime (struct timex *tptr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thentp_adjtimefunction sets the structure specified bytptrto current values.
In addition,ntp_adjtimeupdates some settings to match what you pass to it in
*tptr. Use themodeselement of*tptrto select what settings to update. You can
setoffset,freq,maxerror,esterror,status,constant, andtick.
modes= zero means set nothing.
Only the superuser can update settings.
The return value is 0 on success and other values on failure. The followingerrno
error conditions are defined for this function:
TIME_ERROR
The high accuracy clock model is not properly set up at the moment, thus
the clock must be considered unsynchronized, and the values should be
treated with care. Another reason could be that the specified new values
are not allowed.
EPERM The process specified a settings update, but is not superuser.
For more details see RFC1305 (Network Time Protocol, Version 3) and related doc-
uments.
Portability note: Early versions of the GNU C Library did not have this function,
but did have the synonymousadjtimex.

int adjtime(const struct timeval *delta, struct timeval *olddelta) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This simpler version ofntp_adjtimespeeds up or slows down the system clock for
a short time, in order to correct it by a small amount. This avoids a discontinuous
change in the calendar time reported by theCLOCK_REALTIMEclock, at the price of
having to wait longer for the time to become correct.
Thedeltaargument specifies a relative adjustment to be made to the clock time.
If negative, the system clock is slowed down for a while until it has lost this much
elapsed time. If positive, the system clock is speeded up for a while.
If theolddeltaargument is not a null pointer, theadjtimefunction returns informa-
tion about any previous time adjustment that has not yet completed.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:
EPERM This process does not have the privileges required to adjust theCLOCK_
REALTIMEclock.


Chapter 21: Date and Time 658

For compatibility, the GNU C Library also provides several older functions for controlling
the system time. New programs should prefer to use the functions above.

int stime (const timet *newtime) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Change the CLOCK_REALTIME calendar time to be the simple calendar
time in *newtime. Calling this function is exactly the same as calling
¡®clock_settime (CLOCK_REALTIME)¡¯, except that the new time can only be set to a
precision of one second.
This function is no longer available on GNU systems, but it may be theonly way
to set the time on very old Unix systems, so we continue to document it. If it is
available, it is declared intime.h.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:
EPERM This process does not have the privileges required to adjust theCLOCK_
REALTIMEclock.

int adjtimex (struct timex *timex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
adjtimexis an older name forntp_adjtime. This function is only available on
GNU/Linux systems. It is declared insys/timex.h.

int settimeofday (const struct timeval *tp, const void *tzp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Change the CLOCK_REALTIME calendar time to be the simple calendar time in
*newtime. This function is declared insys/time.h.
When tzp is a null pointer, calling this function is exactly the same as calling
¡®clock_settime (CLOCK_REALTIME)¡¯, except that the new time can only be set to
a precision of one microsecond.
Whentzpis not a null pointer, the data it points tomaybe used to set a system-
wide idea of the current timezone. This feature is obsolete and not supported on GNU
systems. Instead, use the facilities described inSection 21.5.7 [Functions and Variables
for Time Zones], page 678,and inSection 21.5.3 [Broken-down Time], page 659,for
working with time zones.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:
EPERM This process does not have the privileges required to set the CLOCK_
REALTIMEclock.
EINVAL Neither tpnortzp is a null pointer. (For historical reasons, it is not
possible to set the current time and the current time zone in the same
call.)
ENOSYS The operating system does not support setting time zone information,
andtzpis not a null pointer.


Chapter 21: Date and Time 659

## 21.5.3 Broken-down Time.....................................

Simple calendar times represent absolute times as elapsed times since an epoch. This
is convenient for computation, but has no relation to the way people normally think of
calendar time. By contrast,broken-down timeis a binary representation of calendar time
separated into year, month, day, and so on. Broken-down time values are not useful for
calculations, but they are useful for printing human readable time information.

A broken-down time value is always relative to a choice of time zone, and it also indicates
which time zone that is.

```
The symbols in this section are declared in the header filetime.h.
```
struct tm [Data Type]
This is the data type used to represent a broken-down time. The structure contains
at least the following members, which can appear in any order.
int tm_sec
This is the number of full seconds since the top of the minute (normally
in the range 0 through 59 , but the actual upper limit is 60 , to allow for
leap seconds if leap second support is available).
int tm_min
This is the number of full minutes since the top of the hour (in the range
0 through 59 ).
int tm_hour
This is the number of full hours past midnight (in the range 0 through
23 ).
int tm_mday
This is the ordinal day of the month (in the range 1 through 31 ). Watch
out for this one! As the only ordinal number in the structure, it is incon-
sistent with the rest of the structure.
int tm_mon
This is the number of full calendar months since the beginning of the year
(in the range 0 through 11 ). Watch out for this one! People usually use
ordinal numbers for month-of-year (where January = 1).
int tm_year
This is the number of full calendar years since 1900.
int tm_wday
This is the number of full days since Sunday (in the range 0 through 6 ).
int tm_yday
This is the number of full days since the beginning of the year (in the
range 0 through 365 ).
int tm_isdst
This is a flag that indicates whether Daylight Saving Time is (or was, or
will be) in effect at the time described. The value is positive if Daylight
Saving Time is in effect, zero if it is not, and negative if the information
is not available.


Chapter 21: Date and Time 660

```
long int tm_gmtoff
This field describes the time zone that was used to compute this broken-
down time value, including any adjustment for daylight saving; it is the
number of seconds that you must add to UTC to get local time. You can
also think of this as the number of seconds east of UTC. For example,
for U.S. Eastern Standard Time, the value is-5*60*60. Thetm_gmtoff
field is derived from BSD and is a GNU library extension; it is not visible
in a strict ISO C environment.
const char *tm_zone
This field is the name for the time zone that was used to compute this
broken-down time value. Liketm_gmtoff, this field is a BSD and GNU
extension, and is not visible in a strict ISO C environment.
```
struct tm * localtime(const timet *time) [Function]
Preliminary:|MT-Unsafe race:tmbuf env locale|AS-Unsafe heap lock|AC-Unsafe
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelocaltimefunction converts the simple time pointed to bytimeto broken-down
time representation, expressed relative to the user¡¯s specified time zone.
The return value is a pointer to a static broken-down time structure, which might
be overwritten by subsequent calls toctime,gmtime, orlocaltime. (But no other
library function overwrites the contents of this object.)
The return value is the null pointer iftimecannot be represented as a broken-down
time; typically this is because the year cannot fit into anint.
Callinglocaltimealso sets the current time zone as if tzsetwere called. See
Section 21.5.7 [Functions and Variables for Time Zones], page 678.

Using thelocaltimefunction is a big problem in multi-threaded programs. The result
is returned in a static buffer and this is used in all threads. POSIX.1c introduced a variant
of this function.

struct tm * localtime_r (const timet *time, struct tm *resultp) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelocaltime_rfunction works just like thelocaltimefunction. It takes a pointer
to a variable containing a simple time and converts it to the broken-down time format.
But the result is not placed in a static buffer. Instead it is placed in the object of
typestruct tmto which the parameterresultppoints.
If the conversion is successful the function returns a pointer to the object the result
was written into, i.e., it returnsresultp.

struct tm * gmtime(const timet *time) [Function]
Preliminary:|MT-Unsafe race:tmbuf env locale|AS-Unsafe heap lock|AC-Unsafe
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tolocaltime, except that the broken-down time is ex-
pressed as Coordinated Universal Time (UTC) (formerly called Greenwich Mean Time
(GMT)) rather than relative to a local time zone.


Chapter 21: Date and Time 661

As for thelocaltimefunction we have the problem that the result is placed in a static
variable. POSIX.1c also provides a replacement forgmtime.

struct tm * gmtime_r(const timet *time, struct tm *resultp) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tolocaltime_r, except that it converts just likegmtimethe
given time as Coordinated Universal Time.
If the conversion is successful the function returns a pointer to the object the result
was written into, i.e., it returnsresultp.

time_t mktime(struct tm *brokentime) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Themktimefunction converts a broken-down time structure to a simple time repre-
sentation. It also normalizes the contents of the broken-down time structure, and fills
in some components based on the values of the others.
Themktimefunction ignores the specified contents of thetm_wday,tm_yday, tm_
gmtoff, andtm_zonemembers of the broken-down time structure. It uses the values
of the other components to determine the calendar time; it¡¯s permissible for these
components to have unnormalized values outside their normal ranges. The last thing
thatmktimedoes is adjust the components of thebrokentimestructure, including the
members that were initially ignored.
If the specified broken-down time cannot be represented as a simple time,mktime
returns a value of(time_t)(-1)and does not modify the contents ofbrokentime.
Callingmktimealso sets the current time zone as iftzsetwere called;mktimeuses
this information instead ofbrokentime¡¯s initialtm_gmtoffandtm_zonemembers.
SeeSection 21.5.7 [Functions and Variables for Time Zones], page 678.

time_t timelocal (struct tm *brokentime) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
timelocalis functionally identical tomktime, but more mnemonically named. Note
that it is the inverse of thelocaltimefunction.
Portability note:mktimeis essentially universally available.timelocalis rather rare.

time_t timegm(struct tm *brokentime) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
timegmis functionally identical tomktimeexcept it always takes the input values to
be Coordinated Universal Time (UTC) regardless of any local time zone setting.
Note thattimegmis the inverse ofgmtime.
Portability note: mktimeis essentially universally available. timegmis rather rare.
For the most portable conversion from a UTC broken-down time to a simple time,
set theTZenvironment variable to UTC, callmktime, then setTZback.


Chapter 21: Date and Time 662

## 21.5.4 Formatting Calendar Time.............................

The functions described in this section format calendar time values as strings. These func-
tions are declared in the header filetime.h.

char * asctime(const struct tm *brokentime) [Function]
Preliminary: | MT-Unsafe race:asctime locale | AS-Unsafe | AC-Safe | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theasctimefunction converts the broken-down time value thatbrokentimepoints
to into a string in a standard format:
"Tue May 21 13:46:22 1991\n"
The abbreviations for the days of week are: ¡®Sun¡¯, ¡®Mon¡¯, ¡®Tue¡¯, ¡®Wed¡¯, ¡®Thu¡¯, ¡®Fri¡¯, and
¡®Sat¡¯.
The abbreviations for the months are: ¡®Jan¡¯, ¡®Feb¡¯, ¡®Mar¡¯, ¡®Apr¡¯, ¡®May¡¯, ¡®Jun¡¯, ¡®Jul¡¯,
¡®Aug¡¯, ¡®Sep¡¯, ¡®Oct¡¯, ¡®Nov¡¯, and ¡®Dec¡¯.
The return value points to a statically allocated string, which might be overwritten
by subsequent calls toasctimeorctime. (But no other library function overwrites
the contents of this string.)

char * asctime_r (const struct tm *brokentime, char *buffer) [Function]
Preliminary: |MT-Safe locale|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is similar toasctimebut instead of placing the result in a static buffer
it writes the string in the buffer pointed to by the parameterbuffer. This buffer
should have room for at least 26 bytes, including the terminating null.
If no error occurred the function returns a pointer to the string the result was written
into, i.e., it returnsbuffer. Otherwise it returnsNULL.

char * ctime (const timet *time) [Function]
Preliminary:|MT-Unsafe race:tmbuf race:asctime env locale|AS-Unsafe heap lock
|AC-Unsafe lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thectimefunction is similar toasctime, except that you specify the calendar time
argument as atime_tsimple time value rather than in broken-down local time format.
It is equivalent to
asctime (localtime (time))
Calling ctime also sets the current time zone as if tzset were called. See
Section 21.5.7 [Functions and Variables for Time Zones], page 678.

char * ctime_r(const timet *time, char *buffer) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toctime, but places the result in the string pointed to by
buffer. It is equivalent to (written using gcc extensions, seeSection ¡°Statement Exprs¡±
inPorting and Using gcc):
({ struct tm tm; asctime_r (localtime_r (time, &tm), buf); })
If no error occurred the function returns a pointer to the string the result was written
into, i.e., it returnsbuffer. Otherwise it returnsNULL.


Chapter 21: Date and Time 663

size_t strftime (char *s, size tsize, const char *template, const [Function]
struct tm *brokentime)
Preliminary:|MT-Safe env locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar to thesprintffunction (seeSection 12.14 [Formatted Input],
page 311), but the conversion specifications that can appear in the format template
templateare specialized for printing components of the date and timebrokentime
according to the locale currently specified for time conversion (seeChapter 7 [Locales
and Internationalization], page 183) and the current time zone (seeSection 21.5.7
[Functions and Variables for Time Zones], page 678).
Ordinary characters appearing in thetemplateare copied to the output strings; this
can include multibyte character sequences. Conversion specifiers are introduced by a
¡®%¡¯ character, followed by an optional flag which can be one of the following. These
flags are all GNU extensions. The first three affect only the output of numbers:

```
_ The number is padded with spaces.
```
- The number is not padded at all.

```
0 The number is padded with zeros even if the format specifies padding
with spaces.
```
```
^ The output uses uppercase characters, but only if this is possible (see
Section 4.2 [Case Conversion], page 89).
```
```
The default action is to pad the number with zeros to keep it a constant width.
Numbers that do not have a range indicated below are never padded, since there is
no natural width for them.
Following the flag an optional specification of the width is possible. This is specified
in decimal notation. If the natural size of the output of the field has less than the
specified number of characters, the result is written right adjusted and space padded
to the given size.
An optional modifier can follow the optional flag and width specification. The modi-
fiers, which were first standardized by POSIX.2-1992 and by ISO C99, are:
```
```
E Use the locale¡¯s alternative representation for date and time. This mod-
ifier applies to the %c, %C, %x, %X, %y and%Y format specifiers. In a
Japanese locale, for example,%Exmight yield a date format based on the
Japanese Emperors¡¯ reigns.
```
```
O With all format specifiers that produce numbers: use the locale¡¯s alter-
native numeric symbols.
With%B,%b, and%h: use the grammatical form for month names that
is appropriate when the month is named by itself, rather than the form
that is appropriate when the month is used as part of a complete date.
The%OBand%Obformats are a C2X feature, specified in C2X to use
the locale¡¯s ¡®alternative¡¯ month name; the GNU C Library extends this
specification to say that the form used in a complete date is the default
and the form naming the month by itself is the alternative.
```

Chapter 21: Date and Time 664

```
If the format supports the modifier but no alternative representation is available, it
is ignored.
The conversion specifier ends with a format specifier taken from the following list.
The whole ¡®%¡¯ sequence is replaced in the output string as follows:
```
```
%a The abbreviated weekday name according to the current locale.
```
```
%A The full weekday name according to the current locale.
```
```
%b The abbreviated month name according to the current locale, in the gram-
matical form used when the month is part of a complete date. As a C2X
feature (with a more detailed specification in the GNU C Library), theO
modifier can be used (%Ob) to get the grammatical form used when the
month is named by itself.
```
```
%B The full month name according to the current locale, in the grammatical
form used when the month is part of a complete date. As a C2X feature
(with a more detailed specification in the GNU C Library), theOmodifier
can be used (%OB) to get the grammatical form used when the month is
named by itself.
Note that not all languages need two different forms of the month names,
so the text produced by%Band%OB, and by%band%Ob, may or may not
be the same, depending on the locale.
```
```
%c The preferred calendar time representation for the current locale.
```
```
%C The century of the year. This is equivalent to the greatest integer not
greater than the year divided by 100.
If the Emodifier is specified (%EC), instead produces the name of the
period for the year (e.g. an era name) in the locale¡¯s alternative calendar.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%d The day of the month as a decimal number (range 01 through 31 ).
```
```
%D The date using the format%m/%d/%y.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%e The day of the month like with%d, but padded with spaces (range 1
through 31 ).
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%F The date using the format%Y-%m-%d. This is the form specified in the
ISO 8601 standard and is the preferred form for all uses.
This format was first standardized by ISO C99 and by POSIX.1-2001.
```
```
%g The year corresponding to the ISO week number, but without the century
(range 00 through 99 ). This has the same format and value as%y, except
that if the ISO week number (see%V) belongs to the previous or next
year, that year is used instead.
This format was first standardized by ISO C99 and by POSIX.1-2001.
```

Chapter 21: Date and Time 665

```
%G The year corresponding to the ISO week number. This has the same
format and value as %Y, except that if the ISO week number (see%V)
belongs to the previous or next year, that year is used instead.
This format was first standardized by ISO C99 and by POSIX.1-2001 but
was previously available as a GNU extension.
%h The abbreviated month name according to the current locale. The action
is the same as for%b.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%H The hour as a decimal number, using a 24-hour clock (range 00 through
23 ).
%I The hour as a decimal number, using a 12-hour clock (range 01 through
12 ).
```
```
%j The day of the year as a decimal number (range 001 through 366 ).
%k The hour as a decimal number, using a 24-hour clock like%H, but padded
with spaces (range 0 through 23 ).
This format is a GNU extension.
```
```
%l The hour as a decimal number, using a 12-hour clock like%I, but padded
with spaces (range 1 through 12 ).
This format is a GNU extension.
%m The month as a decimal number (range 01 through 12 ).
```
```
%M The minute as a decimal number (range 00 through 59 ).
%n A single ¡®\n¡¯ (newline) character.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%p Either ¡®AM¡¯ or ¡®PM¡¯, according to the given time value; or the corresponding
strings for the current locale. Noon is treated as ¡®PM¡¯ and midnight as
¡®AM¡¯. In most locales ¡®AM¡¯/¡®PM¡¯ format is not supported, in such cases"%p"
yields an empty string.
%P Either ¡®am¡¯ or ¡®pm¡¯, according to the given time value; or the corresponding
strings for the current locale, printed in lowercase characters. Noon is
treated as ¡®pm¡¯ and midnight as ¡®am¡¯. In most locales ¡®AM¡¯/¡®PM¡¯ format is
not supported, in such cases"%P"yields an empty string.
This format is a GNU extension.
```
```
%r The complete calendar time using the AM/PM format of the current
locale.
This format was first standardized by POSIX.2-1992 and by ISO C99. In
the POSIX locale, this format is equivalent to%I:%M:%S %p.
%R The hour and minute in decimal numbers using the format%H:%M.
This format was first standardized by ISO C99 and by POSIX.1-2001 but
was previously available as a GNU extension.
```

Chapter 21: Date and Time 666

```
%s The number of seconds since the epoch, i.e., since 1970-01-01 00:00:00
UTC. Leap seconds are not counted unless leap second support is avail-
able.
This format is a GNU extension.
%S The seconds as a decimal number (range 00 through 60 ).
```
```
%t A single ¡®\t¡¯ (tabulator) character.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%T The time of day using decimal numbers using the format%H:%M:%S.
This format was first standardized by POSIX.2-1992 and by ISO C99.
%u The day of the week as a decimal number (range 1 through 7 ), Monday
being 1.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%U The week number of the current year as a decimal number (range 00
through 53 ), starting with the first Sunday as the first day of the first
week. Days preceding the first Sunday in the year are considered to be
in week 00.
```
```
%V The ISO 8601:1988 week number as a decimal number (range 01 through
53 ). ISO weeks start with Monday and end with Sunday. Week 01 of a
year is the first week which has the majority of its days in that year; this
is equivalent to the week containing the year¡¯s first Thursday, and it is
also equivalent to the week containing January 4. Week 01 of a year can
contain days from the previous year. The week before week 01 of a year
is the last week ( 52 or 53 ) of the previous year even if it contains days
from the new year.
This format was first standardized by POSIX.2-1992 and by ISO C99.
```
```
%w The day of the week as a decimal number (range 0 through 6 ), Sunday
being 0.
```
```
%W The week number of the current year as a decimal number (range 00
through 53 ), starting with the first Monday as the first day of the first
week. All days preceding the first Monday in the year are considered to
be in week 00.
```
```
%x The preferred date representation for the current locale.
```
```
%X The preferred time of day representation for the current locale.
```
```
%y The year without a century as a decimal number (range 00 through 99 ).
This is equivalent to the year modulo 100.
If the Emodifier is specified (%Ey), instead produces the year number
according to a locale-specific alternative calendar. Unlike%y, the number
isnot reduced modulo 100. However, by default it is zero-padded to a
minimum of two digits (this can be overridden by an explicit field width
or by the_and-flags).
```

Chapter 21: Date and Time 667

```
%Y The year as a decimal number, using the Gregorian calendar. Years before
the year 1 are numbered 0 ,-1, and so on.
If theEmodifier is specified (%EY), instead produces a complete represen-
tation of the year according to the locale¡¯s alternative calendar. Generally
this will be some combination of the information produced by%ECand
%Ey. As a GNU extension, the formatting flags_or-may be used with
this conversion specifier; they affect how the year number is printed.
%z RFC 822/ISO 8601:1988 style numeric time zone (e.g.,-0600or+0100),
or nothing if no time zone is determinable.
This format was first standardized by ISO C99 and by POSIX.1-2001 but
was previously available as a GNU extension.
In the POSIX locale, a full RFC 822 timestamp is generated
by the format ¡®"%a, %d %b %Y %H:%M:%S %z"¡¯ (or the equivalent
¡®"%a, %d %b %Y %T %z"¡¯).
%Z The time zone abbreviation (empty if the time zone can¡¯t be determined).
%% A literal ¡®%¡¯ character.
Thesizeparameter can be used to specify the maximum number of characters to be
stored in the arrays, including the terminating null character. If the formatted time
requires more thansizecharacters,strftimereturns zero and the contents of the
arraysare undefined. Otherwise the return value indicates the number of characters
placed in the arrays, not including the terminating null character.
Warning:This convention for the return value which is prescribed in ISO C can lead
to problems in some situations. For certain format strings and certain locales the
output really can be the empty string and this cannot be discovered by testing the
return value only. E.g., in most locales the AM/PM time format is not supported
(most of the world uses the 24 hour time representation). In such locales"%p"will
return the empty string, i.e., the return value is zero. To detect situations like this
something similar to the following code should be used:
buf[0] = '\1';
len = strftime (buf, bufsize, format, tp);
if (len == 0 && buf[0] != '\0')
{
/* Something went wrong in the strftime call. */
...
}
Ifsis a null pointer,strftimedoes not actually write anything, but instead returns
the number of characters it would have written.
Callingstrftimealso sets the current time zone as iftzsetwere called;strftime
uses this information instead ofbrokentime¡¯stm_gmtoffandtm_zonemembers. See
Section 21.5.7 [Functions and Variables for Time Zones], page 678.
For an example ofstrftime, seeSection 21.5.8 [Time Functions Example], page 679.
```
size_t wcsftime (wchart *s, sizetsize, const wchart [Function]
*template, const struct tm *brokentime)
Preliminary:|MT-Safe env locale|AS-Unsafe corrupt heap lock dlopen|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 21: Date and Time 668

```
Thewcsftimefunction is equivalent to thestrftimefunction with the difference that
it operates on wide character strings. The buffer where the result is stored, pointed to
bys, must be an array of wide characters. The parametersizewhich specifies the size
of the output buffer gives the number of wide characters, not the number of bytes.
Also the format stringtemplateis a wide character string. Since all characters needed
to specify the format string are in the basic character set it is portably possible to
write format strings in the C source code using theL"..."notation. The parameter
brokentimehas the same meaning as in thestrftimecall.
Thewcsftimefunction supports the same flags, modifiers, and format specifiers as
thestrftimefunction.
The return value ofwcsftimeis the number of wide characters stored ins. When
more characters would have to be written than can be placed in the buffersthe return
value is zero, with the same problems indicated in thestrftimedocumentation.
```
## 21.5.5 Convert textual time and date information back........

The ISO C standard does not specify any functions which can convert the output of the
strftimefunction back into a binary format. This led to a variety of more-or-less successful
implementations with different interfaces over the years. Then the Unix standard was
extended by the addition of two functions: strptimeandgetdate. Both have strange
interfaces but at least they are widely available.

## 21.5.5.1 Interpret string according to given format..........

The first function is rather low-level. It is nevertheless frequently used in software since it
is better known. Its interface and implementation are heavily influenced by thegetdate
function, which is defined and implemented in terms of calls tostrptime.

char * strptime (const char *s, const char *fmt, struct tm *tp) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thestrptimefunction parses the input stringsaccording to the format stringfmt
and stores its results in the structuretp.
The input string could be generated by astrftime call or obtained any other
way. It does not need to be in a human-recognizable format; e.g. a date passed
as"02:1999:9"is acceptable, even though it is ambiguous without context. As long
as the format stringfmtmatches the input string the function will succeed.
The user has to make sure, though, that the input can be parsed in a unambiguous
way. The string"1999112"can be parsed using the format"%Y%m%d"as 1999-1-12,
1999-11-2, or even 19991-1-2. It is necessary to add appropriate separators to reliably
get results.
The format string consists of the same components as the format string of the
strftimefunction. The only difference is that the flags_, -, 0 , and ^are not
allowed. Several of the distinct formats ofstrftimedo the same work instrptime
since differences like case of the input do not matter. For reasons of symmetry all
formats are supported, though.
The modifiersEandOare also allowed everywhere thestrftimefunction allows them.


Chapter 21: Date and Time 669

```
The formats are:
%a
%A The weekday name according to the current locale, in abbreviated form
or the full name.
```
```
%b
%B
%h A month name according to the current locale. All three specifiers will
recognize both abbreviated and full month names. If the locale provides
two different grammatical forms of month names, all three specifiers will
recognize both forms.
As a GNU extension, theOmodifier can be used with these specifiers; it
has no effect, as both grammatical forms of month names are recognized.
%c The date and time representation for the current locale.
%Ec Like%cbut the locale¡¯s alternative date and time format is used.
%C The century of the year.
It makes sense to use this format only if the format string also contains
the%yformat.
```
```
%EC The locale¡¯s representation of the period.
Unlike%Cit sometimes makes sense to use this format since some cul-
tures represent years relative to the beginning of eras instead of using the
Gregorian years.
%d
%e The day of the month as a decimal number (range 1 through 31 ). Leading
zeroes are permitted but not required.
```
```
%Od
%Oe Same as%dbut using the locale¡¯s alternative numeric symbols.
Leading zeroes are permitted but not required.
%D Equivalent to%m/%d/%y.
%F Equivalent to%Y-%m-%d, which is the ISO 8601 date format.
This is a GNU extension following an ISO C99 extension tostrftime.
```
```
%g The year corresponding to the ISO week number, but without the century
(range 00 through 99 ).
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
This format is a GNU extension following a GNU extension ofstrftime.
%G The year corresponding to the ISO week number.
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
This format is a GNU extension following a GNU extension ofstrftime.
```

Chapter 21: Date and Time 670

### %H

```
%k The hour as a decimal number, using a 24-hour clock (range 00 through
23 ).
%kis a GNU extension following a GNU extension ofstrftime.
%OH Same as%Hbut using the locale¡¯s alternative numeric symbols.
```
```
%I
%l The hour as a decimal number, using a 12-hour clock (range 01 through
12 ).
%lis a GNU extension following a GNU extension ofstrftime.
```
```
%OI Same as%Ibut using the locale¡¯s alternative numeric symbols.
%j The day of the year as a decimal number (range 1 through 366 ).
Leading zeroes are permitted but not required.
%m The month as a decimal number (range 1 through 12 ).
Leading zeroes are permitted but not required.
%Om Same as%mbut using the locale¡¯s alternative numeric symbols.
```
```
%M The minute as a decimal number (range 0 through 59 ).
Leading zeroes are permitted but not required.
```
```
%OM Same as%Mbut using the locale¡¯s alternative numeric symbols.
%n
%t Matches any white space.
%p
```
```
%P The locale-dependent equivalent to ¡®AM¡¯ or ¡®PM¡¯.
This format is not useful unless%Ior%lis also used. Another complica-
tion is that the locale might not define these values at all and therefore
the conversion fails.
%Pis a GNU extension following a GNU extension tostrftime.
%r The complete time using the AM/PM format of the current locale.
A complication is that the locale might not define this format at all and
therefore the conversion fails.
%R The hour and minute in decimal numbers using the format%H:%M.
%Ris a GNU extension following a GNU extension tostrftime.
%s The number of seconds since the epoch, i.e., since 1970-01-01 00:00:00
UTC. Leap seconds are not counted unless leap second support is avail-
able.
%sis a GNU extension following a GNU extension tostrftime.
%S The seconds as a decimal number (range 0 through 60 ).
Leading zeroes are permitted but not required.
```

Chapter 21: Date and Time 671

```
NB:The Unix specification says the upper bound on this value is 61 , a
result of a decision to allow double leap seconds. You will not see the
value 61 because no minute has more than one leap second, but the myth
persists.
%OS Same as%Sbut using the locale¡¯s alternative numeric symbols.
%T Equivalent to the use of%H:%M:%Sin this place.
```
```
%u The day of the week as a decimal number (range 1 through 7 ), Monday
being 1.
Leading zeroes are permitted but not required.
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
%U The week number of the current year as a decimal number (range 0
through 53 ).
Leading zeroes are permitted but not required.
%OU Same as%Ubut using the locale¡¯s alternative numeric symbols.
```
```
%V The ISO 8601:1988 week number as a decimal number (range 1 through
53 ).
Leading zeroes are permitted but not required.
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
%w The day of the week as a decimal number (range 0 through 6 ), Sunday
being 0.
Leading zeroes are permitted but not required.
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
%Ow Same as%wbut using the locale¡¯s alternative numeric symbols.
%W The week number of the current year as a decimal number (range 0
through 53 ).
Leading zeroes are permitted but not required.
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
%OW Same as%Wbut using the locale¡¯s alternative numeric symbols.
%x The date using the locale¡¯s date format.
%Ex Like%xbut the locale¡¯s alternative data representation is used.
```
```
%X The time using the locale¡¯s time format.
%EX Like%Xbut the locale¡¯s alternative time representation is used.
%y The year without a century as a decimal number (range 0 through 99 ).
Leading zeroes are permitted but not required.
```

Chapter 21: Date and Time 672

```
Note that it is questionable to use this format without the%Cformat.
Thestrptimefunction does regard input values in the range 68 to 99 as
the years 1969 to 1999 and the values 0 to 68 as the years 2000 to 2068.
But maybe this heuristic fails for some input data.
Therefore it is best to avoid%ycompletely and use%Yinstead.
```
```
%Ey The offset from%ECin the locale¡¯s alternative representation.
%Oy The offset of the year (from%C) using the locale¡¯s alternative numeric
symbols.
%Y The year as a decimal number, using the Gregorian calendar.
%EY The full alternative year representation.
```
```
%z The offset from GMT in ISO 8601/RFC822 format.
%Z The timezone name.
Note:Currently, this is not fully implemented. The format is recognized,
input is consumed but no field intmis set.
%% A literal ¡®%¡¯ character.
```
```
All other characters in the format string must have a matching character in the input
string. Exceptions are white spaces in the input string which can match zero or more
whitespace characters in the format string.
Portability Note:The XPG standard advises applications to use at least one white-
space character (as specified byisspace) or other non-alphanumeric characters be-
tween any two conversion specifications. The GNU C Library does not have this lim-
itation but other libraries might have trouble parsing formats like"%d%m%Y%H%M%S".
Thestrptimefunction processes the input string from right to left. Each of the
three possible input elements (white space, literal, or format) are handled one after
the other. If the input cannot be matched to the format string the function stops.
The remainder of the format and input strings are not processed.
The function returns a pointer to the first character it was unable to process. If the
input string contains more characters than required by the format string the return
value points right after the last consumed input character. If the whole input string
is consumed the return value points to theNULLbyte at the end of the string. If
an error occurs, i.e.,strptimefails to match all of the format string, the function
returnsNULL.
```
The specification of the function in the XPG standard is rather vague, leaving out a
few important pieces of information. Most importantly, it does not specify what happens
to those elements oftmwhich are not directly initialized by the different formats. The
implementations on different Unix systems vary here.

The GNU C Library implementation does not touch those fields which are not directly
initialized. Exceptions are thetm_wdayandtm_ydayelements, which are recomputed if any
of the year, month, or date elements changed. This has two implications:

- Before calling thestrptimefunction for a new input string, you should prepare thetm
    structure you pass. Normally this will mean initializing all values to zero. Alternatively,


Chapter 21: Date and Time 673

```
you can set all fields to values likeINT_MAX, allowing you to determine which elements
were set by the function call. Zero does not work here since it is a valid value for many
of the fields.
Careful initialization is necessary if you want to find out whether a certain field intm
was initialized by the function call.
```
- You can construct astruct tmvalue with several consecutivestrptimecalls. A useful
    application of this is e.g. the parsing of two separate strings, one containing date
    information and the other time information. By parsing one after the other without
    clearing the structure in-between, you can construct a complete broken-down time.
The following example shows a function which parses a string which contains the date
information in either US style or ISO 8601 form:
const char *
parse_date (const char *input, struct tm *tm)
{
const char *cp;

```
/*First clear the result structure. */
memset (tm, '\0', sizeof (*tm));
```
```
/*Try the ISO format first. */
cp = strptime (input, "%F", tm);
if (cp == NULL)
{
/*Does not match. Try the US form. */
cp = strptime (input, "%D", tm);
}
```
```
return cp;
}
```
## 21.5.5.2 A More User-friendly Way to Parse Times and Dates..

The Unix standard defines another function for parsing date strings. The interface is weird,
but if the function happens to suit your application it is just fine. It is problematic to use
this function in multi-threaded programs or libraries, since it returns a pointer to a static
variable, and uses a global variable and global state (an environment variable).

getdate_err [Variable]
This variable of typeint contains the error code of the last unsuccessful call to
getdate. Defined values are:
1 The environment variableDATEMSKis not defined or null.
2 The template file denoted by theDATEMSKenvironment variable cannot
be opened.
3 Information about the template file cannot retrieved.
4 The template file is not a regular file.
5 An I/O error occurred while reading the template file.
6 Not enough memory available to execute the function.
7 The template file contains no matching template.


Chapter 21: Date and Time 674

```
8 The input date is invalid, but would match a template otherwise. This
includes dates like February 31st, and dates which cannot be represented
in atime_tvariable.
```
struct tm * getdate (const char *string) [Function]
Preliminary:|MT-Unsafe race:getdate env locale|AS-Unsafe heap lock|AC-Unsafe
lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
The interface togetdateis the simplest possible for a function to parse a string and
return the value.stringis the input string and the result is returned in a statically-
allocated variable.
The details about how the string is processed are hidden from the user. In fact, they
can be outside the control of the program. Which formats are recognized is controlled
by the file named by the environment variableDATEMSK. This file should contain lines
of valid format strings which could be passed tostrptime.
Thegetdatefunction reads these format strings one after the other and tries to
match the input string. The first line which completely matches the input string is
used.
Elements not initialized through the format string retain the values present at the
time of thegetdatefunction call.
The formats recognized bygetdateare the same as forstrptime. See above for an
explanation. There are only a few extensions to thestrptimebehavior:

- If the%Zformat is given the broken-down time is based on the current time of
    the timezone matched, not of the current timezone of the runtime environment.
    Note: This is not implemented (currently). The problem is that timezone names
    are not unique. If a fixed timezone is assumed for a given string (sayESTmeaning
    US East Coast time), then uses for countries other than the USA will fail. So far
    we have found no good solution to this.
- If only the weekday is specified the selected day depends on the current date. If
    the current weekday is greater than or equal to thetm_wdayvalue the current
    week¡¯s day is chosen, otherwise the day next week is chosen.
- A similar heuristic is used when only the month is given and not the year. If the
    month is greater than or equal to the current month, then the current year is
    used. Otherwise it wraps to next year. The first day of the month is assumed if
    one is not explicitly specified.
- The current hour, minute, and second are used if the appropriate value is not set
    through the format.
- If no date is given tomorrow¡¯s date is used if the time is smaller than the current
    time. Otherwise today¡¯s date is taken.
It should be noted that the format in the template file need not only contain format
elements. The following is a list of possible format strings (taken from the Unix
standard):
%m
%A %B %d, %Y %H:%M:%S
%A
%B


Chapter 21: Date and Time 675

```
%m/%d/%y %I %p
%d,%m,%Y %H:%M
at %A the %dst of %B in %Y
run job at %I %p,%B %dnd
%A den %d. %B %Y %H.%M Uhr
As you can see, the template list can contain very specific strings likerun job at %I
%p,%B %dnd. Using the above list of templates and assuming the current time is Mon
Sep 22 12:19:47 EDT 1986, we can obtain the following results for the given input.
Input Match Result
Mon %a Mon Sep 22 12:19:47 EDT 1986
Sun %a Sun Sep 28 12:19:47 EDT 1986
Fri %a Fri Sep 26 12:19:47 EDT 1986
September %B Mon Sep 1 12:19:47 EDT 1986
January %B Thu Jan 1 12:19:47 EST 1987
December %B Mon Dec 1 12:19:47 EST 1986
Sep Mon %b %a Mon Sep 1 12:19:47 EDT 1986
Jan Fri %b %a Fri Jan 2 12:19:47 EST 1987
Dec Mon %b %a Mon Dec 1 12:19:47 EST 1986
Jan Wed 1989 %b %a %Y Wed Jan 4 12:19:47 EST 1989
Fri 9 %a %H Fri Sep 26 09:00:00 EDT 1986
Feb 10:30 %b %H:%S Sun Feb 1 10:00:30 EST 1987
10:30 %H:%M Tue Sep 23 10:30:00 EDT 1986
13:30 %H:%M Mon Sep 22 13:30:00 EDT 1986
The return value of the function is a pointer to a static variable of typestruct tm,
or a null pointer if an error occurred. The result is only valid until the nextgetdate
call, making this function unusable in multi-threaded applications.
Theerrnovariable isnotchanged. Error conditions are stored in the global variable
getdate_err. See the description above for a list of the possible error values.
Warning:Thegetdatefunction shouldneverbe used in SUID-programs. The reason
is obvious: using theDATEMSKenvironment variable you can get the function to open
any arbitrary file and chances are high that with some bogus input (such as a binary
file) the program will crash.
```
int getdate_r(const char *string, struct tm *tp) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetdate_rfunction is the reentrant counterpart ofgetdate. It does not use
the global variablegetdate_errto signal an error, but instead returns an error code.
The same error codes as described in thegetdate_errdocumentation above are used,
with 0 meaning success.
Moreover,getdate_rstores the broken-down time in the variable of typestruct tm
pointed to by the second argument, rather than in a static variable.
This function is not defined in the Unix standard. Nevertheless it is available on some
other Unix systems as well.
The warning against usinggetdatein SUID-programs applies togetdate_ras well.


Chapter 21: Date and Time 676

## 21.5.6 Specifying the Time Zone withTZ......................

In POSIX systems, a user can specify the time zone by means of theTZenvironment variable.
For information about how to set environment variables, seeSection 25.4 [Environment
Variables], page 792. The functions for accessing the time zone are declared intime.h.

You should not normally need to setTZ. If the system is configured properly, the default
time zone will be correct. You might setTZif you are using a computer over a network
from a different time zone, and would like times reported to you in the time zone local to
you, rather than what is local to the computer.

In POSIX.1 systems the value of theTZvariable can be in one of three formats. With
the GNU C Library, the most common format is the last one, which can specify a selection
from a large database of time zone information for many regions of the world. The first
two formats are used to describe the time zone information directly, which is both more
cumbersome and less precise. But the POSIX.1 standard only specifies the details of the
first two formats, so it is good to be familiar with them in case you come across a POSIX.1
system that doesn¡¯t support a time zone information database.

The first format is used when there is no Daylight Saving Time (or summer time) in the
local time zone:
std offset
Thestdstring specifies the name of the time zone. It must be three or more characters
long and must not contain a leading colon, embedded digits, commas, nor plus and minus
signs. There is no space character separating the time zone name from theoffset, so these
restrictions are necessary to parse the specification correctly.

Theoffsetspecifies the time value you must add to the local time to get a Coordinated
Universal Time value. It has syntax like [+|-]hh[:mm[:ss]]. This is positive if the local time
zone is west of the Prime Meridian and negative if it is east. The hour must be between 0
and 24 , and the minute and seconds between 0 and 59.

For example, here is how we would specify Eastern Standard Time, but without any
Daylight Saving Time alternative:
EST+5
The second format is used when there is Daylight Saving Time:
std offset dst[offset],start[/time],end[/time]
The initialstdandoffsetspecify the standard time zone, as described above. Thedst
string andoffsetspecify the name and offset for the corresponding Daylight Saving Time
zone; if theoffsetis omitted, it defaults to one hour ahead of standard time.

The remainder of the specification describes when Daylight Saving Time is in effect.
Thestartfield is when Daylight Saving Time goes into effect and theendfield is when the
change is made back to standard time. The following formats are recognized for these fields:

Jn This specifies the Julian day, withnbetween 1 and 365. February 29 is never
counted, even in leap years.

n This specifies the Julian day, withnbetween 0 and 365. February 29 is counted
in leap years.

Mm.w.d This specifies dayd of weekwof monthm. The daydmust be between 0
(Sunday) and 6. The weekwmust be between 1 and 5 ; week 1 is the first week


Chapter 21: Date and Time 677

in which daydoccurs, and week 5 specifies thelastdday in the month. The
monthmshould be between 1 and 12.
Thetime fields specify when, in the local time currently in effect, the change to the
other time occurs. If omitted, the default is02:00:00. The hours part of the time fields
can range from?167 through 167; this is an extension to POSIX.1, which allows only the
range 0 through 24.

Here are some exampleTZvalues, including the appropriate Daylight Saving Time and
its dates of applicability. In North American Eastern Standard Time (EST) and Eastern
Daylight Time (EDT), the normal offset from UTC is 5 hours; since this is west of the prime
meridian, the sign is positive. Summer time begins on March¡¯s second Sunday at 2:00am,
and ends on November¡¯s first Sunday at 2:00am.
EST+5EDT,M3.2.0/2,M11.1.0/2
Israel Standard Time (IST) and Israel Daylight Time (IDT) are 2 hours ahead of the
prime meridian in winter, springing forward an hour on March¡¯s fourth Thursday at 26:00
(i.e., 02:00 on the first Friday on or after March 23), and falling back on October¡¯s last
Sunday at 02:00.
IST-2IDT,M3.4.4/26,M10.5.0
Western Argentina Summer Time (WARST) is 3 hours behind the prime meridian all
year. There is a dummy fall-back transition on December 31 at 25:00 daylight saving
time (i.e., 24:00 standard time, equivalent to January 1 at 00:00 standard time), and a
simultaneous spring-forward transition on January 1 at 00:00 standard time, so daylight
saving time is in effect all year and the initialWARTis a placeholder.
WART4WARST,J1/0,J365/25
Western Greenland Time (WGT) and Western Greenland Summer Time (WGST) are 3
hours behind UTC in the winter. Its clocks follow the European Union rules of springing
forward by one hour on March¡¯s last Sunday at 01:00 UTC (?02:00 local time) and falling
back on October¡¯s last Sunday at 01:00 UTC (?01:00 local time).
WGT3WGST,M3.5.0/-2,M10.5.0/-1
The schedule of Daylight Saving Time in any particular jurisdiction has changed over
the years. To be strictly correct, the conversion of dates and times in the past should be
based on the schedule that was in effect then. However, this format has no facilities to let
you specify how the schedule has changed from year to year. The most you can do is specify
one particular schedule¡ªusually the present day schedule¡ªand this is used to convert any
date, no matter when. For precise time zone specifications, it is best to use the time zone
information database (see below).

The third format looks like this:
:characters
Each operating system interprets this format differently; in the GNU C Library,charac-
tersis the name of a file which describes the time zone.

If theTZenvironment variable does not have a value, the operation chooses a time
zone by default. In the GNU C Library, the default time zone is like the specification
¡®TZ=:/etc/localtime¡¯ (or ¡®TZ=:/usr/local/etc/localtime¡¯, depending on how the GNU
C Library was configured; seeAppendix C [Installing the GNU C Library], page 1088).
Other C libraries use their own rule for choosing the default time zone, so there is little we
can say about them.


Chapter 21: Date and Time 678

Ifcharactersbegins with a slash, it is an absolute file name; otherwise the library looks
for the file/usr/share/zoneinfo/characters. Thezoneinfodirectory contains data files
describing local time zones in many different parts of the world. The names represent
major cities, with subdirectories for geographical areas; for example,America/New_York,
Europe/London,Asia/Hong_Kong. These data files are installed by the system administra-
tor, who also sets/etc/localtimeto point to the data file for the local time zone. The
files typically come from theTime Zone Database (http://www.iana.org/time-zones)
of time zone and daylight saving time information for most regions of the world, which is
maintained by a community of volunteers and put in the public domain.

## 21.5.7 Functions and Variables for Time Zones................

char * tzname[ 2 ] [Variable]
The arraytznamecontains two strings, which are the standard names of the pair of
time zones (standard and Daylight Saving) that the user has selected. tzname[0]
is the name of the standard time zone (for example,"EST"), andtzname[1]is the
name for the time zone when Daylight Saving Time is in use (for example,"EDT").
These correspond to thestdanddststrings (respectively) from theTZenvironment
variable. If Daylight Saving Time is never used,tzname[1]is the empty string.
Thetznamearray is initialized from theTZenvironment variable whenevertzset,
ctime, strftime,mktime, orlocaltimeis called. If multiple abbreviations have
been used (e.g. "EWT"and"EDT"for U.S. Eastern War Time and Eastern Daylight
Time), the array contains the most recent abbreviation.
Thetznamearray is required for POSIX.1 compatibility, but in GNU programs it is
better to use thetm_zonemember of the broken-down time structure, sincetm_zone
reports the correct abbreviation even when it is not the latest one.
Though the strings are declared aschar *the user must refrain from modifying these
strings. Modifying the strings will almost certainly lead to trouble.

void tzset(void) [Function]
Preliminary:|MT-Safe env locale|AS-Unsafe heap lock|AC-Unsafe lock mem fd
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thetzsetfunction initializes thetzname variable from the value of theTZenvi-
ronment variable. It is not usually necessary for your program to call this function,
because it is called automatically when you use the other time conversion functions
that depend on the time zone.

The following variables are defined for compatibility with System V Unix. Liketzname,
these variables are set by callingtzsetor the other time conversion functions.

long int timezone [Variable]
This contains the difference between UTC and the latest local standard time, in sec-
onds west of UTC. For example, in the U.S. Eastern time zone, the value is5*60*60.
Unlike thetm_gmtoffmember of the broken-down time structure, this value is not
adjusted for daylight saving, and its sign is reversed. In GNU programs it is better to
usetm_gmtoff, since it contains the correct offset even when it is not the latest one.


Chapter 21: Date and Time 679

int daylight [Variable]
This variable has a nonzero value if Daylight Saving Time rules apply. A nonzero
value does not necessarily mean that Daylight Saving Time is now in effect; it means
only that Daylight Saving Time is sometimes in effect.

## 21.5.8 Time Functions Example...............................

Here is an example program showing the use of some of the calendar time functions.

```
#include <time.h>
#include <stdio.h>
```
```
#define SIZE 256
```
```
int
main (void)
{
char buffer[SIZE];
time_t curtime;
struct tm *loctime;
```
```
/*Get the current time.*/
curtime = time (NULL);
```
```
/*Convert it to local time representation.*/
loctime = localtime (&curtime);
```
```
/*Print out the date and time in the standard format.*/
fputs (asctime (loctime), stdout);
```
```
/*Print it out in a nice format.*/
strftime (buffer, SIZE, "Today is %A, %B %d.\n", loctime);
fputs (buffer, stdout);
strftime (buffer, SIZE, "The time is %I:%M %p.\n", loctime);
fputs (buffer, stdout);
```
```
return 0;
}
It produces output like this:
Wed Jul 31 13:02:36 1991
Today is Wednesday, July 31.
The time is 01:02 PM.
```
## 21.6 Setting an Alarm............................................

Thealarmandsetitimerfunctions provide a mechanism for a process to interrupt itself
in the future. They do this by setting a timer; when the timer expires, the process receives
a signal.

```
Each process has three independent interval timers available:
```
- A real-time timer that counts elapsed time. This timer sends aSIGALRMsignal to the
    process when it expires.
- A virtual timer that counts processor time used by the process. This timer sends a
    SIGVTALRMsignal to the process when it expires.


Chapter 21: Date and Time 680

- A profiling timer that counts both processor time used by the process, and processor
    time spent in system calls on behalf of the process. This timer sends aSIGPROFsignal
    to the process when it expires.
    This timer is useful for profiling in interpreters. The interval timer mechanism does
    not have the fine granularity necessary for profiling native code.
You can only have one timer of each kind set at any given time. If you set a timer that
has not yet expired, that timer is simply reset to the new value.

You should establish a handler for the appropriate alarm signal using signal or
sigactionbefore issuing a call tosetitimeroralarm. Otherwise, an unusual chain of
events could cause the timer to expire before your program establishes the handler. In this
case it would be terminated, since termination is the default action for the alarm signals.
SeeChapter 24 [Signal Handling], page 714.

To be able to use the alarm function to interrupt a system call which might block
otherwise indefinitely it is important tonotset theSA_RESTARTflag when registering the
signal handler usingsigaction. When not usingsigactionthings get even uglier: the
signalfunction has fixed semantics with respect to restarts. The BSD semantics for this
function is to set the flag. Therefore, ifsigactionfor whatever reason cannot be used, it
is necessary to usesysv_signaland notsignal.

Thesetitimerfunction is the primary means for setting an alarm. This facility is
declared in the header filesys/time.h. Thealarmfunction, declared inunistd.h, provides
a somewhat simpler interface for setting the real-time timer.

struct itimerval [Data Type]
This structure is used to specify when a timer should expire. It contains the following
members:
struct timeval it_interval
This is the period between successive timer interrupts. If zero, the alarm
will only be sent once.
struct timeval it_value
This is the period between now and the first timer interrupt. If zero, the
alarm is disabled.
Thestruct timevaldata type is described inSection 21.2 [Time Types], page 647.

int setitimer(intwhich, const struct itimerval *new, struct [Function]
itimerval *old)
Preliminary: |MT-Safe timer|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thesetitimerfunction sets the timer specified bywhichaccording tonew. The
whichargument can have a value ofITIMER_REAL,ITIMER_VIRTUAL, orITIMER_PROF.
Ifoldis not a null pointer,setitimerreturns information about any previous unex-
pired timer of the same kind in the structure it points to.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:
EINVAL The timer period is too large.


Chapter 21: Date and Time 681

int getitimer(intwhich, struct itimerval *old) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetitimerfunction stores information about the timer specified bywhichin the
structure pointed at byold.
The return value and error conditions are the same as forsetitimer.

ITIMER_REAL
This constant can be used as thewhich argument to the setitimerand
getitimerfunctions to specify the real-time timer.

ITIMER_VIRTUAL
This constant can be used as thewhich argument to the setitimerand
getitimerfunctions to specify the virtual timer.

ITIMER_PROF
This constant can be used as thewhich argument to the setitimerand
getitimerfunctions to specify the profiling timer.

unsigned int alarm(unsigned intseconds) [Function]
Preliminary: |MT-Safe timer|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thealarmfunction sets the real-time timer to expire in secondsseconds. If you
want to cancel any existing alarm, you can do this by callingalarmwith aseconds
argument of zero.
The return value indicates how many seconds remain before the previous alarm would
have been sent. If there was no previous alarm,alarmreturns zero.

Thealarmfunction could be defined in terms ofsetitimerlike this:
unsigned int
alarm (unsigned int seconds)
{
struct itimerval old, new;
new.it_interval.tv_usec = 0;
new.it_interval.tv_sec = 0;
new.it_value.tv_usec = 0;
new.it_value.tv_sec = (long int) seconds;
if (setitimer (ITIMER_REAL, &new, &old) < 0)
return 0;
else
return old.it_value.tv_sec;
}
There is an example showing the use of thealarmfunction inSection 24.4.1 [Signal
Handlers that Return], page 731.

If you simply want your process to wait for a given number of seconds, you should use
thesleepfunction. SeeSection 21.7 [Sleeping], page 682.

You shouldn¡¯t count on the signal arriving precisely when the timer expires. In a multi-
processing environment there is typically some amount of delay involved.

Portability Note:Thesetitimerandgetitimerfunctions are derived from BSD Unix,
while thealarmfunction is specified by the POSIX.1 standard.setitimeris more powerful
thanalarm, butalarmis more widely used.


Chapter 21: Date and Time 682

## 21.7 Sleeping.....................................................

The functionsleepgives a simple way to make the program wait for a short interval.
If your program doesn¡¯t use signals (except to terminate), then you can expectsleepto
wait reliably throughout the specified interval. Otherwise,sleepcan return sooner if a
signal arrives; if you want to wait for a given interval regardless of signals, useselect(see
Section 13.9 [Waiting for Input or Output], page 366) and don¡¯t specify any descriptors to
wait for.

unsigned int sleep(unsigned intseconds) [Function]
Preliminary: |MT-Unsafe sig:SIGCHLD/linux|AS-Unsafe |AC-Unsafe |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesleepfunction waits forsecondsseconds or until a signal is delivered, whichever
happens first.
Ifsleepreturns because the requested interval is over, it returns a value of zero. If
it returns because of delivery of a signal, its return value is the remaining time in the
sleep interval.
Thesleepfunction is declared inunistd.h.

Resist the temptation to implement a sleep for a fixed amount of time by using the
return value ofsleep, when nonzero, to callsleepagain. This will work with a certain
amount of accuracy as long as signals arrive infrequently. But each signal can cause the
eventual wakeup time to be off by an additional second or so. Suppose a few signals happen
to arrive in rapid succession by bad luck¡ªthere is no limit on how much this could shorten
or lengthen the wait.

Instead, compute the calendar time at which the program should stop waiting, and keep
trying to wait until that calendar time. This won¡¯t be off by more than a second. With just
a little more work, you can useselectand make the waiting period quite accurate. (Of
course, heavy system load can cause additional unavoidable delays¡ªunless the machine is
dedicated to one application, there is no way you can avoid this.)

On some systems,sleepcan do strange things if your program usesSIGALRMexplicitly.
Even ifSIGALRMsignals are being ignored or blocked whensleepis called,sleepmight
return prematurely on delivery of aSIGALRMsignal. If you have established a handler for
SIGALRMsignals and aSIGALRMsignal is delivered while the process is sleeping, the action
taken might be just to causesleepto return instead of invoking your handler. And, if
sleepis interrupted by delivery of a signal whose handler requests an alarm or alters the
handling ofSIGALRM, this handler andsleepwill interfere.

On GNU systems, it is safe to usesleepandSIGALRMin the same program, because
sleepdoes not work by means ofSIGALRM.

int nanosleep(const struct timespec *requested_time, struct [Function]
timespec *remaining)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If resolution to seconds is not enough thenanosleepfunction can be used. As the
name suggests the sleep interval can be specified in nanoseconds. The actual elapsed
time of the sleep interval might be longer since the system rounds the elapsed time


Chapter 21: Date and Time 683

```
you request up to the next integer multiple of the actual resolution the system can
deliver.
*requested_timeis the elapsed time of the interval you want to sleep.
The function returns as*remainingthe elapsed time left in the interval for which
you requested to sleep. If the interval completed without getting interrupted by a
signal, this is zero.
struct timespecis described inSection 21.2 [Time Types], page 647.
If the function returns because the interval is over the return value is zero. If the
function returns?1 the global variableerrnois set to the following values:
EINTR The call was interrupted because a signal was delivered to the thread. If
theremainingparameter is not the null pointer the structure pointed to
byremainingis updated to contain the remaining elapsed time.
```
```
EINVAL The nanosecond value in therequestedtimeparameter contains an illegal
value. Either the value is negative or greater than or equal to 1000 million.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timenanosleepis called. If the thread gets canceled these resources
stay allocated until the program ends. To avoid this calls tonanosleepshould be
protected using cancellation handlers.
Thenanosleepfunction is declared intime.h.
```

### 684

## 22 Resource Usage And Limitation............

## 22 Resource Usage And Limitation........................

This chapter describes functions for examining how much of various kinds of resources (CPU
time, memory, etc.) a process has used and getting and setting limits on future usage.

## 22.1 Resource Usage.............................................

The functiongetrusageand the data typestruct rusageare used to examine the resource
usage of a process. They are declared insys/resource.h.

int getrusage(intprocesses, struct rusage *rusage) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function reports resource usage totals for processes specified byprocesses, storing
the information in*rusage.
In most systems,processeshas only two valid values:
RUSAGE_SELF
Just the current process.
RUSAGE_CHILDREN
All child processes (direct and indirect) that have already terminated.
The return value ofgetrusageis zero for success, and-1for failure.
EINVAL The argumentprocessesis not valid.

One way of getting resource usage for a particular child process is with the function
wait4, which returns totals for a child when it terminates. SeeSection 26.8 [BSD Process
Wait Function], page 813.

struct rusage [Data Type]
This data type stores various resource usage statistics. It has the following members,
and possibly others:
struct timeval ru_utime
Time spent executing user instructions.
struct timeval ru_stime
Time spent in operating system code on behalf ofprocesses.
long int ru_maxrss
The maximum resident set size used, in kilobytes. That is, the maximum
number of kilobytes of physical memory thatprocessesused simultane-
ously.
long int ru_ixrss
An integral value expressed in kilobytes times ticks of execution, which
indicates the amount of memory used by text that was shared with other
processes.
long int ru_idrss
An integral value expressed the same way, which is the amount of un-
shared memory used for data.


Chapter 22: Resource Usage And Limitation 685

```
long int ru_isrss
An integral value expressed the same way, which is the amount of un-
shared memory used for stack space.
long int ru_minflt
The number of page faults which were serviced without requiring any
I/O.
long int ru_majflt
The number of page faults which were serviced by doing I/O.
long int ru_nswap
The number of timesprocesseswas swapped entirely out of main memory.
long int ru_inblock
The number of times the file system had to read from the disk on behalf
ofprocesses.
long int ru_oublock
The number of times the file system had to write to the disk on behalf of
processes.
long int ru_msgsnd
Number of IPC messages sent.
long int ru_msgrcv
Number of IPC messages received.
long int ru_nsignals
Number of signals received.
long int ru_nvcsw
The number of timesprocessesvoluntarily invoked a context switch (usu-
ally to wait for some service).
long int ru_nivcsw
The number of times an involuntary context switch took place (because
a time slice expired, or another process of higher priority was scheduled).
```
## 22.2 Limiting Resource Usage....................................

You can specify limits for the resource usage of a process. When the process tries to exceed
a limit, it may get a signal, or the system call by which it tried to do so may fail, depending
on the resource. Each process initially inherits its limit values from its parent, but it can
subsequently change them.

```
There are two per-process limits associated with a resource:
```
current limit
The current limit is the value the system will not allow usage to exceed. It is
also called the ¡°soft limit¡± because the process being limited can generally raise
the current limit at will.

maximum limit
The maximum limit is the maximum value to which a process is allowed to set
its current limit. It is also called the ¡°hard limit¡± because there is no way for


Chapter 22: Resource Usage And Limitation 686

a process to get around it. A process may lower its own maximum limit, but
only the superuser may increase a maximum limit.
The symbols for use withgetrlimit,setrlimit,getrlimit64, andsetrlimit64are
defined insys/resource.h.

int getrlimit(intresource, struct rlimit *rlp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Read the current and maximum limits for the resourceresourceand store them in
*rlp.
The return value is 0 on success and-1on failure. The only possibleerrnoerror
condition isEFAULT.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is in factgetrlimit64. Thus, the LFS interface transparently replaces
the old interface.

int getrlimit64 (intresource, struct rlimit64 *rlp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar togetrlimitbut its second parameter is a pointer to a
variable of typestruct rlimit64, which allows it to read values which wouldn¡¯t fit
in the member of astruct rlimit.
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit machine, this
function is available under the namegetrlimitand so transparently replaces the old
interface.

int setrlimit(intresource, const struct rlimit *rlp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Store the current and maximum limits for the resourceresourcein*rlp.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is possible:
EPERM

- The process tried to raise a current limit beyond the maximum limit.
- The process tried to raise a maximum limit, but is not superuser.
When the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit system
this function is in factsetrlimit64. Thus, the LFS interface transparently replaces
the old interface.

int setrlimit64 (intresource, const struct rlimit64 *rlp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is similar tosetrlimitbut its second parameter is a pointer to a
variable of typestruct rlimit64which allows it to set values which wouldn¡¯t fit in
the member of astruct rlimit.


Chapter 22: Resource Usage And Limitation 687

```
If the sources are compiled with_FILE_OFFSET_BITS == 64on a 32-bit machine this
function is available under the namesetrlimitand so transparently replaces the old
interface.
```
struct rlimit [Data Type]
This structure is used withgetrlimitto receive limit values, and withsetrlimit
to specify limit values for a particular process and resource. It has two fields:
rlim_t rlim_cur
The current limit
rlim_t rlim_max
The maximum limit.
For getrlimit, the structure is an output; it receives the current values. For
setrlimit, it specifies the new values.

```
For the LFS functions a similar type is defined insys/resource.h.
```
struct rlimit64 [Data Type]
This structure is analogous to therlimitstructure above, but its components have
wider ranges. It has two fields:
rlim64_t rlim_cur
This is analogous torlimit.rlim_cur, but with a different type.
rlim64_t rlim_max
This is analogous torlimit.rlim_max, but with a different type.

Here is a list of resources for which you can specify a limit. Memory and file sizes are
measured in bytes.

RLIMIT_CPU
The maximum amount of CPU time the process can use. If it runs for longer
than this, it gets a signal: SIGXCPU. The value is measured in seconds. See
Section 24.2.6 [Operation Error Signals], page 722.

RLIMIT_FSIZE
The maximum size of file the process can create. Trying to write a larger
file causes a signal: SIGXFSZ. SeeSection 24.2.6 [Operation Error Signals],
page 722.

RLIMIT_DATA
The maximum size of data memory for the process. If the process tries to
allocate data memory beyond this amount, the allocation function fails.

RLIMIT_STACK
The maximum stack size for the process. If the process tries to extend its
stack past this size, it gets aSIGSEGVsignal. SeeSection 24.2.1 [Program Error
Signals], page 716.

RLIMIT_CORE
The maximum size core file that this process can create. If the process termi-
nates and would dump a core file larger than this, then no core file is created.
So setting this limit to zero prevents core files from ever being created.


Chapter 22: Resource Usage And Limitation 688

### RLIMIT_RSS

```
The maximum amount of physical memory that this process should get. This
parameter is a guide for the system¡¯s scheduler and memory allocator; the
system may give the process more memory when there is a surplus.
```
RLIMIT_MEMLOCK
The maximum amount of memory that can be locked into physical memory (so
it will never be paged out).

RLIMIT_NPROC
The maximum number of processes that can be created with the same user ID.
If you have reached the limit for your user ID,forkwill fail withEAGAIN. See
Section 26.4 [Creating a Process], page 805.

RLIMIT_NOFILE
RLIMIT_OFILE
The maximum number of files that the process can open. If it tries to open
more files than this, its open attempt fails witherrno EMFILE. SeeSection 2.2
[Error Codes], page 24. Not all systems support this limit; GNU does, and 4.4
BSD does.

RLIMIT_AS
The maximum size of total memory that this process should get. If the process
tries to allocate more memory beyond this amount with, for example,brk,
malloc,mmaporsbrk, the allocation function fails.

RLIM_NLIMITS
The number of different resource limits. Any validresourceoperand must be
less thanRLIM_NLIMITS.

rlim_t RLIM_INFINITY [Constant]
This constant stands for a value of ¡°infinity¡± when supplied as the limit value in
setrlimit.

The following are historical functions to do some of what the functions above do. The
functions above are better choices.

```
ulimitand the command symbols are declared inulimit.h.
```
long int ulimit (intcmd,.. .) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
ulimitgets the current limit or sets the current and maximum limit for a particular
resource for the calling process according to the commandcmd.
If you are getting a limit, the command argument is the only argument. If you are
setting a limit, there is a second argument:long intlimitwhich is the value to which
you are setting the limit.
Thecmdvalues and the operations they specify are:

```
GETFSIZE Get the current limit on the size of a file, in units of 512 bytes.
```

Chapter 22: Resource Usage And Limitation 689

```
SETFSIZE Set the current and maximum limit on the size of a file tolimit * 512
bytes.
There are also some othercmdvalues that may do things on some systems, but they
are not supported.
Only the superuser may increase a maximum limit.
When you successfully get a limit, the return value ofulimitis that limit, which is
never negative. When you successfully set a limit, the return value is zero. When the
function fails, the return value is-1anderrnois set according to the reason:
EPERM A process tried to increase a maximum limit, but is not superuser.
```
```
vlimitand its resource symbols are declared insys/vlimit.h.
```
int vlimit(intresource, intlimit) [Function]
Preliminary:|MT-Unsafe race:setrlimit|AS-Unsafe|AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
vlimitsets the current limit for a resource for a process.
resourceidentifies the resource:
LIM_CPU Maximum CPU time. Same asRLIMIT_CPUforsetrlimit.

```
LIM_FSIZE
Maximum file size. Same asRLIMIT_FSIZEforsetrlimit.
LIM_DATA Maximum data memory. Same asRLIMIT_DATAforsetrlimit.
LIM_STACK
Maximum stack size. Same asRLIMIT_STACKforsetrlimit.
LIM_CORE Maximum core file size. Same asRLIMIT_CORforsetrlimit.
```
```
LIM_MAXRSS
Maximum physical memory. Same asRLIMIT_RSSforsetrlimit.
The return value is zero for success, and-1witherrnoset accordingly for failure:
EPERM The process tried to set its current limit beyond its maximum limit.
```
## 22.3 Process CPU Priority And Scheduling.......................

When multiple processes simultaneously require CPU time, the system¡¯s scheduling policy
and process CPU priorities determine which processes get it. This section describes how
that determination is made and GNU C Library functions to control it.

It is common to refer to CPU scheduling simply as scheduling and a process¡¯ CPU priority
simply as the process¡¯ priority, with the CPU resource being implied. Bear in mind, though,
that CPU time is not the only resource a process uses or that processes contend for. In some
cases, it is not even particularly important. Giving a process a high ¡°priority¡± may have
very little effect on how fast a process runs with respect to other processes. The priorities
discussed in this section apply only to CPU time.

CPU scheduling is a complex issue and different systems do it in wildly different ways.
New ideas continually develop and find their way into the intricacies of the various systems¡¯


Chapter 22: Resource Usage And Limitation 690

scheduling algorithms. This section discusses the general concepts, some specifics of systems
that commonly use the GNU C Library, and some standards.

For simplicity, we talk about CPU contention as if there is only one CPU in the system.
But all the same principles apply when a processor has multiple CPUs, and knowing that
the number of processes that can run at any one time is equal to the number of CPUs, you
can easily extrapolate the information.

The functions described in this section are all defined by the POSIX.1 and POSIX.1b
standards (thesched...functions are POSIX.1b). However, POSIX does not define any
semantics for the values that these functions get and set. In this chapter, the semantics are
based on the Linux kernel¡¯s implementation of the POSIX standard. As you will see, the
Linux implementation is quite the inverse of what the authors of the POSIX syntax had in
mind.

## 22.3.1 Absolute Priority.......................................

Every process has an absolute priority, and it is represented by a number. The higher the
number, the higher the absolute priority.

On systems of the past, and most systems today, all processes have absolute priority
0 and this section is irrelevant. In that case, SeeSection 22.3.4 [Traditional Scheduling],
page 696. Absolute priorities were invented to accommodate realtime systems, in which it
is vital that certain processes be able to respond to external events happening in real time,
which means they cannot wait around while some other process thatwants to, but doesn¡¯t
need torun occupies the CPU.

When two processes are in contention to use the CPU at any instant, the one with
the higher absolute priority always gets it. This is true even if the process with the lower
priority is already using the CPU (i.e., the scheduling is preemptive). Of course, we¡¯re only
talking about processes that are running or ¡°ready to run,¡± which means they are ready to
execute instructions right now. When a process blocks to wait for something like I/O, its
absolute priority is irrelevant.

NB:The term ¡°runnable¡± is a synonym for ¡°ready to run.¡±
When two processes are running or ready to run and both have the same absolute priority,
it¡¯s more interesting. In that case, who gets the CPU is determined by the scheduling policy.
If the processes have absolute priority 0, the traditional scheduling policy described in
Section 22.3.4 [Traditional Scheduling], page 696,applies. Otherwise, the policies described
inSection 22.3.2 [Realtime Scheduling], page 691,apply.

You normally give an absolute priority above 0 only to a process that can be trusted not
to hog the CPU. Such processes are designed to block (or terminate) after relatively short
CPU runs.

A process begins life with the same absolute priority as its parent process. Functions
described inSection 22.3.3 [Basic Scheduling Functions], page 692,can change it.

Only a privileged process can change a process¡¯ absolute priority to something other than
0. Only a privileged process or the target process¡¯ owner can change its absolute priority
at all.

POSIX requires absolute priority values used with the realtime scheduling policies to be
consecutive with a range of at least 32. On Linux, they are 1 through 99. The functions


Chapter 22: Resource Usage And Limitation 691

sched_get_priority_maxandsched_set_priority_minportably tell you what the range
is on a particular system.

## 22.3.1.1 Using Absolute Priority............................

One thing you must keep in mind when designing real time applications is that having higher
absolute priority than any other process doesn¡¯t guarantee the process can run continuously.
Two things that can wreck a good CPU run are interrupts and page faults.

Interrupt handlers live in that limbo between processes. The CPU is executing instruc-
tions, but they aren¡¯t part of any process. An interrupt will stop even the highest priority
process. So you must allow for slight delays and make sure that no device in the system
has an interrupt handler that could cause too long a delay between instructions for your
process.

Similarly, a page fault causes what looks like a straightforward sequence of instructions
to take a long time. The fact that other processes get to run while the page faults in is of no
consequence, because as soon as the I/O is complete, the higher priority process will kick
them out and run again, but the wait for the I/O itself could be a problem. To neutralize
this threat, usemlockormlockall.

There are a few ramifications of the absoluteness of this priority on a single-CPU system
that you need to keep in mind when you choose to set a priority and also when you¡¯re
working on a program that runs with high absolute priority. Consider a process that
has higher absolute priority than any other process in the system and due to a bug in its
program, it gets into an infinite loop. It will never cede the CPU. You can¡¯t run a command
to kill it because your command would need to get the CPU in order to run. The errant
program is in complete control. It controls the vertical, it controls the horizontal.

There are two ways to avoid this: 1) keep a shell running somewhere with a higher
absolute priority or 2) keep a controlling terminal attached to the high priority process
group. All the priority in the world won¡¯t stop an interrupt handler from running and
delivering a signal to the process if you hit Control-C.

Some systems use absolute priority as a means of allocating a fixed percentage of CPU
time to a process. To do this, a super high priority privileged process constantly monitors
the process¡¯ CPU usage and raises its absolute priority when the process isn¡¯t getting its
entitled share and lowers it when the process is exceeding it.

NB:The absolute priority is sometimes called the ¡°static priority.¡± We don¡¯t use that
term in this manual because it misses the most important feature of the absolute priority:
its absoluteness.

## 22.3.2 Realtime Scheduling....................................

Whenever two processes with the same absolute priority are ready to run, the kernel has a
decision to make, because only one can run at a time. If the processes have absolute priority
0, the kernel makes this decision as described inSection 22.3.4 [Traditional Scheduling],
page 696. Otherwise, the decision is as described in this section.

If two processes are ready to run but have different absolute priorities, the decision is
much simpler, and is described inSection 22.3.1 [Absolute Priority], page 690.

Each process has a scheduling policy. For processes with absolute priority other than
zero, there are two available:


Chapter 22: Resource Usage And Limitation 692

1. First Come First Served
2. Round Robin
    The most sensible case is where all the processes with a certain absolute priority have
the same scheduling policy. We¡¯ll discuss that first.

In Round Robin, processes share the CPU, each one running for a small quantum of time
(¡°time slice¡±) and then yielding to another in a circular fashion. Of course, only processes
that are ready to run and have the same absolute priority are in this circle.

In First Come First Served, the process that has been waiting the longest to run gets
the CPU, and it keeps it until it voluntarily relinquishes the CPU, runs out of things to do
(blocks), or gets preempted by a higher priority process.

First Come First Served, along with maximal absolute priority and careful control of
interrupts and page faults, is the one to use when a process absolutely, positively has to
run at full CPU speed or not at all.

Judicious use ofsched_yieldfunction invocations by processes with First Come First
Served scheduling policy forms a good compromise between Round Robin and First Come
First Served.

To understand how scheduling works when processes of different scheduling policies
occupy the same absolute priority, you have to know the nitty gritty details of how processes
enter and exit the ready to run list.

In both cases, the ready to run list is organized as a true queue, where a process gets
pushed onto the tail when it becomes ready to run and is popped off the head when the
scheduler decides to run it. Note that ready to run and running are two mutually exclusive
states. When the scheduler runs a process, that process is no longer ready to run and no
longer in the ready to run list. When the process stops running, it may go back to being
ready to run again.

The only difference between a process that is assigned the Round Robin scheduling policy
and a process that is assigned First Come First Serve is that in the former case, the process
is automatically booted off the CPU after a certain amount of time. When that happens,
the process goes back to being ready to run, which means it enters the queue at the tail.
The time quantum we¡¯re talking about is small. Really small. This is not your father¡¯s
timesharing. For example, with the Linux kernel, the round robin time slice is a thousand
times shorter than its typical time slice for traditional scheduling.

A process begins life with the same scheduling policy as its parent process. Functions
described inSection 22.3.3 [Basic Scheduling Functions], page 692,can change it.

Only a privileged process can set the scheduling policy of a process that has absolute
priority higher than 0.

## 22.3.3 Basic Scheduling Functions.............................

This section describes functions in the GNU C Library for setting the absolute priority and
scheduling policy of a process.

Portability Note: On systems that have the functions in this section, the macro
POSIXPRIORITYSCHEDULING is defined in<unistd.h>.
For the case that the scheduling policy is traditional scheduling, more functions to fine
tune the scheduling are inSection 22.3.4 [Traditional Scheduling], page 696.


Chapter 22: Resource Usage And Limitation 693

Don¡¯t try to make too much out of the naming and structure of these functions. They
don¡¯t match the concepts described in this manual because the functions are as defined
by POSIX.1b, but the implementation on systems that use the GNU C Library is the
inverse of what the POSIX structure contemplates. The POSIX scheme assumes that the
primary scheduling parameter is the scheduling policy and that the priority value, if any, is
a parameter of the scheduling policy. In the implementation, though, the priority value is
king and the scheduling policy, if anything, only fine tunes the effect of that priority.

The symbols in this section are declared by including filesched.h.
Portability Note:In POSIX, thepid_targuments of the functions below refer to process
IDs. On Linux, they are actually thread IDs, and control how specific threads are scheduled
with regards to the entire system. The resulting behavior does not conform to POSIX. This
is why the following description refers to tasks and tasks IDs, and not processes and process
IDs.

struct sched_param [Data Type]
This structure describes an absolute priority.
int sched_priority
absolute priority value

int sched_setscheduler (pidtpid, intpolicy, const struct [Function]
schedparam *param)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function sets both the absolute priority and the scheduling policy for a task.
It assigns the absolute priority value given byparamand the scheduling policypolicy
to the task with IDpid, or the calling task if pidis zero. Ifpolicy is negative,
sched_setschedulerkeeps the existing scheduling policy.
The following macros represent the valid values forpolicy:
SCHED_OTHER
Traditional Scheduling
SCHED_FIFO
First In First Out
SCHED_RR Round Robin
On success, the return value is 0. Otherwise, it is-1andERRNOis set accordingly.
Theerrnovalues specific to this function are:
EPERM

- The calling task does not haveCAP_SYS_NICEpermission andpolicy
    is notSCHED_OTHER(or it¡¯s negative and the existing policy is not
    SCHED_OTHER.
- The calling task does not haveCAP_SYS_NICEpermission and its
    owner is not the target task¡¯s owner. I.e., the effective uid of the
    calling task is neither the effective nor the real uid of taskpid.
ESRCH There is no task with pidpidandpidis not zero.


Chapter 22: Resource Usage And Limitation 694

### EINVAL

- policydoes not identify an existing scheduling policy.
- The absolute priority value identified by *paramis outside the valid
    range for the scheduling policypolicy (or the existing scheduling
    policy ifpolicyis negative) orparamis null.sched_get_priority_
    maxandsched_get_priority_mintell you what the valid range is.
- pidis negative.

int sched_getscheduler (pidtpid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the scheduling policy assigned to the task with IDpid, or the
calling task ifpidis zero.
The return value is the scheduling policy. Seesched_setschedulerfor the possible
values.
If the function fails, the return value is instead-1anderrnois set accordingly.
Theerrnovalues specific to this function are:

```
ESRCH There is no task with pidpidand it is not zero.
```
```
EINVAL pidis negative.
```
```
Note that this function is not an exact mate tosched_setschedulerbecause while
that function sets the scheduling policy and the absolute priority, this function gets
only the scheduling policy. To get the absolute priority, usesched_getparam.
```
int sched_setparam(pidtpid, const struct schedparam *param) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function sets a task¡¯s absolute priority.
It is functionally identical tosched_setschedulerwithpolicy=-1.

int sched_getparam(pidtpid, struct schedparam *param) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns a task¡¯s absolute priority.
pidis the task ID of the task whose absolute priority you want to know.
paramis a pointer to a structure in which the function stores the absolute priority of
the task.
On success, the return value is 0. Otherwise, it is-1anderrnois set accordingly.
Theerrnovalues specific to this function are:

```
ESRCH There is no task with IDpidand it is not zero.
```
```
EINVAL pidis negative.
```

Chapter 22: Resource Usage And Limitation 695

int sched_get_priority_min (intpolicy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the lowest absolute priority value that is allowable for a task
with scheduling policypolicy.
On Linux, it is 0 for SCHEDOTHER and 1 for everything else.
On success, the return value is 0. Otherwise, it is-1andERRNOis set accordingly.
Theerrnovalues specific to this function are:

```
EINVAL policydoes not identify an existing scheduling policy.
```
int sched_get_priority_max (intpolicy) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the highest absolute priority value that is allowable for a task
that with scheduling policypolicy.
On Linux, it is 0 for SCHEDOTHER and 99 for everything else.
On success, the return value is 0. Otherwise, it is-1andERRNOis set accordingly.
Theerrnovalues specific to this function are:

```
EINVAL policydoes not identify an existing scheduling policy.
```
int sched_rr_get_interval(pidtpid, struct timespec [Function]
*interval)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the length of the quantum (time slice) used with the Round
Robin scheduling policy, if it is used, for the task with task IDpid.
It returns the length of time asinterval.
With a Linux kernel, the round robin time slice is always 150 microseconds, andpid
need not even be a real pid.
The return value is 0 on success and in the pathological case that it fails, the return
value is-1anderrnois set accordingly. There is nothing specific that can go wrong
with this function, so there are no specificerrnovalues.

int sched_yield (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function voluntarily gives up the task¡¯s claim on the CPU.
Technically,sched_yieldcauses the calling task to be made immediately ready to
run (as opposed to running, which is what it was before). This means that if it has
absolute priority higher than 0, it gets pushed onto the tail of the queue of tasks that
share its absolute priority and are ready to run, and it will run again when its turn
next arrives. If its absolute priority is 0, it is more complicated, but still has the effect
of yielding the CPU to other tasks.


Chapter 22: Resource Usage And Limitation 696

```
If there are no other tasks that share the calling task¡¯s absolute priority, this function
doesn¡¯t have any effect.
To the extent that the containing program is oblivious to what other processes in the
system are doing and how fast it executes, this function appears as a no-op.
The return value is 0 on success and in the pathological case that it fails, the return
value is-1anderrnois set accordingly. There is nothing specific that can go wrong
with this function, so there are no specificerrnovalues.
```
## 22.3.4 Traditional Scheduling..................................

This section is about the scheduling among processes whose absolute priority is 0. When the
system hands out the scraps of CPU time that are left over after the processes with higher
absolute priority have taken all they want, the scheduling described herein determines who
among the great unwashed processes gets them.

## 22.3.4.1 Introduction To Traditional Scheduling............

Long before there was absolute priority (SeeSection 22.3.1 [Absolute Priority], page 690),
Unix systems were scheduling the CPU using this system. When POSIX came in like the
Romans and imposed absolute priorities to accommodate the needs of realtime processing,
it left the indigenous Absolute Priority Zero processes to govern themselves by their own
familiar scheduling policy.

Indeed, absolute priorities higher than zero are not available on many systems today
and are not typically used when they are, being intended mainly for computers that do
realtime processing. So this section describes the only scheduling many programmers need
to be concerned about.

But just to be clear about the scope of this scheduling: Any time a process with an
absolute priority of 0 and a process with an absolute priority higher than 0 are ready to
run at the same time, the one with absolute priority 0 does not run. If it¡¯s already running
when the higher priority ready-to-run process comes into existence, it stops immediately.

In addition to its absolute priority of zero, every process has another priority, which we
will refer to as"dynamic priority"because it changes over time. The dynamic priority is
meaningless for processes with an absolute priority higher than zero.

The dynamic priority sometimes determines who gets the next turn on the CPU. Some-
times it determines how long turns last. Sometimes it determines whether a process can
kick another off the CPU.

In Linux, the value is a combination of these things, but mostly it just determines the
length of the time slice. The higher a process¡¯ dynamic priority, the longer a shot it gets on
the CPU when it gets one. If it doesn¡¯t use up its time slice before giving up the CPU to
do something like wait for I/O, it is favored for getting the CPU back when it¡¯s ready for
it, to finish out its time slice. Other than that, selection of processes for new time slices is
basically round robin. But the scheduler does throw a bone to the low priority processes: A
process¡¯ dynamic priority rises every time it is snubbed in the scheduling process. In Linux,
even the fat kid gets to play.

The fluctuation of a process¡¯ dynamic priority is regulated by another value: The ¡°nice¡±
value. The nice value is an integer, usually in the range -20 to 20, and represents an upper
limit on a process¡¯ dynamic priority. The higher the nice number, the lower that limit.


Chapter 22: Resource Usage And Limitation 697

On a typical Linux system, for example, a process with a nice value of 20 can get only 10
milliseconds on the CPU at a time, whereas a process with a nice value of -20 can achieve
a high enough priority to get 400 milliseconds.

The idea of the nice value is deferential courtesy. In the beginning, in the Unix garden
of Eden, all processes shared equally in the bounty of the computer system. But not all
processes really need the same share of CPU time, so the nice value gave a courteous process
the ability to refuse its equal share of CPU time that others might prosper. Hence, the higher
a process¡¯ nice value, the nicer the process is. (Then a snake came along and offered some
process a negative nice value and the system became the crass resource allocation system
we know today.)

Dynamic priorities tend upward and downward with an objective of smoothing out allo-
cation of CPU time and giving quick response time to infrequent requests. But they never
exceed their nice limits, so on a heavily loaded CPU, the nice value effectively determines
how fast a process runs.

In keeping with the socialistic heritage of Unix process priority, a process begins life with
the same nice value as its parent process and can raise it at will. A process can also raise
the nice value of any other process owned by the same user (or effective user). But only
a privileged process can lower its nice value. A privileged process can also raise or lower
another process¡¯ nice value.

GNU C Library functions for getting and setting nice values are described in See
Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

## 22.3.4.2 Functions For Traditional Scheduling..............

This section describes how you can read and set the nice value of a process. All these
symbols are declared insys/resource.h.

The function and macro names are defined by POSIX, and refer to"priority,"but the
functions actually have to do with nice values, as the terms are used both in the manual
and POSIX.

The range of valid nice values depends on the kernel, but typically it runs from-20
to 20. A lower nice value corresponds to higher priority for the process. These constants
describe the range of priority values:

PRIO_MIN The lowest valid nice value.

PRIO_MAX The highest valid nice value.

int getpriority (intclass, intid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Return the nice value of a set of processes;classandidspecify which ones (see below).
If the processes specified do not all have the same nice value, this returns the lowest
value that any of them has.
On success, the return value is 0. Otherwise, it is-1anderrnois set accordingly.
Theerrnovalues specific to this function are:
ESRCH The combination ofclassandiddoes not match any existing process.
EINVAL The value ofclassis not valid.


Chapter 22: Resource Usage And Limitation 698

```
If the return value is-1, it could indicate failure, or it could be the nice value. The
only way to make certain is to seterrno = 0before callinggetpriority, then use
errno != 0afterward as the criterion for failure.
```
int setpriority (intclass, intid, intniceval) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the nice value of a set of processes toniceval;classandidspecify which ones (see
below).
The return value is 0 on success, and-1on failure. The followingerrnoerror condi-
tion are possible for this function:
ESRCH The combination ofclassandiddoes not match any existing process.
EINVAL The value ofclassis not valid.

```
EPERM The call would set the nice value of a process which is owned by a different
user than the calling process (i.e., the target process¡¯ real or effective uid
does not match the calling process¡¯ effective uid) and the calling process
does not haveCAP_SYS_NICEpermission.
EACCES The call would lower the process¡¯ nice value and the process does not
haveCAP_SYS_NICEpermission.
```
The argumentsclassandidtogether specify a set of processes in which you are interested.
These are the possible values ofclass:

PRIO_PROCESS
One particular process. The argumentidis a process ID (pid).

PRIO_PGRP
All the processes in a particular process group. The argumentidis a process
group ID (pgid).

PRIO_USER
All the processes owned by a particular user (i.e., whose real uid indicates the
user). The argumentidis a user ID (uid).
If the argumentidis 0, it stands for the calling process, its process group, or its owner
(real uid), according toclass.

int nice (intincrement) [Function]
Preliminary: | MT-Unsafe race:setpriority | AS-Unsafe | AC-Safe | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Increment the nice value of the calling process byincrement. The return value is the
new nice value on success, and-1on failure. In the case of failure,errnowill be set
to the same values as forsetpriority.
Here is an equivalent definition ofnice:
int
nice (int increment)
{
int result, old = getpriority (PRIO_PROCESS, 0);


Chapter 22: Resource Usage And Limitation 699

```
result = setpriority (PRIO_PROCESS, 0, old + increment);
if (result != -1)
return old + increment;
else
return -1;
}
```
## 22.3.5 Limiting execution to certain CPUs.....................

On a multi-processor system the operating system usually distributes the different processes
which are runnable on all available CPUs in a way which allows the system to work most
efficiently. Which processes and threads run can be to some extend be control with the
scheduling functionality described in the last sections. But which CPU finally executes
which process or thread is not covered.

There are a number of reasons why a program might want to have control over this
aspect of the system as well:

- One thread or process is responsible for absolutely critical work which under no cir-
    cumstances must be interrupted or hindered from making progress by other processes
    or threads using CPU resources. In this case the special process would be confined to
    a CPU which no other process or thread is allowed to use.
- The access to certain resources (RAM, I/O ports) has different costs from different
    CPUs. This is the case in NUMA (Non-Uniform Memory Architecture) machines.
    Preferably memory should be accessed locally but this requirement is usually not visible
    to the scheduler. Therefore forcing a process or thread to the CPUs which have local
    access to the most-used memory helps to significantly boost the performance.
- In controlled runtimes resource allocation and book-keeping work (for instance garbage
    collection) is performance local to processors. This can help to reduce locking costs
    if the resources do not have to be protected from concurrent accesses from different
    processors.

The POSIX standard up to this date is of not much help to solve this problem. The
Linux kernel provides a set of interfaces to allow specifyingaffinity setsfor a process. The
scheduler will schedule the thread or process on CPUs specified by the affinity masks. The
interfaces which the GNU C Library define follow to some extent the Linux kernel interface.

cpu_set_t [Data Type]
This data set is a bitset where each bit represents a CPU. How the system¡¯s CPUs
are mapped to bits in the bitset is system dependent. The data type has a fixed size;
in the unlikely case that the number of bits are not sufficient to describe the CPUs
of the system a different interface has to be used.
This type is a GNU extension and is defined insched.h.

To manipulate the bitset, to set and reset bits, a number of macros are defined. Some
of the macros take a CPU number as a parameter. Here it is important to never exceed the
size of the bitset. The following macro specifies the number of bits in thecpu_set_tbitset.

int CPU_SETSIZE [Macro]
The value of this macro is the maximum number of CPUs which can be handled with
acpu_set_tobject.


Chapter 22: Resource Usage And Limitation 700

The typecpu_set_tshould be considered opaque; all manipulation should happen via
the next four macros.

void CPU_ZERO(cpusett *set) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro initializes the CPU setsetto be the empty set.
This macro is a GNU extension and is defined insched.h.

void CPU_SET (intcpu, cpusett *set) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro addscputo the CPU setset.
Thecpuparameter must not have side effects since it is evaluated more than once.
This macro is a GNU extension and is defined insched.h.

void CPU_CLR (intcpu, cpusett *set) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro removescpufrom the CPU setset.
Thecpuparameter must not have side effects since it is evaluated more than once.
This macro is a GNU extension and is defined insched.h.

int CPU_ISSET(intcpu, const cpu sett *set) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value (true) ifcpuis a member of the CPU setset, and
zero (false) otherwise.
Thecpuparameter must not have side effects since it is evaluated more than once.
This macro is a GNU extension and is defined insched.h.

CPU bitsets can be constructed from scratch or the currently installed affinity mask can
be retrieved from the system.

int sched_getaffinity(pidtpid, sizetcpusetsize, cpu sett [Function]
*cpuset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function stores the CPU affinity mask for the process or thread with the IDpid
in thecpusetsizebytes long bitmap pointed to bycpuset. If successful, the function
always initializes all bits in thecpu_set_tobject and returns zero.
Ifpiddoes not correspond to a process or thread on the system the or the function
fails for some other reason, it returns-1anderrnois set to represent the error
condition.

```
ESRCH No process or thread with the given ID found.
```

Chapter 22: Resource Usage And Limitation 701

```
EFAULT The pointercpusetdoes not point to a valid object.
```
```
This function is a GNU extension and is declared insched.h.
```
Note that it is not portably possible to use this information to retrieve the information
for different POSIX threads. A separate interface must be provided for that.

int sched_setaffinity(pidtpid, sizetcpusetsize, const [Function]
cpusett *cpuset)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function installs thecpusetsizebytes long affinity mask pointed to bycpusetfor
the process or thread with the IDpid. If successful the function returns zero and the
scheduler will in the future take the affinity information into account.
If the function fails it will return-1anderrnois set to the error code:

```
ESRCH No process or thread with the given ID found.
```
```
EFAULT The pointercpusetdoes not point to a valid object.
```
```
EINVAL The bitset is not valid. This might mean that the affinity set might not
leave a processor for the process or thread to run on.
```
```
This function is a GNU extension and is declared insched.h.
```
int getcpu(unsigned int *cpu, unsigned int *node) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetcpufunction identifies the processor and node on which the calling thread
or process is currently running and writes them into the integers pointed to by the
cpuandnodearguments. The processor is a unique nonnegative integer identifying
a CPU. The node is a unique nonnegative integer identifying a NUMA node. When
eithercpuornodeisNULL, nothing is written to the respective pointer.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:

```
ENOSYS The operating system does not support this function.
```
```
This function is Linux-specific and is declared insched.h.
```
## 22.4 Querying memory available resources........................

The amount of memory available in the system and the way it is organized determines
oftentimes the way programs can and have to work. For functions likemmapit is necessary
to know about the size of individual memory pages and knowing how much memory is
available enables a program to select appropriate sizes for, say, caches. Before we get into
these details a few words about memory subsystems in traditional Unix systems will be
given.


Chapter 22: Resource Usage And Limitation 702

## 22.4.1 Overview about traditional Unix memory handling......

Unix systems normally provide processes virtual address spaces. This means that the ad-
dresses of the memory regions do not have to correspond directly to the addresses of the
actual physical memory which stores the data. An extra level of indirection is introduced
which translates virtual addresses into physical addresses. This is normally done by the
hardware of the processor.

Using a virtual address space has several advantages. The most important is process
isolation. The different processes running on the system cannot interfere directly with each
other. No process can write into the address space of another process (except when shared
memory is used but then it is wanted and controlled).

Another advantage of virtual memory is that the address space the processes see can ac-
tually be larger than the physical memory available. The physical memory can be extended
by storage on an external media where the content of currently unused memory regions is
stored. The address translation can then intercept accesses to these memory regions and
make memory content available again by loading the data back into memory. This concept
makes it necessary that programs which have to use lots of memory know the difference
between available virtual address space and available physical memory. If the working set of
virtual memory of all the processes is larger than the available physical memory the system
will slow down dramatically due to constant swapping of memory content from the memory
to the storage media and back. This is called ¡°thrashing¡±.

A final aspect of virtual memory which is important and follows from what is said in
the last paragraph is the granularity of the virtual address space handling. When we said
that the virtual address handling stores memory content externally it cannot do this on
a byte-by-byte basis. The administrative overhead does not allow this (leaving alone the
processor hardware). Instead several thousand bytes are handled together and form apage.
The size of each page is always a power of two bytes. The smallest page size in use today
is 4096, with 8192, 16384, and 65536 being other popular sizes.

## 22.4.2 How to get information about the memory subsystem?..

The page size of the virtual memory the process sees is essential to know in several situations.
Some programming interfaces (e.g.,mmap, seeSection 13.8 [Memory-mapped I/O], page 360)
require the user to provide information adjusted to the page size. In the case ofmmapit
is necessary to provide a length argument which is a multiple of the page size. Another
place where the knowledge about the page size is useful is in memory allocation. If one
allocates pieces of memory in larger chunks which are then subdivided by the application
code it is useful to adjust the size of the larger blocks to the page size. If the total memory
requirement for the block is close (but not larger) to a multiple of the page size the kernel¡¯s
memory handling can work more effectively since it only has to allocate memory pages
which are fully used. (To do this optimization it is necessary to know a bit about the
memory allocator which will require a bit of memory itself for each block and this overhead
must not push the total size over the page size multiple.)

The page size traditionally was a compile time constant. But recent development of
processors changed this. Processors now support different page sizes and they can possibly
even vary among different processes on the same system. Therefore the system should be
queried at runtime about the current page size and no assumptions (except about it being
a power of two) should be made.


Chapter 22: Resource Usage And Limitation 703

The correct interface to query about the page size issysconf(seeSection 32.4.1 [Def-
inition ofsysconf], page 893) with the parameter_SC_PAGESIZE. There is a much older
interface available, too.

int getpagesize (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetpagesizefunction returns the page size of the process. This value is fixed
for the runtime of the process but can vary in different runs of the application.
The function is declared inunistd.h.

Widely available on System V derived systems is a method to get information about the
physical memory the system has. The call

```
sysconf (_SC_PHYS_PAGES)
```
returns the total number of pages of physical memory the system has. This does not mean
all this memory is available. This information can be found using

sysconf (_SC_AVPHYS_PAGES)
These two values help to optimize applications. The value returned for_SC_AVPHYS_
PAGESis the amount of memory the application can use without hindering any other process
(given that no other process increases its memory usage). The value returned for_SC_PHYS_
PAGESis more or less a hard limit for the working set. If all applications together constantly
use more than that amount of memory the system is in trouble.

The GNU C Library provides in addition to these already described way to get this
information two functions. They are declared in the filesys/sysinfo.h. Programmers
should prefer to use thesysconfmethod described above.

long int get_phys_pages (void) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe lock fd mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theget_phys_pagesfunction returns the total number of pages of physical memory
the system has. To get the amount of memory this number has to be multiplied by
the page size.
This function is a GNU extension.

long int get_avphys_pages(void) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe lock fd mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.

```
Theget_avphys_pagesfunction returns the number of available pages of physical
memory the system has. To get the amount of memory this number has to be multi-
plied by the page size.
```
```
This function is a GNU extension.
```

Chapter 22: Resource Usage And Limitation 704

## 22.5 Learn about the processors available.........................

The use of threads or processes with shared memory allows an application to take advantage
of all the processing power a system can provide. If the task can be parallelized the optimal
way to write an application is to have at any time as many processes running as there are
processors. To determine the number of processors available to the system one can run
sysconf (_SC_NPROCESSORS_CONF)

which returns the number of processors the operating system configured. But it might be
possible for the operating system to disable individual processors and so the call
sysconf (_SC_NPROCESSORS_ONLN)

returns the number of processors which are currently online (i.e., available).

For these two pieces of information the GNU C Library also provides functions to get
the information directly. The functions are declared insys/sysinfo.h.

int get_nprocs_conf (void) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe lock fd mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theget_nprocs_conffunction returns the number of processors the operating sys-
tem configured.
This function is a GNU extension.

int get_nprocs(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theget_nprocsfunction returns the number of available processors.
This function is a GNU extension.

Before starting more threads it should be checked whether the processors are not already
overused. Unix systems calculate something called theload average. This is a number
indicating how many processes were running. This number is an average over different
periods of time (normally 1, 5, and 15 minutes).

int getloadavg(doubleloadavg[], intnelem) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe fd|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function gets the 1, 5 and 15 minute load averages of the system. The values are
placed inloadavg.getloadavgwill place at mostnelemelements into the array but
never more than three elements. The return value is the number of elements written
toloadavg, or -1 on error.
This function is declared instdlib.h.


### 705

## 23 Non-Local Exits.............................

## 23 Non-Local Exits.....................................

Sometimes when your program detects an unusual situation inside a deeply nested set of
function calls, you would like to be able to immediately return to an outer level of control.
This section describes how you can do suchnon-local exitsusing thesetjmpandlongjmp
functions.

## 23.1 Introduction to Non-Local Exits.............................

As an example of a situation where a non-local exit can be useful, suppose you have an
interactive program that has a ¡°main loop¡± that prompts for and executes commands.
Suppose the ¡°read¡± command reads input from a file, doing some lexical analysis and
parsing of the input while processing it. If a low-level input error is detected, it would be
useful to be able to return immediately to the ¡°main loop¡± instead of having to make each
of the lexical analysis, parsing, and processing phases all have to explicitly deal with error
situations initially detected by nested calls.

(On the other hand, if each of these phases has to do a substantial amount of cleanup
when it exits¡ªsuch as closing files, deallocating buffers or other data structures, and the
like¡ªthen it can be more appropriate to do a normal return and have each phase do its own
cleanup, because a non-local exit would bypass the intervening phases and their associated
cleanup code entirely. Alternatively, you could use a non-local exit but do the cleanup
explicitly either before or after returning to the ¡°main loop¡±.)

In some ways, a non-local exit is similar to using the ¡®return¡¯ statement to return from
a function. But while ¡®return¡¯ abandons only a single function call, transferring control
back to the point at which it was called, a non-local exit can potentially abandon many
levels of nested function calls.

You identify return points for non-local exits by calling the functionsetjmp. This
function saves information about the execution environment in which the call tosetjmp
appears in an object of typejmp_buf. Execution of the program continues normally after
the call tosetjmp, but if an exit is later made to this return point by callinglongjmpwith
the correspondingjmp_bufobject, control is transferred back to the point wheresetjmpwas
called. The return value fromsetjmpis used to distinguish between an ordinary return and
a return made by a call tolongjmp, so calls tosetjmpusually appear in an ¡®if¡¯ statement.

```
Here is how the example program described above might be set up:
```
```
#include <setjmp.h>
#include <stdlib.h>
#include <stdio.h>
```
```
jmp_buf main_loop;
```
```
void
abort_to_main_loop (int status)
{
longjmp (main_loop, status);
}
```
```
int
main (void)
```

Chapter 23: Non-Local Exits 706

```
{
while (1)
if (setjmp (main_loop))
puts ("Back at main loop....");
else
do_command ();
}
```
void
do_command (void)
{
char buffer[128];
if (fgets (buffer, 128, stdin) == NULL)
abort_to_main_loop (-1);
else
exit (EXIT_SUCCESS);
}
The functionabort_to_main_loopcauses an immediate transfer of control back to the
main loop of the program, no matter where it is called from.

The flow of control inside themainfunction may appear a little mysterious at first, but
it is actually a common idiom withsetjmp. A normal call tosetjmpreturns zero, so the
¡°else¡± clause of the conditional is executed. Ifabort_to_main_loopis called somewhere
within the execution ofdo_command, then it actually appears as if thesamecall tosetjmp
inmainwere returning a second time with a value of-1.

```
So, the general pattern for usingsetjmplooks something like:
if (setjmp (buffer))
/*Code to clean up after premature return.*/
```
```
else
/*Code to be executed normally after setting up the return point.*/
```
## 23.2 Details of Non-Local Exits...................................

Here are the details on the functions and data structures used for performing non-local
exits. These facilities are declared insetjmp.h.

jmp_buf [Data Type]
Objects of typejmp_bufhold the state information to be restored by a non-local exit.
The contents of ajmp_bufidentify a specific place to return to.

int setjmp(jmp bufstate) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
When called normally,setjmpstores information about the execution state of the
program instateand returns zero. Iflongjmpis later used to perform a non-local
exit to thisstate,setjmpreturns a nonzero value.

void longjmp (jmp bufstate, intvalue) [Function]
Preliminary:|MT-Safe |AS-Unsafe plugin corrupt lock/hurd|AC-Unsafe corrupt
lock/hurd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 23: Non-Local Exits 707

```
This function restores current execution to the state saved instate, and continues
execution from the call tosetjmpthat established that return point. Returning from
setjmpby means oflongjmpreturns thevalueargument that was passed tolongjmp,
rather than 0. (But ifvalueis given as 0 ,setjmpreturns 1 ).
```
There are a lot of obscure but important restrictions on the use ofsetjmpandlongjmp.
Most of these restrictions are present because non-local exits require a fair amount of magic
on the part of the C compiler and can interact with other parts of the language in strange
ways.

Thesetjmpfunction is actually a macro without an actual function definition, so you
shouldn¡¯t try to ¡®#undef¡¯ it or take its address. In addition, calls tosetjmpare safe in only
the following contexts:

- As the test expression of a selection or iteration statement (such as ¡®if¡¯, ¡®switch¡¯, or
    ¡®while¡¯).
- As one operand of an equality or comparison operator that appears as the test ex-
    pression of a selection or iteration statement. The other operand must be an integer
    constant expression.
- As the operand of a unary ¡®!¡¯ operator, that appears as the test expression of a selection
    or iteration statement.
- By itself as an expression statement.

Return points are valid only during the dynamic extent of the function that calledsetjmp
to establish them. If youlongjmpto a return point that was established in a function that
has already returned, unpredictable and disastrous things are likely to happen.

You should use a nonzerovalueargument tolongjmp. Whilelongjmprefuses to pass
back a zero argument as the return value fromsetjmp, this is intended as a safety net
against accidental misuse and is not really good programming style.

When you perform a non-local exit, accessible objects generally retain whatever values
they had at the timelongjmpwas called. The exception is that the values of automatic
variables local to the function containing thesetjmpcall that have been changed since the
call tosetjmpare indeterminate, unless you have declared themvolatile.

## 23.3 Non-Local Exits and Signals.................................

In BSD Unix systems,setjmpandlongjmpalso save and restore the set of blocked signals;
seeSection 24.7 [Blocking Signals], page 746. However, the POSIX.1 standard requires
setjmpandlongjmpnot to change the set of blocked signals, and provides an additional
pair of functions (sigsetjmpandsiglongjmp) to get the BSD behavior.

The behavior ofsetjmpandlongjmpin the GNU C Library is controlled by feature
test macros; seeSection 1.3.4 [Feature Test Macros], page 15. The default in the GNU C
Library is the POSIX.1 behavior rather than the BSD behavior.

```
The facilities in this section are declared in the header filesetjmp.h.
```
sigjmp_buf [Data Type]
This is similar tojmp_buf, except that it can also store state information about the
set of blocked signals.


Chapter 23: Non-Local Exits 708

int sigsetjmp(sigjmpbufstate, intsavesigs) [Function]
Preliminary: |MT-Safe | AS-Unsafe lock/hurd |AC-Unsafe lock/hurd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is similar tosetjmp. Ifsavesigsis nonzero, the set of blocked signals is saved in
stateand will be restored if asiglongjmpis later performed with thisstate.

void siglongjmp (sigjmpbufstate, intvalue) [Function]
Preliminary:|MT-Safe |AS-Unsafe plugin corrupt lock/hurd|AC-Unsafe corrupt
lock/hurd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This is similar tolongjmpexcept for the type of itsstateargument. If thesigsetjmp
call that set thisstateused a nonzerosavesigsflag,siglongjmpalso restores the set
of blocked signals.

## 23.4 Complete Context Control...................................

The Unix standard provides one more set of functions to control the execution path and these
functions are more powerful than those discussed in this chapter so far. These functions
were part of the original System V API and by this route were added to the Unix API.
Besides on branded Unix implementations these interfaces are not widely available. Not all
platforms and/or architectures the GNU C Library is available on provide this interface.
Useconfigureto detect the availability.

Similar to thejmp_bufandsigjmp_buftypes used for the variables to contain the state
of thelongjmpfunctions the interfaces of interest here have an appropriate type as well.
Objects of this type are normally much larger since more information is contained. The
type is also used in a few more places as we will see. The types and functions described in
this section are all defined and declared respectively in theucontext.hheader file.

ucontext_t [Data Type]
Theucontext_ttype is defined as a structure with at least the following elements:
ucontext_t *uc_link
This is a pointer to the next context structure which is used if the context
described in the current structure returns.
sigset_t uc_sigmask
Set of signals which are blocked when this context is used.
stack_t uc_stack
Stack used for this context. The value need not be (and normally is
not) the stack pointer. SeeSection 24.9 [Using a Separate Signal Stack],
page 755.
mcontext_t uc_mcontext
This element contains the actual state of the process. Themcontext_t
type is also defined in this header but the definition should be treated
as opaque. Any use of knowledge of the type makes applications less
portable.

Objects of this type have to be created by the user. The initialization and modification
happens through one of the following functions:


Chapter 23: Non-Local Exits 709

int getcontext(ucontextt *ucp) [Function]
Preliminary:|MT-Safe race:ucp|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thegetcontextfunction initializes the variable pointed to byucpwith the context
of the calling thread. The context contains the content of the registers, the signal
mask, and the current stack. Executing the contents would start at the point where
thegetcontextcall just returned.
Compatibility Note:Depending on the operating system, information about the cur-
rent context¡¯s stack may be in theuc_stackfield ofucp, or it may instead be in
architecture-specific subfields of theuc_mcontextfield.
The function returns 0 if successful. Otherwise it returns-1and setserrnoaccord-
ingly.

Thegetcontextfunction is similar tosetjmpbut it does not provide an indication of
whethergetcontextis returning for the first time or whether an initialized context has
just been restored. If this is necessary the user has to determine this herself. This must be
done carefully since the context contains registers which might contain register variables.
This is a good situation to define variables withvolatile.

Once the context variable is initialized it can be used as is or it can be modified using
themakecontextfunction. The latter is normally done when implementing co-routines or
similar constructs.

void makecontext (ucontext t *ucp, void(*func)(void), intargc, [Function]

.. .)
Preliminary:|MT-Safe race:ucp|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Theucpparameter passed tomakecontextshall be initialized by a call togetcontext.
The context will be modified in a way such that if the context is resumed it will start
by calling the functionfuncwhich getsargcinteger arguments passed. The integer
arguments which are to be passed should follow theargcparameter in the call to
makecontext.
Before the call to this function theuc_stackanduc_linkelement of theucpstructure
should be initialized. Theuc_stackelement describes the stack which is used for
this context. No two contexts which are used at the same time should use the same
memory region for a stack.
Theuc_linkelement of the object pointed to by ucpshould be a pointer to the
context to be executed when the functionfuncreturns or it should be a null pointer.
Seesetcontextfor more information about the exact use.

While allocating the memory for the stack one has to be careful. Most modern processors
keep track of whether a certain memory region is allowed to contain code which is executed
or not. Data segments and heap memory are normally not tagged to allow this. The result
is that programs would fail. Examples for such code include the calling sequences the GNU
C compiler generates for calls to nested functions. Safe ways to allocate stacks correctly
include using memory on the original thread¡¯s stack or explicitly allocating memory tagged
for execution using (seeSection 13.8 [Memory-mapped I/O], page 360).


Chapter 23: Non-Local Exits 710

Compatibility note: The current Unix standard is very imprecise about the way the stack
is allocated. All implementations seem to agree that theuc_stackelement must be used
but the values stored in the elements of thestack_tvalue are unclear. The GNU C Library
and most other Unix implementations require thess_spvalue of theuc_stackelement to
point to the base of the memory region allocated for the stack and the size of the memory
region is stored inss_size. There are implementations out there which requiress_spto
be set to the value the stack pointer will have (which can, depending on the direction the
stack grows, be different). This difference makes themakecontextfunction hard to use and
it requires detection of the platform at compile time.

int setcontext(const ucontextt *ucp) [Function]
Preliminary: |MT-Safe race:ucp|AS-Unsafe corrupt|AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesetcontextfunction restores the context described byucp. The context is not
modified and can be reused as often as wanted.
If the context was created bygetcontextexecution resumes with the registers filled
with the same values and the same stack as if thegetcontextcall just returned.
If the context was modified with a call tomakecontextexecution continues with the
function passed tomakecontextwhich gets the specified parameters passed. If this
function returns execution is resumed in the context which was referenced by the
uc_linkelement of the context structure passed tomakecontextat the time of the
call. Ifuc_linkwas a null pointer the application terminates normally with an exit
status value ofEXIT_SUCCESS(seeSection 25.7 [Program Termination], page 798).
If the context was created by a call to a signal handler or from any other source then
the behaviour ofsetcontextis unspecified.
Since the context contains information about the stack no two threads should use the
same context at the same time. The result in most cases would be disastrous.
Thesetcontextfunction does not return unless an error occurred in which case it
returns-1.

Thesetcontextfunction simply replaces the current context with the one described by
theucpparameter. This is often useful but there are situations where the current context
has to be preserved.

int swapcontext (ucontextt *restrictoucp, const ucontextt [Function]
*restrictucp)
Preliminary:|MT-Safe race:oucp race:ucp|AS-Unsafe corrupt|AC-Unsafe corrupt
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theswapcontextfunction is similar tosetcontextbut instead of just replacing the
current context the latter is first saved in the object pointed to byoucpas if this was
a call togetcontext. The saved context would resume after the call toswapcontext.
Once the current context is saved the context described inucpis installed and exe-
cution continues as described in this context.
Ifswapcontextsucceeds the function does not return unless the contextoucpis used
without prior modification bymakecontext. The return value in this case is 0. If the
function fails it returns-1and setserrnoaccordingly.


Chapter 23: Non-Local Exits 711

Example for SVID Context Handling

The easiest way to use the context handling functions is as a replacement forsetjmpand
longjmp. The context contains on most platforms more information which may lead to
fewer surprises but this also means using these functions is more expensive (besides being
less portable).
int
random_search (int n, int (*fp) (int, ucontext_t *))
{
volatile int cnt = 0;
ucontext_t uc;

```
/*Safe current context. */
if (getcontext (&uc) < 0)
return -1;
```
```
/*If we have not triedntimes try again. */
if (cnt++ < n)
/*Call the function with a new random number
and the context. */
if (fp (rand (), &uc) != 0)
/*We found what we were looking for. */
return 1;
```
/*Not found. */
return 0;
}
Using contexts in such a way enables emulating exception handling. The search functions
passed in thefpparameter could be very large, nested, and complex which would make it
complicated (or at least would require a lot of code) to leave the function with an error
value which has to be passed down to the caller. By using the context it is possible to leave
the search function in one step and allow restarting the search which also has the nice side
effect that it can be significantly faster.

Something which is harder to implement withsetjmpandlongjmpis to switch tem-
porarily to a different execution path and then resume where execution was stopped.

```
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <ucontext.h>
#include <sys/time.h>
```
```
/*Set by the signal handler.*/
static volatile int expired;
```
```
/*The contexts.*/
static ucontext_t uc[3];
```
```
/*We do only a certain number of switches.*/
static int switches;
```
```
/*This is the function doing the work. It is just a
skeleton, real code has to be filled in.*/
static void
```

Chapter 23: Non-Local Exits 712

```
f (int n)
{
int m = 0;
while (1)
{
/*This is where the work would be done.*/
if (++m % 100 == 0)
{
putchar ('.');
fflush (stdout);
}
```
```
/*Regularly theexpirevariable must be checked.*/
if (expired)
{
/*We do not want the program to run forever.*/
if (++switches == 20)
return;
```
```
printf ("\nswitching from %d to %d\n", n, 3 - n);
expired = 0;
/*Switch to the other context, saving the current one.*/
swapcontext (&uc[n], &uc[3 - n]);
}
}
}
```
```
/*This is the signal handler which simply set the variable.*/
void
handler (int signal)
{
expired = 1;
}
```
```
int
main (void)
{
struct sigaction sa;
struct itimerval it;
char st1[8192];
char st2[8192];
```
```
/*Initialize the data structures for the interval timer.*/
sa.sa_flags = SA_RESTART;
sigfillset (&sa.sa_mask);
sa.sa_handler = handler;
it.it_interval.tv_sec = 0;
it.it_interval.tv_usec = 1;
it.it_value = it.it_interval;
```
```
/*Install the timer and get the context we can manipulate.*/
if (sigaction (SIGPROF, &sa, NULL) < 0
|| setitimer (ITIMER_PROF, &it, NULL) < 0
|| getcontext (&uc[1]) == -1
|| getcontext (&uc[2]) == -1)
abort ();
```

Chapter 23: Non-Local Exits 713

```
/*Create a context with a separate stack which causes the
functionfto be call with the parameter 1.
Note that theuc_linkpoints to the main context
which will cause the program to terminate once the function
return.*/
uc[1].uc_link = &uc[0];
uc[1].uc_stack.ss_sp = st1;
uc[1].uc_stack.ss_size = sizeof st1;
makecontext (&uc[1], (void (*) (void)) f, 1, 1);
```
```
/*Similarly, but 2 is passed as the parameter tof.*/
uc[2].uc_link = &uc[0];
uc[2].uc_stack.ss_sp = st2;
uc[2].uc_stack.ss_size = sizeof st2;
makecontext (&uc[2], (void (*) (void)) f, 1, 2);
```
```
/*Start running.*/
swapcontext (&uc[0], &uc[1]);
putchar ('\n');
```
return 0;
}
This an example how the context functions can be used to implement co-routines or coop-
erative multi-threading. All that has to be done is to call every once in a whileswapcontext
to continue running a different context. It is not recommended to do the context switching
from the signal handler directly since leaving the signal handler viasetcontextif the signal
was delivered during code that was not asynchronous signal safe could lead to problems.
Setting a variable in the signal handler and checking it in the body of the functions which
are executed is a safer approach. Sinceswapcontextis saving the current context it is
possible to have multiple different scheduling points in the code. Execution will always
resume where it was left.


### 714

## 24 Signal Handling.....................................

Asignal is a software interrupt delivered to a process. The operating system uses sig-
nals to report exceptional situations to an executing program. Some signals report errors
such as references to invalid memory addresses; others report asynchronous events, such as
disconnection of a phone line.

The GNU C Library defines a variety of signal types, each for a particular kind of event.
Some kinds of events make it inadvisable or impossible for the program to proceed as usual,
and the corresponding signals normally abort the program. Other kinds of signals that
report harmless events are ignored by default.

If you anticipate an event that causes signals, you can define a handler function and tell
the operating system to run it when that particular type of signal arrives.

Finally, one process can send a signal to another process; this allows a parent process to
abort a child, or two related processes to communicate and synchronize.

## 24.1 Basic Concepts of Signals....................................

This section explains basic concepts of how signals are generated, what happens after a
signal is delivered, and how programs can handle signals.

## 24.1.1 Some Kinds of Signals..................................

A signal reports the occurrence of an exceptional event. These are some of the events that
can cause (orgenerate, orraise) a signal:

- A program error such as dividing by zero or issuing an address outside the valid range.
- A user request to interrupt or terminate the program. Most environments are set up to
    let a user suspend the program by typingC-z, or terminate it withC-c. Whatever key
    sequence is used, the operating system sends the proper signal to interrupt the process.
- The termination of a child process.
- Expiration of a timer or alarm.
- A call tokillorraiseby the same process.
- A call tokillfrom another process. Signals are a limited but useful form of interprocess
    communication.
- An attempt to perform an I/O operation that cannot be done. Examples are reading
    from a pipe that has no writer (seeChapter 15 [Pipes and FIFOs], page 450), and
    reading or writing to a terminal in certain situations (seeChapter 28 [Job Control],
    page 817).

Each of these kinds of events (excepting explicit calls tokillandraise) generates its
own particular kind of signal. The various kinds of signals are listed and described in detail
inSection 24.2 [Standard Signals], page 716.

## 24.1.2 Concepts of Signal Generation..........................

In general, the events that generate signals fall into three major categories: errors, external
events, and explicit requests.


Chapter 24: Signal Handling 715

An error means that a program has done something invalid and cannot continue exe-
cution. But not all kinds of errors generate signals¡ªin fact, most do not. For example,
opening a nonexistent file is an error, but it does not raise a signal; instead,openreturns-1.
In general, errors that are necessarily associated with certain library functions are reported
by returning a value that indicates an error. The errors which raise signals are those which
can happen anywhere in the program, not just in library calls. These include division by
zero and invalid memory addresses.

An external event generally has to do with I/O or other processes. These include the
arrival of input, the expiration of a timer, and the termination of a child process.

An explicit request means the use of a library function such askillwhose purpose is
specifically to generate a signal.

Signals may be generatedsynchronouslyorasynchronously. A synchronous signal per-
tains to a specific action in the program, and is delivered (unless blocked) during that
action. Most errors generate signals synchronously, and so do explicit requests by a process
to generate a signal for that same process. On some machines, certain kinds of hardware
errors (usually floating-point exceptions) are not reported completely synchronously, but
may arrive a few instructions later.

Asynchronous signals are generated by events outside the control of the process that
receives them. These signals arrive at unpredictable times during execution. External
events generate signals asynchronously, and so do explicit requests that apply to some
other process.

A given type of signal is either typically synchronous or typically asynchronous. For
example, signals for errors are typically synchronous because errors generate signals syn-
chronously. But any type of signal can be generated synchronously or asynchronously with
an explicit request.

## 24.1.3 How Signals Are Delivered..............................

When a signal is generated, it becomespending. Normally it remains pending for just a
short period of time and then isdelivered to the process that was signaled. However, if
that kind of signal is currentlyblocked, it may remain pending indefinitely¡ªuntil signals of
that kind areunblocked. Once unblocked, it will be delivered immediately. SeeSection 24.7
[Blocking Signals], page 746.

When the signal is delivered, whether right away or after a long delay, thespecified
actionfor that signal is taken. For certain signals, such asSIGKILL andSIGSTOP, the
action is fixed, but for most signals, the program has a choice: ignore the signal, specify a
handler function, or accept thedefault actionfor that kind of signal. The program specifies
its choice using functions such assignalorsigaction(seeSection 24.3 [Specifying Signal
Actions], page 725). We sometimes say that a handlercatchesthe signal. While the handler
is running, that particular signal is normally blocked.

If the specified action for a kind of signal is to ignore it, then any such signal which
is generated is discarded immediately. This happens even if the signal is also blocked at
the time. A signal discarded in this way will never be delivered, not even if the program
subsequently specifies a different action for that kind of signal and then unblocks it.

If a signal arrives which the program has neither handled nor ignored, itsdefault ac-
tiontakes place. Each kind of signal has its own default action, documented below (see


Chapter 24: Signal Handling 716

Section 24.2 [Standard Signals], page 716). For most kinds of signals, the default action is
to terminate the process. For certain kinds of signals that represent ¡°harmless¡± events, the
default action is to do nothing.

When a signal terminates a process, its parent process can determine the cause of termi-
nation by examining the termination status code reported by thewaitorwaitpidfunctions.
(This is discussed in more detail inSection 26.6 [Process Completion], page 809.) The in-
formation it can get includes the fact that termination was due to a signal and the kind
of signal involved. If a program you run from a shell is terminated by a signal, the shell
typically prints some kind of error message.

The signals that normally represent program errors have a special property: when one of
these signals terminates the process, it also writes acore dump filewhich records the state
of the process at the time of termination. You can examine the core dump with a debugger
to investigate what caused the error.

If you raise a ¡°program error¡± signal by explicit request, and this terminates the process,
it makes a core dump file just as if the signal had been due directly to an error.

## 24.2 Standard Signals............................................

This section lists the names for various standard kinds of signals and describes what kind
of event they mean. Each signal name is a macro which stands for a positive integer¡ª
thesignal numberfor that kind of signal. Your programs should never make assumptions
about the numeric code for a particular kind of signal, but rather refer to them always by
the names defined here. This is because the number for a given kind of signal can vary from
system to system, but the meanings of the names are standardized and fairly uniform.

```
The signal names are defined in the header filesignal.h.
```
int NSIG [Macro]
The value of this symbolic constant is the total number of signals defined. Since the
signal numbers are allocated consecutively,NSIGis also one greater than the largest
defined signal number.

## 24.2.1 Program Error Signals..................................

The following signals are generated when a serious program error is detected by the op-
erating system or the computer itself. In general, all of these signals are indications that
your program is seriously broken in some way, and there¡¯s usually no way to continue the
computation which encountered the error.

Some programs handle program error signals in order to tidy up before terminating; for
example, programs that turn off echoing of terminal input should handle program error
signals in order to turn echoing back on. The handler should end by specifying the default
action for the signal that happened and then reraising it; this will cause the program to
terminate with that signal, as if it had not had a handler. (SeeSection 24.4.2 [Handlers
That Terminate the Process], page 732.)

Termination is the sensible ultimate outcome from a program error in most programs.
However, programming systems such as Lisp that can load compiled user programs might
need to keep executing even if a user program incurs an error. These programs have handlers
which uselongjmpto return control to the command level.


Chapter 24: Signal Handling 717

The default action for all of these signals is to cause the process to terminate. If you block
or ignore these signals or establish handlers for them that return normally, your program
will probably break horribly when such signals happen, unless they are generated byraise
orkillinstead of a real error.

When one of these program error signals terminates a process, it also writes acore dump
filewhich records the state of the process at the time of termination. The core dump file is
namedcoreand is written in whichever directory is current in the process at the time. (On
GNU/Hurd systems, you can specify the file name for core dumps with the environment
variableCOREFILE.) The purpose of core dump files is so that you can examine them with
a debugger to investigate what caused the error.

int SIGFPE [Macro]
TheSIGFPEsignal reports a fatal arithmetic error. Although the name is derived from
¡°floating-point exception¡±, this signal actually covers all arithmetic errors, including
division by zero and overflow. If a program stores integer data in a location which
is then used in a floating-point operation, this often causes an ¡°invalid operation¡±
exception, because the processor cannot recognize the data as a floating-point number.

```
Actual floating-point exceptions are a complicated subject because there are many
types of exceptions with subtly different meanings, and theSIGFPE signal doesn¡¯t
distinguish between them. TheIEEE Standard for Binary Floating-Point Arithmetic
(ANSI/IEEE Std 754-1985 and ANSI/IEEE Std 854-1987)defines various floating-
point exceptions and requires conforming computer systems to report their occur-
rences. However, this standard does not specify how the exceptions are reported, or
what kinds of handling and control the operating system can offer to the programmer.
```
BSD systems provide theSIGFPEhandler with an extra argument that distinguishes var-
ious causes of the exception. In order to access this argument, you must define the handler
to accept two arguments, which means you must cast it to a one-argument function type
in order to establish the handler. The GNU C Library does provide this extra argument,
but the value is meaningful only on operating systems that provide the information (BSD
systems and GNU systems).

FPE_INTOVF_TRAP
Integer overflow (impossible in a C program unless you enable overflow trapping
in a hardware-specific fashion).

FPE_INTDIV_TRAP
Integer division by zero.

FPE_SUBRNG_TRAP
Subscript-range (something that C programs never check for).

FPE_FLTOVF_TRAP
Floating overflow trap.

FPE_FLTDIV_TRAP
Floating/decimal division by zero.


Chapter 24: Signal Handling 718

### FPE_FLTUND_TRAP

```
Floating underflow trap. (Trapping on floating underflow is not normally en-
abled.)
```
FPE_DECOVF_TRAP
Decimal overflow trap. (Only a few machines have decimal arithmetic and C
never uses it.)

int SIGILL [Macro]
The name of this signal is derived from ¡°illegal instruction¡±; it usually means your
program is trying to execute garbage or a privileged instruction. Since the C compiler
generates only valid instructions,SIGILLtypically indicates that the executable file
is corrupted, or that you are trying to execute data. Some common ways of getting
into the latter situation are by passing an invalid object where a pointer to a function
was expected, or by writing past the end of an automatic array (or similar problems
with pointers to automatic variables) and corrupting other data on the stack such as
the return address of a stack frame.
SIGILLcan also be generated when the stack overflows, or when the system has
trouble running the handler for a signal.

int SIGSEGV [Macro]
This signal is generated when a program tries to read or write outside the memory that
is allocated for it, or to write memory that can only be read. (Actually, the signals
only occur when the program goes far enough outside to be detected by the system¡¯s
memory protection mechanism.) The name is an abbreviation for ¡°segmentation
violation¡±.
Common ways of getting aSIGSEGVcondition include dereferencing a null or unini-
tialized pointer, or when you use a pointer to step through an array, but fail to check
for the end of the array. It varies among systems whether dereferencing a null pointer
generatesSIGSEGVorSIGBUS.

int SIGBUS [Macro]
This signal is generated when an invalid pointer is dereferenced. LikeSIGSEGV, this
signal is typically the result of dereferencing an uninitialized pointer. The difference
between the two is thatSIGSEGVindicates an invalid access to valid memory, while
SIGBUSindicates an access to an invalid address. In particular,SIGBUSsignals often
result from dereferencing a misaligned pointer, such as referring to a four-word integer
at an address not divisible by four. (Each kind of computer has its own requirements
for address alignment.)
The name of this signal is an abbreviation for ¡°bus error¡±.

int SIGABRT [Macro]
This signal indicates an error detected by the program itself and reported by calling
abort. SeeSection 25.7.4 [Aborting a Program], page 801.

int SIGIOT [Macro]
Generated by the PDP-11 ¡°iot¡± instruction. On most machines, this is just another
name forSIGABRT.


Chapter 24: Signal Handling 719

int SIGTRAP [Macro]
Generated by the machine¡¯s breakpoint instruction, and possibly other trap instruc-
tions. This signal is used by debuggers. Your program will probably only seeSIGTRAP
if it is somehow executing bad instructions.

int SIGEMT [Macro]
Emulator trap; this results from certain unimplemented instructions which might be
emulated in software, or the operating system¡¯s failure to properly emulate them.

int SIGSYS [Macro]
Bad system call; that is to say, the instruction to trap to the operating system was
executed, but the code number for the system call to perform was invalid.

## 24.2.2 Termination Signals....................................

These signals are all used to tell a process to terminate, in one way or another. They have
different names because they¡¯re used for slightly different purposes, and programs might
want to handle them differently.

The reason for handling these signals is usually so your program can tidy up as appro-
priate before actually terminating. For example, you might want to save state information,
delete temporary files, or restore the previous terminal modes. Such a handler should end
by specifying the default action for the signal that happened and then reraising it; this
will cause the program to terminate with that signal, as if it had not had a handler. (See
Section 24.4.2 [Handlers That Terminate the Process], page 732.)

```
The (obvious) default action for all of these signals is to cause the process to terminate.
```
int SIGTERM [Macro]
TheSIGTERMsignal is a generic signal used to cause program termination. Unlike
SIGKILL, this signal can be blocked, handled, and ignored. It is the normal way to
politely ask a program to terminate.
The shell commandkillgeneratesSIGTERMby default.

int SIGINT [Macro]
TheSIGINT(¡°program interrupt¡±) signal is sent when the user types the INTR charac-
ter (normallyC-c). SeeSection 17.4.9 [Special Characters], page 516, for information
about terminal driver support forC-c.

int SIGQUIT [Macro]
TheSIGQUITsignal is similar toSIGINT, except that it¡¯s controlled by a different key¡ª
the QUIT character, usuallyC-\¡ªand produces a core dump when it terminates the
process, just like a program error signal. You can think of this as a program error
condition ¡°detected¡± by the user.
SeeSection 24.2.1 [Program Error Signals], page 716, for information about core
dumps. SeeSection 17.4.9 [Special Characters], page 516, for information about
terminal driver support.
Certain kinds of cleanups are best omitted in handlingSIGQUIT. For example, if the
program creates temporary files, it should handle the other termination requests by
deleting the temporary files. But it is better forSIGQUITnot to delete them, so that
the user can examine them in conjunction with the core dump.


Chapter 24: Signal Handling 720

int SIGKILL [Macro]
TheSIGKILLsignal is used to cause immediate program termination. It cannot be
handled or ignored, and is therefore always fatal. It is also not possible to block this
signal.
This signal is usually generated only by explicit request. Since it cannot be handled,
you should generate it only as a last resort, after first trying a less drastic method such
asC-corSIGTERM. If a process does not respond to any other termination signals,
sending it aSIGKILLsignal will almost always cause it to go away.
In fact, ifSIGKILLfails to terminate a process, that by itself constitutes an operating
system bug which you should report.
The system will generateSIGKILLfor a process itself under some unusual conditions
where the program cannot possibly continue to run (even to run a signal handler).

int SIGHUP [Macro]
TheSIGHUP(¡°hang-up¡±) signal is used to report that the user¡¯s terminal is discon-
nected, perhaps because a network or telephone connection was broken. For more
information about this, seeSection 17.4.6 [Control Modes], page 511.
This signal is also used to report the termination of the controlling process on a
terminal to jobs associated with that session; this termination effectively disconnects
all processes in the session from the controlling terminal. For more information, see
Section 25.7.5 [Termination Internals], page 801.

## 24.2.3 Alarm Signals..........................................

These signals are used to indicate the expiration of timers. SeeSection 21.6 [Setting an
Alarm], page 679, for information about functions that cause these signals to be sent.

The default behavior for these signals is to cause program termination. This default is
rarely useful, but no other default would be useful; most of the ways of using these signals
would require handler functions in any case.

int SIGALRM [Macro]
This signal typically indicates expiration of a timer that measures real or clock time.
It is used by thealarmfunction, for example.

int SIGVTALRM [Macro]
This signal typically indicates expiration of a timer that measures CPU time used by
the current process. The name is an abbreviation for ¡°virtual time alarm¡±.

int SIGPROF [Macro]
This signal typically indicates expiration of a timer that measures both CPU time
used by the current process, and CPU time expended on behalf of the process by the
system. Such a timer is used to implement code profiling facilities, hence the name
of this signal.

## 24.2.4 Asynchronous I/O Signals..............................

The signals listed in this section are used in conjunction with asynchronous I/O facilities.
You have to take explicit action by callingfcntlto enable a particular file descriptor to
generate these signals (seeSection 13.19 [Interrupt-Driven Input], page 400). The default
action for these signals is to ignore them.


Chapter 24: Signal Handling 721

int SIGIO [Macro]
This signal is sent when a file descriptor is ready to perform input or output.
On most operating systems, terminals and sockets are the only kinds of files that can
generateSIGIO; other kinds, including ordinary files, never generateSIGIOeven if
you ask them to.
On GNU systemsSIGIOwill always be generated properly if you successfully set
asynchronous mode withfcntl.

int SIGURG [Macro]
This signal is sent when ¡°urgent¡± or out-of-band data arrives on a socket. See
Section 16.9.8 [Out-of-Band Data], page 491.

int SIGPOLL [Macro]
This is a System V signal name, more or less similar toSIGIO. It is defined only for
compatibility.

## 24.2.5 Job Control Signals.....................................

These signals are used to support job control. If your system doesn¡¯t support job control,
then these macros are defined but the signals themselves can¡¯t be raised or handled.

You should generally leave these signals alone unless you really understand how job
control works. SeeChapter 28 [Job Control], page 817.

int SIGCHLD [Macro]
This signal is sent to a parent process whenever one of its child processes terminates
or stops.
The default action for this signal is to ignore it. If you establish a handler for this
signal while there are child processes that have terminated but not reported their
status viawaitorwaitpid(seeSection 26.6 [Process Completion], page 809), whether
your new handler applies to those processes or not depends on the particular operating
system.

int SIGCLD [Macro]
This is an obsolete name forSIGCHLD.

int SIGCONT [Macro]
You can send aSIGCONTsignal to a process to make it continue. This signal is
special¡ªit always makes the process continue if it is stopped, before the signal is
delivered. The default behavior is to do nothing else. You cannot block this signal.
You can set a handler, butSIGCONTalways makes the process continue regardless.
Most programs have no reason to handleSIGCONT; they simply resume execution
without realizing they were ever stopped. You can use a handler forSIGCONTto make
a program do something special when it is stopped and continued¡ªfor example, to
reprint a prompt when it is suspended while waiting for input.

int SIGSTOP [Macro]
TheSIGSTOPsignal stops the process. It cannot be handled, ignored, or blocked.


Chapter 24: Signal Handling 722

int SIGTSTP [Macro]
TheSIGTSTPsignal is an interactive stop signal. UnlikeSIGSTOP, this signal can be
handled and ignored.
Your program should handle this signal if you have a special need to leave files or
system tables in a secure state when a process is stopped. For example, programs
that turn off echoing should handleSIGTSTPso they can turn echoing back on before
stopping.
This signal is generated when the user types the SUSP character (normallyC-z). For
more information about terminal driver support, seeSection 17.4.9 [Special Charac-
ters], page 516.

int SIGTTIN [Macro]
A process cannot read from the user¡¯s terminal while it is running as a background
job. When any process in a background job tries to read from the terminal, all of the
processes in the job are sent aSIGTTINsignal. The default action for this signal is
to stop the process. For more information about how this interacts with the terminal
driver, seeSection 28.3 [Access to the Controlling Terminal], page 818.

int SIGTTOU [Macro]
This is similar toSIGTTIN, but is generated when a process in a background job
attempts to write to the terminal or set its modes. Again, the default action is to
stop the process. SIGTTOUis only generated for an attempt to write to the terminal
if theTOSTOPoutput mode is set; seeSection 17.4.5 [Output Modes], page 510.

While a process is stopped, no more signals can be delivered to it until it is continued,
exceptSIGKILLsignals and (obviously)SIGCONTsignals. The signals are marked as pending,
but not delivered until the process is continued. TheSIGKILLsignal always causes termina-
tion of the process and can¡¯t be blocked, handled or ignored. You can ignoreSIGCONT, but it
always causes the process to be continued anyway if it is stopped. Sending aSIGCONTsignal
to a process causes any pending stop signals for that process to be discarded. Likewise, any
pendingSIGCONTsignals for a process are discarded when it receives a stop signal.

When a process in an orphaned process group (seeSection 28.4 [Orphaned Process
Groups], page 819) receives aSIGTSTP,SIGTTIN, orSIGTTOUsignal and does not handle
it, the process does not stop. Stopping the process would probably not be very useful,
since there is no shell program that will notice it stop and allow the user to continue it.
What happens instead depends on the operating system you are using. Some systems
may do nothing; others may deliver another signal instead, such asSIGKILLorSIGHUP.
On GNU/Hurd systems, the process dies withSIGKILL; this avoids the problem of many
stopped, orphaned processes lying around the system.

## 24.2.6 Operation Error Signals................................

These signals are used to report various errors generated by an operation done by the
program. They do not necessarily indicate a programming error in the program, but an
error that prevents an operating system call from completing. The default action for all of
them is to cause the process to terminate.


Chapter 24: Signal Handling 723

int SIGPIPE [Macro]
Broken pipe. If you use pipes or FIFOs, you have to design your application so that
one process opens the pipe for reading before another starts writing. If the reading
process never starts, or terminates unexpectedly, writing to the pipe or FIFO raises
aSIGPIPEsignal. IfSIGPIPEis blocked, handled or ignored, the offending call fails
withEPIPEinstead.
Pipes and FIFO special files are discussed in more detail inChapter 15 [Pipes and
FIFOs], page 450.
Another cause ofSIGPIPEis when you try to output to a socket that isn¡¯t connected.
SeeSection 16.9.5.1 [Sending Data], page 486.

int SIGLOST [Macro]
Resource lost. This signal is generated when you have an advisory lock on an NFS
file, and the NFS server reboots and forgets about your lock.
On GNU/Hurd systems,SIGLOSTis generated when any server program dies unex-
pectedly. It is usually fine to ignore the signal; whatever call was made to the server
that died just returns an error.

int SIGXCPU [Macro]
CPU time limit exceeded. This signal is generated when the process exceeds its soft
resource limit on CPU time. SeeSection 22.2 [Limiting Resource Usage], page 685.

int SIGXFSZ [Macro]
File size limit exceeded. This signal is generated when the process attempts to extend
a file so it exceeds the process¡¯s soft resource limit on file size. SeeSection 22.2
[Limiting Resource Usage], page 685.

## 24.2.7 Miscellaneous Signals...................................

These signals are used for various other purposes. In general, they will not affect your
program unless it explicitly uses them for something.

int SIGUSR1 [Macro]
int SIGUSR2 [Macro]
TheSIGUSR1andSIGUSR2signals are set aside for you to use any way you want.
They¡¯re useful for simple interprocess communication, if you write a signal handler
for them in the program that receives the signal.
There is an example showing the use ofSIGUSR1andSIGUSR2inSection 24.6.2 [Sig-
naling Another Process], page 743.
The default action is to terminate the process.

int SIGWINCH [Macro]
Window size change. This is generated on some systems (including GNU) when the
terminal driver¡¯s record of the number of rows and columns on the screen is changed.
The default action is to ignore it.
If a program does full-screen display, it should handleSIGWINCH. When the signal
arrives, it should fetch the new screen size and reformat its display accordingly.


Chapter 24: Signal Handling 724

int SIGINFO [Macro]
Information request. On 4.4 BSD and GNU/Hurd systems, this signal is sent to all
the processes in the foreground process group of the controlling terminal when the
user types the STATUS character in canonical mode; seeSection 17.4.9.2 [Characters
that Cause Signals], page 518.
If the process is the leader of the process group, the default action is to print some
status information about the system and what the process is doing. Otherwise the
default is to do nothing.

## 24.2.8 Signal Messages........................................

We mentioned above that the shell prints a message describing the signal that terminated
a child process. The clean way to print a message describing a signal is to use the functions
strsignalandpsignal. These functions use a signal number to specify which kind of
signal to describe. The signal number may come from the termination status of a child
process (seeSection 26.6 [Process Completion], page 809) or it may come from a signal
handler in the same process.

char * strsignal (intsignum) [Function]
Preliminary:|MT-Unsafe race:strsignal locale|AS-Unsafe init i18n corrupt heap|
AC-Unsafe init corrupt mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns a pointer to a statically-allocated string containing a message
describing the signalsignum. You should not modify the contents of this string; and,
since it can be rewritten on subsequent calls, you should save a copy of it if you need
to reference it later.
This function is a GNU extension, declared in the header filestring.h.

void psignal (intsignum, const char *message) [Function]
Preliminary: |MT-Safe locale |AS-Unsafe corrupt i18n heap|AC-Unsafe lock
corrupt mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function prints a message describing the signalsignumto the standard error
output streamstderr; seeSection 12.2 [Standard Streams], page 266.
If you callpsignalwith amessagethat is either a null pointer or an empty string,
psignaljust prints the message corresponding tosignum, adding a trailing newline.
If you supply a non-nullmessageargument, thenpsignalprefixes its output with
this string. It adds a colon and a space character to separate themessagefrom the
string corresponding tosignum.
This function is a BSD feature, declared in the header filesignal.h.

const char * sigdescr_np(intsignum) [Function]
|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns the message describing the signalsignumorNULLfor invalid
signal number (e.g"Hangup"forSIGHUP). Different thanstrsignalthe returned
description is not translated. The message points to a static storage whose lifetime
is the whole lifetime of the program.
This function is a GNU extension, declared in the header filestring.h.


Chapter 24: Signal Handling 725

const char * sigabbrev_np(intsignum) [Function]
|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns the abbreviation describing the signalsignumorNULLfor invalid
signal number. The message points to a static storage whose lifetime is the whole
lifetime of the program.
This function is a GNU extension, declared in the header filestring.h.

## 24.3 Specifying Signal Actions....................................

The simplest way to change the action for a signal is to use thesignalfunction. You can
specify a built-in action (such as to ignore the signal), or you canestablish a handler.

The GNU C Library also implements the more versatilesigactionfacility. This section
describes both facilities and gives suggestions on which to use when.

## 24.3.1 Basic Signal Handling..................................

Thesignalfunction provides a simple interface for establishing an action for a particular
signal. The function and associated macros are declared in the header filesignal.h.

sighandler_t [Data Type]
This is the type of signal handler functions. Signal handlers take one integer argument
specifying the signal number, and have return typevoid. So, you should define
handler functions like this:
voidhandler(int signum) { ... }
The namesighandler_tfor this data type is a GNU extension.

sighandler_t signal (intsignum, sighandlertaction) [Function]
Preliminary:|MT-Safe sigintr|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thesignalfunction establishesactionas the action for the signalsignum.
The first argument,signum, identifies the signal whose behavior you want to control,
and should be a signal number. The proper way to specify a signal number is with one
of the symbolic signal names (seeSection 24.2 [Standard Signals], page 716)¡ªdon¡¯t
use an explicit number, because the numerical code for a given kind of signal may
vary from operating system to operating system.
The second argument,action, specifies the action to use for the signalsignum. This
can be one of the following:

```
SIG_DFL SIG_DFLspecifies the default action for the particular signal. The default
actions for various kinds of signals are stated inSection 24.2 [Standard
Signals], page 716.
SIG_IGN SIG_IGNspecifies that the signal should be ignored.
Your program generally should not ignore signals that represent serious
events or that are normally used to request termination. You cannot ig-
nore theSIGKILLorSIGSTOPsignals at all. You can ignore program error
signals likeSIGSEGV, but ignoring the error won¡¯t enable the program to
```

Chapter 24: Signal Handling 726

```
continue executing meaningfully. Ignoring user requests such asSIGINT,
SIGQUIT, andSIGTSTPis unfriendly.
When you do not wish signals to be delivered during a certain part of
the program, the thing to do is to block them, not ignore them. See
Section 24.7 [Blocking Signals], page 746.
```
```
handler Supply the address of a handler function in your program, to specify
running this handler as the way to deliver the signal.
For more information about defining signal handler functions, see
Section 24.4 [Defining Signal Handlers], page 731.
If you set the action for a signal toSIG_IGN, or if you set it toSIG_DFLand the default
action is to ignore that signal, then any pending signals of that type are discarded
(even if they are blocked). Discarding the pending signals means that they will never
be delivered, not even if you subsequently specify another action and unblock this
kind of signal.
Thesignalfunction returns the action that was previously in effect for the specified
signum. You can save this value and restore it later by callingsignalagain.
Ifsignalcan¡¯t honor the request, it returnsSIG_ERRinstead. The followingerrno
error conditions are defined for this function:
EINVAL You specified an invalidsignum; or you tried to ignore or provide a handler
forSIGKILLorSIGSTOP.
```
Compatibility Note:A problem encountered when working with thesignalfunction is
that it has different semantics on BSD and SVID systems. The difference is that on SVID
systems the signal handler is deinstalled after signal delivery. On BSD systems the handler
must be explicitly deinstalled. In the GNU C Library we use the BSD version by default.
To use the SVID version you can either use the functionsysv_signal(see below) or use
the_XOPEN_SOURCEfeature select macro (seeSection 1.3.4 [Feature Test Macros], page 15).
In general, use of these functions should be avoided because of compatibility problems. It
is better to usesigactionif it is available since the results are much more reliable.

Here is a simple example of setting up a handler to delete temporary files when certain
fatal signals happen:
#include <signal.h>

```
void
termination_handler (int signum)
{
struct temp_file *p;
```
```
for (p = temp_file_list; p; p = p->next)
unlink (p->name);
}
```
```
int
main (void)
{
...
if (signal (SIGINT, termination_handler) == SIG_IGN)
signal (SIGINT, SIG_IGN);
```

Chapter 24: Signal Handling 727

```
if (signal (SIGHUP, termination_handler) == SIG_IGN)
signal (SIGHUP, SIG_IGN);
if (signal (SIGTERM, termination_handler) == SIG_IGN)
signal (SIGTERM, SIG_IGN);
```
```
}
```
Note that if a given signal was previously set to be ignored, this code avoids altering that
setting. This is because non-job-control shells often ignore certain signals when starting
children, and it is important for the children to respect this.

We do not handleSIGQUITor the program error signals in this example because these
are designed to provide information for debugging (a core dump), and the temporary files
may give useful information.

sighandler_t sysv_signal(intsignum, sighandlertaction) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesysv_signalimplements the behavior of the standardsignalfunction as found
on SVID systems. The difference to BSD systems is that the handler is deinstalled
after a delivery of a signal.
Compatibility Note:As said above forsignal, this function should be avoided when
possible.sigactionis the preferred method.

sighandler_t ssignal(intsignum, sighandlertaction) [Function]
Preliminary:|MT-Safe sigintr|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thessignalfunction does the same thing assignal; it is provided only for compat-
ibility with SVID.

sighandler_t SIG_ERR [Macro]
The value of this macro is used as the return value fromsignalto indicate an error.

## 24.3.2 Advanced Signal Handling..............................

Thesigactionfunction has the same basic effect assignal: to specify how a signal should
be handled by the process. However,sigactionoffers more control, at the expense of more
complexity. In particular,sigactionallows you to specify additional flags to control when
the signal is generated and how the handler is invoked.

```
Thesigactionfunction is declared insignal.h.
```
struct sigaction [Data Type]
Structures of typestruct sigactionare used in thesigactionfunction to specify
all the information about how to handle a particular signal. This structure contains
at least the following members:

```
sighandler_t sa_handler
This is used in the same way as the actionargument to the signal
function. The value can beSIG_DFL,SIG_IGN, or a function pointer. See
Section 24.3.1 [Basic Signal Handling], page 725.
```

Chapter 24: Signal Handling 728

```
sigset_t sa_mask
This specifies a set of signals to be blocked while the handler runs.
Blocking is explained inSection 24.7.5 [Blocking Signals for a Handler],
page 750. Note that the signal that was delivered is automatically blocked
by default before its handler is started; this is true regardless of the value
insa_mask. If you want that signal not to be blocked within its handler,
you must write code in the handler to unblock it.
```
```
int sa_flags
This specifies various flags which can affect the behavior of the signal.
These are described in more detail inSection 24.3.5 [Flags forsigaction],
page 730.
```
int sigaction(intsignum, const struct sigaction *restrictaction, [Function]
struct sigaction *restrictold-action)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theactionargument is used to set up a new action for the signalsignum, while
theold-actionargument is used to return information about the action previously
associated with this signal. (In other words,old-actionhas the same purpose as the
signalfunction¡¯s return value¡ªyou can check to see what the old action in effect for
the signal was, and restore it later if you want.)
Eitheractionorold-actioncan be a null pointer. Ifold-actionis a null pointer, this
simply suppresses the return of information about the old action. Ifactionis a null
pointer, the action associated with the signalsignumis unchanged; this allows you to
inquire about how a signal is being handled without changing that handling.
The return value from sigactionis zero if it succeeds, and -1 on failure. The
followingerrnoerror conditions are defined for this function:

```
EINVAL Thesignumargument is not valid, or you are trying to trap or ignore
SIGKILLorSIGSTOP.
```
## 24.3.3 Interaction ofsignalandsigaction...................

It¡¯s possible to use both thesignalandsigactionfunctions within a single program, but
you have to be careful because they can interact in slightly strange ways.

Thesigactionfunction specifies more information than thesignalfunction, so the re-
turn value fromsignalcannot express the full range ofsigactionpossibilities. Therefore,
if you usesignalto save and later reestablish an action, it may not be able to reestablish
properly a handler that was established withsigaction.

To avoid having problems as a result, always usesigactionto save and restore a handler
if your program usessigactionat all. Sincesigactionis more general, it can properly
save and reestablish any action, regardless of whether it was established originally with
signalorsigaction.

On some systems if you establish an action with signaland then examine it with
sigaction, the handler address that you get may not be the same as what you specified
withsignal. It may not even be suitable for use as an action argument withsignal. But


Chapter 24: Signal Handling 729

you can rely on using it as an argument tosigaction. This problem never happens on
GNU systems.

So, you¡¯re better off using one or the other of the mechanisms consistently within a single
program.

Portability Note: The basicsignalfunction is a feature of ISO C, whilesigaction
is part of the POSIX.1 standard. If you are concerned about portability to non-POSIX
systems, then you should use thesignalfunction instead.

## 24.3.4 sigactionFunction Example..........................

InSection 24.3.1 [Basic Signal Handling], page 725, we gave an example of establishing a
simple handler for termination signals usingsignal. Here is an equivalent example using
sigaction:

```
#include <signal.h>
```
```
void
termination_handler (int signum)
{
struct temp_file *p;
```
```
for (p = temp_file_list; p; p = p->next)
unlink (p->name);
}
```
```
int
main (void)
{
...
struct sigaction new_action, old_action;
```
```
/*Set up the structure to specify the new action.*/
new_action.sa_handler = termination_handler;
sigemptyset (&new_action.sa_mask);
new_action.sa_flags = 0;
```
sigaction (SIGINT, NULL, &old_action);
if (old_action.sa_handler != SIG_IGN)
sigaction (SIGINT, &new_action, NULL);
sigaction (SIGHUP, NULL, &old_action);
if (old_action.sa_handler != SIG_IGN)
sigaction (SIGHUP, &new_action, NULL);
sigaction (SIGTERM, NULL, &old_action);
if (old_action.sa_handler != SIG_IGN)
sigaction (SIGTERM, &new_action, NULL);
...
}
The program just loads thenew_actionstructure with the desired parameters and passes
it in thesigactioncall. The usage ofsigemptysetis described later; seeSection 24.7
[Blocking Signals], page 746.

As in the example usingsignal, we avoid handling signals previously set to be ignored.
Here we can avoid altering the signal handler even momentarily, by using the feature of
sigactionthat lets us examine the current action without specifying a new one.


Chapter 24: Signal Handling 730

Here is another example. It retrieves information about the current action forSIGINT
without changing that action.
struct sigaction query_action;

```
if (sigaction (SIGINT, NULL, &query_action) < 0)
/* sigactionreturns -1 in case of error.*/
else if (query_action.sa_handler == SIG_DFL)
/* SIGINTis handled in the default, fatal manner.*/
else if (query_action.sa_handler == SIG_IGN)
/* SIGINTis ignored.*/
else
/*A programmer-defined signal handler is in effect.*/
```
## 24.3.5 Flags forsigaction....................................

Thesa_flagsmember of thesigactionstructure is a catch-all for special features. Most
of the time,SA_RESTARTis a good value to use for this field.

The value ofsa_flagsis interpreted as a bit mask. Thus, you should choose the flags
you want to set,orthose flags together, and store the result in thesa_flagsmember of
yoursigactionstructure.

Each signal number has its own set of flags. Each call tosigactionaffects one particular
signal number, and the flags that you specify apply only to that particular signal.

In the GNU C Library, establishing a handler withsignalsets all the flags to zero except
forSA_RESTART, whose value depends on the settings you have made withsiginterrupt.
SeeSection 24.5 [Primitives Interrupted by Signals], page 741, to see what this is about.

```
These macros are defined in the header filesignal.h.
```
int SA_NOCLDSTOP [Macro]
This flag is meaningful only for theSIGCHLDsignal. When the flag is set, the system
delivers the signal for a terminated child process but not for one that is stopped. By
default,SIGCHLDis delivered for both terminated children and stopped children.
Setting this flag for a signal other thanSIGCHLDhas no effect.

int SA_ONSTACK [Macro]
If this flag is set for a particular signal number, the system uses the signal stack
when delivering that kind of signal. SeeSection 24.9 [Using a Separate Signal Stack],
page 755. If a signal with this flag arrives and you have not set a signal stack, the
system terminates the program withSIGILL.

int SA_RESTART [Macro]
This flag controls what happens when a signal is delivered during certain primitives
(such asopen,readorwrite), and the signal handler returns normally. There are
two alternatives: the library function can resume, or it can return failure with error
codeEINTR.
The choice is controlled by theSA_RESTARTflag for the particular kind of signal that
was delivered. If the flag is set, returning from a handler resumes the library function.
If the flag is clear, returning from a handler makes the function fail. SeeSection 24.5
[Primitives Interrupted by Signals], page 741.


Chapter 24: Signal Handling 731

## 24.3.6 Initial Signal Actions...................................

When a new process is created (seeSection 26.4 [Creating a Process], page 805), it inherits
handling of signals from its parent process. However, when you load a new process image
using theexecfunction (seeSection 26.5 [Executing a File], page 806), any signals that
you¡¯ve defined your own handlers for revert to theirSIG_DFLhandling. (If you think about
it a little, this makes sense; the handler functions from the old program are specific to
that program, and aren¡¯t even present in the address space of the new program image.) Of
course, the new program can establish its own handlers.

When a program is run by a shell, the shell normally sets the initial actions for the child
process toSIG_DFLorSIG_IGN, as appropriate. It¡¯s a good idea to check to make sure that
the shell has not set up an initial action ofSIG_IGNbefore you establish your own signal
handlers.

Here is an example of how to establish a handler forSIGHUP, but not ifSIGHUPis currently
ignored:

```
struct sigaction temp;
```
```
sigaction (SIGHUP, NULL, &temp);
```
```
if (temp.sa_handler != SIG_IGN)
{
temp.sa_handler = handle_sighup;
sigemptyset (&temp.sa_mask);
sigaction (SIGHUP, &temp, NULL);
}
```
## 24.4 Defining Signal Handlers....................................

This section describes how to write a signal handler function that can be established with
thesignalorsigactionfunctions.

A signal handler is just a function that you compile together with the rest of the program.
Instead of directly invoking the function, you usesignalorsigactionto tell the operating
system to call it when a signal arrives. This is known asestablishingthe handler. See
Section 24.3 [Specifying Signal Actions], page 725.

```
There are two basic strategies you can use in signal handler functions:
```
- You can have the handler function note that the signal arrived by tweaking some global
    data structures, and then return normally.
- You can have the handler function terminate the program or transfer control to a point
    where it can recover from the situation that caused the signal.
You need to take special care in writing handler functions because they can be called
asynchronously. That is, a handler might be called at any point in the program, unpre-
dictably. If two signals arrive during a very short interval, one handler can run within
another. This section describes what your handler should do, and what you should avoid.

## 24.4.1 Signal Handlers that Return............................

Handlers which return normally are usually used for signals such asSIGALRMand the I/O and
interprocess communication signals. But a handler forSIGINTmight also return normally
after setting a flag that tells the program to exit at a convenient time.


Chapter 24: Signal Handling 732

It is not safe to return normally from the handler for a program error signal, because the
behavior of the program when the handler function returns is not defined after a program
error. SeeSection 24.2.1 [Program Error Signals], page 716.

Handlers that return normally must modify some global variable in order to have any
effect. Typically, the variable is one that is examined periodically by the program dur-
ing normal operation. Its data type should besig_atomic_tfor reasons described in
Section 24.4.7 [Atomic Data Access and Signal Handling], page 739.

Here is a simple example of such a program. It executes the body of the loop until it
has noticed that aSIGALRMsignal has arrived. This technique is useful because it allows
the iteration in progress when the signal arrives to complete before the loop exits.

```
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
```
```
/*This flag controls termination of the main loop.*/
volatile sig_atomic_t keep_going = 1;
```
```
/*The signal handler just clears the flag and re-enables itself.*/
void
catch_alarm (int sig)
{
keep_going = 0;
signal (sig, catch_alarm);
}
```
```
void
do_stuff (void)
{
puts ("Doing stuff while waiting for alarm....");
}
```
```
int
main (void)
{
/*Establish a handler for SIGALRM signals.*/
signal (SIGALRM, catch_alarm);
```
```
/*Set an alarm to go off in a little while.*/
alarm (2);
```
```
/*Check the flag once in a while to see when to quit.*/
while (keep_going)
do_stuff ();
```
```
return EXIT_SUCCESS;
}
```
## 24.4.2 Handlers That Terminate the Process...................

Handler functions that terminate the program are typically used to cause orderly cleanup
or recovery from program error signals and interactive interrupts.

The cleanest way for a handler to terminate the process is to raise the same signal that
ran the handler in the first place. Here is how to do this:
volatile sig_atomic_t fatal_error_in_progress = 0;


Chapter 24: Signal Handling 733

```
void
fatal_error_signal (int sig)
{
/*Since this handler is established for more than one kind of signal,
it might still get invoked recursively by delivery of some other kind
of signal. Use a static variable to keep track of that.*/
if (fatal_error_in_progress)
raise (sig);
fatal_error_in_progress = 1;
```
```
/*Now do the clean up actions:
```
- reset terminal modes
- kill child processes
- remove lock files*/

```
/*Now reraise the signal. We reactivate the signal¡¯s
default handling, which is to terminate the process.
We could just callexitorabort,
but reraising the signal sets the return status
from the process correctly.*/
signal (sig, SIG_DFL);
raise (sig);
}
```
## 24.4.3 Nonlocal Control Transfer in Handlers..................

You can do a nonlocal transfer of control out of a signal handler using thesetjmpand
longjmpfacilities (seeChapter 23 [Non-Local Exits], page 705).

When the handler does a nonlocal control transfer, the part of the program that was
running will not continue. If this part of the program was in the middle of updating an
important data structure, the data structure will remain inconsistent. Since the program
does not terminate, the inconsistency is likely to be noticed later on.

There are two ways to avoid this problem. One is to block the signal for the parts of the
program that update important data structures. Blocking the signal delays its delivery until
it is unblocked, once the critical updating is finished. SeeSection 24.7 [Blocking Signals],
page 746.

The other way is to re-initialize the crucial data structures in the signal handler, or to
make their values consistent.

```
Here is a rather schematic example showing the reinitialization of one global variable.
```

Chapter 24: Signal Handling 734

```
#include <signal.h>
#include <setjmp.h>
```
```
jmp_buf return_to_top_level;
```
```
volatile sig_atomic_t waiting_for_input;
```
```
void
handle_sigint (int signum)
{
/*We may have been waiting for input when the signal arrived,
but we are no longer waiting once we transfer control.*/
waiting_for_input = 0;
longjmp (return_to_top_level, 1);
}
```
```
int
main (void)
{
```
```
signal (SIGINT, sigint_handler);
```
```
while (1) {
prepare_for_command ();
if (setjmp (return_to_top_level) == 0)
read_and_execute_command ();
}
}
```
```
/*Imagine this is a subroutine used by various commands.*/
char *
read_data ()
{
if (input_from_terminal) {
waiting_for_input = 1;
```
```
waiting_for_input = 0;
} else {
```
```
}
}
```
## 24.4.4 Signals Arriving While a Handler Runs.................

What happens if another signal arrives while your signal handler function is running?

When the handler for a particular signal is invoked, that signal is automatically blocked
until the handler returns. That means that if two signals of the same kind arrive close
together, the second one will be held until the first has been handled. (The handler can
explicitly unblock the signal usingsigprocmask, if you want to allow more signals of this
type to arrive; seeSection 24.7.3 [Process Signal Mask], page 748.)

However, your handler can still be interrupted by delivery of another kind of signal. To
avoid this, you can use thesa_maskmember of the action structure passed tosigaction
to explicitly specify which signals should be blocked while the signal handler runs. These
signals are in addition to the signal for which the handler was invoked, and any other


Chapter 24: Signal Handling 735

signals that are normally blocked by the process. SeeSection 24.7.5 [Blocking Signals for a
Handler], page 750.

When the handler returns, the set of blocked signals is restored to the value it had
before the handler ran. So usingsigprocmaskinside the handler only affects what signals
can arrive during the execution of the handler itself, not what signals can arrive once the
handler returns.

Portability Note: Always usesigactionto establish a handler for a signal that you
expect to receive asynchronously, if you want your program to work properly on System
V Unix. On this system, the handling of a signal whose handler was established with
signalautomatically sets the signal¡¯s action back toSIG_DFL, and the handler must re-
establish itself each time it runs. This practice, while inconvenient, does work when signals
cannot arrive in succession. However, if another signal can arrive right away, it may arrive
before the handler can re-establish itself. Then the second signal would receive the default
handling, which could terminate the process.

## 24.4.5 Signals Close Together Merge into One.................

If multiple signals of the same type are delivered to your process before your signal handler
has a chance to be invoked at all, the handler may only be invoked once, as if only a single
signal had arrived. In effect, the signals merge into one. This situation can arise when the
signal is blocked, or in a multiprocessing environment where the system is busy running
some other processes while the signals are delivered. This means, for example, that you
cannot reliably use a signal handler to count signals. The only distinction you can reliably
make is whether at least one signal has arrived since a given time in the past.

Here is an example of a handler forSIGCHLDthat compensates for the fact that the
number of signals received may not equal the number of child processes that generate them.
It assumes that the program keeps track of all the child processes with a chain of structures
as follows:
struct process
{
struct process *next;
/*The process ID of this child. */
int pid;
/*The descriptor of the pipe or pseudo terminal
on which output comes from this child. */
int input_descriptor;
/*Nonzero if this process has stopped or terminated. */
sig_atomic_t have_status;
/*The status of this child; 0 if running,
otherwise a status value fromwaitpid. */
int status;
};

struct process *process_list;
This example also uses a flag to indicate whether signals have arrived since some time
in the past¡ªwhenever the program last cleared it to zero.
/*Nonzero means some child¡¯s status has changed
so look atprocess_listfor the details. */
int process_status_change;
Here is the handler itself:


Chapter 24: Signal Handling 736

```
void
sigchld_handler (int signo)
{
int old_errno = errno;
```
```
while (1) {
register int pid;
int w;
struct process *p;
```
```
/*Keep asking for a status until we get a definitive result. */
do
{
errno = 0;
pid = waitpid (WAIT_ANY, &w, WNOHANG | WUNTRACED);
}
while (pid <= 0 && errno == EINTR);
```
```
if (pid <= 0) {
/*A real failure means there are no more
stopped or terminated child processes, so return. */
errno = old_errno;
return;
}
```
```
/*Find the process that signaled us, and record its status. */
```
```
for (p = process_list; p; p = p->next)
if (p->pid == pid) {
p->status = w;
/* Indicate that thestatusfield
has data to look at. We do this only after storing it. */
p->have_status = 1;
```
```
/* If process has terminated, stop waiting for its output. */
if (WIFSIGNALED (w) || WIFEXITED (w))
if (p->input_descriptor)
FD_CLR (p->input_descriptor, &input_wait_mask);
```
```
/* The program should check this flag from time to time
to see if there is any news inprocess_list. */
++process_status_change;
}
```
```
/*Loop around to handle all the processes
that have something to tell us. */
}
}
```
```
Here is the proper way to check the flagprocess_status_change:
if (process_status_change) {
struct process *p;
process_status_change = 0;
for (p = process_list; p; p = p->next)
if (p->have_status) {
...Examinep->status ...
}
}
```

Chapter 24: Signal Handling 737

It is vital to clear the flag before examining the list; otherwise, if a signal were delivered
just before the clearing of the flag, and after the appropriate element of the process list had
been checked, the status change would go unnoticed until the next signal arrived to set the
flag again. You could, of course, avoid this problem by blocking the signal while scanning
the list, but it is much more elegant to guarantee correctness by doing things in the right
order.

The loop which checks process status avoids examiningp->statusuntil it sees that
status has been validly stored. This is to make sure that the status cannot change in
the middle of accessing it. Oncep->have_statusis set, it means that the child process
is stopped or terminated, and in either case, it cannot stop or terminate again until the
program has taken notice. SeeSection 24.4.7.3 [Atomic Usage Patterns], page 740, for more
information about coping with interruptions during accesses of a variable.

Here is another way you can test whether the handler has run since the last time you
checked. This technique uses a counter which is never changed outside the handler. Instead
of clearing the count, the program remembers the previous value and sees whether it has
changed since the previous check. The advantage of this method is that different parts of
the program can check independently, each part checking whether there has been a signal
since that part last checked.
sig_atomic_t process_status_change;

```
sig_atomic_t last_process_status_change;
```
```
{
sig_atomic_t prev = last_process_status_change;
last_process_status_change = process_status_change;
if (last_process_status_change != prev) {
struct process *p;
for (p = process_list; p; p = p->next)
if (p->have_status) {
...Examinep->status ...
}
}
}
```
## 24.4.6 Signal Handling and Nonreentrant Functions............

Handler functions usually don¡¯t do very much. The best practice is to write a handler that
does nothing but set an external variable that the program checks regularly, and leave all
serious work to the program. This is best because the handler can be called asynchronously,
at unpredictable times¡ªperhaps in the middle of a primitive function, or even between
the beginning and the end of a C operator that requires multiple instructions. The data
structures being manipulated might therefore be in an inconsistent state when the handler
function is invoked. Even copying oneintvariable into another can take two instructions
on most machines.

```
This means you have to be very careful about what you do in a signal handler.
```
- If your handler needs to access any global variables from your program, declare those
    variablesvolatile. This tells the compiler that the value of the variable might change
    asynchronously, and inhibits certain optimizations that would be invalidated by such
    modifications.


Chapter 24: Signal Handling 738

- If you call a function in the handler, make sure it isreentrantwith respect to signals,
    or else make sure that the signal cannot interrupt a call to a related function.
A function can be non-reentrant if it uses memory that is not on the stack.
- If a function uses a static variable or a global variable, or a dynamically-allocated object
    that it finds for itself, then it is non-reentrant and any two calls to the function can
    interfere.
    For example, suppose that the signal handler usesgethostbyname. This function
    returns its value in a static object, reusing the same object each time. If the signal
    happens to arrive during a call togethostbyname, or even after one (while the program
    is still using the value), it will clobber the value that the program asked for.
    However, if the program does not usegethostbynameor any other function that returns
    information in the same object, or if it always blocks signals around each use, then you
    are safe.
    There are a large number of library functions that return values in a fixed object,
    always reusing the same object in this fashion, and all of them cause the same problem.
    Function descriptions in this manual always mention this behavior.
- If a function uses and modifies an object that you supply, then it is potentially non-
    reentrant; two calls can interfere if they use the same object.
    This case arises when you do I/O using streams. Suppose that the signal handler prints
    a message withfprintf. Suppose that the program was in the middle of anfprintf
    call using the same stream when the signal was delivered. Both the signal handler¡¯s
    message and the program¡¯s data could be corrupted, because both calls operate on the
    same data structure¡ªthe stream itself.
    However, if you know that the stream that the handler uses cannot possibly be used
    by the program at a time when signals can arrive, then you are safe. It is no problem
    if the program uses some other stream.
- On most systems,mallocandfreeare not reentrant, because they use a static data
    structure which records what memory blocks are free. As a result, no library functions
    that allocate or free memory are reentrant. This includes functions that allocate space
    to store a result.
    The best way to avoid the need to allocate memory in a handler is to allocate in advance
    space for signal handlers to use.
    The best way to avoid freeing memory in a handler is to flag or record the objects to
    be freed, and have the program check from time to time whether anything is waiting
    to be freed. But this must be done with care, because placing an object on a chain is
    not atomic, and if it is interrupted by another signal handler that does the same thing,
    you could ¡°lose¡± one of the objects.
- Any function that modifieserrnois non-reentrant, but you can correct for this: in the
    handler, save the original value oferrnoand restore it before returning normally. This
    prevents errors that occur within the signal handler from being confused with errors
    from system calls at the point the program is interrupted to run the handler.
    This technique is generally applicable; if you want to call in a handler a function that
    modifies a particular object in memory, you can make this safe by saving and restoring
    that object.


Chapter 24: Signal Handling 739

- Merely reading from a memory object is safe provided that you can deal with any of the
    values that might appear in the object at a time when the signal can be delivered. Keep
    in mind that assignment to some data types requires more than one instruction, which
    means that the handler could run ¡°in the middle of¡± an assignment to the variable if
    its type is not atomic. SeeSection 24.4.7 [Atomic Data Access and Signal Handling],
    page 739.
- Merely writing into a memory object is safe as long as a sudden change in the value,
    at any time when the handler might run, will not disturb anything.

## 24.4.7 Atomic Data Access and Signal Handling...............

Whether the data in your application concerns atoms, or mere text, you have to be careful
about the fact that access to a single datum is not necessarilyatomic. This means that it
can take more than one instruction to read or write a single object. In such cases, a signal
handler might be invoked in the middle of reading or writing the object.

There are three ways you can cope with this problem. You can use data types that are
always accessed atomically; you can carefully arrange that nothing untoward happens if an
access is interrupted, or you can block all signals around any access that had better not be
interrupted (seeSection 24.7 [Blocking Signals], page 746).

## 24.4.7.1 Problems with Non-Atomic Access.................

Here is an example which shows what can happen if a signal handler runs in the middle of
modifying a variable. (Interrupting the reading of a variable can also lead to paradoxical
results, but here we only show writing.)

```
#include <signal.h>
#include <stdio.h>
```
```
volatile struct two_words { int a, b; } memory;
```
```
void
handler(int signum)
{
printf ("%d,%d\n", memory.a, memory.b);
alarm (1);
}
```
int
main (void)
{
static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
signal (SIGALRM, handler);
memory = zeros;
alarm (1);
while (1)
{
memory = zeros;
memory = ones;
}
}
This program fillsmemorywith zeros, ones, zeros, ones, alternating forever; meanwhile,
once per second, the alarm signal handler prints the current contents. (Callingprintf


Chapter 24: Signal Handling 740

in the handler is safe in this program because it is certainly not being called outside the
handler when the signal happens.)

Clearly, this program can print a pair of zeros or a pair of ones. But that¡¯s not all it can
do! On most machines, it takes several instructions to store a new value inmemory, and the
value is stored one word at a time. If the signal is delivered in between these instructions,
the handler might find thatmemory.ais zero andmemory.bis one (or vice versa).

On some machines it may be possible to store a new value inmemory with just one
instruction that cannot be interrupted. On these machines, the handler will always print
two zeros or two ones.

## 24.4.7.2 Atomic Types.....................................

To avoid uncertainty about interrupting access to a variable, you can use a particular data
type for which access is always atomic:sig_atomic_t. Reading and writing this data type
is guaranteed to happen in a single instruction, so there¡¯s no way for a handler to run ¡°in
the middle¡± of an access.

The typesig_atomic_tis always an integer data type, but which one it is, and how
many bits it contains, may vary from machine to machine.

sig_atomic_t [Data Type]
This is an integer data type. Objects of this type are always accessed atomically.

In practice, you can assume thatintis atomic. You can also assume that pointer
types are atomic; that is very convenient. Both of these assumptions are true on all of the
machines that the GNU C Library supports and on all POSIX systems we know of.

## 24.4.7.3 Atomic Usage Patterns............................

Certain patterns of access avoid any problem even if an access is interrupted. For example,
a flag which is set by the handler, and tested and cleared by the main program from time
to time, is always safe even if access actually requires two instructions. To show that this
is so, we must consider each access that could be interrupted, and show that there is no
problem if it is interrupted.

An interrupt in the middle of testing the flag is safe because either it¡¯s recognized to be
nonzero, in which case the precise value doesn¡¯t matter, or it will be seen to be nonzero the
next time it¡¯s tested.

An interrupt in the middle of clearing the flag is no problem because either the value
ends up zero, which is what happens if a signal comes in just before the flag is cleared, or
the value ends up nonzero, and subsequent events occur as if the signal had come in just
after the flag was cleared. As long as the code handles both of these cases properly, it can
also handle a signal in the middle of clearing the flag. (This is an example of the sort of
reasoning you need to do to figure out whether non-atomic usage is safe.)

Sometimes you can ensure uninterrupted access to one object by protecting its use with
another object, perhaps one whose type guarantees atomicity. SeeSection 24.4.5 [Signals
Close Together Merge into One], page 735, for an example.


Chapter 24: Signal Handling 741

## 24.5 Primitives Interrupted by Signals............................

A signal can arrive and be handled while an I/O primitive such asopenorreadis waiting
for an I/O device. If the signal handler returns, the system faces the question: what should
happen next?

POSIX specifies one approach: make the primitive fail right away. The error code for
this kind of failure isEINTR. This is flexible, but usually inconvenient. Typically, POSIX
applications that use signal handlers must check forEINTRafter each library function that
can return it, in order to try the call again. Often programmers forget to check, which is a
common source of error.

The GNU C Library provides a convenient way to retry a call after a temporary failure,
with the macroTEMP_FAILURE_RETRY:

TEMP_FAILURE_RETRY(expression) [Macro]
This macro evaluatesexpressiononce, and examines its value as typelong int. If the
value equals-1, that indicates a failure anderrnoshould be set to show what kind
of failure. If it fails and reports error codeEINTR,TEMP_FAILURE_RETRYevaluates it
again, and over and over until the result is not a temporary failure.
The value returned byTEMP_FAILURE_RETRYis whatever valueexpressionproduced.

BSD avoidsEINTRentirely and provides a more convenient approach: to restart the
interrupted primitive, instead of making it fail. If you choose this approach, you need not
be concerned withEINTR.

You can choose either approach with the GNU C Library. If you usesigactionto
establish a signal handler, you can specify how that handler should behave. If you specify
theSA_RESTARTflag, return from that handler will resume a primitive; otherwise, return
from that handler will causeEINTR. SeeSection 24.3.5 [Flags forsigaction], page 730.

Another way to specify the choice is with thesiginterruptfunction. SeeSection 24.10
[BSD Signal Handling], page 757.

When you don¡¯t specify withsigactionorsiginterruptwhat a particular handler
should do, it uses a default choice. The default choice in the GNU C Library is to make
primitives fail withEINTR.

The description of each primitive affected by this issue listsEINTRamong the error codes
it can return.

There is one situation where resumption never happens no matter which choice you
make: when a data-transfer function such asreadorwriteis interrupted by a signal after
transferring part of the data. In this case, the function returns the number of bytes already
transferred, indicating partial success.

This might at first appear to cause unreliable behavior on record-oriented devices (includ-
ing datagram sockets; seeSection 16.10 [Datagram Socket Operations], page 493), where
splitting onereadorwriteinto two would read or write two records. Actually, there is
no problem, because interruption after a partial transfer cannot happen on such devices;
they always transfer an entire record in one burst, with no waiting once data transfer has
started.


Chapter 24: Signal Handling 742

## 24.6 Generating Signals..........................................

Besides signals that are generated as a result of a hardware trap or interrupt, your program
can explicitly send signals to itself or to another process.

## 24.6.1 Signaling Yourself......................................

A process can send itself a signal with theraisefunction. This function is declared in
signal.h.

int raise (intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theraisefunction sends the signalsignumto the calling process. It returns zero if
successful and a nonzero value if it fails. About the only reason for failure would be
if the value ofsignumis invalid.

int gsignal(intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegsignalfunction does the same thing asraise; it is provided only for compati-
bility with SVID.

One convenient use forraiseis to reproduce the default behavior of a signal that you
have trapped. For instance, suppose a user of your program types the SUSP character
(usuallyC-z; seeSection 17.4.9 [Special Characters], page 516) to send it an interactive
stop signal (SIGTSTP), and you want to clean up some internal data buffers before stopping.
You might set this up like this:

```
#include <signal.h>
```
```
/*When a stop signal arrives, set the action back to the default
and then resend the signal after doing cleanup actions.*/
```
```
void
tstp_handler (int sig)
{
signal (SIGTSTP, SIG_DFL);
/*Do cleanup actions here.*/
...
raise (SIGTSTP);
}
```
```
/*When the process is continued again, restore the signal handler.*/
```
```
void
cont_handler (int sig)
{
signal (SIGCONT, cont_handler);
signal (SIGTSTP, tstp_handler);
}
```

Chapter 24: Signal Handling 743

```
/*Enable both handlers during program initialization.*/
```
```
int
main (void)
{
signal (SIGCONT, cont_handler);
signal (SIGTSTP, tstp_handler);
```
}
Portability note:raisewas invented by the ISO C committee. Older systems may not
support it, so usingkillmay be more portable. SeeSection 24.6.2 [Signaling Another
Process], page 743.

## 24.6.2 Signaling Another Process..............................

Thekillfunction can be used to send a signal to another process. In spite of its name, it
can be used for a lot of things other than causing a process to terminate. Some examples
of situations where you might want to send signals between processes are:

- A parent process starts a child to perform a task¡ªperhaps having the child running
    an infinite loop¡ªand then terminates the child when the task is no longer needed.
- A process executes as part of a group, and needs to terminate or notify the other
    processes in the group when an error or other event occurs.
- Two processes need to synchronize while working together.

This section assumes that you know a little bit about how processes work. For more
information on this subject, seeChapter 26 [Processes], page 803.

```
Thekillfunction is declared insignal.h.
```
int kill (pidtpid, intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thekillfunction sends the signalsignumto the process or process group specified
bypid. Besides the signals listed inSection 24.2 [Standard Signals], page 716,signum
can also have a value of zero to check the validity of thepid.
Thepidspecifies the process or process group to receive the signal:

```
pid> 0 The process whose identifier ispid. (On Linux, the signal is sent to the
entire process even ifpidis a thread ID distinct from the process ID.)
pid== 0 All processes in the same process group as the sender.
```
```
pid< -1 The process group whose identifier is?pid.
pid== -1 If the process is privileged, send the signal to all processes except for some
special system processes. Otherwise, send the signal to all processes with
the same effective user ID.
A process can send a signal to itself with a call likekill (getpid(),signum). If
killis used by a process to send a signal to itself, and the signal is not blocked,
thenkilldelivers at least one signal (which might be some other pending unblocked
signal instead of the signalsignum) to that process before it returns.
```

Chapter 24: Signal Handling 744

```
The return value fromkillis zero if the signal can be sent successfully. Otherwise,
no signal is sent, and a value of-1is returned. Ifpidspecifies sending a signal to
several processes,killsucceeds if it can send the signal to at least one of them.
There¡¯s no way you can tell which of the processes got the signal or whether all of
them did.
The followingerrnoerror conditions are defined for this function:
EINVAL Thesignumargument is an invalid or unsupported number.
EPERM You do not have the privilege to send a signal to the process or any of
the processes in the process group named bypid.
ESRCH Thepidargument does not refer to an existing process or group.
```
int tgkill(pidtpid, pidttid, intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thetgkillfunction sends the signalsignumto the thread or process with IDtid,
like thekillfunction, but only if the process ID of the threadtidis equal topid. If
the target thread belongs to another process, the function fails withESRCH.
Thetgkillfunction can be used to avoid sending a signal to a thread in the wrong
process if the caller ensures that the passedpidvalue is not reused by the kernel (for
example, if it is the process ID of the current process, as returned bygetpid).

int killpg(intpgid, intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is similar tokill, but sends signalsignumto the process grouppgid. This func-
tion is provided for compatibility with BSD; usingkillto do this is more portable.

As a simple example ofkill, the callkill (getpid (),sig)has the same effect as
raise (sig).

## 24.6.3 Permission for usingkill..............................

There are restrictions that prevent you from usingkillto send signals to any random
process. These are intended to prevent antisocial behavior such as arbitrarily killing off
processes belonging to another user. In typical use,killis used to pass signals between
parent, child, and sibling processes, and in these situations you normally do have permission
to send signals. The only common exception is when you run a setuid program in a child
process; if the program changes its real UID as well as its effective UID, you may not have
permission to send a signal. Thesuprogram does this.

Whether a process has permission to send a signal to another process is determined by
the user IDs of the two processes. This concept is discussed in detail inSection 30.2 [The
Persona of a Process], page 845.

Generally, for a process to be able to send a signal to another process, either the sending
process must belong to a privileged user (like ¡®root¡¯), or the real or effective user ID of
the sending process must match the real or effective user ID of the receiving process. If
the receiving process has changed its effective user ID from the set-user-ID mode bit on its


Chapter 24: Signal Handling 745

process image file, then the owner of the process image file is used in place of its current
effective user ID. In some implementations, a parent process might be able to send signals to
a child process even if the user ID¡¯s don¡¯t match, and other implementations might enforce
other restrictions.

TheSIGCONTsignal is a special case. It can be sent if the sender is part of the same
session as the receiver, regardless of user IDs.

## 24.6.4 Usingkillfor Communication.........................

Here is a longer example showing how signals can be used for interprocess communication.
This is what theSIGUSR1andSIGUSR2signals are provided for. Since these signals are fatal
by default, the process that is supposed to receive them must trap them throughsignal
orsigaction.

In this example, a parent process forks a child process and then waits for the child to
complete its initialization. The child process tells the parent when it is ready by sending it
aSIGUSR1signal, using thekillfunction.

```
#include <signal.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
```
```
/*When aSIGUSR1signal arrives, set this variable.*/
volatile sig_atomic_t usr_interrupt = 0;
```
```
void
synch_signal (int sig)
{
usr_interrupt = 1;
}
```
```
/*The child process executes this function.*/
void
child_function (void)
{
/*Perform initialization.*/
printf ("I'm here!!! My pid is %d.\n", (int) getpid ());
```
```
/*Let parent know you¡¯re done.*/
kill (getppid (), SIGUSR1);
```
```
/*Continue with execution.*/
puts ("Bye, now....");
exit (0);
}
```
```
int
main (void)
{
struct sigaction usr_action;
sigset_t block_mask;
pid_t child_id;
```
```
/*Establish the signal handler.*/
sigfillset (&block_mask);
```

Chapter 24: Signal Handling 746

```
usr_action.sa_handler = synch_signal;
usr_action.sa_mask = block_mask;
usr_action.sa_flags = 0;
sigaction (SIGUSR1, &usr_action, NULL);
```
```
/*Create the child process. */
child_id = fork ();
if (child_id == 0)
child_function (); /*Does not return.*/
```
```
/*Busy wait for the child to send a signal.*/
while (!usr_interrupt)
;
```
```
/*Now continue execution.*/
puts ("That's all, folks!");
```
return 0;
}
This example uses a busy wait, which is bad, because it wastes CPU cycles that other
programs could otherwise use. It is better to ask the system to wait until the signal arrives.
See the example inSection 24.8 [Waiting for a Signal], page 753.

## 24.7 Blocking Signals.............................................

Blocking a signal means telling the operating system to hold it and deliver it later. Generally,
a program does not block signals indefinitely¡ªit might as well ignore them by setting
their actions toSIG_IGN. But it is useful to block signals briefly, to prevent them from
interrupting sensitive operations. For instance:

- You can use thesigprocmaskfunction to block signals while you modify global vari-
    ables that are also modified by the handlers for these signals.
- You can setsa_maskin yoursigactioncall to block certain signals while a particular
    signal handler runs. This way, the signal handler can run without being interrupted
    itself by signals.

## 24.7.1 Why Blocking Signals is Useful.........................

Temporary blocking of signals withsigprocmaskgives you a way to prevent interrupts
during critical parts of your code. If signals arrive in that part of the program, they are
delivered later, after you unblock them.

One example where this is useful is for sharing data between a signal handler and the
rest of the program. If the type of the data is notsig_atomic_t(seeSection 24.4.7 [Atomic
Data Access and Signal Handling], page 739), then the signal handler could run when the
rest of the program has only half finished reading or writing the data. This would lead to
confusing consequences.

To make the program reliable, you can prevent the signal handler from running while
the rest of the program is examining or modifying that data¡ªby blocking the appropriate
signal around the parts of the program that touch the data.

Blocking signals is also necessary when you want to perform a certain action only if a
signal has not arrived. Suppose that the handler for the signal sets a flag of typesig_
atomic_t; you would like to test the flag and perform the action if the flag is not set. This


Chapter 24: Signal Handling 747

is unreliable. Suppose the signal is delivered immediately after you test the flag, but before
the consequent action: then the program will perform the action even though the signal has
arrived.

The only way to test reliably for whether a signal has yet arrived is to test while the
signal is blocked.

## 24.7.2 Signal Sets.............................................

All of the signal blocking functions use a data structure called asignal setto specify what
signals are affected. Thus, every activity involves two stages: creating the signal set, and
then passing it as an argument to a library function.

```
These facilities are declared in the header filesignal.h.
```
sigset_t [Data Type]
Thesigset_tdata type is used to represent a signal set. Internally, it may be
implemented as either an integer or structure type.
For portability, use only the functions described in this section to initialize, change,
and retrieve information fromsigset_tobjects¡ªdon¡¯t try to manipulate them di-
rectly.

There are two ways to initialize a signal set. You can initially specify it to be empty
withsigemptysetand then add specified signals individually. Or you can specify it to be
full withsigfillsetand then delete specified signals individually.

You must always initialize the signal set with one of these two functions before using it
in any other way. Don¡¯t try to set all the signals explicitly because thesigset_tobject
might include some other information (like a version field) that needs to be initialized as
well. (In addition, it¡¯s not wise to put into your program an assumption that the system
has no signals aside from the ones you know about.)

int sigemptyset (sigsett *set) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function initializes the signal setsetto exclude all of the defined signals. It
always returns 0.

int sigfillset(sigsett *set) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function initializes the signal setsetto include all of the defined signals. Again,
the return value is 0.

int sigaddset(sigsett *set, intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function adds the signalsignumto the signal setset. Allsigaddsetdoes is
modifyset; it does not block or unblock any signals.
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:
EINVAL Thesignumargument doesn¡¯t specify a valid signal.


Chapter 24: Signal Handling 748

int sigdelset(sigsett *set, intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function removes the signalsignumfrom the signal setset. Allsigdelsetdoes
is modifyset; it does not block or unblock any signals. The return value and error
conditions are the same as forsigaddset.

```
Finally, there is a function to test what signals are in a signal set:
```
int sigismember (const sigsett *set, intsignum) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesigismemberfunction tests whether the signalsignumis a member of the signal
setset. It returns 1 if the signal is in the set, 0 if not, and-1if there is an error.
The followingerrnoerror condition is defined for this function:

```
EINVAL Thesignumargument doesn¡¯t specify a valid signal.
```
## 24.7.3 Process Signal Mask....................................

The collection of signals that are currently blocked is called thesignal mask. Each process
has its own signal mask. When you create a new process (seeSection 26.4 [Creating a
Process], page 805), it inherits its parent¡¯s mask. You can block or unblock signals with
total flexibility by modifying the signal mask.

The prototype for thesigprocmaskfunction is insignal.h.
Note that you must not usesigprocmaskin multi-threaded processes, because each
thread has its own signal mask and there is no single process signal mask. According to
POSIX, the behavior ofsigprocmaskin a multi-threaded process is ¡°unspecified¡±. Instead,
usepthread_sigmask.

int sigprocmask (inthow, const sigsett *restrictset, sigsett [Function]
*restrictoldset)
Preliminary: | MT-Unsafe race:sigprocmask/bsd(SIGUNBLOCK) | AS-Unsafe
lock/hurd|AC-Unsafe lock/hurd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thesigprocmaskfunction is used to examine or change the calling process¡¯s signal
mask. Thehowargument determines how the signal mask is changed, and must be
one of the following values:

```
SIG_BLOCK
Block the signals inset¡ªadd them to the existing mask. In other words,
the new mask is the union of the existing mask andset.
```
```
SIG_UNBLOCK
Unblock the signals inset¡ªremove them from the existing mask.
```
```
SIG_SETMASK
Usesetfor the mask; ignore the previous value of the mask.
```

Chapter 24: Signal Handling 749

```
The last argument,oldset, is used to return information about the old process signal
mask. If you just want to change the mask without looking at it, pass a null pointer
as theoldsetargument. Similarly, if you want to know what¡¯s in the mask without
changing it, pass a null pointer forset(in this case thehowargument is not signif-
icant). Theoldsetargument is often used to remember the previous signal mask in
order to restore it later. (Since the signal mask is inherited overforkandexeccalls,
you can¡¯t predict what its contents are when your program starts running.)
```
```
If invokingsigprocmaskcauses any pending signals to be unblocked, at least one of
those signals is delivered to the process beforesigprocmaskreturns. The order in
which pending signals are delivered is not specified, but you can control the order
explicitly by making multiplesigprocmaskcalls to unblock various signals one at a
time.
```
```
Thesigprocmaskfunction returns 0 if successful, and-1to indicate an error. The
followingerrnoerror conditions are defined for this function:
```
```
EINVAL Thehowargument is invalid.
```
```
You can¡¯t block theSIGKILLandSIGSTOPsignals, but if the signal set includes these,
sigprocmaskjust ignores them instead of returning an error status.
```
```
Remember, too, that blocking program error signals such asSIGFPE leads to un-
desirable results for signals generated by an actual program error (as opposed to
signals sent withraiseorkill). This is because your program may be too broken
to be able to continue executing to a point where the signal is unblocked again. See
Section 24.2.1 [Program Error Signals], page 716.
```
## 24.7.4 Blocking to Test for Delivery of a Signal................

Now for a simple example. Suppose you establish a handler forSIGALRMsignals that sets a
flag whenever a signal arrives, and your main program checks this flag from time to time and
then resets it. You can prevent additionalSIGALRMsignals from arriving in the meantime
by wrapping the critical part of the code with calls tosigprocmask, like this:

```
/*This variable is set by the SIGALRM signal handler.*/
volatile sig_atomic_t flag = 0;
```
```
int
main (void)
{
sigset_t block_alarm;
```
```
...
```
```
/*Initialize the signal mask.*/
sigemptyset (&block_alarm);
sigaddset (&block_alarm, SIGALRM);
```

Chapter 24: Signal Handling 750

```
while (1)
{
/*Check if a signal has arrived; if so, reset the flag.*/
sigprocmask (SIG_BLOCK, &block_alarm, NULL);
if (flag)
{
actions-if-not-arrived
flag = 0;
}
sigprocmask (SIG_UNBLOCK, &block_alarm, NULL);
```
```
}
}
```
## 24.7.5 Blocking Signals for a Handler..........................

When a signal handler is invoked, you usually want it to be able to finish without being
interrupted by another signal. From the moment the handler starts until the moment it
finishes, you must block signals that might confuse it or corrupt its data.

When a handler function is invoked on a signal, that signal is automatically blocked (in
addition to any other signals that are already in the process¡¯s signal mask) during the time
the handler is running. If you set up a handler forSIGTSTP, for instance, then the arrival
of that signal forces furtherSIGTSTPsignals to wait during the execution of the handler.

However, by default, other kinds of signals are not blocked; they can arrive during
handler execution.

The reliable way to block other kinds of signals during the execution of the handler is
to use thesa_maskmember of thesigactionstructure.

```
Here is an example:
#include <signal.h>
#include <stddef.h>
```
```
void catch_stop ();
```
```
void
install_handler (void)
{
struct sigaction setup_action;
sigset_t block_mask;
```
sigemptyset (&block_mask);
/*Block other terminal-generated signals while handler runs.*/
sigaddset (&block_mask, SIGINT);
sigaddset (&block_mask, SIGQUIT);
setup_action.sa_handler = catch_stop;
setup_action.sa_mask = block_mask;
setup_action.sa_flags = 0;
sigaction (SIGTSTP, &setup_action, NULL);
}
This is more reliable than blocking the other signals explicitly in the code for the handler.
If you block signals explicitly in the handler, you can¡¯t avoid at least a short interval at the
beginning of the handler where they are not yet blocked.


Chapter 24: Signal Handling 751

You cannot remove signals from the process¡¯s current mask using this mechanism. How-
ever, you can make calls tosigprocmaskwithin your handler to block or unblock signals
as you wish.

In any case, when the handler returns, the system restores the mask that was in place
before the handler was entered. If any signals that become unblocked by this restoration
are pending, the process will receive those signals immediately, before returning to the code
that was interrupted.

## 24.7.6 Checking for Pending Signals...........................

You can find out which signals are pending at any time by callingsigpending. This function
is declared insignal.h.

int sigpending(sigsett *set) [Function]
Preliminary: |MT-Safe | AS-Unsafe lock/hurd |AC-Unsafe lock/hurd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesigpendingfunction stores information about pending signals inset. If there is
a pending signal that is blocked from delivery, then that signal is a member of the
returned set. (You can test whether a particular signal is a member of this set using
sigismember; seeSection 24.7.2 [Signal Sets], page 747.)
The return value is 0 if successful, and-1on failure.

Testing whether a signal is pending is not often useful. Testing when that signal is not
blocked is almost certainly bad design.

```
Here is an example.
#include <signal.h>
#include <stddef.h>
```
```
sigset_t base_mask, waiting_mask;
```
```
sigemptyset (&base_mask);
sigaddset (&base_mask, SIGINT);
sigaddset (&base_mask, SIGTSTP);
```
```
/*Block user interrupts while doing other processing.*/
sigprocmask (SIG_SETMASK, &base_mask, NULL);
...
```
/*After a while, check to see whether any signals are pending.*/
sigpending (&waiting_mask);
if (sigismember (&waiting_mask, SIGINT)) {
/*User has tried to kill the process.*/
}
else if (sigismember (&waiting_mask, SIGTSTP)) {
/*User has tried to stop the process.*/
}
Remember that if there is a particular signal pending for your process, additional signals
of that same type that arrive in the meantime might be discarded. For example, if aSIGINT
signal is pending when anotherSIGINTsignal arrives, your program will probably only see
one of them when you unblock this signal.

Portability Note:Thesigpendingfunction is new in POSIX.1. Older systems have no
equivalent facility.


Chapter 24: Signal Handling 752

## 24.7.7 Remembering a Signal to Act On Later.................

Instead of blocking a signal using the library facilities, you can get almost the same results
by making the handler set a flag to be tested later, when you ¡°unblock¡±. Here is an example:

```
/*If this flag is nonzero, don¡¯t handle the signal right away.*/
volatile sig_atomic_t signal_pending;
```
```
/*This is nonzero if a signal arrived and was not handled.*/
volatile sig_atomic_t defer_signal;
```
```
void
handler (int signum)
{
if (defer_signal)
signal_pending = signum;
else
... /*¡®¡®Really¡± handle the signal.*/
}
```
```
...
```
```
void
update_mumble (int frob)
{
/*Prevent signals from having immediate effect.*/
defer_signal++;
/*Now updatemumble, without worrying about interruption.*/
mumble.a = 1;
mumble.b = hack ();
mumble.c = frob;
/*We have updatedmumble. Handle any signal that came in.*/
defer_signal--;
if (defer_signal == 0 && signal_pending != 0)
raise (signal_pending);
}
```
Note how the particular signal that arrives is stored insignal_pending. That way, we
can handle several types of inconvenient signals with the same mechanism.

We increment and decrementdefer_signalso that nested critical sections will work
properly; thus, ifupdate_mumblewere called withsignal_pendingalready nonzero, signals
would be deferred not only withinupdate_mumble, but also within the caller. This is also
why we do not checksignal_pendingifdefer_signalis still nonzero.

The incrementing and decrementing ofdefer_signaleach require more than one in-
struction; it is possible for a signal to happen in the middle. But that does not cause any
problem. If the signal happens early enough to see the value from before the increment or
decrement, that is equivalent to a signal which came before the beginning of the increment
or decrement, which is a case that works properly.

It is absolutely vital to decrementdefer_signalbefore testingsignal_pending, be-
cause this avoids a subtle bug. If we did these things in the other order, like this,

```
if (defer_signal == 1 && signal_pending != 0)
raise (signal_pending);
defer_signal--;
```

Chapter 24: Signal Handling 753

then a signal arriving in between theifstatement and the decrement would be effectively
¡°lost¡± for an indefinite amount of time. The handler would merely setdefer_signal, but
the program having already tested this variable, it would not test the variable again.

Bugs like these are calledtiming errors. They are especially bad because they happen
only rarely and are nearly impossible to reproduce. You can¡¯t expect to find them with a
debugger as you would find a reproducible bug. So it is worth being especially careful to
avoid them.

(You would not be tempted to write the code in this order, given the use ofdefer_
signalas a counter which must be tested along withsignal_pending. After all, testing
for zero is cleaner than testing for one. But if you did not usedefer_signalas a counter,
and gave it values of zero and one only, then either order might seem equally simple. This
is a further advantage of using a counter fordefer_signal: it will reduce the chance you
will write the code in the wrong order and create a subtle bug.)

## 24.8 Waiting for a Signal.........................................

If your program is driven by external events, or uses signals for synchronization, then when
it has nothing to do it should probably wait until a signal arrives.

## 24.8.1 Usingpause............................................

The simple way to wait until a signal arrives is to callpause. Please read about its disad-
vantages, in the following section, before you use it.

int pause (void) [Function]
Preliminary:|MT-Unsafe race:sigprocmask/!bsd!linux|AS-Unsafe lock/hurd|AC-
Unsafe lock/hurd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thepausefunction suspends program execution until a signal arrives whose action
is either to execute a handler function, or to terminate the process.
If the signal causes a handler function to be executed, thenpausereturns. This is
considered an unsuccessful return (since ¡°successful¡± behavior would be to suspend the
program forever), so the return value is-1. Even if you specify that other primitives
should resume when a system handler returns (seeSection 24.5 [Primitives Interrupted
by Signals], page 741), this has no effect onpause; it always fails when a signal is
handled.
The followingerrnoerror conditions are defined for this function:

```
EINTR The function was interrupted by delivery of a signal.
```
```
If the signal causes program termination,pausedoesn¡¯t return (obviously).
This function is a cancellation point in multithreaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timepauseis called. If the thread gets cancelled these resources stay
allocated until the program ends. To avoid this calls topauseshould be protected
using cancellation handlers.
Thepausefunction is declared inunistd.h.
```

Chapter 24: Signal Handling 754

24.8.2 Problems withpause

The simplicity ofpausecan conceal serious timing errors that can make a program hang
mysteriously.

It is safe to usepauseif the real work of your program is done by the signal handlers
themselves, and the ¡°main program¡± does nothing but callpause. Each time a signal is
delivered, the handler will do the next batch of work that is to be done, and then return,
so that the main loop of the program can callpauseagain.

You can¡¯t safely usepauseto wait until one more signal arrives, and then resume real
work. Even if you arrange for the signal handler to cooperate by setting a flag, you still
can¡¯t usepausereliably. Here is an example of this problem:
/* usr_interruptis set by the signal handler. */
if (!usr_interrupt)
pause ();

```
/*Do work once the signal arrives. */
```
This has a bug: the signal could arrive after the variableusr_interruptis checked, but
before the call topause. If no further signals arrive, the process would never wake up again.

You can put an upper limit on the excess waiting by usingsleepin a loop, instead of
usingpause. (SeeSection 21.7 [Sleeping], page 682, for more aboutsleep.) Here is what
this looks like:
/* usr_interruptis set by the signal handler.
while (!usr_interrupt)
sleep (1);

```
/*Do work once the signal arrives. */
```
For some purposes, that is good enough. But with a little more complexity, you can
wait reliably until a particular signal handler is run, usingsigsuspend.

## 24.8.3 Usingsigsuspend......................................

The clean and reliable way to wait for a signal to arrive is to block it and then use
sigsuspend. By usingsigsuspendin a loop, you can wait for certain kinds of signals,
while letting other kinds of signals be handled by their handlers.

int sigsuspend(const sigsett *set) [Function]
Preliminary:|MT-Unsafe race:sigprocmask/!bsd!linux|AS-Unsafe lock/hurd|AC-
Unsafe lock/hurd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function replaces the process¡¯s signal mask withset and then suspends the
process until a signal is delivered whose action is either to terminate the process or
invoke a signal handling function. In other words, the program is effectively suspended
until one of the signals that is not a member ofsetarrives.
If the process is woken up by delivery of a signal that invokes a handler function, and
the handler function returns, thensigsuspendalso returns.
The mask remains set only as long as sigsuspend is waiting. The function
sigsuspendalways restores the previous signal mask when it returns.
The return value and error conditions are the same as forpause.


Chapter 24: Signal Handling 755

Withsigsuspend, you can replace thepauseorsleeploop in the previous section with
something completely reliable:
sigset_t mask, oldmask;

```
/*Set up the mask of signals to temporarily block.*/
sigemptyset (&mask);
sigaddset (&mask, SIGUSR1);
```
/*Wait for a signal to arrive.*/
sigprocmask (SIG_BLOCK, &mask, &oldmask);
while (!usr_interrupt)
sigsuspend (&oldmask);
sigprocmask (SIG_UNBLOCK, &mask, NULL);
This last piece of code is a little tricky. The key point to remember here is that when
sigsuspendreturns, it resets the process¡¯s signal mask to the original value, the value from
before the call tosigsuspend¡ªin this case, theSIGUSR1signal is once again blocked. The
second call tosigprocmaskis necessary to explicitly unblock this signal.

One other point: you may be wondering why thewhileloop is necessary at all, since the
program is apparently only waiting for oneSIGUSR1signal. The answer is that the mask
passed tosigsuspendpermits the process to be woken up by the delivery of other kinds
of signals, as well¡ªfor example, job control signals. If the process is woken up by a signal
that doesn¡¯t setusr_interrupt, it just suspends itself again until the ¡°right¡± kind of signal
eventually arrives.

This technique takes a few more lines of preparation, but that is needed just once for
each kind of wait criterion you want to use. The code that actually waits is just four lines.

## 24.9 Using a Separate Signal Stack...............................

A signal stack is a special area of memory to be used as the execution stack during signal
handlers. It should be fairly large, to avoid any danger that it will overflow in turn; the
macroSIGSTKSZis defined to a canonical size for signal stacks. You can usemallocto
allocate the space for the stack. Then callsigaltstackorsigstackto tell the system to
use that space for the signal stack.

You don¡¯t need to write signal handlers differently in order to use a signal stack. Switch-
ing from one stack to the other happens automatically. (Some non-GNU debuggers on some
machines may get confused if you examine a stack trace while a handler that uses the signal
stack is running.)

There are two interfaces for telling the system to use a separate signal stack.sigstack
is the older interface, which comes from 4.2 BSD.sigaltstackis the newer interface, and
comes from 4.4 BSD. Thesigaltstackinterface has the advantage that it does not require
your program to know which direction the stack grows, which depends on the specific
machine and operating system.

stack_t [Data Type]
This structure describes a signal stack. It contains the following members:


Chapter 24: Signal Handling 756

```
void *ss_sp
This points to the base of the signal stack.
size_t ss_size
This is the size (in bytes) of the signal stack which ¡®ss_sp¡¯ points to. You
should set this to however much space you allocated for the stack.
There are two macros defined insignal.hthat you should use in calcu-
lating this size:
SIGSTKSZ This is the canonical size for a signal stack. It is judged to
be sufficient for normal uses.
MINSIGSTKSZ
This is the amount of signal stack space the operating system
needs just to implement signal delivery. The size of a signal
stackmustbe greater than this.
For most cases, just usingSIGSTKSZforss_sizeis sufficient.
But if you know how much stack space your program¡¯s signal
handlers will need, you may want to use a different size. In
this case, you should allocateMINSIGSTKSZadditional bytes
for the signal stack and increasess_sizeaccordingly.
int ss_flags
This field contains the bitwiseorof these flags:
SS_DISABLE
This tells the system that it should not use the signal stack.
SS_ONSTACK
This is set by the system, and indicates that the signal stack
is currently in use. If this bit is not set, then signals will be
delivered on the normal user stack.
```
int sigaltstack (const stackt *restrictstack, stack t *restrict [Function]
oldstack)
Preliminary: |MT-Safe | AS-Unsafe lock/hurd |AC-Unsafe lock/hurd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesigaltstackfunction specifies an alternate stack for use during signal handling.
When a signal is received by the process and its action indicates that the signal stack
is used, the system arranges a switch to the currently installed signal stack while the
handler for that signal is executed.
Ifoldstackis not a null pointer, information about the currently installed signal stack
is returned in the location it points to. Ifstack is not a null pointer, then this is
installed as the new stack for use by signal handlers.
The return value is 0 on success and-1on failure. Ifsigaltstackfails, it setserrno
to one of these values:
EINVAL You tried to disable a stack that was in fact currently in use.
ENOMEM The size of the alternate stack was too small. It must be greater than
MINSIGSTKSZ.


Chapter 24: Signal Handling 757

Here is the oldersigstackinterface. You should usesigaltstackinstead on systems
that have it.

struct sigstack [Data Type]
This structure describes a signal stack. It contains the following members:

```
void *ss_sp
This is the stack pointer. If the stack grows downwards on your machine,
this should point to the top of the area you allocated. If the stack grows
upwards, it should point to the bottom.
```
```
int ss_onstack
This field is true if the process is currently using this stack.
```
int sigstack (struct sigstack *stack, struct sigstack *oldstack) [Function]
Preliminary: |MT-Safe | AS-Unsafe lock/hurd |AC-Unsafe lock/hurd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesigstackfunction specifies an alternate stack for use during signal handling.
When a signal is received by the process and its action indicates that the signal stack
is used, the system arranges a switch to the currently installed signal stack while the
handler for that signal is executed.
Ifoldstackis not a null pointer, information about the currently installed signal stack
is returned in the location it points to. Ifstack is not a null pointer, then this is
installed as the new stack for use by signal handlers.
The return value is 0 on success and-1on failure.

## 24.10 BSD Signal Handling.......................................

This section describes alternative signal handling functions derived from BSD Unix. These
facilities were an advance, in their time; today, they are mostly obsolete, and supported
mainly for compatibility with BSD Unix.

There are many similarities between the BSD and POSIX signal handling facilities,
because the POSIX facilities were inspired by the BSD facilities. Besides having different
names for all the functions to avoid conflicts, the main difference between the two is that
BSD Unix represents signal masks as anintbit mask, rather than as asigset_tobject.

```
The BSD facilities are declared insignal.h.
```
int siginterrupt (intsignum, intfailflag) [Function]
Preliminary: |MT-Unsafe const:sigintr|AS-Unsafe |AC-Unsafe corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function specifies which approach to use when certain primitives are interrupted
by handling signalsignum. Iffailflag is false, signalsignumrestarts primitives. If
failflagis true, handlingsignumcauses these primitives to fail with error codeEINTR.
SeeSection 24.5 [Primitives Interrupted by Signals], page 741.
This function has been replaced by theSA_RESTARTflag of thesigactionfunction.
SeeSection 24.3.2 [Advanced Signal Handling], page 727.


Chapter 24: Signal Handling 758

int sigmask(intsignum) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a signal mask that has the bit for signalsignumset. You can
bitwise-OR the results of several calls tosigmasktogether to specify more than one
signal. For example,
(sigmask (SIGTSTP) | sigmask (SIGSTOP)
| sigmask (SIGTTIN) | sigmask (SIGTTOU))
specifies a mask that includes all the job-control stop signals.
This macro has been replaced by thesigset_ttype and the associated signal set
manipulation functions. SeeSection 24.7.2 [Signal Sets], page 747.

int sigblock (intmask) [Function]
Preliminary: |MT-Safe | AS-Unsafe lock/hurd |AC-Unsafe lock/hurd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is equivalent tosigprocmask(seeSection 24.7.3 [Process Signal Mask],
page 748) with ahowargument ofSIG_BLOCK: it adds the signals specified bymask
to the calling process¡¯s set of blocked signals. The return value is the previous set of
blocked signals.

int sigsetmask(intmask) [Function]
Preliminary: |MT-Safe | AS-Unsafe lock/hurd |AC-Unsafe lock/hurd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is equivalent tosigprocmask(seeSection 24.7.3 [Process Signal Mask],
page 748) with ahowargument ofSIG_SETMASK: it sets the calling process¡¯s signal
mask tomask. The return value is the previous set of blocked signals.

int sigpause (intmask) [Function]
Preliminary:|MT-Unsafe race:sigprocmask/!bsd!linux|AS-Unsafe lock/hurd|AC-
Unsafe lock/hurd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is the equivalent ofsigsuspend(seeSection 24.8 [Waiting for a Signal],
page 753): it sets the calling process¡¯s signal mask tomask, and waits for a signal to
arrive. On return the previous set of blocked signals is restored.


### 759

## 25 The Basic Program/System Interface......

## 25 The Basic Program/System Interface....................

Processesare the primitive units for allocation of system resources. Each process has its
own address space and (usually) one thread of control. A process executes a program; you
can have multiple processes executing the same program, but each process has its own copy
of the program within its own address space and executes it independently of the other
copies. Though it may have multiple threads of control within the same program and a
program may be composed of multiple logically separate modules, a process always executes
exactly one program.

Note that we are using a specific definition of ¡°program¡± for the purposes of this manual,
which corresponds to a common definition in the context of Unix systems. In popular usage,
¡°program¡± enjoys a much broader definition; it can refer for example to a system¡¯s kernel,
an editor macro, a complex package of software, or a discrete section of code executing
within a process.

Writing the program is what this manual is all about. This chapter explains the most
basic interface between your program and the system that runs, or calls, it. This includes
passing of parameters (arguments and environment) from the system, requesting basic ser-
vices from the system, and telling the system the program is done.

A program starts another program with theexecfamily of system calls. This chapter
looks at program startup from the execee¡¯s point of view. To see the event from the execor¡¯s
point of view, seeSection 26.5 [Executing a File], page 806.

## 25.1 Program Arguments.........................................

The system starts a C program by calling the functionmain. It is up to you to write a
function namedmain¡ªotherwise, you won¡¯t even be able to link your program without
errors.

In ISO C you can definemaineither to take no arguments, or to take two arguments
that represent the command line arguments to the program, like this:
int main (intargc, char *argv[])
The command line arguments are the whitespace-separated tokens given in the shell
command used to invoke the program; thus, in ¡®cat foo bar¡¯, the arguments are ¡®foo¡¯ and
¡®bar¡¯. The only way a program can look at its command line arguments is via the arguments
ofmain. Ifmaindoesn¡¯t take arguments, then you cannot get at the command line.

The value of theargcargument is the number of command line arguments. Theargv
argument is a vector of C strings; its elements are the individual command line argument
strings. The file name of the program being run is also included in the vector as the
first element; the value ofargccounts this element. A null pointer always follows the last
element:argv[argc]is this null pointer.

For the command ¡®cat foo bar¡¯,argcis 3 andargvhas three elements,"cat","foo"
and"bar".

In Unix systems you can definemaina third way, using three arguments:
int main (intargc, char *argv[], char *envp[])
The first two arguments are just the same. The third argumentenvpgives the program¡¯s
environment; it is the same as the value ofenviron. SeeSection 25.4 [Environment Vari-


Chapter 25: The Basic Program/System Interface 760

ables], page 792. POSIX.1 does not allow this three-argument form, so to be portable it is
best to writemainto take two arguments, and use the value ofenviron.

## 25.1.1 Program Argument Syntax Conventions................

POSIX recommends these conventions for command line arguments. getopt (see
Section 25.2 [Parsing program options using getopt], page 761) and argp_parse (see
Section 25.3 [Parsing Program Options with Argp], page 768) make it easy to implement
them.

- Arguments are options if they begin with a hyphen delimiter (¡®-¡¯).
- Multiple options may follow a hyphen delimiter in a single token if the options do not
    take arguments. Thus, ¡®-abc¡¯ is equivalent to ¡®-a -b -c¡¯.
- Option names are single alphanumeric characters (as forisalnum; seeSection 4.1 [Clas-
    sification of Characters], page 87).
- Certain options require an argument. For example, the-ooption of theldcommand
    requires an argument¡ªan output file name.
- An option and its argument may or may not appear as separate tokens. (In other words,
    the whitespace separating them is optional.) Thus,-o fooand-ofooare equivalent.
- Options typically precede other non-option arguments.
    The implementations ofgetoptandargp_parsein the GNU C Library normally make
    it appear as if all the option arguments were specified before all the non-option argu-
    ments for the purposes of parsing, even if the user of your program intermixed option
    and non-option arguments. They do this by reordering the elements of theargvarray.
    This behavior is nonstandard; if you want to suppress it, define the_POSIX_OPTION_
    ORDERenvironment variable. See Section 25.4.2 [Standard Environment Variables],
    page 795.
- The argument--terminates all options; any following arguments are treated as non-
    option arguments, even if they begin with a hyphen.
- A token consisting of a single hyphen character is interpreted as an ordinary non-option
    argument. By convention, it is used to specify input from or output to the standard
    input and output streams.
- Options may be supplied in any order, or appear multiple times. The interpretation is
    left up to the particular application program.

GNU addslong optionsto these conventions. Long options consist of--followed by
a name made of alphanumeric characters and dashes. Option names are typically one to
three words long, with hyphens to separate words. Users can abbreviate the option names
as long as the abbreviations are unique.

To specify an argument for a long option, write--name=value. This syntax enables a
long option to accept an argument that is itself optional.

```
Eventually, GNU systems will provide completion for long option names in the shell.
```
## 25.1.2 Parsing Program Arguments............................

If the syntax for the command line arguments to your program is simple enough, you can
simply pick the arguments off fromargvby hand. But unless your program takes a fixed


Chapter 25: The Basic Program/System Interface 761

number of arguments, or all of the arguments are interpreted in the same way (as file names,
for example), you are usually better off usinggetopt(seeSection 25.2 [Parsing program
options usinggetopt], page 761) orargp_parse(seeSection 25.3 [Parsing Program Options
with Argp], page 768) to do the parsing.

getoptis more standard (the short-option only version of it is a part of the POSIX
standard), but usingargp_parseis often easier, both for very simple and very complex
option structures, because it does more of the dirty work for you.

## 25.2 Parsing program options usinggetopt.......................

Thegetoptandgetopt_longfunctions automate some of the chore involved in parsing
typical unix command line options.

## 25.2.1 Using thegetoptfunction..............................

Here are the details about how to call thegetoptfunction. To use this facility, your program
must include the header fileunistd.h.

int opterr [Variable]
If the value of this variable is nonzero, thengetoptprints an error message to the
standard error stream if it encounters an unknown option character or an option with
a missing required argument. This is the default behavior. If you set this variable
to zero,getoptdoes not print any messages, but it still returns the character?to
indicate an error.

int optopt [Variable]
Whengetoptencounters an unknown option character or an option with a missing
required argument, it stores that option character in this variable. You can use this
for providing your own diagnostic messages.

int optind [Variable]
This variable is set bygetoptto the index of the next element of theargvarray to
be processed. Oncegetopthas found all of the option arguments, you can use this
variable to determine where the remaining non-option arguments begin. The initial
value of this variable is 1.

char * optarg [Variable]
This variable is set bygetoptto point at the value of the option argument, for those
options that accept arguments.

int getopt(intargc, char *const *argv, const char *options) [Function]
Preliminary: |MT-Unsafe race:getopt env|AS-Unsafe heap i18n lock corrupt|
AC-Unsafe mem lock corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetoptfunction gets the next option argument from the argument list specified
by theargv andargc arguments. Normally these values come directly from the
arguments received bymain.
Theoptionsargument is a string that specifies the option characters that are valid
for this program. An option character in this string can be followed by a colon (¡®:¡¯)


Chapter 25: The Basic Program/System Interface 762

```
to indicate that it takes a required argument. If an option character is followed by
two colons (¡®::¡¯), its argument is optional; this is a GNU extension.
```
```
getopthas three ways to deal with options that follow non-optionsargvelements.
The special argument ¡®--¡¯ forces in all cases the end of option scanning.
```
- The default is to permute the contents ofargvwhile scanning it so that eventually
    all the non-options are at the end. This allows options to be given in any order,
    even with programs that were not written to expect this.
- If theoptionsargument string begins with a hyphen (¡®-¡¯), this is treated specially.
    It permits arguments that are not options to be returned as if they were associated
    with option character ¡®\1¡¯.
- POSIX demands the following behavior: the first non-option stops option
    processing. This mode is selected by either setting the environment variable
    POSIXLY_CORRECTor beginning theoptions argument string with a plus sign
    (¡®+¡¯).

```
Thegetoptfunction returns the option character for the next command line option.
When no more option arguments are available, it returns-1. There may still be more
non-option arguments; you must compare the external variableoptindagainst the
argcparameter to check this.
```
```
If the option has an argument,getopt returns the argument by storing it in the
variableoptarg. You don¡¯t ordinarily need to copy theoptargstring, since it is a
pointer into the originalargvarray, not into a static area that might be overwritten.
```
```
Ifgetoptfinds an option character inargvthat was not included inoptions, or a
missing option argument, it returns ¡®?¡¯ and sets the external variableoptoptto the
actual option character. If the first character ofoptionsis a colon (¡®:¡¯), thengetopt
returns ¡®:¡¯ instead of ¡®?¡¯ to indicate a missing option argument. In addition, if the
external variableopterris nonzero (which is the default),getoptprints an error
message.
```
## 25.2.2 Example of Parsing Arguments withgetopt............

Here is an example showing howgetoptis typically used. The key points to notice are:

- Normally,getoptis called in a loop. Whengetoptreturns-1, indicating no more
    options are present, the loop terminates.
- Aswitchstatement is used to dispatch on the return value fromgetopt. In typical
    use, each case just sets a variable that is used later in the program.
- A second loop is used to process the remaining non-option arguments.


Chapter 25: The Basic Program/System Interface 763

```
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
```
```
int
main (int argc, char **argv)
{
int aflag = 0;
int bflag = 0;
char *cvalue = NULL;
int index;
int c;
```
```
opterr = 0;
```
```
while ((c = getopt (argc, argv, "abc:")) != -1)
switch (c)
{
case 'a':
aflag = 1;
break;
case 'b':
bflag = 1;
break;
case 'c':
cvalue = optarg;
break;
case '?':
if (optopt == 'c')
fprintf (stderr, "Option -%c requires an argument.\n", optopt);
else if (isprint (optopt))
fprintf (stderr, "Unknown option `-%c'.\n", optopt);
else
fprintf (stderr,
"Unknown option character `\\x%x'.\n",
optopt);
return 1;
default:
abort ();
}
```
```
printf ("aflag = %d, bflag = %d, cvalue = %s\n",
aflag, bflag, cvalue);
```
```
for (index = optind; index < argc; index++)
printf ("Non-option argument %s\n", argv[index]);
return 0;
}
```
Here are some examples showing what this program prints with different combinations
of arguments:

```
% testopt
aflag = 0, bflag = 0, cvalue = (null)
```
```
% testopt -a -b
aflag = 1, bflag = 1, cvalue = (null)
```

Chapter 25: The Basic Program/System Interface 764

```
% testopt -ab
aflag = 1, bflag = 1, cvalue = (null)
```
```
% testopt -c foo
aflag = 0, bflag = 0, cvalue = foo
```
```
% testopt -cfoo
aflag = 0, bflag = 0, cvalue = foo
```
```
% testopt arg1
aflag = 0, bflag = 0, cvalue = (null)
Non-option argument arg1
```
```
% testopt -a arg1
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument arg1
```
```
% testopt -c foo arg1
aflag = 0, bflag = 0, cvalue = foo
Non-option argument arg1
```
```
% testopt -a -- -b
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument -b
```
```
% testopt -a -
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument -
```
## 25.2.3 Parsing Long Options withgetopt_long...............

To accept GNU-style long options as well as single-character options, usegetopt_long
instead ofgetopt. This function is declared ingetopt.h, notunistd.h. You should make
every program accept long options if it uses any options, for this takes little extra work and
helps beginners remember how to use the program.

struct option [Data Type]
This structure describes a single long option name for the sake ofgetopt_long. The
argumentlongoptsmust be an array of these structures, one for each long option.
Terminate the array with an element containing all zeros.
Thestruct optionstructure has these fields:
const char *name
This field is the name of the option. It is a string.
int has_arg
This field says whether the option takes an argument. It is an integer,
and there are three legitimate values:no_argument,required_argument
andoptional_argument.
int *flag
int val These fields control how to report or act on the option when it occurs.
If flagis a null pointer, then theval is a value which identifies this
option. Often these values are chosen to uniquely identify particular long
options.


Chapter 25: The Basic Program/System Interface 765

```
Ifflagis not a null pointer, it should be the address of anintvariable
which is the flag for this option. The value invalis the value to store in
the flag to indicate that the option was seen.
```
int getopt_long (intargc, char *const *argv, const char [Function]
*shortopts, const struct option *longopts, int *indexptr)
Preliminary: |MT-Unsafe race:getopt env|AS-Unsafe heap i18n lock corrupt|
AC-Unsafe mem lock corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Decode options from the vectorargv(whose length isargc). The argumentshortopts
describes the short options to accept, just as it does ingetopt. The argumentlongopts
describes the long options to accept (see above).
Whengetopt_longencounters a short option, it does the same thing thatgetopt
would do: it returns the character code for the option, and stores the option¡¯s argu-
ment (if it has one) inoptarg.
Whengetopt_longencounters a long option, it takes actions based on theflagand
valfields of the definition of that option.
Ifflagis a null pointer, thengetopt_longreturns the contents ofvalto indicate
which option it found. You should arrange distinct values in thevalfield for options
with different meanings, so you can decode these values aftergetopt_longreturns.
If the long option is equivalent to a short option, you can use the short option¡¯s
character code inval.
Ifflagis not a null pointer, that means this option should just set a flag in the
program. The flag is a variable of typeintthat you define. Put the address of the
flag in theflagfield. Put in thevalfield the value you would like this option to
store in the flag. In this case,getopt_longreturns 0.
For any long option,getopt_longtells you the index in the arraylongoptsof the
options definition, by storing it into*indexptr. You can get the name of the option
withlongopts[*indexptr].name. So you can distinguish among long options either
by the values in theirvalfields or by their indices. You can also distinguish in this
way among long options that set flags.
When a long option has an argument,getopt_longputs the argument value in the
variableoptargbefore returning. When the option has no argument, the value in
optargis a null pointer. This is how you can tell whether an optional argument was
supplied.
Whengetopt_longhas no more options to handle, it returns-1, and leaves in the
variableoptindthe index inargvof the next remaining argument.

Since long option names were used beforegetopt_longwas invented there are pro-
gram interfaces which require programs to recognize options like ¡®-option value¡¯ instead
of ¡®--option value¡¯. To enable these programs to use the GNU getopt functionality there
is one more function available.

int getopt_long_only(intargc, char *const *argv, const char [Function]
*shortopts, const struct option *longopts, int *indexptr)
Preliminary: |MT-Unsafe race:getopt env|AS-Unsafe heap i18n lock corrupt|
AC-Unsafe mem lock corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 25: The Basic Program/System Interface 766

```
Thegetopt_long_onlyfunction is equivalent to thegetopt_longfunction but it
allows the user of the application to pass long options with only ¡®-¡¯ instead of ¡®--¡¯.
The ¡®--¡¯ prefix is still recognized but instead of looking through the short options if
a ¡®-¡¯ is seen it is first tried whether this parameter names a long option. If not, it is
parsed as a short option.
Assuminggetopt_long_onlyis used starting an application with
app -foo
thegetopt_long_onlywill first look for a long option named ¡®foo¡¯. If this is not
found, the short options ¡®f¡¯, ¡®o¡¯, and again ¡®o¡¯ are recognized.
```
## 25.2.4 Example of Parsing Long Options withgetopt_long....

```
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
```
```
/*Flag set by ¡®--verbose¡¯.*/
static int verbose_flag;
```
```
int
main (int argc, char **argv)
{
int c;
```
```
while (1)
{
static struct option long_options[] =
{
/*These options set a flag.*/
{"verbose", no_argument, &verbose_flag, 1},
{"brief", no_argument, &verbose_flag, 0},
/*These options don¡¯t set a flag.
We distinguish them by their indices.*/
{"add", no_argument, 0, 'a'},
{"append", no_argument, 0, 'b'},
{"delete", required_argument, 0, 'd'},
{"create", required_argument, 0, 'c'},
{"file", required_argument, 0, 'f'},
{0, 0, 0, 0}
};
/* getopt_longstores the option index here.*/
int option_index = 0;
```
```
c = getopt_long (argc, argv, "abc:d:f:",
long_options, &option_index);
```
```
/*Detect the end of the options.*/
if (c == -1)
break;
```
```
switch (c)
{
case 0:
/*If this option set a flag, do nothing else now.*/
if (long_options[option_index].flag != 0)
```

Chapter 25: The Basic Program/System Interface 767

```
break;
printf ("option %s", long_options[option_index].name);
if (optarg)
printf (" with arg %s", optarg);
printf ("\n");
break;
```
```
case 'a':
puts ("option -a\n");
break;
```
```
case 'b':
puts ("option -b\n");
break;
```
```
case 'c':
printf ("option -c with value `%s'\n", optarg);
break;
```
```
case 'd':
printf ("option -d with value `%s'\n", optarg);
break;
```
```
case 'f':
printf ("option -f with value `%s'\n", optarg);
break;
```
```
case '?':
/* getopt_longalready printed an error message.*/
break;
```
```
default:
abort ();
}
}
```
```
/*Instead of reporting ¡®--verbose¡¯
and ¡®--brief¡¯ as they are encountered,
we report the final status resulting from them.*/
if (verbose_flag)
puts ("verbose flag is set");
```
```
/*Print any remaining command line arguments (not options).*/
if (optind < argc)
{
printf ("non-option ARGV-elements: ");
while (optind < argc)
printf ("%s ", argv[optind++]);
putchar ('\n');
}
```
```
exit (0);
}
```

Chapter 25: The Basic Program/System Interface 768

## 25.3 Parsing Program Options with Argp.........................

Argpis an interface for parsing unix-style argument vectors. SeeSection 25.1 [Program
Arguments], page 759.

Argp provides features unavailable in the more commonly used getopt interface.
These features include automatically producing output in response to the ¡®--help¡¯ and
¡®--version¡¯ options, as described in the GNU coding standards. Using argp makes it less
likely that programmers will neglect to implement these additional options or keep them
up to date.

Argp also provides the ability to merge several independently defined option parsers into
one, mediating conflicts between them and making the result appear seamless. A library
can export an argp option parser that user programs might employ in conjunction with
their own option parsers, resulting in less work for the user programs. Some programs may
use only argument parsers exported by libraries, thereby achieving consistent and efficient
option-parsing for abstractions implemented by the libraries.

```
The header file<argp.h>should be included to use argp.
```
## 25.3.1 Theargp_parseFunction..............................

The main interface to argp is theargp_parsefunction. In many cases, callingargp_parse
is the only argument-parsing code needed inmain. SeeSection 25.1 [Program Arguments],
page 759.

error_t argp_parse(const struct argp *argp, intargc, char [Function]
**argv, unsignedflags, int *arg_index, void *input)
Preliminary:|MT-Unsafe race:argpbuf locale env|AS-Unsafe heap i18n lock corrupt
|AC-Unsafe mem lock corrupt|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theargp_parsefunction parses the arguments inargv, of lengthargc, using the argp
parserargp. SeeSection 25.3.3 [Specifying Argp Parsers], page 769. Passing a null
pointer forargpis the same as using astruct argpcontaining all zeros.
flagsis a set of flag bits that modify the parsing behavior. SeeSection 25.3.7 [Flags
forargp_parse], page 778.inputis passed through to the argp parserargp, and has
meaning defined byargp. A typical usage is to pass a pointer to a structure which is
used for specifying parameters to the parser and passing back the results.
Unless theARGP_NO_EXITorARGP_NO_HELPflags are included inflags, callingargp_
parsemay result in the program exiting. This behavior is true if an error is detected,
or when an unknown option is encountered. SeeSection 25.7 [Program Termination],
page 798.
Ifargindexis non-null, the index of the first unparsed option inargvis returned as
a value.
The return value is zero for successful parsing, or an error code (seeSection 2.2 [Error
Codes], page 24) if an error is detected. Different argp parsers may return arbitrary
error codes, but the standard error codes are: ENOMEMif a memory allocation error
occurred, orEINVALif an unknown option or option argument is encountered.


Chapter 25: The Basic Program/System Interface 769

## 25.3.2 Argp Global Variables..................................

These variables make it easy for user programs to implement the ¡®--version¡¯ option and
provide a bug-reporting address in the ¡®--help¡¯ output. These are implemented in argp by
default.

const char * argp_program_version [Variable]
If defined or set by the user program to a non-zero value, then a ¡®--version¡¯ option
is added when parsing withargp_parse, which will print the ¡®--version¡¯ string
followed by a newline and exit. The exception to this is if theARGP_NO_EXITflag is
used.

const char * argp_program_bug_address [Variable]
If defined or set by the user program to a non-zero value,argp_program_bug_address
should point to a string that will be printed at the end of the standard output for the
¡®--help¡¯ option, embedded in a sentence that says ¡®Report bugs toaddress.¡¯.

argp_program_version_hook [Variable]
If defined or set by the user program to a non-zero value, a ¡®--version¡¯ option is
added when parsing witharg_parse, which prints the program version and exits
with a status of zero. This is not the case if theARGP_NO_HELPflag is used. If the
ARGP_NO_EXITflag is set, the exit behavior of the program is suppressed or modified,
as when the argp parser is going to be used by other programs.
It should point to a function with this type of signature:
voidprint-version(FILE *stream, struct argp_state *state)
SeeSection 25.3.5.2 [Argp Parsing State], page 775, for an explanation ofstate.
This variable takes precedence overargp_program_version, and is useful if a program
has version information not easily expressed in a simple string.

error_t argp_err_exit_status [Variable]
This is the exit status used when argp exits due to a parsing error. If not defined or
set by the user program, this defaults to:EX_USAGEfrom<sysexits.h>.

## 25.3.3 Specifying Argp Parsers................................

The first argument to theargp_parsefunction is a pointer to astruct argp, which is
known as anargp parser:

struct argp [Data Type]
This structure specifies how to parse a given set of options and arguments, perhaps
in conjunction with other argp parsers. It has the following fields:
const struct argp_option *options
A pointer to a vector ofargp_optionstructures specifying which options
this argp parser understands; it may be zero if there are no options at
all. SeeSection 25.3.4 [Specifying Options in an Argp Parser], page 770.
argp_parser_t parser
A pointer to a function that defines actions for this parser; it is called
for each option parsed, and at other well-defined points in the parsing


Chapter 25: The Basic Program/System Interface 770

```
process. A value of zero is the same as a pointer to a function that always
returnsARGP_ERR_UNKNOWN. SeeSection 25.3.5 [Argp Parser Functions],
page 772.
const char *args_doc
If non-zero, a string describing what non-option arguments are called by
this parser. This is only used to print the ¡®Usage:¡¯ message. If it contains
newlines, the strings separated by them are considered alternative usage
patterns and printed on separate lines. Lines after the first are prefixed
by ¡®or:¡¯ instead of ¡®Usage:¡¯.
const char *doc
If non-zero, a string containing extra text to be printed before and after
the options in a long help message, with the two sections separated by a
vertical tab ('\v','\013') character. By convention, the documentation
before the options is just a short string explaining what the program does.
Documentation printed after the options describe behavior in more detail.
const struct argp_child *children
A pointer to a vector ofargp_childstructures. This pointer specifies
which additional argp parsers should be combined with this one. See
Section 25.3.6 [Combining Multiple Argp Parsers], page 778.
char *(*help_filter)(intkey, const char *text, void *input)
If non-zero, a pointer to a function that filters the output of help messages.
SeeSection 25.3.8 [Customizing Argp Help Output], page 779.
const char *argp_domain
If non-zero, the strings used in the argp library are translated using the
domain described by this string. If zero, the current default domain is
used.
```
Of the above group,options,parser,args_doc, and thedocfields are usually all that
are needed. If an argp parser is defined as an initialized C variable, only the fields used
need be specified in the initializer. The rest will default to zero due to the way C structure
initialization works. This design is exploited in most argp structures; the most-used fields
are grouped near the beginning, the unused fields left unspecified.

## 25.3.4 Specifying Options in an Argp Parser...................

Theoptionsfield in astruct argppoints to a vector ofstruct argp_optionstructures,
each of which specifies an option that the argp parser supports. Multiple entries may be
used for a single option provided it has multiple names. This should be terminated by an
entry with zero in all fields. Note that when using an initialized C array for options, writing
{ 0 }is enough to achieve this.

struct argp_option [Data Type]
This structure specifies a single option that an argp parser understands, as well as
how to parse and document that option. It has the following fields:
const char *name
The long name for this option, corresponding to the long option ¡®--name¡¯;
this field may be zero if this optiononlyhas a short name. To specify


Chapter 25: The Basic Program/System Interface 771

```
multiple names for an option, additional entries may follow this one, with
theOPTION_ALIASflag set. SeeSection 25.3.4.1 [Flags for Argp Options],
page 771.
int key The integer key provided by the current option to the option parser. If
keyhas a value that is a printableasciicharacter (i.e.,isascii (key)
is true), italsospecifies a short option ¡®-char¡¯, wherechar is theascii
character with the codekey.
const char *arg
If non-zero, this is the name of an argument associated with this option,
which must be provided (e.g., with the ¡®--name=value¡¯ or ¡®-char value¡¯
syntaxes), unless the OPTION_ARG_OPTIONALflag (see Section 25.3.4.1
[Flags for Argp Options], page 771) is set, in which case itmaybe pro-
vided.
int flags Flags associated with this option, some of which are referred to above.
SeeSection 25.3.4.1 [Flags for Argp Options], page 771.
const char *doc
A documentation string for this option, for printing in help messages.
If both thenameandkeyfields are zero, this string will be printed tabbed
left from the normal option column, making it useful as a group header.
This will be the first thing printed in its group. In this usage, it¡¯s con-
ventional to end the string with a ¡®:¡¯ character.
int group Group identity for this option.
In a long help message, options are sorted alphabetically within each
group, and the groups presented in the order 0, 1, 2,... ,n,?m,... ,
?2,?1.
Every entry in an options array with this field 0 will inherit the group
number of the previous entry, or zero if it¡¯s the first one. If it¡¯s a group
header withnameandkeyfields both zero, the previous entry+1 is the
default. Automagic options such as ¡®--help¡¯ are put into group?1.
Note that because of C structure initialization rules, this field often need
not be specified, because 0 is the correct value.
```
## 25.3.4.1 Flags for Argp Options............................

The following flags may be or¡¯d together in theflagsfield of astruct argp_option. These
flags control various aspects of how that option is parsed or displayed in help messages:

OPTION_ARG_OPTIONAL
The argument associated with this option is optional.

OPTION_HIDDEN
This option isn¡¯t displayed in any help messages.

OPTION_ALIAS
This option is an alias for the closest previous non-alias option. This means
that it will be displayed in the same help entry, and will inherit fields other
thannameandkeyfrom the option being aliased.


Chapter 25: The Basic Program/System Interface 772

### OPTION_DOC

```
This option isn¡¯t actually an option and should be ignored by the actual option
parser. It is an arbitrary section of documentation that should be displayed
in much the same manner as the options. This is known as adocumentation
option.
If this flag is set, then the optionnamefield is displayed unmodified (e.g., no
¡®--¡¯ prefix is added) at the left-margin where ashortoption would normally be
displayed, and this documentation string is left in its usual place. For purposes
of sorting, any leading whitespace and punctuation is ignored, unless the first
non-whitespace character is ¡®-¡¯. This entry is displayed after all options, after
OPTION_DOCentries with a leading ¡®-¡¯, in the same group.
```
OPTION_NO_USAGE
This option shouldn¡¯t be included in ¡®long¡¯ usage messages, but should still be
included in other help messages. This is intended for options that are completely
documented in an argp¡¯sargs_docfield. SeeSection 25.3.3 [Specifying Argp
Parsers], page 769. Including this option in the generic usage list would be
redundant, and should be avoided.
For instance, ifargs_docis"FOO BAR\n-x BLAH", and the ¡®-x¡¯ option¡¯s purpose
is to distinguish these two cases, ¡®-x¡¯ should probably be markedOPTION_NO_
USAGE.

## 25.3.5 Argp Parser Functions..................................

The function pointed to by theparserfield in astruct argp(seeSection 25.3.3 [Specifying
Argp Parsers], page 769) defines what actions take place in response to each option or
argument parsed. It is also used as a hook, allowing a parser to perform tasks at certain
other points during parsing.

```
Argp parser functions have the following type signature:
error_tparser(intkey, char *arg, struct argp_state *state)
```
where the arguments are as follows:

key For each option that is parsed,parseris called with a value ofkeyfrom that
option¡¯skeyfield in the option vector. See Section 25.3.4 [Specifying Op-
tions in an Argp Parser], page 770. parseris also called at other times with
special reserved keys, such asARGP_KEY_ARGfor non-option arguments. See
Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

arg Ifkeyis an option,argis its given value. This defaults to zero if no value is
specified. Only options that have a non-zeroargfield can ever have a value.
These mustalwayshave a value unless theOPTION_ARG_OPTIONALflag is speci-
fied. If the input being parsed specifies a value for an option that doesn¡¯t allow
one, an error results beforeparserever gets called.
Ifkey is ARGP_KEY_ARG,arg is a non-option argument. Other special keys
always have a zeroarg.

state statepoints to astruct argp_state, containing useful information about the
current parsing state for use byparser. SeeSection 25.3.5.2 [Argp Parsing
State], page 775.


Chapter 25: The Basic Program/System Interface 773

Whenparseris called, it should perform whatever action is appropriate forkey, and
return 0 for success,ARGP_ERR_UNKNOWNif the value ofkey is not handled by this parser
function, or a unix error code if a real error occurred. SeeSection 2.2 [Error Codes], page 24.

int ARGP_ERR_UNKNOWN [Macro]
Argp parser functions should returnARGP_ERR_UNKNOWNfor anykey value they do
not recognize, or for non-option arguments (key== ARGP_KEY_ARG) that they are not
equipped to handle.

```
A typical parser function uses a switch statement onkey:
error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
switch (key)
{
caseoption_key:
action
break;
```
```
default:
return ARGP_ERR_UNKNOWN;
}
return 0;
}
```
## 25.3.5.1 Special Keys for Argp Parser Functions............

In addition to key values corresponding to user options, thekeyargument to argp parser
functions may have a number of other special values. In the following exampleargandstate
refer to parser function arguments. SeeSection 25.3.5 [Argp Parser Functions], page 772.

ARGP_KEY_ARG
This is not an option at all, but rather a command line argument, whose value
is pointed to byarg.
When there are multiple parser functions in play due to argp parsers being
combined, it¡¯s impossible to know which one will handle a specific argument.
Each is called until one returns 0 or an error other thanARGP_ERR_UNKNOWN; if
an argument is not handled,argp_parseimmediately returns success, without
parsing any more arguments.
Once a parser function returns success for this key, that fact is recorded, and
theARGP_KEY_NO_ARGScase won¡¯t be used. However, if while processing the
argument a parser function decrements thenextfield of itsstateargument, the
option won¡¯t be considered processed; this is to allow you to actually modify
the argument, perhaps into an option, and have it processed again.

ARGP_KEY_ARGS
If a parser function returnsARGP_ERR_UNKNOWNforARGP_KEY_ARG, it is imme-
diately called again with the keyARGP_KEY_ARGS, which has a similar meaning,
but is slightly more convenient for consuming all remaining arguments.argis
0, and the tail of the argument vector may be found atstate->argv +state-
>next. If success is returned for this key, andstate->nextis unchanged, all
remaining arguments are considered to have been consumed. Otherwise, the


Chapter 25: The Basic Program/System Interface 774

```
amount by whichstate->nexthas been adjusted indicates how many were
used. Here¡¯s an example that uses both, for different args:
...
case ARGP_KEY_ARG:
if (state->arg_num == 0)
/* First argument */
first_arg =arg;
else
/* Let the next case parse it. */
return ARGP_KEY_UNKNOWN;
break;
case ARGP_KEY_ARGS:
remaining_args =state->argv +state->next;
num_remaining_args =state->argc -state->next;
break;
```
ARGP_KEY_END
This indicates that there are no more command line arguments. Parser func-
tions are called in a different order, children first. This allows each parser to
clean up its state for the parent.

ARGP_KEY_NO_ARGS
Because it¡¯s common to do some special processing if there aren¡¯t any non-
option args, parser functions are called with this key if they didn¡¯t successfully
process any non-option arguments. This is called just beforeARGP_KEY_END,
where more general validity checks on previously parsed arguments take place.

ARGP_KEY_INIT
This is passed in before any parsing is done. Afterwards, the values of each
element of thechild_inputfield ofstate, if any, are copied to each child¡¯s
state to be the initial value of theinputwhentheirparsers are called.

ARGP_KEY_SUCCESS
Passed in when parsing has successfully been completed, even if arguments
remain.

ARGP_KEY_ERROR
Passed in if an error has occurred and parsing is terminated. In this case a call
with a key ofARGP_KEY_SUCCESSis never made.

ARGP_KEY_FINI
The final key ever seen by any parser, even afterARGP_KEY_SUCCESSandARGP_
KEY_ERROR. Any resources allocated byARGP_KEY_INIT may be freed here.
At times, certain resources allocated are to be returned to the caller after a
successful parse. In that case, those particular resources can be freed in the
ARGP_KEY_ERRORcase.

In all cases,ARGP_KEY_INITis the first key seen by parser functions, andARGP_KEY_FINI
the last, unless an error was returned by the parser forARGP_KEY_INIT. Other keys can
occur in one the following orders.optrefers to an arbitrary option key:

opt.. .ARGP_KEY_NO_ARGS ARGP_KEY_END ARGP_KEY_SUCCESS
The arguments being parsed did not contain any non-option arguments.


Chapter 25: The Basic Program/System Interface 775

(opt| ARGP_KEY_ARG).. .ARGP_KEY_END ARGP_KEY_SUCCESS
All non-option arguments were successfully handled by a parser function. There
may be multiple parser functions if multiple argp parsers were combined.

(opt| ARGP_KEY_ARG).. .ARGP_KEY_SUCCESS
Some non-option argument went unrecognized.
This occurs when every parser function returnsARGP_KEY_UNKNOWNfor an ar-
gument, in which case parsing stops at that argument ifargindex is a null
pointer. Otherwise an error occurs.

In all cases, if a non-null value forargindexgets passed toargp_parse, the index of
the first unparsed command-line argument is passed back in that value.

If an error occurs and is either detected by argp or because a parser function returned an
error value, each parser is called withARGP_KEY_ERROR. No further calls are made, except
the final call withARGP_KEY_FINI.

## 25.3.5.2 Argp Parsing State................................

The third argument to argp parser functions (seeSection 25.3.5 [Argp Parser Functions],
page 772) is a pointer to astruct argp_state, which contains information about the state
of the option parsing.

struct argp_state [Data Type]
This structure has the following fields, which may be modified as noted:

```
const struct argp *const root_argp
The top level argp parser being parsed. Note that this is oftennot the
samestruct argppassed intoargp_parseby the invoking program. See
Section 25.3 [Parsing Program Options with Argp], page 768. It is an
internal argp parser that contains options implemented byargp_parse
itself, such as ¡®--help¡¯.
```
```
int argc
char **argv
The argument vector being parsed. This may be modified.
```
```
int next The index in argvof the next argument to be parsed. This may be
modified.
One way to consume all remaining arguments in the input is to set
state->next =state->argc, perhaps after recording the value of the
next field to find the consumed arguments. The current option can
be re-parsed immediately by decrementing this field, then modifying
state->argv[state->next]to reflect the option that should be reex-
amined.
```
```
unsigned flags
The flags supplied toargp_parse. These may be modified, although
some flags may only take effect whenargp_parseis first invoked. See
Section 25.3.7 [Flags forargp_parse], page 778.
```

Chapter 25: The Basic Program/System Interface 776

```
unsigned arg_num
While calling a parsing function with thekeyargumentARGP_KEY_ARG,
this represents the number of the current arg, starting at 0. It is incre-
mented after eachARGP_KEY_ARGcall returns. At all other times, this is
the number ofARGP_KEY_ARGarguments that have been processed.
```
```
int quoted
If non-zero, the index inargvof the first argument following a special ¡®--¡¯
argument. This prevents anything that follows from being interpreted as
an option. It is only set after argument parsing has proceeded past this
point.
void *input
An arbitrary pointer passed in from the caller ofargp_parse, in theinput
argument.
void **child_inputs
These are values that will be passed to child parsers. This vector will be
the same length as the number of children in the current parser. Each
child parser will be given the value ofstate->child_inputs[i]asits
state->inputfield, whereiis the index of the child in the this parser¡¯s
childrenfield. SeeSection 25.3.6 [Combining Multiple Argp Parsers],
page 778.
void *hook
For the parser function¡¯s use. Initialized to 0, but otherwise ignored by
argp.
char *name
The name used when printing messages. This is initialized toargv[0],
orprogram_invocation_nameifargv[0]is unavailable.
FILE *err_stream
FILE *out_stream
The stdio streams used when argp prints. Error messages are printed to
err_stream, all other output, such as ¡®--help¡¯ output) toout_stream.
These are initialized tostderrandstdoutrespectively. SeeSection 12.2
[Standard Streams], page 266.
void *pstate
Private, for use by the argp implementation.
```
## 25.3.5.3 Functions For Use in Argp Parsers.................

Argp provides a number of functions available to the user of argp (seeSection 25.3.5 [Argp
Parser Functions], page 772), mostly for producing error messages. These take as their first
argument thestate argument to the parser function. SeeSection 25.3.5.2 [Argp Parsing
State], page 775.

void argp_usage (const struct argpstate *state) [Function]
Preliminary:|MT-Unsafe race:argpbuf env locale|AS-Unsafe heap i18n corrupt|
AC-Unsafe mem corrupt lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 25: The Basic Program/System Interface 777

```
Outputs the standard usage message for the argp parser referred to bystate to
state->err_stream and terminates the program with exit (argp_err_exit_
status). SeeSection 25.3.2 [Argp Global Variables], page 769.
```
void argp_error (const struct argpstate *state, const char *fmt, [Function]

.. .)
Preliminary:|MT-Unsafe race:argpbuf env locale|AS-Unsafe heap i18n corrupt|
AC-Unsafe mem corrupt lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Prints the printf format stringfmtand following args, preceded by the program name
and ¡®:¡¯, and followed by a ¡®Try ... --help¡¯ message, and terminates the program with
an exit status ofargp_err_exit_status. SeeSection 25.3.2 [Argp Global Variables],
page 769.

void argp_failure(const struct argp state *state, intstatus, int [Function]
errnum, const char *fmt,.. .)
Preliminary: |MT-Safe |AS-Unsafe corrupt heap|AC-Unsafe lock corrupt mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Similar to the standard GNU error-reporting functionerror, this prints the program
name and ¡®:¡¯, the printf format stringfmt, and the appropriate following args. If it
is non-zero, the standard unix error text forerrnumis printed. Ifstatusis non-zero,
it terminates the program with that value as its exit status.
The difference betweenargp_failureandargp_erroris thatargp_erroris for
parsing errors, whereasargp_failureis for other problems that occur during parsing
but don¡¯t reflect a syntactic problem with the input, such as illegal values for options,
bad phase of the moon, etc.

void argp_state_help(const struct argp state *state, FILE [Function]
*stream, unsignedflags)
Preliminary:|MT-Unsafe race:argpbuf env locale|AS-Unsafe heap i18n corrupt|
AC-Unsafe mem corrupt lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Outputs a help message for the argp parser referred to bystate, tostream. Theflags
argument determines what sort of help message is produced. SeeSection 25.3.10
[Flags for theargp_helpFunction], page 780.

Error output is sent to state->err_stream, and the program name printed is
state->name.

The output or program termination behavior of these functions may be suppressed if the
ARGP_NO_EXITorARGP_NO_ERRSflags are passed toargp_parse. SeeSection 25.3.7 [Flags
forargp_parse], page 778.

This behavior is useful if an argp parser is exported for use by other programs (e.g., by
a library), and may be used in a context where it is not desirable to terminate the program
in response to parsing errors. In argp parsers intended for such general use, and for the case
where the programdoesn¡¯tterminate, calls to any of these functions should be followed by
code that returns the appropriate error code:
if (bad argument syntax)
{
argp_usage (state);


Chapter 25: The Basic Program/System Interface 778

```
return EINVAL;
}
```
If a parser function willonly be used whenARGP_NO_EXITis not set, the return may be
omitted.

## 25.3.6 Combining Multiple Argp Parsers.......................

Thechildrenfield in astruct argpenables other argp parsers to be combined with the
referencing one for the parsing of a single set of arguments. This field should point to a
vector ofstruct argp_child, which is terminated by an entry having a value of zero in the
argpfield.

Where conflicts between combined parsers arise, as when two specify an option with the
same name, the parser conflicts are resolved in favor of the parent argp parser(s), or the
earlier of the argp parsers in the list of children.

struct argp_child [Data Type]
An entry in the list of subsidiary argp parsers pointed to by thechildrenfield in a
struct argp. The fields are as follows:

```
const struct argp *argp
The child argp parser, or zero to end of the list.
```
```
int flags Flags for this child.
const char *header
If non-zero, this is an optional header to be printed within help output
before the child options. As a side-effect, a non-zero value forces the child
options to be grouped together. To achieve this effect without actually
printing a header string, use a value of"". As with header strings specified
in an option entry, the conventional value of the last character is ¡®:¡¯. See
Section 25.3.4 [Specifying Options in an Argp Parser], page 770.
```
```
int group This is where the child options are grouped relative to the other ¡®con-
solidated¡¯ options in the parent argp parser. The values are the same as
thegroupfield instruct argp_option. SeeSection 25.3.4 [Specifying
Options in an Argp Parser], page 770. All child-groupings follow parent
options at a particular group level. If both this field andheaderare zero,
then the child¡¯s options aren¡¯t grouped together, they are merged with
parent options at the parent option group level.
```
## 25.3.7 Flags forargp_parse...................................

The default behavior ofargp_parseis designed to be convenient for the most common case
of parsing program command line argument. To modify these defaults, the following flags
may be or¡¯d together in theflagsargument toargp_parse:

ARGP_PARSE_ARGV0
Don¡¯t ignore the first element of theargvargument toargp_parse. Unless
ARGP_NO_ERRSis set, the first element of the argument vector is skipped for
option parsing purposes, as it corresponds to the program name in a command
line.


Chapter 25: The Basic Program/System Interface 779

### ARGP_NO_ERRS

```
Don¡¯t print error messages for unknown options tostderr; unless this flag is
set,ARGP_PARSE_ARGV0is ignored, asargv[0]is used as the program name
in the error messages. This flag impliesARGP_NO_EXIT. This is based on the
assumption that silent exiting upon errors is bad behavior.
```
ARGP_NO_ARGS
Don¡¯t parse any non-option args. Normally these are parsed by calling the parse
functions with a key ofARGP_KEY_ARG, the actual argument being the value.
This flag needn¡¯t normally be set, as the default behavior is to stop parsing
as soon as an argument fails to be parsed. SeeSection 25.3.5 [Argp Parser
Functions], page 772.

ARGP_IN_ORDER
Parse options and arguments in the same order they occur on the command
line. Normally they¡¯re rearranged so that all options come first.

ARGP_NO_HELP
Don¡¯t provide the standard long option ¡®--help¡¯, which ordinarily causes usage
and option help information to be output tostdoutandexit (0).

ARGP_NO_EXIT
Don¡¯t exit on errors, although they may still result in error messages.

ARGP_LONG_ONLY
Use the GNU getopt ¡®long-only¡¯ rules for parsing arguments. This allows long-
options to be recognized with only a single ¡®-¡¯ (i.e., ¡®-help¡¯). This results in a
less useful interface, and its use is discouraged as it conflicts with the way most
GNU programs work as well as the GNU coding standards.

ARGP_SILENT
Turns off any message-printing/exiting options, specifically ARGP_NO_EXIT,
ARGP_NO_ERRS, andARGP_NO_HELP.

## 25.3.8 Customizing Argp Help Output.........................

Thehelp_filterfield in astruct argpis a pointer to a function that filters the text of
help messages before displaying them. They have a function signature like:

```
char *help-filter(intkey, const char *text, void *input)
```
Wherekeyis either a key from an option, in which casetextis that option¡¯s help text. See
Section 25.3.4 [Specifying Options in an Argp Parser], page 770. Alternately, one of the
special keys with names beginning with ¡®ARGP_KEY_HELP_¡¯ might be used, describing which
other help texttextwill contain. SeeSection 25.3.8.1 [Special Keys for Argp Help Filter
Functions], page 780.

The function should return eithertextif it remains as-is, or a replacement string allocated
usingmalloc. This will be either be freed by argp or zero, which prints nothing. The value
oftextis suppliedafter any translation has been done, so if any of the replacement text
needs translation, it will be done by the filter function. inputis either the input supplied
toargp_parseor it is zero, ifargp_helpwas called directly by the user.


Chapter 25: The Basic Program/System Interface 780

## 25.3.8.1 Special Keys for Argp Help Filter Functions........

The following special values may be passed to an argp help filter function as the first
argument in addition to key values for user options. They specify which help text thetext
argument contains:

ARGP_KEY_HELP_PRE_DOC
The help text preceding options.

ARGP_KEY_HELP_POST_DOC
The help text following options.

ARGP_KEY_HELP_HEADER
The option header string.

ARGP_KEY_HELP_EXTRA
This is used after all other documentation;textis zero for this key.

ARGP_KEY_HELP_DUP_ARGS_NOTE
The explanatory note printed when duplicate option arguments have been sup-
pressed.

ARGP_KEY_HELP_ARGS_DOC
The argument doc string; formally theargs_docfield from the argp parser.
SeeSection 25.3.3 [Specifying Argp Parsers], page 769.

## 25.3.9 Theargp_helpFunction...............................

Normally programs using argp need not be written with particular printing argument-
usage-type help messages in mind as the standard ¡®--help¡¯ option is handled automatically
by argp. Typical error cases can be handled using argp_usageandargp_error. See
Section 25.3.5.3 [Functions For Use in Argp Parsers], page 776. However, if it¡¯s desirable to
print a help message in some context other than parsing the program options, argp offers
theargp_helpinterface.

void argp_help(const struct argp *argp, FILE *stream, unsigned [Function]
flags, char *name)
Preliminary:|MT-Unsafe race:argpbuf env locale|AS-Unsafe heap i18n corrupt|
AC-Unsafe mem corrupt lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This outputs a help message for the argp parserargptostream. The type of messages
printed will be determined byflags.
Any options such as ¡®--help¡¯ that are implemented automatically by argp itself will
notbe present in the help output; for this reason it is best to useargp_state_helpif
calling from within an argp parser function. SeeSection 25.3.5.3 [Functions For Use
in Argp Parsers], page 776.

## 25.3.10 Flags for theargp_helpFunction.....................

When callingargp_help(seeSection 25.3.9 [Theargp_helpFunction], page 780) orargp_
state_help(seeSection 25.3.5.3 [Functions For Use in Argp Parsers], page 776) the exact
output is determined by theflagsargument. This should consist of any of the following
flags, or¡¯d together:


Chapter 25: The Basic Program/System Interface 781

### ARGP_HELP_USAGE

```
A unix ¡®Usage:¡¯ message that explicitly lists all options.
```
ARGP_HELP_SHORT_USAGE
A unix ¡®Usage:¡¯ message that displays an appropriate placeholder to indicate
where the options go; useful for showing the non-option argument syntax.

ARGP_HELP_SEE
A ¡®Try ... for more help¡¯ message; ¡®...¡¯ contains the program name and
¡®--help¡¯.

ARGP_HELP_LONG
A verbose option help message that gives each option available along with its
documentation string.

ARGP_HELP_PRE_DOC
The part of the argp parser doc string preceding the verbose option help.

ARGP_HELP_POST_DOC
The part of the argp parser doc string that following the verbose option help.

ARGP_HELP_DOC
(ARGP_HELP_PRE_DOC | ARGP_HELP_POST_DOC)

ARGP_HELP_BUG_ADDR
A message that prints where to report bugs for this program, if theargp_
program_bug_addressvariable contains this information.

ARGP_HELP_LONG_ONLY
This will modify any output to reflect theARGP_LONG_ONLYmode.
The following flags are only understood when used withargp_state_help. They control
whether the function returns after printing its output, or terminates the program:

ARGP_HELP_EXIT_ERR
This will terminate the program withexit (argp_err_exit_status).

ARGP_HELP_EXIT_OK
This will terminate the program withexit (0).
The following flags are combinations of the basic flags for printing standard messages:

ARGP_HELP_STD_ERR
Assuming that an error message for a parsing error has printed, this prints a
message on how to get help, and terminates the program with an error.

ARGP_HELP_STD_USAGE
This prints a standard usage message and terminates the program with an error.
This is used when no other specific error messages are appropriate or available.

ARGP_HELP_STD_HELP
This prints the standard response for a ¡®--help¡¯ option, and terminates the
program successfully.

## 25.3.11 Argp Examples........................................

These example programs demonstrate the basic usage of argp.


Chapter 25: The Basic Program/System Interface 782

## 25.3.11.1 A Minimal Program Using Argp..................

This is perhaps the smallest program possible that uses argp. It won¡¯t do much except
give an error message and exit when there are any arguments, and prints a rather pointless
message for ¡®--help¡¯.

```
/*This is (probably) the smallest possible program that
uses argp. It won¡¯t do much except give an error
messages and exit when there are any arguments, and print
a (rather pointless) messages for ¨Chelp.*/
```
```
#include <stdlib.h>
#include <argp.h>
```
```
int
main (int argc, char **argv)
{
argp_parse (0, argc, argv, 0, 0, 0);
exit (0);
}
```
## 25.3.11.2 A Program Using Argp with Only Default Options..

This program doesn¡¯t use any options or arguments, it uses argp to be compliant with the
GNU standard command line format.

In addition to giving no arguments and implementing a ¡®--help¡¯ option, this example
has a ¡®--version¡¯ option, which will put the given documentation string and bug address
in the ¡®--help¡¯ output, as per GNU standards.

The variableargpcontains the argument parser specification. Adding fields to this
structure is the way most parameters are passed toargp_parse. The first three fields are
normally used, but they are not in this small program. There are also two global variables
that argp can use defined here,argp_program_versionandargp_program_bug_address.
They are considered global variables because they will almost always be constant for a given
program, even if they use different argument parsers for various tasks.

```
/*This program doesn¡¯t use any options or arguments, but uses
argp to be compliant with the GNU standard command line
format.
```
```
In addition to making sure no arguments are given, and
implementing a ¨Chelp option, this example will have a
¨Cversion option, and will put the given documentation string
and bug address in the ¨Chelp output, as per GNU standards.
```
```
The variable ARGP contains the argument parser specification;
adding fields to this structure is the way most parameters are
passed to argpparse (the first three fields are usually used,
but not in this small program). There are also two global
variables that argp knows about defined here,
ARGPPROGRAMVERSION and ARGPPROGRAMBUGADDRESS (they are
global variables because they will almost always be constant
for a given program, even if it uses different argument
parsers for various tasks).*/
```
```
#include <stdlib.h>
```

Chapter 25: The Basic Program/System Interface 783

```
#include <argp.h>
```
```
const char *argp_program_version =
"argp-ex2 1.0";
const char *argp_program_bug_address =
"<bug-gnu-utils@gnu.org>";
```
```
/*Program documentation.*/
static char doc[] =
"Argp example #2 -- a pretty minimal program using argp";
```
```
/*Our argument parser. Theoptions,parser, and
args_docfields are zero because we have neither options or
arguments;docandargp_program_bug_addresswill be
used in the output for ¡®--help¡¯, and the ¡®--version¡¯
option will print outargp_program_version.*/
static struct argp argp = { 0, 0, 0, doc };
```
```
int
main (int argc, char **argv)
{
argp_parse (&argp, argc, argv, 0, 0, 0);
exit (0);
}
```
## 25.3.11.3 A Program Using Argp with User Options........

This program uses the same features as example 2, adding user options and arguments.

We now use the first four fields inargp(seeSection 25.3.3 [Specifying Argp Parsers],
page 769) and specifyparse_optas the parser function. SeeSection 25.3.5 [Argp Parser
Functions], page 772.

Note that in this example,mainuses a structure to communicate with theparse_opt
function, a pointer to which it passes in theinputargument toargp_parse. SeeSection 25.3
[Parsing Program Options with Argp], page 768. It is retrieved byparse_optthrough the
inputfield in itsstateargument. SeeSection 25.3.5.2 [Argp Parsing State], page 775. Of
course, it¡¯s also possible to use global variables instead, but using a structure like this is
somewhat more flexible and clean.

```
/*This program uses the same features as example 2, and uses options and
arguments.
```
```
We now use the first four fields in ARGP, so here¡¯s a description of them:
OPTIONS ¨C A pointer to a vector of struct argpoption (see below)
PARSER ¨C A function to parse a single option, called by argp
ARGSDOC ¨C A string describing how the non-option arguments should look
DOC ¨C A descriptive string about this program; if it contains a
vertical tab character (\v), the part after it will be
printed *following* the options
```
```
The function PARSER takes the following arguments:
KEY ¨C An integer specifying which option this is (taken
from the KEY field in each struct argpoption), or
a special key specifying something else; the only
special keys we use here are ARGPKEYARG, meaning
a non-option argument, and ARGPKEYEND, meaning
that all arguments have been parsed
```

Chapter 25: The Basic Program/System Interface 784

```
ARG ¨C For an option KEY, the string value of its
argument, or NULL if it has none
STATE¨C A pointer to a struct argpstate, containing
various useful information about the parsing state; used here
are the INPUT field, which reflects the INPUT argument to
argpparse, and the ARGNUM field, which is the number of the
current non-option argument being parsed
It should return either 0, meaning success, ARGPERRUNKNOWN, meaning the
given KEY wasn¡¯t recognized, or an errno value indicating some other
error.
```
```
Note that in this example, main uses a structure to communicate with the
parseopt function, a pointer to which it passes in the INPUT argument to
argpparse. Of course, it¡¯s also possible to use global variables
instead, but this is somewhat more flexible.
```
```
The OPTIONS field contains a pointer to a vector of struct argpoption¡¯s;
that structure has the following fields (if you assign your option
structures using array initialization like this example, unspecified
fields will be defaulted to 0, and need not be specified):
NAME ¨C The name of this option¡¯s long option (may be zero)
KEY ¨C The KEY to pass to the PARSER function when parsing this option,
*and* the name of this option¡¯s short option, if it is a
printable ascii character
ARG ¨C The name of this option¡¯s argument, if any
FLAGS ¨C Flags describing this option; some of them are:
OPTIONARGOPTIONAL ¨C The argument to this option is optional
OPTIONALIAS ¨C This option is an alias for the
previous option
OPTIONHIDDEN ¨C Don¡¯t show this option in ¨Chelp output
DOC ¨C A documentation string for this option, shown in ¨Chelp output
```
```
An options vector should be terminated by an option with all fields zero.*/
```
```
#include <stdlib.h>
#include <argp.h>
```
```
const char *argp_program_version =
"argp-ex3 1.0";
const char *argp_program_bug_address =
"<bug-gnu-utils@gnu.org>";
```
```
/*Program documentation.*/
static char doc[] =
"Argp example #3 -- a program with options and arguments using argp";
```
```
/*A description of the arguments we accept.*/
static char args_doc[] = "ARG1 ARG2";
```
```
/*The options we understand.*/
static struct argp_option options[] = {
{"verbose", 'v', 0, 0, "Produce verbose output" },
{"quiet", 'q', 0, 0, "Don't produce any output" },
{"silent", 's', 0, OPTION_ALIAS },
{"output", 'o', "FILE", 0,
"Output to FILE instead of standard output" },
{ 0 }
};
```

Chapter 25: The Basic Program/System Interface 785

```
/*Used bymainto communicate withparse_opt.*/
struct arguments
{
char *args[2]; /*arg1&arg2 */
int silent, verbose;
char *output_file;
};
```
```
/*Parse a single option.*/
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
/*Get theinputargument fromargp_parse, which we
know is a pointer to our arguments structure.*/
struct arguments *arguments = state->input;
```
```
switch (key)
{
case 'q': case 's':
arguments->silent = 1;
break;
case 'v':
arguments->verbose = 1;
break;
case 'o':
arguments->output_file = arg;
break;
```
```
case ARGP_KEY_ARG:
if (state->arg_num >= 2)
/* Too many arguments.*/
argp_usage (state);
```
```
arguments->args[state->arg_num] = arg;
```
```
break;
```
```
case ARGP_KEY_END:
if (state->arg_num < 2)
/* Not enough arguments.*/
argp_usage (state);
break;
```
```
default:
return ARGP_ERR_UNKNOWN;
}
return 0;
}
```
```
/*Our argp parser.*/
static struct argp argp = { options, parse_opt, args_doc, doc };
```
```
int
main (int argc, char **argv)
{
struct arguments arguments;
```

Chapter 25: The Basic Program/System Interface 786

```
/*Default values.*/
arguments.silent = 0;
arguments.verbose = 0;
arguments.output_file = "-";
```
```
/*Parse our arguments; every option seen byparse_optwill
be reflected inarguments.*/
argp_parse (&argp, argc, argv, 0, 0, &arguments);
```
```
printf ("ARG1 = %s\nARG2 = %s\nOUTPUT_FILE = %s\n"
"VERBOSE = %s\nSILENT = %s\n",
arguments.args[0], arguments.args[1],
arguments.output_file,
arguments.verbose? "yes" : "no",
arguments.silent? "yes" : "no");
```
```
exit (0);
}
```
## 25.3.11.4 A Program Using Multiple Combined Argp Parsers..

This program uses the same features as example 3, but has more options, and presents more
structure in the ¡®--help¡¯ output. It also illustrates how you can ¡®steal¡¯ the remainder of
the input arguments past a certain point for programs that accept a list of items. It also
illustrates thekeyvalueARGP_KEY_NO_ARGS, which is only given if no non-option arguments
were supplied to the program. SeeSection 25.3.5.1 [Special Keys for Argp Parser Functions],
page 773.

For structuring help output, two features are used:headersand a two part option string.
Theheadersare entries in the options vector. SeeSection 25.3.4 [Specifying Options in an
Argp Parser], page 770. The first four fields are zero. The two part documentation string
are in the variabledoc, which allows documentation both before and after the options. See
Section 25.3.3 [Specifying Argp Parsers], page 769, the two parts ofdocare separated by
a vertical-tab character ('\v', or'\013'). By convention, the documentation before the
options is a short string stating what the program does, and after any options it is longer,
describing the behavior in more detail. All documentation strings are automatically filled
for output, although newlines may be included to force a line break at a particular point. In
addition, documentation strings are passed to thegettextfunction, for possible translation
into the current locale.

```
/*This program uses the same features as example 3, but has more
options, and somewhat more structure in the -help output. It
also shows how you can ¡®steal¡¯ the remainder of the input
arguments past a certain point, for programs that accept a
list of items. It also shows the special argp KEY value
ARGPKEYNOARGS, which is only given if no non-option
arguments were supplied to the program.
```
```
For structuring the help output, two features are used,
*headers* which are entries in the options vector with the
first four fields being zero, and a two part documentation
string (in the variable DOC), which allows documentation both
before and after the options; the two parts of DOC are
separated by a vertical-tab character (¡¯\v¡¯, or ¡¯\013¡¯). By
convention, the documentation before the options is just a
```

Chapter 25: The Basic Program/System Interface 787

```
short string saying what the program does, and that afterwards
is longer, describing the behavior in more detail. All
documentation strings are automatically filled for output,
although newlines may be included to force a line break at a
particular point. All documentation strings are also passed to
the ¡®gettext¡¯ function, for possible translation into the
current locale.*/
```
```
#include <stdlib.h>
#include <error.h>
#include <argp.h>
```
```
const char *argp_program_version =
"argp-ex4 1.0";
const char *argp_program_bug_address =
"<bug-gnu-utils@prep.ai.mit.edu>";
```
```
/*Program documentation.*/
static char doc[] =
"Argp example #4 -- a program with somewhat more complicated\
options\
\vThis part of the documentation comes *after* the options;\
note that the text is automatically filled, but it's possible\
to force a line-break, e.g.\n<-- here.";
```
```
/*A description of the arguments we accept.*/
static char args_doc[] = "ARG1 [STRING...]";
```
```
/*Keys for options without short-options.*/
#define OPT_ABORT 1 /*¨Cabort*/
```
```
/*The options we understand.*/
static struct argp_option options[] = {
{"verbose", 'v', 0, 0, "Produce verbose output" },
{"quiet", 'q', 0, 0, "Don't produce any output" },
{"silent", 's', 0, OPTION_ALIAS },
{"output", 'o', "FILE", 0,
"Output to FILE instead of standard output" },
```
```
{0,0,0,0, "The following options should be grouped together:" },
{"repeat", 'r', "COUNT", OPTION_ARG_OPTIONAL,
"Repeat the output COUNT (default 10) times"},
{"abort", OPT_ABORT, 0, 0, "Abort before showing any output"},
```
```
{ 0 }
};
```
```
/*Used bymainto communicate withparse_opt.*/
struct arguments
{
char *arg1; /*arg1*/
char **strings; /*[string... ]*/
int silent, verbose, abort; /*¡®-s¡¯, ¡®-v¡¯, ¡®--abort¡¯*/
char *output_file; /*filearg to ¡®--output¡¯*/
int repeat_count; /*countarg to ¡®--repeat¡¯*/
};
```
```
/*Parse a single option.*/
```

Chapter 25: The Basic Program/System Interface 788

```
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
/*Get theinputargument fromargp_parse, which we
know is a pointer to our arguments structure.*/
struct arguments *arguments = state->input;
```
```
switch (key)
{
case 'q': case 's':
arguments->silent = 1;
break;
case 'v':
arguments->verbose = 1;
break;
case 'o':
arguments->output_file = arg;
break;
case 'r':
arguments->repeat_count = arg? atoi (arg) : 10;
break;
case OPT_ABORT:
arguments->abort = 1;
break;
```
```
case ARGP_KEY_NO_ARGS:
argp_usage (state);
```
```
case ARGP_KEY_ARG:
/*Here we know thatstate->arg_num == 0, since we
force argument parsing to end before any more arguments can
get here.*/
arguments->arg1 = arg;
```
```
/*Now we consume all the rest of the arguments.
state->nextis the index instate->argvof the
next argument to be parsed, which is the firststring
we¡¯re interested in, so we can just use
&state->argv[state->next]as the value for
arguments->strings.
```
```
In addition, by settingstate->nextto the end
of the arguments, we can force argp to stop parsing here and
return.*/
arguments->strings = &state->argv[state->next];
state->next = state->argc;
```
```
break;
```
```
default:
return ARGP_ERR_UNKNOWN;
}
return 0;
}
```
```
/*Our argp parser.*/
static struct argp argp = { options, parse_opt, args_doc, doc };
```

Chapter 25: The Basic Program/System Interface 789

```
int
main (int argc, char **argv)
{
int i, j;
struct arguments arguments;
```
```
/*Default values.*/
arguments.silent = 0;
arguments.verbose = 0;
arguments.output_file = "-";
arguments.repeat_count = 1;
arguments.abort = 0;
```
```
/*Parse our arguments; every option seen byparse_optwill be
reflected inarguments.*/
argp_parse (&argp, argc, argv, 0, 0, &arguments);
```
```
if (arguments.abort)
error (10, 0, "ABORTED");
```
```
for (i = 0; i < arguments.repeat_count; i++)
{
printf ("ARG1 = %s\n", arguments.arg1);
printf ("STRINGS = ");
for (j = 0; arguments.strings[j]; j++)
printf (j == 0? "%s" : ", %s", arguments.strings[j]);
printf ("\n");
printf ("OUTPUT_FILE = %s\nVERBOSE = %s\nSILENT = %s\n",
arguments.output_file,
arguments.verbose? "yes" : "no",
arguments.silent? "yes" : "no");
}
```
```
exit (0);
}
```
## 25.3.12 Argp User Customization..............................

The formatting of argp ¡®--help¡¯ output may be controlled to some extent by a program¡¯s
users, by setting theARGP_HELP_FMT environment variable to a comma-separated list of
tokens. Whitespace is ignored:

¡®dup-args¡¯
¡®no-dup-args¡¯
These turnduplicate-argument-modeon or off. In duplicate argument mode, if
an option that accepts an argument has multiple names, the argument is shown
for each name. Otherwise, it is only shown for the first long option. A note is
subsequently printed so the user knows that it applies to other names as well.
The default is ¡®no-dup-args¡¯, which is less consistent, but prettier.

¡®dup-args-note¡¯
¡®no-dup-args-note¡¯
These will enable or disable the note informing the user of suppressed option
argument duplication. The default is ¡®dup-args-note¡¯.

¡®short-opt-col=n¡¯
This prints the first short option in columnn. The default is 2.


Chapter 25: The Basic Program/System Interface 790

¡®long-opt-col=n¡¯
This prints the first long option in columnn. The default is 6.

¡®doc-opt-col=n¡¯
This prints ¡®documentation options¡¯ (seeSection 25.3.4.1 [Flags for Argp Op-
tions], page 771) in columnn. The default is 2.

¡®opt-doc-col=n¡¯
This prints the documentation for options starting in columnn. The default is
29.

¡®header-col=n¡¯
This will indent the group headers that document groups of options to column
n. The default is 1.

¡®usage-indent=n¡¯
This will indent continuation lines in ¡®Usage:¡¯ messages to column n. The
default is 12.

¡®rmargin=n¡¯
This will word wrap help output at or before columnn. The default is 79.

## 25.3.12.1 Parsing of Suboptions............................

Having a single level of options is sometimes not enough. There might be too many options
which have to be available or a set of options is closely related.

For this case some programs use suboptions. One of the most prominent programs is
certainlymount(8). The-ooption take one argument which itself is a comma separated list
of options. To ease the programming of code like this the functiongetsuboptis available.

int getsubopt(char **optionp, char *const *tokens, char [Function]
**valuep)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theoptionpparameter must be a pointer to a variable containing the address of the
string to process. When the function returns, the reference is updated to point to the
next suboption or to the terminating ¡®\0¡¯ character if there are no more suboptions
available.
Thetokensparameter references an array of strings containing the known suboptions.
All strings must be ¡®\0¡¯ terminated and to mark the end a null pointer must be
stored. Whengetsuboptfinds a possible legal suboption it compares it with all strings
available in thetokensarray and returns the index in the string as the indicator.
In case the suboption has an associated value introduced by a ¡®=¡¯ character, a pointer
to the value is returned invaluep. The string is ¡®\0¡¯ terminated. If no argument is
availablevaluepis set to the null pointer. By doing this the caller can check whether
a necessary value is given or whether no unexpected value is present.
In case the next suboption in the string is not mentioned in thetokensarray the
starting address of the suboption including a possible value is returned invaluepand
the return value of the function is ¡®-1¡¯.


Chapter 25: The Basic Program/System Interface 791

## 25.3.13 Parsing of Suboptions Example........................

The code which might appear in themount(8) program is a perfect example of the use of
getsubopt:

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
```
```
int do_all;
const char *type;
int read_size;
int write_size;
int read_only;
```
```
enum
{
RO_OPTION = 0,
RW_OPTION,
READ_SIZE_OPTION,
WRITE_SIZE_OPTION,
THE_END
};
```
```
const char *mount_opts[] =
{
[RO_OPTION] = "ro",
[RW_OPTION] = "rw",
[READ_SIZE_OPTION] = "rsize",
[WRITE_SIZE_OPTION] = "wsize",
[THE_END] = NULL
};
```
```
int
main (int argc, char **argv)
{
char *subopts, *value;
int opt;
```
```
while ((opt = getopt (argc, argv, "at:o:")) != -1)
switch (opt)
{
case 'a':
do_all = 1;
break;
case 't':
type = optarg;
break;
case 'o':
subopts = optarg;
while (*subopts != '\0')
switch (getsubopt (&subopts, mount_opts, &value))
{
case RO_OPTION:
read_only = 1;
break;
case RW_OPTION:
read_only = 0;
```

Chapter 25: The Basic Program/System Interface 792

```
break;
case READ_SIZE_OPTION:
if (value == NULL)
abort ();
read_size = atoi (value);
break;
case WRITE_SIZE_OPTION:
if (value == NULL)
abort ();
write_size = atoi (value);
break;
default:
/*Unknown suboption.*/
printf ("Unknown suboption `%s'\n", value);
break;
}
break;
default:
abort ();
}
```
```
/*Do the real work.*/
```
```
return 0;
}
```
## 25.4 Environment Variables......................................

When a program is executed, it receives information about the context in which it was
invoked in two ways. The first mechanism uses theargvandargcarguments to itsmain
function, and is discussed inSection 25.1 [Program Arguments], page 759. The second
mechanism usesenvironment variablesand is discussed in this section.

Theargvmechanism is typically used to pass command-line arguments specific to the
particular program being invoked. The environment, on the other hand, keeps track of in-
formation that is shared by many programs, changes infrequently, and that is less frequently
used.

The environment variables discussed in this section are the same environment variables
that you set using assignments and theexportcommand in the shell. Programs executed
from the shell inherit all of the environment variables from the shell.

Standard environment variables are used for information about the user¡¯s home direc-
tory, terminal type, current locale, and so on; you can define additional variables for other
purposes. The set of all environment variables that have values is collectively known as the
environment.

Names of environment variables are case-sensitive and must not contain the character
¡®=¡¯. System-defined environment variables are invariably uppercase.

The values of environment variables can be anything that can be represented as a string.
A value must not contain an embedded null character, since this is assumed to terminate
the string.


Chapter 25: The Basic Program/System Interface 793

## 25.4.1 Environment Access....................................

The value of an environment variable can be accessed with thegetenvfunction. This is
declared in the header filestdlib.h.

Libraries should usesecure_getenvinstead ofgetenv, so that they do not accidentally
use untrusted environment variables. Modifications of environment variables are not allowed
in multi-threaded programs. Thegetenvandsecure_getenvfunctions can be safely used
in multi-threaded programs.

char * getenv(const char *name) [Function]
Preliminary: |MT-Safe env|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns a string that is the value of the environment variablename.
You must not modify this string. In some non-Unix systems not using the GNU C
Library, it might be overwritten by subsequent calls togetenv(but not by any other
library function). If the environment variablenameis not defined, the value is a null
pointer.

char * secure_getenv(const char *name) [Function]
Preliminary: |MT-Safe env|AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function is similar togetenv, but it returns a null pointer if the environment is
untrusted. This happens when the program file has SUID or SGID bits set. General-
purpose libraries should always prefer this function overgetenvto avoid vulnerabili-
ties if the library is referenced from a SUID/SGID program.
This function is a GNU extension.

int putenv(char *string) [Function]
Preliminary: |MT-Unsafe const:env|AS-Unsafe heap lock|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theputenvfunction adds or removes definitions from the environment. If thestring
is of the form ¡®name=value¡¯, the definition is added to the environment. Otherwise,
thestringis interpreted as the name of an environment variable, and any definition
for this variable in the environment is removed.
If the function is successful it returns 0. Otherwise the return value is nonzero and
errnois set to indicate the error.
The difference to thesetenvfunction is that the exact string given as the parameter
string is put into the environment. If the user should change the string after the
putenvcall this will reflect automatically in the environment. This also requires that
stringnot be an automatic variable whose scope is left before the variable is removed
from the environment. The same applies of course to dynamically allocated variables
which are freed later.
This function is part of the extended Unix interface. You should define
XOPENSOURCEbefore including any header.

int setenv(const char *name, const char *value, intreplace) [Function]
Preliminary: |MT-Unsafe const:env|AS-Unsafe heap lock|AC-Unsafe corrupt
lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 25: The Basic Program/System Interface 794

```
Thesetenvfunction can be used to add a new definition to the environment. The
entry with the namenameis replaced by the value ¡®name=value¡¯. Please note that
this is also true ifvalueis the empty string. To do this a new string is created and the
stringsnameandvalueare copied. A null pointer for thevalueparameter is illegal.
If the environment already contains an entry with keynamethereplaceparameter
controls the action. If replace is zero, nothing happens. Otherwise the old entry is
replaced by the new one.
Please note that you cannot remove an entry completely using this function.
If the function is successful it returns 0. Otherwise the environment is unchanged
and the return value is-1anderrnois set.
This function was originally part of the BSD library but is now part of the Unix
standard.
```
int unsetenv (const char *name) [Function]
Preliminary: | MT-Unsafe const:env |AS-Unsafe lock |AC-Unsafe lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Using this function one can remove an entry completely from the environment. If the
environment contains an entry with the keynamethis whole entry is removed. A call
to this function is equivalent to a call toputenvwhen thevaluepart of the string is
empty.
The function returns-1ifnameis a null pointer, points to an empty string, or points
to a string containing a=character. It returns 0 if the call succeeded.
This function was originally part of the BSD library but is now part of the Unix
standard. The BSD version had no return value, though.

There is one more function to modify the whole environment. This function is said to
be used in the POSIX.9 (POSIX bindings for Fortran 77) and so one should expect it did
made it into POSIX.1. But this never happened. But we still provide this function as a
GNU extension to enable writing standard compliant Fortran environments.

int clearenv (void) [Function]
Preliminary:|MT-Unsafe const:env|AS-Unsafe heap lock|AC-Unsafe lock mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theclearenvfunction removes all entries from the environment. Usingputenvand
setenvnew entries can be added again later.
If the function is successful it returns 0. Otherwise the return value is nonzero.

You can deal directly with the underlying representation of environment objects to add
more variables to the environment (for example, to communicate with another program you
are about to execute; seeSection 26.5 [Executing a File], page 806).

char ** environ [Variable]
The environment is represented as an array of strings. Each string is of the format
¡®name=value¡¯. The order in which strings appear in the environment is not significant,
but the samenamemust not appear more than once. The last element of the array
is a null pointer.
This variable is declared in the header fileunistd.h.
If you just want to get the value of an environment variable, usegetenv.


Chapter 25: The Basic Program/System Interface 795

Unix systems, and GNU systems, pass the initial value ofenvironas the third argument
tomain. SeeSection 25.1 [Program Arguments], page 759.

## 25.4.2 Standard Environment Variables........................

These environment variables have standard meanings. This doesn¡¯t mean that they are
always present in the environment; but if these variablesare present, they have these
meanings. You shouldn¡¯t try to use these environment variable names for some other
purpose.

HOME

```
This is a string representing the user¡¯shome directory, or initial default working
directory.
The user can setHOMEto any value. If you need to make sure to obtain the
proper home directory for a particular user, you should not useHOME; instead,
look up the user¡¯s name in the user database (seeSection 30.13 [User Database],
page 864).
For most purposes, it is better to useHOME, precisely because this lets the user
specify the value.
```
LOGNAME

```
This is the name that the user used to log in. Since the value in the environment
can be tweaked arbitrarily, this is not a reliable way to identify the user who
is running a program; a function likegetlogin(seeSection 30.11 [Identifying
Who Logged In], page 855) is better for that purpose.
For most purposes, it is better to useLOGNAME, precisely because this lets the
user specify the value.
```
PATH

```
Apathis a sequence of directory names which is used for searching for a file.
The variablePATHholds a path used for searching for programs to be run.
Theexeclpandexecvpfunctions (seeSection 26.5 [Executing a File], page 806)
use this environment variable, as do many shells and other utilities which are
implemented in terms of those functions.
The syntax of a path is a sequence of directory names separated by colons. An
empty string instead of a directory name stands for the current directory (see
Section 14.1 [Working Directory], page 402).
A typical value for this environment variable might be a string like:
:/bin:/etc:/usr/bin:/usr/new/X11:/usr/new:/usr/local/bin
This means that if the user tries to execute a program namedfoo, the system
will look for files namedfoo,/bin/foo,/etc/foo, and so on. The first of these
files that exists is the one that is executed.
```
TERM

```
This specifies the kind of terminal that is receiving program output. Some
programs can make use of this information to take advantage of special escape
sequences or terminal modes supported by particular kinds of terminals. Many
```

Chapter 25: The Basic Program/System Interface 796

```
programs which use the termcap library (seeSection ¡°Finding a Terminal De-
scription¡± inThe Termcap Library Manual) use theTERMenvironment variable,
for example.
```
TZ

```
This specifies the time zone. SeeSection 21.5.6 [Specifying the Time Zone with
TZ], page 676, for information about the format of this string and how it is used.
```
LANG

```
This specifies the default locale to use for attribute categories where neitherLC_
ALLnor the specific environment variable for that category is set. SeeChapter 7
[Locales and Internationalization], page 183, for more information about locales.
```
LC_ALL

```
If this environment variable is set it overrides the selection for all the locales
done using the otherLC_*environment variables. The value of the otherLC_*
environment variables is simply ignored in this case.
```
LC_COLLATE
This specifies what locale to use for string sorting.

LC_CTYPE

```
This specifies what locale to use for character sets and character classification.
```
LC_MESSAGES
This specifies what locale to use for printing messages and to parse responses.

LC_MONETARY
This specifies what locale to use for formatting monetary values.

LC_NUMERIC
This specifies what locale to use for formatting numbers.

LC_TIME

```
This specifies what locale to use for formatting date/time values.
```
NLSPATH

```
This specifies the directories in which thecatopenfunction looks for message
translation catalogs.
```
_POSIX_OPTION_ORDER
If this environment variable is defined, it suppresses the usual reordering of com-
mand line arguments bygetoptandargp_parse. SeeSection 25.1.1 [Program
Argument Syntax Conventions], page 760.

## 25.5 Auxiliary Vector............................................

When a program is executed, it receives information from the operating system about the
environment in which it is operating. The form of this information is a table of key-value
pairs, where the keys are from the set of ¡®AT_¡¯ values inelf.h. Some of the data is provided
by the kernel for libc consumption, and may be obtained by ordinary interfaces, such as
sysconf. However, on a platform-by-platform basis there may be information that is not
available any other way.


Chapter 25: The Basic Program/System Interface 797

## 25.5.1 Definition ofgetauxval................................

unsigned long int getauxval (unsigned long inttype) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to inquire about the entries in the auxiliary vector. Thetype
argument should be one of the ¡®AT_¡¯ symbols defined inelf.h. If a matching entry
is found, the value is returned; if the entry is not found, zero is returned anderrno
is set toENOENT.

For some platforms, the keyAT_HWCAPis the easiest way to inquire about any instruction
set extensions available at runtime. In this case, there will (of necessity) be a platform-
specific set of ¡®HWCAP_¡¯ values masked together that describe the capabilities of the cpu on
which the program is being executed.

## 25.6 System Calls................................................

A system call is a request for service that a program makes of the kernel. The service
is generally something that only the kernel has the privilege to do, such as doing I/O.
Programmers don¡¯t normally need to be concerned with system calls because there are
functions in the GNU C Library to do virtually everything that system calls do. These
functions work by making system calls themselves. For example, there is a system call that
changes the permissions of a file, but you don¡¯t need to know about it because you can just
use the GNU C Library¡¯schmodfunction.

System calls are sometimes called kernel calls.
However, there are times when you want to make a system call explicitly, and for that,
the GNU C Library provides thesyscallfunction. syscallis harder to use and less
portable than functions likechmod, but easier and more portable than coding the system
call in assembler instructions.

syscallis most useful when you are working with a system call which is special to your
system or is newer than the GNU C Library you are using.syscallis implemented in an
entirely generic way; the function does not know anything about what a particular system
call does or even if it is valid.

The description ofsyscallin this section assumes a certain protocol for system calls
on the various platforms on which the GNU C Library runs. That protocol is not defined
by any strong authority, but we won¡¯t describe it here either because anyone who is coding
syscallprobably won¡¯t accept anything less than kernel and C library source code as a
specification of the interface between them anyway.

```
syscallis declared inunistd.h.
```
long int syscall (long intsysno,.. .) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
syscallperforms a generic system call.
sysnois the system call number. Each kind of system call is identified by a number.
Macros for all the possible system call numbers are defined insys/syscall.h


Chapter 25: The Basic Program/System Interface 798

```
The remaining arguments are the arguments for the system call, in order, and their
meanings depend on the kind of system call. Each kind of system call has a definite
number of arguments, from zero to five. If you code more arguments than the system
call takes, the extra ones to the right are ignored.
```
```
The return value is the return value from the system call, unless the system call failed.
In that case,syscallreturns-1and setserrnoto an error code that the system call
returned. Note that system calls do not return-1when they succeed.
```
```
If you specify an invalidsysno,syscallreturns-1witherrno=ENOSYS.
```
```
Example:
```
```
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
```
```
int rc;
```
```
rc = syscall(SYS_chmod, "/etc/passwd", 0444);
```
```
if (rc == -1)
fprintf(stderr, "chmod failed, errno = %d\n", errno);
```
```
This, if all the compatibility stars are aligned, is equivalent to the following preferable
code:
```
```
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
```
```
int rc;
```
```
rc = chmod("/etc/passwd", 0444);
if (rc == -1)
fprintf(stderr, "chmod failed, errno = %d\n", errno);
```
## 25.7 Program Termination.......................................

The usual way for a program to terminate is simply for itsmainfunction to return. The
exit status valuereturned from themainfunction is used to report information back to the
process¡¯s parent process or shell.

```
A program can also terminate normally by calling theexitfunction.
```
In addition, programs can be terminated by signals; this is discussed in more detail in
Chapter 24 [Signal Handling], page 714. Theabortfunction causes a signal that kills the
program.


Chapter 25: The Basic Program/System Interface 799

## 25.7.1 Normal Termination....................................

A process terminates normally when its program signals it is done by callingexit. Return-
ing frommainis equivalent to callingexit, and the value thatmainreturns is used as the
argument toexit.

void exit (intstatus) [Function]
Preliminary: |MT-Unsafe race:exit|AS-Unsafe corrupt|AC-Unsafe corrupt lock
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theexitfunction tells the system that the program is done, which causes it to
terminate the process.
statusis the program¡¯s exit status, which becomes part of the process¡¯ termination
status. This function does not return.

```
Normal termination causes the following actions:
```
1. Functions that were registered with theatexitoron_exitfunctions are called in the
    reverse order of their registration. This mechanism allows your application to specify
    its own ¡°cleanup¡± actions to be performed at program termination. Typically, this is
    used to do things like saving program state information in a file, or unlocking locks in
    shared data bases.
2. All open streams are closed, writing out any buffered output data. SeeSection 12.4
    [Closing Streams], page 271. In addition, temporary files opened with thetmpfile
    function are removed; seeSection 14.11 [Temporary Files], page 446.
3. _exitis called, terminating the program. SeeSection 25.7.5 [Termination Internals],
    page 801.

## 25.7.2 Exit Status.............................................

When a program exits, it can return to the parent process a small amount of information
about the cause of termination, using theexit status. This is a value between 0 and 255
that the exiting process passes as an argument toexit.

Normally you should use the exit status to report very broad information about success
or failure. You can¡¯t provide a lot of detail about the reasons for the failure, and most
parent processes would not want much detail anyway.

There are conventions for what sorts of status values certain programs should return.
The most common convention is simply 0 for success and 1 for failure. Programs that
perform comparison use a different convention: they use status 1 to indicate a mismatch,
and status 2 to indicate an inability to compare. Your program should follow an existing
convention if an existing convention makes sense for it.

A general convention reserves status values 128 and up for special purposes. In particular,
the value 128 is used to indicate failure to execute another program in a subprocess. This
convention is not universally obeyed, but it is a good idea to follow it in your programs.

Warning:Don¡¯t try to use the number of errors as the exit status. This is actually not
very useful; a parent process would generally not care how many errors occurred. Worse
than that, it does not work, because the status value is truncated to eight bits. Thus, if
the program tried to report 256 errors, the parent would receive a report of 0 errors¡ªthat
is, success.


Chapter 25: The Basic Program/System Interface 800

For the same reason, it does not work to use the value oferrnoas the exit status¡ªthese
can exceed 255.

Portability note: Some non-POSIX systems use different conventions for exit status
values. For greater portability, you can use the macrosEXIT_SUCCESSandEXIT_FAILURE
for the conventional status value for success and failure, respectively. They are declared in
the filestdlib.h.

int EXIT_SUCCESS [Macro]
This macro can be used with theexitfunction to indicate successful program com-
pletion.
On POSIX systems, the value of this macro is 0. On other systems, the value might
be some other (possibly non-constant) integer expression.

int EXIT_FAILURE [Macro]
This macro can be used with theexitfunction to indicate unsuccessful program
completion in a general sense.
On POSIX systems, the value of this macro is 1. On other systems, the value might be
some other (possibly non-constant) integer expression. Other nonzero status values
also indicate failures. Certain programs use different nonzero status values to indicate
particular kinds of"non-success". For example,diffuses status value 1 to mean that
the files are different, and 2 or more to mean that there was difficulty in opening the
files.

Don¡¯t confuse a program¡¯s exit status with a process¡¯ termination status. There are lots
of ways a process can terminate besides having its program finish. In the event that the
process terminationiscaused by program termination (i.e.,exit), though, the program¡¯s
exit status becomes part of the process¡¯ termination status.

## 25.7.3 Cleanups on Exit.......................................

Your program can arrange to run its own cleanup functions if normal termination happens.
If you are writing a library for use in various application programs, then it is unreliable to
insist that all applications call the library¡¯s cleanup functions explicitly before exiting. It is
much more robust to make the cleanup invisible to the application, by setting up a cleanup
function in the library itself usingatexitoron_exit.

int atexit(void(*function)(void)) [Function]
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theatexitfunction registers the functionfunctionto be called at normal program
termination. Thefunctionis called with no arguments.
The return value fromatexitis zero on success and nonzero if the function cannot
be registered.

int on_exit(void(*function)(intstatus, void *arg), void *arg) [Function]
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 25: The Basic Program/System Interface 801

```
This function is a somewhat more powerful variant ofatexit. It accepts two argu-
ments, a functionfunctionand an arbitrary pointerarg. At normal program termi-
nation, thefunctionis called with two arguments: thestatusvalue passed toexit,
and thearg.
This function is included in the GNU C Library only for compatibility for SunOS,
and may not be supported by other implementations.
```
```
Here¡¯s a trivial program that illustrates the use ofexitandatexit:
```
```
#include <stdio.h>
#include <stdlib.h>
```
```
void
bye (void)
{
puts ("Goodbye, cruel world....");
}
```
```
int
main (void)
{
atexit (bye);
exit (EXIT_SUCCESS);
}
```
When this program is executed, it just prints the message and exits.

25.7.4 Aborting a Program

You can abort your program using theabortfunction. The prototype for this function is
instdlib.h.

void abort(void) [Function]
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe lock corrupt |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Theabortfunction causes abnormal program termination. This does not execute
cleanup functions registered withatexitoron_exit.
This function actually terminates the process by raising aSIGABRTsignal, and your
program can include a handler to intercept this signal; seeChapter 24 [Signal Han-
dling], page 714.

## 25.7.5 Termination Internals..................................

The_exitfunction is the primitive used for process termination byexit. It is declared in
the header fileunistd.h.

void _exit(intstatus) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The_exitfunction is the primitive for causing a process to terminate with sta-
tusstatus. Calling this function does not execute cleanup functions registered with
atexitoron_exit.


Chapter 25: The Basic Program/System Interface 802

void _Exit(intstatus) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
The_Exitfunction is the ISO C equivalent to_exit. The ISO C committee members
were not sure whether the definitions of_exitand_Exitwere compatible so they
have not used the POSIX name.
This function was introduced in ISO C99 and is declared instdlib.h.

When a process terminates for any reason¡ªeither because the program terminates, or
as a result of a signal¡ªthe following things happen:

- All open file descriptors in the process are closed. SeeChapter 13 [Low-Level In-
    put/Output], page 342. Note that streams are not flushed automatically when the
    process terminates; seeChapter 12 [Input/Output on Streams], page 266.
- A process exit status is saved to be reported back to the parent process viawaitor
    waitpid; seeSection 26.6 [Process Completion], page 809. If the program exited, this
    status includes as its low-order 8 bits the program exit status.
- Any child processes of the process being terminated are assigned a new parent process.
    (On most systems, including GNU, this is theinitprocess, with process ID 1.)
- ASIGCHLDsignal is sent to the parent process.
- If the process is a session leader that has a controlling terminal, then aSIGHUPsignal is
    sent to each process in the foreground job, and the controlling terminal is disassociated
    from that session. SeeChapter 28 [Job Control], page 817.
- If termination of a process causes a process group to become orphaned, and any member
    of that process group is stopped, then aSIGHUPsignal and aSIGCONTsignal are sent
    to each process in the group. SeeChapter 28 [Job Control], page 817.


### 803

## 26 Processes.....................................

## 26 Processes..........................................

Processesare the primitive units for allocation of system resources. Each process has its
own address space and (usually) one thread of control. A process executes a program; you
can have multiple processes executing the same program, but each process has its own copy
of the program within its own address space and executes it independently of the other
copies.

Processes are organized hierarchically. Each process has aparent processwhich explicitly
arranged to create it. The processes created by a given parent are called itschild processes.
A child inherits many of its attributes from the parent process.

This chapter describes how a program can create, terminate, and control child processes.
Actually, there are three distinct operations involved: creating a new child process, causing
the new process to execute a program, and coordinating the completion of the child process
with the original program.

Thesystemfunction provides a simple, portable mechanism for running another pro-
gram; it does all three steps automatically. If you need more control over the details of how
this is done, you can use the primitive functions to do each step individually instead.

## 26.1 Running a Command........................................

The easy way to run another program is to use thesystemfunction. This function does all
the work of running a subprogram, but it doesn¡¯t give you much control over the details:
you have to wait until the subprogram terminates before you can do anything else.

int system(const char *command) [Function]
Preliminary:|MT-Safe |AS-Unsafe plugin heap lock|AC-Unsafe lock mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function executescommand as a shell command. In the GNU C Library, it
always uses the default shellshto run the command. In particular, it searches the
directories inPATHto find programs to execute. The return value is-1if it wasn¡¯t
possible to create the shell process, and otherwise is the status of the shell process.
SeeSection 26.6 [Process Completion], page 809, for details on how this status code
can be interpreted.
If thecommandargument is a null pointer, a return value of zero indicates that no
command processor is available.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timesystemis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this calls tosystemshould be protected
using cancellation handlers.
Thesystemfunction is declared in the header filestdlib.h.

Portability Note:Some C implementations may not have any notion of a command pro-
cessor that can execute other programs. You can determine whether a command processor
exists by executingsystem (NULL); if the return value is nonzero, a command processor is
available.


Chapter 26: Processes 804

Thepopenandpclosefunctions (seeSection 15.2 [Pipe to a Subprocess], page 452) are
closely related to thesystemfunction. They allow the parent process to communicate with
the standard input and output channels of the command being executed.

## 26.2 Process Creation Concepts..................................

This section gives an overview of processes and of the steps involved in creating a process
and making it run another program.

A new processes is created when one of the functionsposix_spawn,fork, orvforkis
called. (Thesystemandpopenalso create new processes internally.) Due to the name of
theforkfunction, the act of creating a new process is sometimes calledforkinga process.
Each new process (thechild processorsubprocess) is allocated a process ID, distinct from
the process ID of the parent process. SeeSection 26.3 [Process Identification], page 804.

After forking a child process, both the parent and child processes continue to execute
normally. If you want your program to wait for a child process to finish executing before con-
tinuing, you must do this explicitly after the fork operation, by callingwaitorwaitpid(see
Section 26.6 [Process Completion], page 809). These functions give you limited information
about why the child terminated¡ªfor example, its exit status code.

A newly forked child process continues to execute the same program as its parent process,
at the point where theforkcall returns. You can use the return value fromforkto tell
whether the program is running in the parent process or the child.

Having several processes run the same program is only occasionally useful. But the child
can execute another program using one of theexecfunctions; seeSection 26.5 [Executing
a File], page 806. The program that the process is executing is called itsprocess image.
Starting execution of a new program causes the process to forget all about its previous
process image; when the new program exits, the process exits too, instead of returning to
the previous process image.

## 26.3 Process Identification........................................

Each process is named by aprocess IDnumber, a value of typepid_t. A process ID is
allocated to each process when it is created. Process IDs are reused over time. The lifetime
of a process ends when the parent process of the corresponding process waits on the process
ID after the process has terminated. SeeSection 26.6 [Process Completion], page 809. (The
parent process can arrange for such waiting to happen implicitly.) A process ID uniquely
identifies a process only during the lifetime of the process. As a rule of thumb, this means
that the process must still be running.

Process IDs can also denote process groups and sessions. SeeChapter 28 [Job Control],
page 817.

On Linux, threads created bypthread_createalso receive athread ID. The thread ID
of the initial (main) thread is the same as the process ID of the entire process. Thread IDs
for subsequently created threads are distinct. They are allocated from the same numbering
space as process IDs. Process IDs and thread IDs are sometimes also referred to collectively
astask IDs. In contrast to processes, threads are never waited for explicitly, so a thread
ID becomes eligible for reuse as soon as a thread exits or is canceled. This is true even for
joinable threads, not just detached threads. Threads are assigned to athread group. In the


Chapter 26: Processes 805

GNU C Library implementation running on Linux, the process ID is the thread group ID
of all threads in the process.

You can get the process ID of a process by callinggetpid. The functiongetppidreturns
the process ID of the parent of the current process (this is also known as theparent process
ID). Your program should include the header filesunistd.handsys/types.hto use these
functions.

pid_t [Data Type]
Thepid_tdata type is a signed integer type which is capable of representing a process
ID. In the GNU C Library, this is anint.

pid_t getpid (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetpidfunction returns the process ID of the current process.

pid_t getppid(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetppidfunction returns the process ID of the parent of the current process.

pid_t gettid (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegettidfunction returns the thread ID of the current thread. The returned value
is obtained from the Linux kernel and is not subject to caching. See the discussion of
thread IDs above, especially regarding reuse of the IDs of threads which have exited.
This function is specific to Linux.

## 26.4 Creating a Process..........................................

Theforkfunction is the primitive for creating a process. It is declared in the header file
unistd.h.

pid_t fork(void) [Function]
Preliminary:|MT-Safe |AS-Unsafe plugin|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theforkfunction creates a new process.
If the operation is successful, there are then both parent and child processes and both
seeforkreturn, but with different values: it returns a value of 0 in the child process
and returns the child¡¯s process ID in the parent process.
If process creation failed,forkreturns a value of -1in the parent process. The
followingerrnoerror conditions are defined forfork:
EAGAIN There aren¡¯t enough system resources to create another process, or the
user already has too many processes running. This means exceeding
the RLIMIT_NPROCresource limit, which can usually be increased; see
Section 22.2 [Limiting Resource Usage], page 685.


Chapter 26: Processes 806

```
ENOMEM The process requires more space than the system can supply.
```
```
The specific attributes of the child process that differ from the parent process are:
```
- The child process has its own unique process ID.
- The parent process ID of the child process is the process ID of its parent process.
- The child process gets its own copies of the parent process¡¯s open file descriptors. Sub-
    sequently changing attributes of the file descriptors in the parent process won¡¯t affect
    the file descriptors in the child, and vice versa. SeeSection 13.12 [Control Operations
    on Files], page 383. However, the file position associated with each descriptor is shared
    by both processes; seeSection 11.1.2 [File Position], page 262.
- The elapsed processor times for the child process are set to zero; seeSection 21.4.2
    [Processor Time Inquiry], page 650.
- The child doesn¡¯t inherit file locks set by the parent process. SeeSection 13.12 [Control
    Operations on Files], page 383.
- The child doesn¡¯t inherit alarms set by the parent process. SeeSection 21.6 [Setting
    an Alarm], page 679.
- The set of pending signals (seeSection 24.1.3 [How Signals Are Delivered], page 715)
    for the child process is cleared. (The child process inherits its mask of blocked signals
    and signal actions from the parent process.)

pid_t vfork(void) [Function]
Preliminary:|MT-Safe |AS-Unsafe plugin|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thevforkfunction is similar toforkbut on some systems it is more efficient; however,
there are restrictions you must follow to use it safely.
Whileforkmakes a complete copy of the calling process¡¯s address space and allows
both the parent and child to execute independently,vforkdoes not make this copy.
Instead, the child process created withvforkshares its parent¡¯s address space until
it calls_exitor one of theexecfunctions. In the meantime, the parent process
suspends execution.
You must be very careful not to allow the child process created withvforkto modify
any global data or even local variables shared with the parent. Furthermore, the child
process cannot return from (or do a long jump out of) the function that calledvfork!
This would leave the parent process¡¯s control information very confused. If in doubt,
useforkinstead.
Some operating systems don¡¯t really implementvfork. The GNU C Library permits
you to usevforkon all systems, but actually executesforkifvforkisn¡¯t available. If
you follow the proper precautions for usingvfork, your program will still work even
if the system usesforkinstead.

## 26.5 Executing a File.............................................

This section describes theexecfamily of functions, for executing a file as a process image.
You can use these functions to make a child process execute a new program after it has
been forked.


Chapter 26: Processes 807

To see the effects ofexecfrom the point of view of the called program, seeChapter 25
[The Basic Program/System Interface], page 759.

The functions in this family differ in how you specify the arguments, but otherwise they
all do the same thing. They are declared in the header fileunistd.h.

int execv (const char *filename, char *constargv[]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theexecvfunction executes the file named byfilenameas a new process image.
Theargvargument is an array of null-terminated strings that is used to provide a
value for theargvargument to themainfunction of the program to be executed. The
last element of this array must be a null pointer. By convention, the first element
of this array is the file name of the program sans directory names. SeeSection 25.1
[Program Arguments], page 759, for full details on how programs can access these
arguments.
The environment for the new process image is taken from theenvironvariable of
the current process image; seeSection 25.4 [Environment Variables], page 792, for
information about environments.

int execl (const char *filename, const char *arg0,.. .) [Function]
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This is similar toexecv, but theargvstrings are specified individually instead of as
an array. A null pointer must be passed as the last such argument.

int execve(const char *filename, char *constargv[], char *const [Function]
env[])
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is similar toexecv, but permits you to specify the environment for the new
program explicitly as theenv argument. This should be an array of strings in the
same format as for theenvironvariable; seeSection 25.4.1 [Environment Access],
page 793.

int fexecve(intfd, char *constargv[], char *constenv[]) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is similar toexecve, but instead of identifying the program executable by its
pathname, the file descriptorfdis used. The descriptor must have been opened with
theO_RDONLYflag or (on Linux) theO_PATHflag.
On Linux,fexecvecan fail with an error ofENOSYSif/prochas not been mounted
and the kernel lacks support for the underlyingexecveatsystem call.

int execle(const char *filename, const char *arg0,... , char [Function]
*constenv[])
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 26: Processes 808

```
This is similar toexecl, but permits you to specify the environment for the new
program explicitly. The environment argument is passed following the null pointer
that marks the lastargvargument, and should be an array of strings in the same
format as for theenvironvariable.
```
int execvp(const char *filename, char *constargv[]) [Function]
Preliminary:|MT-Safe env|AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theexecvpfunction is similar toexecv, except that it searches the directories listed in
thePATHenvironment variable (seeSection 25.4.2 [Standard Environment Variables],
page 795) to find the full file name of a file fromfilenameiffilenamedoes not contain
a slash.
This function is useful for executing system utility programs, because it looks for
them in the places that the user has chosen. Shells use it to run the commands that
users type.

int execlp(const char *filename, const char *arg0,.. .) [Function]
Preliminary:|MT-Safe env|AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function is likeexecl, except that it performs the same file name searching as
theexecvpfunction.

The size of the argument list and environment list taken together must not be greater
thanARG_MAXbytes. SeeSection 32.1 [General Capacity Limits], page 890. On GNU/Hurd
systems, the size (which compares againstARG_MAX) includes, for each string, the number
of characters in the string, plus the size of achar *, plus one, rounded up to a multiple of
the size of achar *. Other systems may have somewhat different rules for counting.

These functions normally don¡¯t return, since execution of a new program causes the
currently executing program to go away completely. A value of-1is returned in the event
of a failure. In addition to the usual file name errors (seeSection 11.2.3 [File Name Errors],
page 264), the followingerrnoerror conditions are defined for these functions:

E2BIG The combined size of the new program¡¯s argument list and environment list is
larger thanARG_MAXbytes. GNU/Hurd systems have no specific limit on the
argument list size, so this error code cannot result, but you may getENOMEM
instead if the arguments are too big for available memory.

ENOEXEC The specified file can¡¯t be executed because it isn¡¯t in the right format.

ENOMEM Executing the specified file requires more storage than is available.

If execution of the new file succeeds, it updates the access time field of the file as if the
file had been read. SeeSection 14.9.9 [File Times], page 439, for more details about access
times of files.

The point at which the file is closed again is not specified, but is at some point before
the process exits or before another process image is executed.

Executing a new process image completely changes the contents of memory, copying only
the argument and environment strings to new locations. But many other attributes of the
process are unchanged:


Chapter 26: Processes 809

- The process ID and the parent process ID. SeeSection 26.2 [Process Creation Concepts],
    page 804.
- Session and process group membership. SeeSection 28.1 [Concepts of Job Control],
    page 817.
- Real user ID and group ID, and supplementary group IDs. SeeSection 30.2 [The
    Persona of a Process], page 845.
- Pending alarms. SeeSection 21.6 [Setting an Alarm], page 679.
- Current working directory and root directory. SeeSection 14.1 [Working Directory],
    page 402. On GNU/Hurd systems, the root directory is not copied when executing a
    setuid program; instead the system default root directory is used for the new program.
- File mode creation mask. SeeSection 14.9.7 [Assigning File Permissions], page 436.
- Process signal mask; seeSection 24.7.3 [Process Signal Mask], page 748.
- Pending signals; seeSection 24.7 [Blocking Signals], page 746.
- Elapsed processor time associated with the process; seeSection 21.4.2 [Processor Time
    Inquiry], page 650.

If the set-user-ID and set-group-ID mode bits of the process image file are set, this affects
the effective user ID and effective group ID (respectively) of the process. These concepts
are discussed in detail inSection 30.2 [The Persona of a Process], page 845.

Signals that are set to be ignored in the existing process image are also set to be ignored
in the new process image. All other signals are set to the default action in the new process
image. For more information about signals, seeChapter 24 [Signal Handling], page 714.

File descriptors open in the existing process image remain open in the new process image,
unless they have theFD_CLOEXEC(close-on-exec) flag set. The files that remain open inherit
all attributes of the open file descriptors from the existing process image, including file
locks. File descriptors are discussed inChapter 13 [Low-Level Input/Output], page 342.

Streams, by contrast, cannot survive throughexecfunctions, because they are located
in the memory of the process itself. The new process image has no streams except those it
creates afresh. Each of the streams in the pre-execprocess image has a descriptor inside
it, and these descriptors do survive throughexec(provided that they do not haveFD_
CLOEXECset). The new process image can reconnect these to new streams usingfdopen
(seeSection 13.4 [Descriptors and Streams], page 352).

## 26.6 Process Completion.........................................

The functions described in this section are used to wait for a child process to terminate or
stop, and determine its status. These functions are declared in the header filesys/wait.h.

pid_t waitpid(pidtpid, int *status-ptr, intoptions) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thewaitpidfunction is used to request status information from a child process whose
process ID ispid. Normally, the calling process is suspended until the child process
makes status information available by terminating.


Chapter 26: Processes 810

```
Other values for thepidargument have special interpretations. A value of-1or
WAIT_ANYrequests status information for any child process; a value of 0 orWAIT_
MYPGRPrequests information for any child process in the same process group as the
calling process; and any other negative value? pgidrequests information for any
child process whose process group ID ispgid.
If status information for a child process is available immediately, this function re-
turns immediately without waiting. If more than one eligible child process has status
information available, one of them is chosen randomly, and its status is returned im-
mediately. To get the status from the other eligible child processes, you need to call
waitpidagain.
Theoptionsargument is a bit mask. Its value should be the bitwise OR (that is, the
¡®|¡¯ operator) of zero or more of theWNOHANGandWUNTRACEDflags. You can use the
WNOHANGflag to indicate that the parent process shouldn¡¯t wait; and theWUNTRACED
flag to request status information from stopped processes as well as processes that
have terminated.
The status information from the child process is stored in the object thatstatus-ptr
points to, unlessstatus-ptris a null pointer.
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timewaitpidis called. If the thread gets canceled these resources
stay allocated until the program ends. To avoid this calls towaitpid should be
protected using cancellation handlers.
The return value is normally the process ID of the child process whose status is
reported. If there are child processes but none of them is waiting to be noticed,
waitpidwill block until one is. However, if theWNOHANGoption was specified,waitpid
will return zero instead of blocking.
If a specific PID to wait for was given towaitpid, it will ignore all other children
(if any). Therefore if there are children waiting to be noticed but the child whose
PID was specified is not one of them,waitpidwill block or return zero as described
above.
A value of-1is returned in case of error. The followingerrnoerror conditions are
defined for this function:
```
```
EINTR The function was interrupted by delivery of a signal to the calling process.
SeeSection 24.5 [Primitives Interrupted by Signals], page 741.
```
```
ECHILD There are no child processes to wait for, or the specifiedpidis not a child
of the calling process.
```
```
EINVAL An invalid value was provided for theoptionsargument.
```
These symbolic constants are defined as values for thepid argument to thewaitpid
function.

WAIT_ANY

```
This constant macro (whose value is-1) specifies thatwaitpidshould return
status information about any child process.
```

Chapter 26: Processes 811

### WAIT_MYPGRP

```
This constant (with value 0 ) specifies thatwaitpidshould return status in-
formation about any child process in the same process group as the calling
process.
```
These symbolic constants are defined as flags for theoptionsargument to thewaitpid
function. You can bitwise-OR the flags together to obtain a value to use as the argument.

WNOHANG

```
This flag specifies thatwaitpidshould return immediately instead of waiting,
if there is no child process ready to be noticed.
```
WUNTRACED
This flag specifies thatwaitpidshould report the status of any child processes
that have been stopped as well as those that have terminated.

pid_t wait(int *status-ptr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is a simplified version ofwaitpid, and is used to wait until any one child process
terminates. The call:
wait (&status)
is exactly equivalent to:
waitpid (-1, &status, 0)
This function is a cancellation point in multi-threaded programs. This is a problem
if the thread allocates some resources (like memory, file descriptors, semaphores or
whatever) at the timewaitis called. If the thread gets canceled these resources stay
allocated until the program ends. To avoid this calls towaitshould be protected
using cancellation handlers.

pid_t wait4(pidtpid, int *status-ptr, intoptions, struct rusage [Function]
*usage)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If usage is a null pointer, wait4 is equivalent to waitpid (pid,status-ptr,
options).
Ifusageis not null,wait4stores usage figures for the child process in*rusage(but
only if the child has terminated, not if it has stopped). SeeSection 22.1 [Resource
Usage], page 684.
This function is a BSD extension.

Here¡¯s an example of how to usewaitpid to get the status from all child processes
that have terminated, without ever waiting. This function is designed to be a handler for
SIGCHLD, the signal that indicates that at least one child process has terminated.


Chapter 26: Processes 812

```
void
sigchld_handler (int signum)
{
int pid, status, serrno;
serrno = errno;
while (1)
{
pid = waitpid (WAIT_ANY, &status, WNOHANG);
if (pid < 0)
{
perror ("waitpid");
break;
}
if (pid == 0)
break;
notice_termination (pid, status);
}
errno = serrno;
}
```
## 26.7 Process Completion Status..................................

If the exit status value (seeSection 25.7 [Program Termination], page 798) of the child
process is zero, then the status value reported bywaitpidorwaitis also zero. You can
test for other kinds of information encoded in the returned status value using the following
macros. These macros are defined in the header filesys/wait.h.

int WIFEXITED(intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value if the child process terminated normally with
exitor_exit.

int WEXITSTATUS (intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
IfWIFEXITEDis true ofstatus, this macro returns the low-order 8 bits of the exit
status value from the child process. SeeSection 25.7.2 [Exit Status], page 799.

int WIFSIGNALED (intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value if the child process terminated because it received
a signal that was not handled. SeeChapter 24 [Signal Handling], page 714.

int WTERMSIG (intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
IfWIFSIGNALEDis true ofstatus, this macro returns the signal number of the signal
that terminated the child process.


Chapter 26: Processes 813

int WCOREDUMP(intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value if the child process terminated and produced a
core dump.

int WIFSTOPPED(intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro returns a nonzero value if the child process is stopped.

int WSTOPSIG (intstatus) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
IfWIFSTOPPEDis true ofstatus, this macro returns the signal number of the signal
that caused the child process to stop.

## 26.8 BSD Process Wait Function.................................

The GNU C Library also provides thewait3function for compatibility with BSD. This
function is declared insys/wait.h. It is the predecessor towait4, which is more flexible.
wait3is now obsolete.

pid_t wait3(int *status-ptr, intoptions, struct rusage *usage) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
If usage is a null pointer, wait3 is equivalent to waitpid (-1,status-ptr,
options).
Ifusageis not null,wait3stores usage figures for the child process in*rusage(but
only if the child has terminated, not if it has stopped). SeeSection 22.1 [Resource
Usage], page 684.

## 26.9 Process Creation Example...................................

Here is an example program showing how you might write a function similar to the built-in
system. It executes itscommandargument using the equivalent of ¡®sh -ccommand¡¯.
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

```
/*Execute the command using this shell program. */
#define SHELL "/bin/sh"
```
```
int
my_system (const char *command)
{
int status;
pid_t pid;
```

Chapter 26: Processes 814

pid = fork ();
if (pid == 0)
{
/*This is the child process. Execute the shell command.*/
execl (SHELL, SHELL, "-c", command, NULL);
_exit (EXIT_FAILURE);
}
else if (pid < 0)
/*The fork failed. Report failure. */
status = -1;
else
/*This is the parent process. Wait for the child to complete. */
if (waitpid (pid, &status, 0) != pid)
status = -1;
return status;
}
There are a couple of things you should pay attention to in this example.
Remember that the firstargvargument supplied to the program represents the name of
the program being executed. That is why, in the call toexecl,SHELLis supplied once to
name the program to execute and a second time to supply a value forargv[0].

Theexeclcall in the child process doesn¡¯t return if it is successful. If it fails, you must
do something to make the child process terminate. Just returning a bad status code with
returnwould leave two processes running the original program. Instead, the right behavior
is for the child process to report failure to its parent process.

Call_exitto accomplish this. The reason for using_exitinstead ofexitis to avoid
flushing fully buffered streams such asstdout. The buffers of these streams probably
contain data that was copied from the parent process by thefork, data that will be output
eventually by the parent process. Callingexitin the child would output the data twice.
SeeSection 25.7.5 [Termination Internals], page 801.


### 815

## 27 Inter-Process Communication..............

## 27 Inter-Process Communication..........................

This chapter describes the GNU C Library inter-process communication primitives.

## 27.1 Semaphores.................................................

The GNU C Library implements the semaphore APIs as defined in POSIX and System V.
Semaphores can be used by multiple processes to coordinate shared resources. The following
is a complete list of the semaphore functions provided by the GNU C Library.

## 27.1.1 System V Semaphores..................................

int semctl(intsemid, intsemnum, intcmd); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe corrupt/linux|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.

int semget(keytkey, intnsems, intsemflg); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

int semop (intsemid, struct sembuf *sops, size tnsops); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

int semtimedop(intsemid, struct sembuf *sops, size tnsops, const [Function]
struct timespec *timeout);
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

## 27.1.2 POSIX Semaphores....................................

int sem_init (semt *sem, intpshared, unsigned intvalue); [Function]
Preliminary:|MT-Safe|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.

int sem_destroy (semt *sem); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

sem_t *sem_open (const char *name, intoflag, ...); [Function]
Preliminary: |MT-Safe |AS-Unsafe init|AC-Unsafe init|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.

int sem_close(sem t *sem); [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.

int sem_unlink(const char *name); [Function]
Preliminary:|MT-Safe |AS-Unsafe init|AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.


Chapter 27: Inter-Process Communication 816

int sem_wait (semt *sem); [Function]
Preliminary:|MT-Safe|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.

int sem_timedwait(sem t *sem, const struct timespec *abstime); [Function]
Preliminary:|MT-Safe|AS-Safe|AC-Unsafe corrupt|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.

int sem_trywait (semt *sem); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

int sem_post (semt *sem); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.

int sem_getvalue (semt *sem, int *sval); [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


### 817

## 28 Job Control..................................

## 28 Job Control........................................

Job controlrefers to the protocol for allowing a user to move between multiple process
groups(or jobs) within a single login session. The job control facilities are set up so
that appropriate behavior for most programs happens automatically and they need not do
anything special about job control. So you can probably ignore the material in this chapter
unless you are writing a shell or login program.

You need to be familiar with concepts relating to process creation (seeSection 26.2 [Pro-
cess Creation Concepts], page 804) and signal handling (seeChapter 24 [Signal Handling],
page 714) in order to understand this material presented in this chapter.

Some old systems do not support job control, but GNU systems always have, and it is a
required feature in the 2001 revision of POSIX.1 (seeSection 1.2.2 [POSIX (The Portable
Operating System Interface)], page 2). If you need to be portable to old systems, you can
use the_POSIX_JOB_CONTROLmacro to test at compile-time whether the system supports
job control. SeeSection 32.2 [Overall System Options], page 891.

## 28.1 Concepts of Job Control.....................................

The fundamental purpose of an interactive shell is to read commands from the user¡¯s ter-
minal and create processes to execute the programs specified by those commands. It can
do this using thefork(seeSection 26.4 [Creating a Process], page 805) andexec(see
Section 26.5 [Executing a File], page 806) functions.

A single command may run just one process¡ªbut often one command uses several pro-
cesses. If you use the ¡®|¡¯ operator in a shell command, you explicitly request several pro-
grams in their own processes. But even if you run just one program, it can use multiple
processes internally. For example, a single compilation command such as ¡®cc -c foo.c¡¯
typically uses four processes (though normally only two at any given time). If you run
make, its job is to run other programs in separate processes.

The processes belonging to a single command are called aprocess grouporjob. This is
so that you can operate on all of them at once. For example, typingC-csends the signal
SIGINTto terminate all the processes in the foreground process group.

Asessionis a larger group of processes. Normally all the processes that stem from a
single login belong to the same session.

Every process belongs to a process group. When a process is created, it becomes a
member of the same process group and session as its parent process. You can put it in
another process group using thesetpgidfunction, provided the process group belongs to
the same session.

The only way to put a process in a different session is to make it the initial process of
a new session, or asession leader, using thesetsidfunction. This also puts the session
leader into a new process group, and you can¡¯t move it out of that process group again.

Usually, new sessions are created by the system login program, and the session leader is
the process running the user¡¯s login shell.

A shell that supports job control must arrange to control which job can use the terminal
at any time. Otherwise there might be multiple jobs trying to read from the terminal at
once, and confusion about which process should receive the input typed by the user. To


Chapter 28: Job Control 818

prevent this, the shell must cooperate with the terminal driver using the protocol described
in this chapter.

The shell can give unlimited access to the controlling terminal to only one process group
at a time. This is called theforeground jobon that controlling terminal. Other process
groups managed by the shell that are executing without such access to the terminal are
calledbackground jobs.

If a background job needs to read from its controlling terminal, it isstoppedby the ter-
minal driver; if theTOSTOPmode is set, likewise for writing. The user can stop a foreground
job by typing the SUSP character (seeSection 17.4.9 [Special Characters], page 516) and a
program can stop any job by sending it aSIGSTOPsignal. It¡¯s the responsibility of the shell
to notice when jobs stop, to notify the user about them, and to provide mechanisms for
allowing the user to interactively continue stopped jobs and switch jobs between foreground
and background.

SeeSection 28.3 [Access to the Controlling Terminal], page 818, for more information
about I/O to the controlling terminal.

## 28.2 Controlling Terminal of a Process............................

One of the attributes of a process is its controlling terminal. Child processes created with
forkinherit the controlling terminal from their parent process. In this way, all the processes
in a session inherit the controlling terminal from the session leader. A session leader that
has control of a terminal is called thecontrolling processof that terminal.

You generally do not need to worry about the exact mechanism used to allocate a
controlling terminal to a session, since it is done for you by the system when you log in.

An individual process disconnects from its controlling terminal when it callssetsidto
become the leader of a new session. SeeSection 28.6.2 [Process Group Functions], page 831.

## 28.3 Access to the Controlling Terminal..........................

Processes in the foreground job of a controlling terminal have unrestricted access to that
terminal; background processes do not. This section describes in more detail what happens
when a process in a background job tries to access its controlling terminal.

When a process in a background job tries to read from its controlling terminal, the
process group is usually sent aSIGTTINsignal. This normally causes all of the processes
in that group to stop (unless they handle the signal and don¡¯t stop themselves). However,
if the reading process is ignoring or blocking this signal, thenreadfails with anEIOerror
instead.

Similarly, when a process in a background job tries to write to its controlling terminal,
the default behavior is to send aSIGTTOUsignal to the process group. However, the behavior
is modified by theTOSTOPbit of the local modes flags (seeSection 17.4.7 [Local Modes],
page 512). If this bit is not set (which is the default), then writing to the controlling
terminal is always permitted without sending a signal. Writing is also permitted if the
SIGTTOUsignal is being ignored or blocked by the writing process.

Most other terminal operations that a program can do are treated as reading or as
writing. (The description of each operation should say which.)


Chapter 28: Job Control 819

For more information about the primitivereadandwritefunctions, seeSection 13.2
[Input and Output Primitives], page 345.

## 28.4 Orphaned Process Groups...................................

When a controlling process terminates, its terminal becomes free and a new session can be
established on it. (In fact, another user could log in on the terminal.) This could cause a
problem if any processes from the old session are still trying to use that terminal.

To prevent problems, process groups that continue running even after the session leader
has terminated are marked asorphaned process groups.

When a process group becomes an orphan, its processes are sent aSIGHUPsignal. Or-
dinarily, this causes the processes to terminate. However, if a program ignores this signal
or establishes a handler for it (seeChapter 24 [Signal Handling], page 714), it can continue
running as in the orphan process group even after its controlling process terminates; but it
still cannot access the terminal any more.

## 28.5 Implementing a Job Control Shell...........................

This section describes what a shell must do to implement job control, by presenting an
extensive sample program to illustrate the concepts involved.

- Section 28.5.1 [Data Structures for the Shell], page 819, introduces the example and
    presents its primary data structures.
- Section 28.5.2 [Initializing the Shell], page 821, discusses actions which the shell must
    perform to prepare for job control.
- Section 28.5.3 [Launching Jobs], page 822, includes information about how to create
    jobs to execute commands.
- Section 28.5.4 [Foreground and Background], page 825, discusses what the shell should
    do differently when launching a job in the foreground as opposed to a background job.
- Section 28.5.5 [Stopped and Terminated Jobs], page 827, discusses reporting of job
    status back to the shell.
- Section 28.5.6 [Continuing Stopped Jobs], page 829, tells you how to continue jobs that
    have been stopped.
- Section 28.5.7 [The Missing Pieces], page 830, discusses other parts of the shell.

## 28.5.1 Data Structures for the Shell...........................

All of the program examples included in this chapter are part of a simple shell program.
This section presents data structures and utility functions which are used throughout the
example.

The sample shell deals mainly with two data structures. Thejobtype contains infor-
mation about a job, which is a set of subprocesses linked together with pipes. Theprocess
type holds information about a single subprocess. Here are the relevant data structure
declarations:


Chapter 28: Job Control 820

```
/*A process is a single process. */
typedef struct process
{
struct process *next; /*next process in pipeline*/
char **argv; /*for exec*/
pid_t pid; /*process ID*/
char completed; /*true if process has completed*/
char stopped; /*true if process has stopped*/
int status; /*reported status value*/
} process;
```
```
/*A job is a pipeline of processes. */
typedef struct job
{
struct job *next; /*next active job*/
char *command; /*command line, used for messages*/
process *first_process; /*list of processes in this job*/
pid_t pgid; /*process group ID*/
char notified; /*true if user told about stopped job*/
struct termios tmodes; /*saved terminal modes*/
int stdin, stdout, stderr; /*standard i/o channels*/
} job;
```
```
/*The active jobs are linked into a list. This is its head. */
job *first_job = NULL;
```
```
Here are some utility functions that are used for operating onjobobjects.
```
```
/*Find the active job with the indicatedpgid. */
job *
find_job (pid_t pgid)
{
job *j;
```
```
for (j = first_job; j; j = j->next)
if (j->pgid == pgid)
return j;
return NULL;
}
```
```
/*Return true if all processes in the job have stopped or completed. */
int
job_is_stopped (job *j)
{
process *p;
```
```
for (p = j->first_process; p; p = p->next)
if (!p->completed && !p->stopped)
return 0;
return 1;
}
```

Chapter 28: Job Control 821

```
/*Return true if all processes in the job have completed. */
int
job_is_completed (job *j)
{
process *p;
```
```
for (p = j->first_process; p; p = p->next)
if (!p->completed)
return 0;
return 1;
}
```
## 28.5.2 Initializing the Shell....................................

When a shell program that normally performs job control is started, it has to be careful in
case it has been invoked from another shell that is already doing its own job control.

A subshell that runs interactively has to ensure that it has been placed in the foreground
by its parent shell before it can enable job control itself. It does this by getting its initial
process group ID with thegetpgrpfunction, and comparing it to the process group ID of
the current foreground job associated with its controlling terminal (which can be retrieved
using thetcgetpgrpfunction).

If the subshell is not running as a foreground job, it must stop itself by sending aSIGTTIN
signal to its own process group. It may not arbitrarily put itself into the foreground; it must
wait for the user to tell the parent shell to do this. If the subshell is continued again, it
should repeat the check and stop itself again if it is still not in the foreground.

Once the subshell has been placed into the foreground by its parent shell, it can enable
its own job control. It does this by callingsetpgidto put itself into its own process group,
and then callingtcsetpgrpto place this process group into the foreground.

When a shell enables job control, it should set itself to ignore all the job control stop
signals so that it doesn¡¯t accidentally stop itself. You can do this by setting the action for
all the stop signals toSIG_IGN.

A subshell that runs non-interactively cannot and should not support job control. It
must leave all processes it creates in the same process group as the shell itself; this allows
the non-interactive shell and its child processes to be treated as a single job by the parent
shell. This is easy to do¡ªjust don¡¯t use any of the job control primitives¡ªbut you must
remember to make the shell do it.

```
Here is the initialization code for the sample shell that shows how to do all of this.
/*Keep track of attributes of the shell. */
```
```
#include <sys/types.h>
#include <termios.h>
#include <unistd.h>
```
```
pid_t shell_pgid;
struct termios shell_tmodes;
int shell_terminal;
int shell_is_interactive;
```
```
/*Make sure the shell is running interactively as the foreground job
before proceeding.*/
```

Chapter 28: Job Control 822

```
void
init_shell ()
{
```
```
/*See if we are running interactively. */
shell_terminal = STDIN_FILENO;
shell_is_interactive = isatty (shell_terminal);
```
```
if (shell_is_interactive)
{
/*Loop until we are in the foreground. */
while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
kill (- shell_pgid, SIGTTIN);
```
```
/*Ignore interactive and job-control signals. */
signal (SIGINT, SIG_IGN);
signal (SIGQUIT, SIG_IGN);
signal (SIGTSTP, SIG_IGN);
signal (SIGTTIN, SIG_IGN);
signal (SIGTTOU, SIG_IGN);
signal (SIGCHLD, SIG_IGN);
```
```
/*Put ourselves in our own process group. */
shell_pgid = getpid ();
if (setpgid (shell_pgid, shell_pgid) < 0)
{
perror ("Couldn't put the shell in its own process group");
exit (1);
}
```
```
/*Grab control of the terminal. */
tcsetpgrp (shell_terminal, shell_pgid);
```
```
/*Save default terminal attributes for shell. */
tcgetattr (shell_terminal, &shell_tmodes);
}
}
```
## 28.5.3 Launching Jobs........................................

Once the shell has taken responsibility for performing job control on its controlling terminal,
it can launch jobs in response to commands typed by the user.

To create the processes in a process group, you use the sameforkandexecfunctions
described inSection 26.2 [Process Creation Concepts], page 804. Since there are multiple
child processes involved, though, things are a little more complicated and you must be
careful to do things in the right order. Otherwise, nasty race conditions can result.

You have two choices for how to structure the tree of parent-child relationships among
the processes. You can either make all the processes in the process group be children of
the shell process, or you can make one process in group be the ancestor of all the other
processes in that group. The sample shell program presented in this chapter uses the first
approach because it makes bookkeeping somewhat simpler.

As each process is forked, it should put itself in the new process group by callingsetpgid;
seeSection 28.6.2 [Process Group Functions], page 831. The first process in the new group


Chapter 28: Job Control 823

becomes itsprocess group leader, and its process ID becomes theprocess group IDfor the
group.

The shell should also callsetpgidto put each of its child processes into the new process
group. This is because there is a potential timing problem: each child process must be put
in the process group before it begins executing a new program, and the shell depends on
having all the child processes in the group before it continues executing. If both the child
processes and the shell callsetpgid, this ensures that the right things happen no matter
which process gets to it first.

If the job is being launched as a foreground job, the new process group also needs to be
put into the foreground on the controlling terminal usingtcsetpgrp. Again, this should
be done by the shell as well as by each of its child processes, to avoid race conditions.

The next thing each child process should do is to reset its signal actions.
During initialization, the shell process set itself to ignore job control signals; see
Section 28.5.2 [Initializing the Shell], page 821. As a result, any child processes it creates
also ignore these signals by inheritance. This is definitely undesirable, so each child process
should explicitly set the actions for these signals back toSIG_DFLjust after it is forked.

Since shells follow this convention, applications can assume that they inherit the correct
handling of these signals from the parent process. But every application has a responsi-
bility not to mess up the handling of stop signals. Applications that disable the normal
interpretation of the SUSP character should provide some other mechanism for the user to
stop the job. When the user invokes this mechanism, the program should send aSIGTSTP
signal to the process group of the process, not just to the process itself. SeeSection 24.6.2
[Signaling Another Process], page 743.

Finally, each child process should callexecin the normal way. This is also the point
at which redirection of the standard input and output channels should be handled. See
Section 13.13 [Duplicating Descriptors], page 384, for an explanation of how to do this.

Here is the function from the sample shell program that is responsible for launching a
program. The function is executed by each child process immediately after it has been
forked by the shell, and never returns.
void
launch_process (process *p, pid_t pgid,
int infile, int outfile, int errfile,
int foreground)
{
pid_t pid;

```
if (shell_is_interactive)
{
/*Put the process into the process group and give the process group
the terminal, if appropriate.
This has to be done both by the shell and in the individual
child processes because of potential race conditions. */
pid = getpid ();
if (pgid == 0) pgid = pid;
setpgid (pid, pgid);
if (foreground)
tcsetpgrp (shell_terminal, pgid);
```
```
/*Set the handling for job control signals back to the default. */
```

Chapter 28: Job Control 824

```
signal (SIGINT, SIG_DFL);
signal (SIGQUIT, SIG_DFL);
signal (SIGTSTP, SIG_DFL);
signal (SIGTTIN, SIG_DFL);
signal (SIGTTOU, SIG_DFL);
signal (SIGCHLD, SIG_DFL);
}
```
```
/*Set the standard input/output channels of the new process. */
if (infile != STDIN_FILENO)
{
dup2 (infile, STDIN_FILENO);
close (infile);
}
if (outfile != STDOUT_FILENO)
{
dup2 (outfile, STDOUT_FILENO);
close (outfile);
}
if (errfile != STDERR_FILENO)
{
dup2 (errfile, STDERR_FILENO);
close (errfile);
}
```
/*Exec the new process. Make sure we exit. */
execvp (p->argv[0], p->argv);
perror ("execvp");
exit (1);
}
If the shell is not running interactively, this function does not do anything with process
groups or signals. Remember that a shell not performing job control must keep all of its
subprocesses in the same process group as the shell itself.

Next, here is the function that actually launches a complete job. After creating the child
processes, this function calls some other functions to put the newly created job into the fore-
ground or background; these are discussed inSection 28.5.4 [Foreground and Background],
page 825.

```
void
launch_job (job *j, int foreground)
{
process *p;
pid_t pid;
int mypipe[2], infile, outfile;
```
```
infile = j->stdin;
for (p = j->first_process; p; p = p->next)
{
/*Set up pipes, if necessary. */
if (p->next)
{
if (pipe (mypipe) < 0)
{
perror ("pipe");
exit (1);
}
outfile = mypipe[1];
```

Chapter 28: Job Control 825

```
}
else
outfile = j->stdout;
```
```
/*Fork the child processes. */
pid = fork ();
if (pid == 0)
/* This is the child process. */
launch_process (p, j->pgid, infile,
outfile, j->stderr, foreground);
else if (pid < 0)
{
/*The fork failed. */
perror ("fork");
exit (1);
}
else
{
/*This is the parent process. */
p->pid = pid;
if (shell_is_interactive)
{
if (!j->pgid)
j->pgid = pid;
setpgid (pid, j->pgid);
}
}
```
```
/*Clean up after pipes. */
if (infile != j->stdin)
close (infile);
if (outfile != j->stdout)
close (outfile);
infile = mypipe[0];
}
```
```
format_job_info (j, "launched");
```
```
if (!shell_is_interactive)
wait_for_job (j);
else if (foreground)
put_job_in_foreground (j, 0);
else
put_job_in_background (j, 0);
}
```
## 28.5.4 Foreground and Background............................

Now let¡¯s consider what actions must be taken by the shell when it launches a job into
the foreground, and how this differs from what must be done when a background job is
launched.

When a foreground job is launched, the shell must first give it access to the controlling
terminal by callingtcsetpgrp. Then, the shell should wait for processes in that process
group to terminate or stop. This is discussed in more detail inSection 28.5.5 [Stopped and
Terminated Jobs], page 827.


Chapter 28: Job Control 826

When all of the processes in the group have either completed or stopped, the shell should
regain control of the terminal for its own process group by callingtcsetpgrpagain. Since
stop signals caused by I/O from a background process or a SUSP character typed by the
user are sent to the process group, normally all the processes in the job stop together.

The foreground job may have left the terminal in a strange state, so the shell should
restore its own saved terminal modes before continuing. In case the job is merely stopped,
the shell should first save the current terminal modes so that it can restore them later if
the job is continued. The functions for dealing with terminal modes aretcgetattrand
tcsetattr; these are described inSection 17.4 [Terminal Modes], page 505.

```
Here is the sample shell¡¯s function for doing all of this.
/*Put jobjin the foreground. Ifcontis nonzero,
restore the saved terminal modes and send the process group a
SIGCONTsignal to wake it up before we block. */
```
```
void
put_job_in_foreground (job *j, int cont)
{
/*Put the job into the foreground. */
tcsetpgrp (shell_terminal, j->pgid);
```
```
/*Send the job a continue signal, if necessary. */
if (cont)
{
tcsetattr (shell_terminal, TCSADRAIN, &j->tmodes);
if (kill (- j->pgid, SIGCONT) < 0)
perror ("kill (SIGCONT)");
}
```
```
/*Wait for it to report. */
wait_for_job (j);
```
```
/*Put the shell back in the foreground. */
tcsetpgrp (shell_terminal, shell_pgid);
```
/*Restore the shell¡¯s terminal modes. */
tcgetattr (shell_terminal, &j->tmodes);
tcsetattr (shell_terminal, TCSADRAIN, &shell_tmodes);
}
If the process group is launched as a background job, the shell should remain in the
foreground itself and continue to read commands from the terminal.

In the sample shell, there is not much that needs to be done to put a job into the
background. Here is the function it uses:

```
/*Put a job in the background. If the cont argument is true, send
the process group aSIGCONTsignal to wake it up. */
```
```
void
put_job_in_background (job *j, int cont)
{
/*Send the job a continue signal, if necessary. */
if (cont)
if (kill (-j->pgid, SIGCONT) < 0)
perror ("kill (SIGCONT)");
}
```

Chapter 28: Job Control 827

## 28.5.5 Stopped and Terminated Jobs..........................

When a foreground process is launched, the shell must block until all of the processes in
that job have either terminated or stopped. It can do this by calling thewaitpidfunction;
seeSection 26.6 [Process Completion], page 809. Use theWUNTRACEDoption so that status
is reported for processes that stop as well as processes that terminate.

The shell must also check on the status of background jobs so that it can report termi-
nated and stopped jobs to the user; this can be done by callingwaitpidwith theWNOHANG
option. A good place to put a such a check for terminated and stopped jobs is just before
prompting for a new command.

The shell can also receive asynchronous notification that there is status information
available for a child process by establishing a handler forSIGCHLDsignals. SeeChapter 24
[Signal Handling], page 714.

In the sample shell program, theSIGCHLDsignal is normally ignored. This is to avoid
reentrancy problems involving the global data structures the shell manipulates. But at
specific times when the shell is not using these data structures¡ªsuch as when it is waiting
for input on the terminal¡ªit makes sense to enable a handler forSIGCHLD. The same
function that is used to do the synchronous status checks (do_job_notification, in this
case) can also be called from within this handler.

Here are the parts of the sample shell program that deal with checking the status of jobs
and reporting the information to the user.

```
/*Store the status of the processpidthat was returned by waitpid.
Return 0 if all went well, nonzero otherwise. */
```
```
int
mark_process_status (pid_t pid, int status)
{
job *j;
process *p;
```
```
if (pid > 0)
{
/*Update the record for the process. */
for (j = first_job; j; j = j->next)
for (p = j->first_process; p; p = p->next)
if (p->pid == pid)
{
p->status = status;
if (WIFSTOPPED (status))
p->stopped = 1;
else
{
p->completed = 1;
if (WIFSIGNALED (status))
fprintf (stderr, "%d: Terminated by signal %d.\n",
(int) pid, WTERMSIG (p->status));
}
return 0;
}
fprintf (stderr, "No child process %d.\n", pid);
return -1;
}
```

Chapter 28: Job Control 828

```
else if (pid == 0 || errno == ECHILD)
/*No processes ready to report. */
return -1;
else {
/*Other weird errors. */
perror ("waitpid");
return -1;
}
}
```
```
/*Check for processes that have status information available,
without blocking. */
```
```
void
update_status (void)
{
int status;
pid_t pid;
```
```
do
pid = waitpid (WAIT_ANY, &status, WUNTRACED|WNOHANG);
while (!mark_process_status (pid, status));
}
```
```
/*Check for processes that have status information available,
blocking until all processes in the given job have reported. */
```
```
void
wait_for_job (job *j)
{
int status;
pid_t pid;
```
```
do
pid = waitpid (WAIT_ANY, &status, WUNTRACED);
while (!mark_process_status (pid, status)
&& !job_is_stopped (j)
&& !job_is_completed (j));
}
```
```
/*Format information about job status for the user to look at. */
```
```
void
format_job_info (job *j, const char *status)
{
fprintf (stderr, "%ld (%s): %s\n", (long)j->pgid, status, j->command);
}
```

Chapter 28: Job Control 829

```
/*Notify the user about stopped or terminated jobs.
Delete terminated jobs from the active job list. */
```
```
void
do_job_notification (void)
{
job *j, *jlast, *jnext;
```
```
/*Update status information for child processes. */
update_status ();
```
```
jlast = NULL;
for (j = first_job; j; j = jnext)
{
jnext = j->next;
```
```
/*If all processes have completed, tell the user the job has
completed and delete it from the list of active jobs. */
if (job_is_completed (j)) {
format_job_info (j, "completed");
if (jlast)
jlast->next = jnext;
else
first_job = jnext;
free_job (j);
}
```
```
/*Notify the user about stopped jobs,
marking them so that we won¡¯t do this more than once. */
else if (job_is_stopped (j) && !j->notified) {
format_job_info (j, "stopped");
j->notified = 1;
jlast = j;
}
```
```
/*Don¡¯t say anything about jobs that are still running. */
else
jlast = j;
}
}
```
## 28.5.6 Continuing Stopped Jobs...............................

The shell can continue a stopped job by sending aSIGCONTsignal to its process group. If
the job is being continued in the foreground, the shell should first invoketcsetpgrpto give
the job access to the terminal, and restore the saved terminal settings. After continuing a
job in the foreground, the shell should wait for the job to stop or complete, as if the job
had just been launched in the foreground.

The sample shell program handles both newly created and continued jobs with the same
pair of functions,put_job_in_foregroundandput_job_in_background. The definitions
of these functions were given inSection 28.5.4 [Foreground and Background], page 825.
When continuing a stopped job, a nonzero value is passed as thecontargument to ensure
that theSIGCONTsignal is sent and the terminal modes reset, as appropriate.

This leaves only a function for updating the shell¡¯s internal bookkeeping about the job
being continued:


Chapter 28: Job Control 830

```
/*Mark a stopped job J as being running again. */
```
```
void
mark_job_as_running (job *j)
{
Process *p;
```
```
for (p = j->first_process; p; p = p->next)
p->stopped = 0;
j->notified = 0;
}
```
```
/*Continue the job J. */
```
```
void
continue_job (job *j, int foreground)
{
mark_job_as_running (j);
if (foreground)
put_job_in_foreground (j, 1);
else
put_job_in_background (j, 1);
}
```
## 28.5.7 The Missing Pieces.....................................

The code extracts for the sample shell included in this chapter are only a part of the entire
shell program. In particular, nothing at all has been said about howjobandprogramdata
structures are allocated and initialized.

Most real shells provide a complex user interface that has support for a command lan-
guage; variables; abbreviations, substitutions, and pattern matching on file names; and the
like. All of this is far too complicated to explain here! Instead, we have concentrated on
showing how to implement the core process creation and job control functions that can be
called from such a shell.

```
Here is a table summarizing the major entry points we have presented:
```
void init_shell (void)
Initialize the shell¡¯s internal state. SeeSection 28.5.2 [Initializing the Shell],
page 821.

void launch_job (job *j, intforeground)
Launch the jobjas either a foreground or background job. SeeSection 28.5.3
[Launching Jobs], page 822.

void do_job_notification (void)
Check for and report any jobs that have terminated or stopped. Can be called
synchronously or within a handler forSIGCHLD signals. SeeSection 28.5.5
[Stopped and Terminated Jobs], page 827.

void continue_job (job *j, intforeground)
Continue the jobj. SeeSection 28.5.6 [Continuing Stopped Jobs], page 829.
Of course, a real shell would also want to provide other functions for managing jobs.
For example, it would be useful to have commands to list all active jobs or to send a signal
(such asSIGKILL) to a job.


Chapter 28: Job Control 831

## 28.6 Functions for Job Control...................................

This section contains detailed descriptions of the functions relating to job control.

## 28.6.1 Identifying the Controlling Terminal....................

You can use thectermidfunction to get a file name that you can use to open the controlling
terminal. In the GNU C Library, it returns the same string all the time:"/dev/tty". That
is a special ¡°magic¡± file name that refers to the controlling terminal of the current process (if
it has one). To find the name of the specific terminal device, usettyname; seeSection 17.1
[Identifying Terminals], page 503.

```
The functionctermidis declared in the header filestdio.h.
```
char * ctermid(char *string) [Function]
Preliminary: |MT-Safe !posix/!string|AS-Safe |AC-Safe |SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Thectermidfunction returns a string containing the file name of the controlling
terminal for the current process. Ifstring is not a null pointer, it should be an
array that can hold at leastL_ctermidcharacters; the string is returned in this
array. Otherwise, a pointer to a string in a static area is returned, which might get
overwritten on subsequent calls to this function.
An empty string is returned if the file name cannot be determined for any reason.
Even if a file name is returned, access to the file it represents is not guaranteed.

int L_ctermid [Macro]
The value of this macro is an integer constant expression that represents the size of
a string large enough to hold the file name returned byctermid.

See also theisatty andttynamefunctions, inSection 17.1 [Identifying Terminals],
page 503.

## 28.6.2 Process Group Functions...............................

Here are descriptions of the functions for manipulating process groups. Your program should
include the header filessys/types.handunistd.hto use these functions.

pid_t setsid (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesetsidfunction creates a new session. The calling process becomes the session
leader, and is put in a new process group whose process group ID is the same as the
process ID of that process. There are initially no other processes in the new process
group, and no other process groups in the new session.
This function also makes the calling process have no controlling terminal.
Thesetsidfunction returns the new process group ID of the calling process if suc-
cessful. A return value of-1indicates an error. The followingerrnoerror conditions
are defined for this function:
EPERM The calling process is already a process group leader, or there is already
another process group around that has the same process group ID.


Chapter 28: Job Control 832

pid_t getsid (pidtpid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetsidfunction returns the process group ID of the session leader of the specified
process. If apidis 0 , the process group ID of the session leader of the current process
is returned.
In case of error-1is returned anderrnois set. The followingerrnoerror conditions
are defined for this function:
ESRCH There is no process with the given process IDpid.
EPERM The calling process and the process specified bypidare in different ses-
sions, and the implementation doesn¡¯t allow to access the process group
ID of the session leader of the process with IDpidfrom the calling process.

pid_t getpgrp(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetpgrpfunction returns the process group ID of the calling process.

int getpgid(pidtpid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetpgidfunction returns the process group ID of the processpid. You can supply
a value of 0 for thepidargument to get information about the calling process.
In case of error-1is returned anderrnois set. The followingerrnoerror conditions
are defined for this function:
ESRCH There is no process with the given process IDpid. The calling process
and the process specified bypidare in different sessions, and the imple-
mentation doesn¡¯t allow to access the process group ID of the process
with IDpidfrom the calling process.

int setpgid(pidtpid, pidtpgid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesetpgidfunction puts the processpidinto the process grouppgid. As a special
case, eitherpidorpgidcan be zero to indicate the process ID of the calling process.
If the operation is successful,setpgidreturns zero. Otherwise it returns-1. The
followingerrnoerror conditions are defined for this function:
EACCES The child process named bypidhas executed anexecfunction since it
was forked.
EINVAL The value of thepgidis not valid.
ENOSYS The system doesn¡¯t support job control.
EPERM The process indicated by thepidargument is a session leader, or is not
in the same session as the calling process, or the value of thepgidargu-
ment doesn¡¯t match a process group ID in the same session as the calling
process.


Chapter 28: Job Control 833

```
ESRCH The process indicated by thepidargument is not the calling process or
a child of the calling process.
```
int setpgrp(pidtpid, pidtpgid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This is the BSD Unix name forsetpgid. Both functions do exactly the same thing.

## 28.6.3 Functions for Controlling Terminal Access..............

These are the functions for reading or setting the foreground process group of a terminal.
You should include the header filessys/types.handunistd.hin your application to use
these functions.

Although these functions take a file descriptor argument to specify the terminal device,
the foreground job is associated with the terminal file itself and not a particular open file
descriptor.

pid_t tcgetpgrp (intfiledes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the process group ID of the foreground process group associated
with the terminal open on descriptorfiledes.
If there is no foreground process group, the return value is a number greater than 1
that does not match the process group ID of any existing process group. This can
happen if all of the processes in the job that was formerly the foreground job have
terminated, and no other job has yet been moved into the foreground.
In case of an error, a value of-1is returned. The followingerrnoerror conditions
are defined for this function:

```
EBADF Thefiledesargument is not a valid file descriptor.
```
```
ENOSYS The system doesn¡¯t support job control.
ENOTTY The terminal file associated with thefiledesargument isn¡¯t the controlling
terminal of the calling process.
```
int tcsetpgrp(intfiledes, pid tpgid) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to set a terminal¡¯s foreground process group ID. The argument
filedesis a descriptor which specifies the terminal;pgidspecifies the process group.
The calling process must be a member of the same session aspgidand must have the
same controlling terminal.
For terminal access purposes, this function is treated as output. If it is called from a
background process on its controlling terminal, normally all processes in the process
group are sent aSIGTTOU signal. The exception is if the calling process itself is
ignoring or blockingSIGTTOUsignals, in which case the operation is performed and
no signal is sent.


Chapter 28: Job Control 834

```
If successful,tcsetpgrpreturns 0. A return value of-1indicates an error. The
followingerrnoerror conditions are defined for this function:
EBADF Thefiledesargument is not a valid file descriptor.
EINVAL Thepgidargument is not valid.
ENOSYS The system doesn¡¯t support job control.
```
```
ENOTTY Thefiledesisn¡¯t the controlling terminal of the calling process.
EPERM Thepgidisn¡¯t a process group in the same session as the calling process.
```
pid_t tcgetsid(intfildes) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function is used to obtain the process group ID of the session for which the
terminal specified byfildesis the controlling terminal. If the call is successful the
group ID is returned. Otherwise the return value is(pid_t) -1and the global variable
errnois set to the following value:
EBADF Thefiledesargument is not a valid file descriptor.
ENOTTY The calling process does not have a controlling terminal, or the file is not
the controlling terminal.


### 835

## 29 System Databases and Name Service Switch..

## 29 System Databases and Name Service Switch..............

Various functions in the C Library need to be configured to work correctly in the local
environment. Traditionally, this was done by using files (e.g.,/etc/passwd), but other
nameservices (like the Network Information Service (NIS) and the Domain Name Service
(DNS)) became popular, and were hacked into the C library, usually with a fixed search
order.

The GNU C Library contains a cleaner solution to this problem. It is designed after
a method used by Sun Microsystems in the C library of Solaris 2. The GNU C Library
follows their name and calls this schemeName Service Switch(NSS).

Though the interface might be similar to Sun¡¯s version there is no common code. We
never saw any source code of Sun¡¯s implementation and so the internal interface is incom-
patible. This also manifests in the file names we use as we will see later.

## 29.1 NSS Basics..................................................

The basic idea is to put the implementation of the different services offered to access the
databases in separate modules. This has some advantages:

1. Contributors can add new services without adding them to the GNU C Library.
2. The modules can be updated separately.
3. The C library image is smaller.

To fulfill the first goal above, the ABI of the modules will be described below. For getting
the implementation of a new service right it is important to understand how the functions in
the modules get called. They are in no way designed to be used by the programmer directly.
Instead the programmer should only use the documented and standardized functions to
access the databases.

The databases available in the NSS are

aliases Mail aliases

ethers Ethernet numbers,

group Groups of users, seeSection 30.14 [Group Database], page 868.

gshadow Group passphrase hashes and related information.

hosts Host names and numbers, seeSection 16.6.2.4 [Host Names], page 469.

initgroups
Supplementary group access list.

netgroup Network wide list of host and users, seeSection 30.16 [Netgroup Database],
page 872.

networks Network names and numbers, seeSection 16.13 [Networks Database], page 501.

passwd User identities, seeSection 30.13 [User Database], page 864.

protocols
Network protocols, seeSection 16.6.6 [Protocols Database], page 477.


Chapter 29: System Databases and Name Service Switch 836

publickey
Public keys for Secure RPC.

rpc Remote procedure call names and numbers.

services Network services, seeSection 16.6.4 [The Services Database], page 474.

shadow User passphrase hashes and related information.

More databases may be added later.

## 29.2 The NSS Configuration File.................................

Somehow the NSS code must be told about the wishes of the user. For this reason there is
the file/etc/nsswitch.conf. For each database, this file contains a specification of how
the lookup process should work. The file could look like this:

```
# /etc/nsswitch.conf
#
# Name Service Switch configuration file.
#
```
```
passwd: db files
shadow: files
group: db files
```
```
hosts: files dns
networks: files
```
ethers: db files
protocols: db files
rpc: db files
services: db files
The first column is the database as you can guess from the table above. The rest of
the line specifies how the lookup process works. Please note that you specify the way it
works for each database individually. This cannot be done with the old way of a monolithic
implementation.

```
The configuration specification for each database can contain two different items:
```
- the service specification likefiles,db, ornis.
- the reaction on lookup result like[NOTFOUND=return].

## 29.2.1 Services in the NSS configuration File...................

The above example file mentions five different services:files,db,dns,nis, andnisplus.
This does not mean these services are available on all sites and neither does it mean these
are all the services which will ever be available.

In fact, these names are simply strings which the NSS code uses to find the implicitly
addressed functions. The internal interface will be described later. Visible to the user are
the modules which implement an individual service.


Chapter 29: System Databases and Name Service Switch 837

Assume the servicenameshall be used for a lookup. The code for this service is im-
plemented in a module calledlibnss_name. On a system supporting shared libraries this
is in fact a shared library with the name (for example)libnss_name.so.2. The number
at the end is the currently used version of the interface which will not change frequently.
Normally the user should not have to be cognizant of these files since they should be placed
in a directory where they are found automatically. Only the names of all available services
are important.

Lastly, some system software may make use of the NSS configuration file to store their
own configuration for similar purposes. Examples of this include theautomountservice
which is used byautofs.

## 29.2.2 Actions in the NSS configuration.......................

The second item in the specification gives the user much finer control on the lookup process.
Action items are placed between two service names and are written within brackets. The
general form is

```
[(!?status=action)+ ]
```
where
status?success | notfound | unavail | tryagain
action?return | continue
The case of the keywords is insignificant. Thestatusvalues are the results of a call to a
lookup function of a specific service. They mean:

¡®success¡¯ No error occurred and the wanted entry is returned. The default action for this
isreturn.

¡®notfound¡¯
The lookup process works ok but the needed value was not found. The default
action iscontinue.

¡®unavail¡¯ The service is permanently unavailable. This can either mean the needed file is
not available, or, for DNS, the server is not available or does not allow queries.
The default action iscontinue.

¡®tryagain¡¯
The service is temporarily unavailable. This could mean a file is locked or
a server currently cannot accept more connections. The default action is
continue.

Theactionvalues mean:

¡®return¡¯

```
If the status matches, stop the lookup process at this service specification. If
an entry is available, provide it to the application. If an error occurred, report
it to the application. In case of a prior ¡®merge¡¯ action, the data is combined
with previous lookup results, as explained below.
```
¡®continue¡¯
If the status matches, proceed with the lookup process at the next entry, dis-
carding the result of the current lookup (and any merged data). An exception
is the ¡®initgroups¡¯ database and the ¡®success¡¯ status, where ¡®continue¡¯ acts
likemergebelow.


Chapter 29: System Databases and Name Service Switch 838

¡®merge¡¯

```
Proceed with the lookup process, retaining the current lookup result. This ac-
tion is useful only with the ¡®success¡¯ status. If a subsequent service lookup
succeeds and has a matching ¡®return¡¯ specification, the results are merged,
the lookup process ends, and the merged results are returned to the applica-
tion. If the following service has a matching ¡®merge¡¯ action, the lookup process
continues, retaining the combined data from this and any previous lookups.
After amergeaction, errors from subsequent lookups are ignored, and the data
gathered so far will be returned.
The ¡®merge¡¯ only applies to the ¡®success¡¯ status. It is currently implemented
for the ¡®group¡¯ database and its group members field, ¡®gr_mem¡¯. If specified for
other databases, it causes the lookup to fail (if thestatusmatches).
When processing ¡®merge¡¯ for ¡®group¡¯ membership, the group GID and name
must be identical for both entries. If only one or the other is a match, the
behavior is undefined.
```
If we have a line like

```
ethers: nisplus [NOTFOUND=return] db files
```
this is equivalent to
ethers: nisplus [SUCCESS=return NOTFOUND=return UNAVAIL=continue
TRYAGAIN=continue]
db [SUCCESS=return NOTFOUND=continue UNAVAIL=continue
TRYAGAIN=continue]
files

(except that it would have to be written on one line). The default value for the actions are
normally what you want, and only need to be changed in exceptional cases.

If the optional!is placed before thestatusthis means the following action is used for
all statuses butstatusitself. I.e.,!is negation as in the C language (and others).

Before we explain the exception which makes this action item necessary one more remark:
obviously it makes no sense to add another action item after thefilesservice. Since there
is no other service following the actionalwaysisreturn.

Now, why is this[NOTFOUND=return]action useful? To understand this we should know
that thenisplusservice is often complete; i.e., if an entry is not available in the NIS+tables
it is not available anywhere else. This is what is expressed by this action item: it is useless
to examine further services since they will not give us a result.

The situation would be different if the NIS+service is not available because the machine
is booting. In this case the return value of the lookup function is notnotfoundbut instead
unavail. And as you can see in the complete form above: in this situation thedband
filesservices are used. Neat, isn¡¯t it? The system administrator need not pay special
care for the time the system is not completely ready to work (while booting or shutdown
or network problems).

## 29.2.3 Notes on the NSS Configuration File....................

Finally a few more hints. The NSS implementation is not completely helpless if
/etc/nsswitch.confdoes not exist. For all supported databases there is a default value


Chapter 29: System Databases and Name Service Switch 839

so it should normally be possible to get the system running even if the file is corrupted or
missing.

For thehostsandnetworksdatabases the default value isdns [!UNAVAIL=return]
files. I.e., the system is prepared for the DNS service not to be available but if it is
available the answer it returns is definitive.

Thepasswd,group, andshadowdatabases was traditionally handled in a special way.
The appropriate files in the/etcdirectory were read but if an entry with a name starting
with a+character was found NIS was used. This kind of lookup was removed and now the
default value for the services isfiles. libnsscompat no longer depends on libnsl and can
be used without NIS.

For all other databases the default value isfiles.
A second point is that the user should try to optimize the lookup process. The different
service have different response times. A simple file look up on a local file could be fast, but
if the file is long and the needed entry is near the end of the file this may take quite some
time. In this case it might be better to use thedbservice which allows fast local access to
large data sets.

Often the situation is that some global information like NIS must be used. So it is
unavoidable to use service entries likenisetc. But one should avoid slow services like this
if possible.

## 29.3 NSS Module Internals.......................................

Now it is time to describe what the modules look like. The functions contained in a module
are identified by their names. I.e., there is no jump table or the like. How this is done is of
no interest here; those interested in this topic should read about Dynamic Linking.

## 29.3.1 The Naming Scheme of the NSS Modules...............

The name of each function consists of various parts:

nssservicefunction
serviceof course corresponds to the name of the module this function is found in.^1 The
functionpart is derived from the interface function in the C library itself. If the user calls
the functiongethostbynameand the service used isfilesthe function
_nss_files_gethostbyname_r

in the module
libnss_files.so.2

is used. You see, what is explained above in not the whole truth. In fact the NSS modules
only contain reentrant versions of the lookup functions. I.e., if the user would call the
gethostbyname_rfunction this also would end in the above function. For all user interface
functions the C library maps this call to a call to the reentrant function. For reentrant
functions this is trivial since the interface is (nearly) the same. For the non-reentrant
version the library keeps internal buffers which are used to replace the user supplied buffer.

I.e., the reentrant functionscanhave counterparts. No service module is forced to have
functions for all databases and all kinds to access them. If a function is not available it is

(^1) Now you might ask why this information is duplicated. The answer is that we want to make it possible
to link directly with these shared objects.


Chapter 29: System Databases and Name Service Switch 840

simply treated as if the function would returnunavail(seeSection 29.2.2 [Actions in the
NSS configuration], page 837).

The file namelibnss_files.so.2would be on a Solaris 2 systemnss_files.so.2.
This is the difference mentioned above. Sun¡¯s NSS modules are usable as modules which
get indirectly loaded only.

The NSS modules in the GNU C Library are prepared to be used as normal libraries
themselves. This isnot true at the moment, though. However, the organization of the
name space in the modules does not make it impossible like it is for Solaris. Now you can
see why the modules are still libraries.^2

## 29.3.2 The Interface of the Function in NSS Modules..........

Now we know about the functions contained in the modules. It is now time to describe the
types. When we mentioned the reentrant versions of the functions above, this means there
are some additional arguments (compared with the standard, non-reentrant versions). The
prototypes for the non-reentrant and reentrant versions of our function above are:
struct hostent *gethostbyname (const char *name)

```
int gethostbyname_r (const char *name, struct hostent *result_buf,
char *buf, size_t buflen, struct hostent **result,
int *h_errnop)
```
The actual prototype of the function in the NSS modules in this case is
enum nss_status _nss_files_gethostbyname_r (const char *name,
struct hostent *result_buf,
char *buf, size_t buflen,
int *errnop, int *h_errnop)
I.e., the interface function is in fact the reentrant function with the change of the return
value, the omission of theresultparameter, and the addition of theerrnopparameter.
While the user-level function returns a pointer to the result the reentrant function return
anenum nss_statusvalue:

NSS_STATUS_TRYAGAIN
numeric value-2

NSS_STATUS_UNAVAIL
numeric value-1

NSS_STATUS_NOTFOUND
numeric value 0

NSS_STATUS_SUCCESS
numeric value 1

Now you see where the action items of the/etc/nsswitch.conffile are used.

If you study the source code you will find there is a fifth value: NSS_STATUS_RETURN.
This is an internal use only value, used by a few functions in places where none of the above
value can be used. If necessary the source code should be examined to learn about the
details.

(^2) There is a second explanation: we were too lazy to change the Makefiles to allow the generation of shared
objects not starting withlibbut don¡¯t tell this to anybody.


Chapter 29: System Databases and Name Service Switch 841

In case the interface function has to return an error it is important that the correct error
code is stored in*errnop. Some return status values have only one associated error code,
others have more.

NSS_STATUS_TRYAGAIN EAGAIN One of the functions used ran temporarily
out of resources or a service is currently not
available.
ERANGE The provided buffer is not large enough.
The function should be called again with
a larger buffer.
NSS_STATUS_UNAVAIL ENOENT A necessary input file cannot be found.
NSS_STATUS_NOTFOUND ENOENT The requested entry is not available.

NSS_STATUS_NOTFOUND SUCCESS There are no entries. Use this to avoid re-
turning errors for inactive services which
may be enabled at a later time. This is not
the same as the service being temporarily
unavailable.
These are proposed values. There can be other error codes and the described error codes
can have different meaning. With one exception: when returningNSS_STATUS_TRYAGAIN
the error codeERANGEmustmean that the user provided buffer is too small. Everything
else is non-critical.

In statically linked programs, the main application and NSS modules do not share the
same thread-local variableerrno, which is the reason why there is an expliciterrnopfunction
argument.

The above function has something special which is missing for almost all the other
module functions. There is an argumentherrnop. This points to a variable which will be
filled with the error code in case the execution of the function fails for some reason. (In
statically linked programs, the thread-local variableh_errnois not shared with the main
application.)

ThegetXXXbyYYYfunctions are the most important functions in the NSS modules. But
there are others which implement the other ways to access system databases (say for the
user database, there aresetpwent,getpwent, andendpwent). These will be described in
more detail later. Here we give a general way to determine the signature of the module
function:

- the return value isenum nss_status;
- the name (seeSection 29.3.1 [The Naming Scheme of the NSS Modules], page 839);
- the first arguments are identical to the arguments of the non-reentrant function;
- the next four arguments are:
    STRUCT_TYPE *result_buf
       pointer to buffer where the result is stored. STRUCT_TYPEis normally a
       struct which corresponds to the database.
    char *buffer
       pointer to a buffer where the function can store additional data for the
       result etc.


Chapter 29: System Databases and Name Service Switch 842

```
size_t buflen
length of the buffer pointed to bybuffer.
```
```
int *errnop
the low-level error code to return to the application. If the return value
is notNSS_STATUS_SUCCESS,*errnopneeds to be set to a non-zero value.
An NSS module should never set*errnopto zero. The valueERANGEis
special, as described above.
```
- possibly a last argumentherrnop, for the host name and network name lookup func-
    tions. If the return value is notNSS_STATUS_SUCCESS,*h_errnopneeds to be set to a
    non-zero value. A generic error code isNETDB_INTERNAL, which instructs the caller to
    examine*errnopfor further details. (This includes theERANGEspecial case.)

This table is correct for all functions but theset...entandend...entfunctions.

29.4 Extending NSS

One of the advantages of NSS mentioned above is that it can be extended quite easily.
There are two ways in which the extension can happen: adding another database or adding
another service. The former is normally done only by the C library developers. It is here
only important to remember that adding another database is independent from adding
another service because a service need not support all databases or lookup functions.

A designer/implementer of a new service is therefore free to choose the databases s/he
is interested in and leave the rest for later (or completely aside).

29.4.1 Adding another Service to NSS

The sources for a new service need not (and should not) be part of the GNU C Library
itself. The developer retains complete control over the sources and its development. The
links between the C library and the new service module consists solely of the interface
functions.

Each module is designed following a specific interface specification. For now the version
is 2 (the interface in version 1 was not adequate) and this manifests in the version number
of the shared library object of the NSS modules: they have the extension.2. If the interface
changes again in an incompatible way, this number will be increased. Modules using the
old interface will still be usable.

Developers of a new service will have to make sure that their module is created using
the correct interface number. This means the file itself must have the correct name and on
ELF systems thesoname(Shared Object Name) must also have this number. Building a
module from a bunch of object files on an ELF system using GNU CC could be done like
this:
gcc -shared -o libnss_NAME.so.2 -Wl,-soname,libnss_NAME.so.2 OBJECTS

Section ¡°Link Options¡± inGNU CC, to learn more about this command line.

To use the new module the library must be able to find it. This can be achieved by
using options for the dynamic linker so that it will search the directory where the binary is
placed. For an ELF system this could be done by adding the wanted directory to the value
ofLD_LIBRARY_PATH.


Chapter 29: System Databases and Name Service Switch 843

But this is not always possible since some programs (those which run under IDs which
do not belong to the user) ignore this variable. Therefore the stable version of the module
should be placed into a directory which is searched by the dynamic linker. Normally this
should be the directory$prefix/lib, where$prefixcorresponds to the value given to
configure using the--prefixoption. But be careful: this should only be done if it is clear
the module does not cause any harm. System administrators should be careful.

29.4.2 Internals of the NSS Module Functions

Until now we only provided the syntactic interface for the functions in the NSS module. In
fact there is not much more we can say since the implementation obviously is different for
each function. But a few general rules must be followed by all functions.

In fact there are four kinds of different functions which may appear in the interface. All
derive from the traditional ones for system databases.dbin the following table is normally
an abbreviation for the database (e.g., it ispwfor the user database).

enum nss_status _nss_database_setdbent (void)
This function prepares the service for following operations. For a simple file
based lookup this means files could be opened, for other services this function
simply is a noop.
One special case for this function is that it takes an additional argument for
somedatabases (i.e., the interface isint setdbent (int)). Section 16.6.2.4
[Host Names], page 469, which describes thesethostentfunction.
The return value should beNSSSTATUS SUCCESSor according to the table
above in case of an error (seeSection 29.3.2 [The Interface of the Function in
NSS Modules], page 840).

enum nss_status _nss_database_enddbent (void)
This function simply closes all files which are still open or removes buffer caches.
If there are no files or buffers to remove this is again a simple noop.
There normally is no return value other thanNSSSTATUSSUCCESS.

enum nss_status _nss_database_getdbent_r (STRUCTURE*result, char *buffer,
size_t buflen, int *errnop)
Since this function will be called several times in a row to retrieve one entry after
the other it must keep some kind of state. But this also means the functions are
not really reentrant. They are reentrant only in that simultaneous calls to this
function will not try to write the retrieved data in the same place (as it would
be the case for the non-reentrant functions); instead, it writes to the structure
pointed to by theresultparameter. But the calls share a common state and in
the case of a file access this means they return neighboring entries in the file.
The buffer of lengthbuflenpointed to bybuffercan be used for storing some
additional data for the result. It isnotguaranteed that the same buffer will be
passed for the next call of this function. Therefore one must not misuse this
buffer to save some state information from one call to another.
Before the function returns with a failure code, the implementation should store
the value of the localerrnovariable in the variable pointed to beerrnop. This
is important to guarantee the module working in statically linked programs.
The stored value must not be zero.


Chapter 29: System Databases and Name Service Switch 844

```
As explained above this function could also have an additional last argument.
This depends on the database used; it happens only forhostandnetworks.
The function shall returnNSS_STATUS_SUCCESSas long as there are more en-
tries. When the last entry was read it should returnNSS_STATUS_NOTFOUND.
When the buffer given as an argument is too small for the data to be returned
NSS_STATUS_TRYAGAINshould be returned. When the service was not formerly
initialized by a call to_nss_DATABASE_setdbentall return values allowed for
this function can also be returned here.
```
enum nss_status _nss_DATABASE_getdbbyXX_r (PARAMS,STRUCTURE*result, char
*buffer, size_t buflen, int *errnop)
This function shall return the entry from the database which is addressed by
thePARAMS. The type and number of these arguments vary. It must be
individually determined by looking to the user-level interface functions. All
arguments given to the non-reentrant version are here described byPARAMS.
The result must be stored in the structure pointed to byresult. If there are
additional data to return (say strings, where theresultstructure only contains
pointers) the function must use thebufferof lengthbuflen. There must not be
any references to non-constant global data.
The implementation of this function should honor thestayopenflag set by the
setDBentfunction whenever this makes sense.
Before the function returns, the implementation should store the value of the
localerrnovariable in the variable pointed to byerrnop. This is important to
guarantee the module works in statically linked programs.
Again, this function takes an additional last argument for the host and
networksdatabase.
The return value should as always follow the rules given above (see
Section 29.3.2 [The Interface of the Function in NSS Modules], page 840).


### 845

## 30 Users and Groups...................................

Every user who can log in on the system is identified by a unique number called theuser
ID. Each process has an effective user ID which says which user¡¯s access permissions it has.

Users are classified intogroupsfor access control purposes. Each process has one or
moregroup ID valueswhich say which groups the process can use for access to files.

The effective user and group IDs of a process collectively form itspersona. This deter-
mines which files the process can access. Normally, a process inherits its persona from the
parent process, but under special circumstances a process can change its persona and thus
change its access permissions.

Each file in the system also has a user ID and a group ID. Access control works by
comparing the user and group IDs of the file with those of the running process.

The system keeps a database of all the registered users, and another database of all the
defined groups. There are library functions you can use to examine these databases.

30.1 User and Group IDs

Each user account on a computer system is identified by auser name(orlogin name) and
user ID. Normally, each user name has a unique user ID, but it is possible for several login
names to have the same user ID. The user names and corresponding user IDs are stored in
a data base which you can access as described inSection 30.13 [User Database], page 864.

Users are classified ingroups. Each user name belongs to onedefault groupand may
also belong to any number ofsupplementary groups. Users who are members of the same
group can share resources (such as files) that are not accessible to users who are not a
member of that group. Each group has agroup name andgroup ID. SeeSection 30.14
[Group Database], page 868, for how to find information about a group ID or group name.

30.2 The Persona of a Process

At any time, each process has an effective user ID, aeffective group ID, and a set of
supplementary group IDs. These IDs determine the privileges of the process. They are
collectively called thepersonaof the process, because they determine ¡°who it is¡± for purposes
of access control.

Your login shell starts out with a persona which consists of your user ID, your default
group ID, and your supplementary group IDs (if you are in more than one group). In normal
circumstances, all your other processes inherit these values.

A process also has areal user IDwhich identifies the user who created the process, and
areal group IDwhich identifies that user¡¯s default group. These values do not play a role in
access control, so we do not consider them part of the persona. But they are also important.

Both the real and effective user ID can be changed during the lifetime of a process. See
Section 30.3 [Why Change the Persona of a Process?], page 846.

For details on how a process¡¯s effective user ID and group IDs affect its permission to
access files, seeSection 14.9.6 [How Your Access to a File is Decided], page 436.

The effective user ID of a process also controls permissions for sending signals using the
killfunction. SeeSection 24.6.2 [Signaling Another Process], page 743.


Chapter 30: Users and Groups 846

Finally, there are many operations which can only be performed by a process whose
effective user ID is zero. A process with this user ID is aprivileged process. Commonly the
user namerootis associated with user ID 0, but there may be other user names with this
ID.

30.3 Why Change the Persona of a Process?

The most obvious situation where it is necessary for a process to change its user and/or
group IDs is theloginprogram. Whenloginstarts running, its user ID isroot. Its job
is to start a shell whose user and group IDs are those of the user who is logging in. (To
accomplish this fully,loginmust set the real user and group IDs as well as its persona.
But this is a special case.)

The more common case of changing persona is when an ordinary user program needs
access to a resource that wouldn¡¯t ordinarily be accessible to the user actually running it.

For example, you may have a file that is controlled by your program but that shouldn¡¯t be
read or modified directly by other users, either because it implements some kind of locking
protocol, or because you want to preserve the integrity or privacy of the information it
contains. This kind of restricted access can be implemented by having the program change
its effective user or group ID to match that of the resource.

Thus, imagine a game program that saves scores in a file. The game program itself
needs to be able to update this file no matter who is running it, but if users can write the
file without going through the game, they can give themselves any scores they like. Some
people consider this undesirable, or even reprehensible. It can be prevented by creating a
new user ID and login name (say,games) to own the scores file, and make the file writable
only by this user. Then, when the game program wants to update this file, it can change
its effective user ID to be that forgames. In effect, the program must adopt the persona of
gamesso it can write to the scores file.

30.4 How an Application Can Change Persona

The ability to change the persona of a process can be a source of unintentional privacy
violations, or even intentional abuse. Because of the potential for problems, changing
persona is restricted to special circumstances.

You can¡¯t arbitrarily set your user ID or group ID to anything you want; only privileged
processes can do that. Instead, the normal way for a program to change its persona is that
it has been set up in advance to change to a particular user or group. This is the function
of the setuid and setgid bits of a file¡¯s access mode. SeeSection 14.9.5 [The Mode Bits for
Access Permission], page 434.

When the setuid bit of an executable file is on, executing that file gives the process
a third user ID: thefile user ID. This ID is set to the owner ID of the file. The system
then changes the effective user ID to the file user ID. The real user ID remains as it was.
Likewise, if the setgid bit is on, the process is given afile group IDequal to the group ID
of the file, and its effective group ID is changed to the file group ID.

If a process has a file ID (user or group), then it can at any time change its effective ID
to its real ID and back to its file ID. Programs use this feature to relinquish their special
privileges except when they actually need them. This makes it less likely that they can be
tricked into doing something inappropriate with their privileges.


Chapter 30: Users and Groups 847

Portability Note:Older systems do not have file IDs. To determine if a system has this
feature, you can test the compiler define_POSIX_SAVED_IDS. (In the POSIX standard, file
IDs are known as saved IDs.)

SeeSection 14.9 [File Attributes], page 425, for a more general discussion of file modes
and accessibility.

30.5 Reading the Persona of a Process

Here are detailed descriptions of the functions for reading the user and group IDs of a
process, both real and effective. To use these facilities, you must include the header files
sys/types.handunistd.h.

uid_t [Data Type]
This is an integer data type used to represent user IDs. In the GNU C Library, this
is an alias forunsigned int.

gid_t [Data Type]
This is an integer data type used to represent group IDs. In the GNU C Library, this
is an alias forunsigned int.

uid_t getuid (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetuidfunction returns the real user ID of the process.

gid_t getgid (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetgidfunction returns the real group ID of the process.

uid_t geteuid(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegeteuidfunction returns the effective user ID of the process.

gid_t getegid(void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetegidfunction returns the effective group ID of the process.

int getgroups(intcount, gidt *groups) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetgroupsfunction is used to inquire about the supplementary group IDs of the
process. Up tocountof these group IDs are stored in the arraygroups; the return
value from the function is the number of group IDs actually stored. Ifcountis smaller
than the total number of supplementary group IDs, thengetgroupsreturns a value
of-1anderrnois set toEINVAL.


Chapter 30: Users and Groups 848

```
Ifcountis zero, thengetgroupsjust returns the total number of supplementary group
IDs. On systems that do not support supplementary groups, this will always be zero.
Here¡¯s how to usegetgroupsto read all the supplementary group IDs:
gid_t *
read_all_groups (void)
{
int ngroups = getgroups (0, NULL);
gid_t *groups
= (gid_t *) xmalloc (ngroups * sizeof (gid_t));
int val = getgroups (ngroups, groups);
if (val < 0)
{
free (groups);
return NULL;
}
return groups;
}
```
30.6 Setting the User ID

This section describes the functions for altering the user ID (real and/or effective) of a pro-
cess. To use these facilities, you must include the header filessys/types.handunistd.h.

int seteuid(uidtneweuid) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function sets the effective user ID of a process toneweuid, provided that the
process is allowed to change its effective user ID. A privileged process (effective user
ID zero) can change its effective user ID to any legal value. An unprivileged process
with a file user ID can change its effective user ID to its real user ID or to its file user
ID. Otherwise, a process may not change its effective user ID at all.
Theseteuidfunction returns a value of 0 to indicate successful completion, and a
value of-1to indicate an error. The followingerrnoerror conditions are defined for
this function:
EINVAL The value of theneweuidargument is invalid.
EPERM The process may not change to the specified ID.
Older systems (those without the_POSIX_SAVED_IDSfeature) do not have this func-
tion.

int setuid(uidtnewuid) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
If the calling process is privileged, this function sets both the real and effective user
IDs of the process tonewuid. It also deletes the file user ID of the process, if any.
newuidmay be any legal value. (Once this has been done, there is no way to recover
the old effective user ID.)
If the process is not privileged, and the system supports the_POSIX_SAVED_IDSfea-
ture, then this function behaves likeseteuid.


Chapter 30: Users and Groups 849

```
The return values and error conditions are the same as forseteuid.
```
int setreuid (uidtruid, uidteuid) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function sets the real user ID of the process toruidand the effective user ID to
euid. Ifruidis-1, it means not to change the real user ID; likewise ifeuidis-1, it
means not to change the effective user ID.
Thesetreuidfunction exists for compatibility with 4.3 BSD Unix, which does not
support file IDs. You can use this function to swap the effective and real user IDs of
the process. (Privileged processes are not limited to this particular usage.) If file IDs
are supported, you should use that feature instead of this function. SeeSection 30.8
[Enabling and Disabling Setuid Access], page 851.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:

```
EPERM The process does not have the appropriate privileges; you do not have
permission to change to the specified ID.
```
30.7 Setting the Group IDs

This section describes the functions for altering the group IDs (real and effective) of a pro-
cess. To use these facilities, you must include the header filessys/types.handunistd.h.

int setegid(gidtnewgid) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function sets the effective group ID of the process tonewgid, provided that the
process is allowed to change its group ID. Just as withseteuid, if the process is
privileged it may change its effective group ID to any value; if it isn¡¯t, but it has a
file group ID, then it may change to its real group ID or file group ID; otherwise it
may not change its effective group ID.
Note that a process is only privileged if its effectiveuser ID is zero. The effective
group ID only affects access permissions.
The return values and error conditions forsetegidare the same as those forseteuid.
This function is only present if_POSIX_SAVED_IDSis defined.

int setgid(gid tnewgid) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function sets both the real and effective group ID of the process tonewgid,
provided that the process is privileged. It also deletes the file group ID, if any.
If the process is not privileged, thensetgidbehaves likesetegid.
The return values and error conditions forsetgidare the same as those forseteuid.


Chapter 30: Users and Groups 850

int setregid (gidtrgid, gidtegid) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function sets the real group ID of the process torgidand the effective group ID
toegid. Ifrgidis-1, it means not to change the real group ID; likewise ifegidis-1,
it means not to change the effective group ID.
Thesetregidfunction is provided for compatibility with 4.3 BSD Unix, which does
not support file IDs. You can use this function to swap the effective and real group
IDs of the process. (Privileged processes are not limited to this usage.) If file IDs are
supported, you should use that feature instead of using this function. SeeSection 30.8
[Enabling and Disabling Setuid Access], page 851.
The return values and error conditions for setregidare the same as those for
setreuid.

setuidandsetgidbehave differently depending on whether the effective user ID at the
time is zero. If it is not zero, they behave likeseteuidandsetegid. If it is, they change
both effective and real IDs and delete the file ID. To avoid confusion, we recommend you
always useseteuidandsetegidexcept when you know the effective user ID is zero and
your intent is to change the persona permanently. This case is rare¡ªmost of the programs
that need it, such asloginandsu, have already been written.

Note that if your program is setuid to some user other thanroot, there is no way to
drop privileges permanently.

The system also lets privileged processes change their supplementary group IDs. To use
setgroupsorinitgroups, your programs should include the header filegrp.h.

int setgroups(sizetcount, const gidt *groups) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
This function sets the process¡¯s supplementary group IDs. It can only be called from
privileged processes. Thecountargument specifies the number of group IDs in the
arraygroups.
This function returns 0 if successful and-1on error. The followingerrnoerror
conditions are defined for this function:
EPERM The calling process is not privileged.

int initgroups(const char *user, gid tgroup) [Function]
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt mem fd lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theinitgroupsfunction sets the process¡¯s supplementary group IDs to be the normal
default for the user nameuser. The groupgroupis automatically included.
This function works by scanning the group database for all the groupsuserbelongs
to. It then callssetgroupswith the list it has constructed.
The return values and error conditions are the same as forsetgroups.
If you are interested in the groups a particular user belongs to, but do not want to change
the process¡¯s supplementary group IDs, you can usegetgrouplist. To usegetgrouplist,
your programs should include the header filegrp.h.


Chapter 30: Users and Groups 851

int getgrouplist (const char *user, gidtgroup, gid t *groups, [Function]
int *ngroups)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt mem fd lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetgrouplistfunction scans the group database for all the groupsuserbelongs
to. Up to *ngroupsgroup IDs corresponding to these groups are stored in the array
groups; the return value from the function is the number of group IDs actually stored.
If *ngroupsis smaller than the total number of groups found, thengetgrouplist
returns a value of-1and stores the actual number of groups in *ngroups. The group
groupis automatically included in the list of groups returned bygetgrouplist.
Here¡¯s how to usegetgrouplistto read all supplementary groups foruser:
gid_t *
supplementary_groups (char *user)
{
int ngroups = 16;
gid_t *groups
= (gid_t *) xmalloc (ngroups * sizeof (gid_t));
struct passwd *pw = getpwnam (user);

```
if (pw == NULL)
return NULL;
```
```
if (getgrouplist (pw->pw_name, pw->pw_gid, groups, &ngroups) < 0)
{
groups = xrealloc (ngroups * sizeof (gid_t));
getgrouplist (pw->pw_name, pw->pw_gid, groups, &ngroups);
}
return groups;
}
```
30.8 Enabling and Disabling Setuid Access

A typical setuid program does not need its special access all of the time. It¡¯s a good idea
to turn off this access when it isn¡¯t needed, so it can¡¯t possibly give unintended access.

If the system supports the_POSIX_SAVED_IDSfeature, you can accomplish this with
seteuid. When the game program starts, its real user ID isjdoe, its effective user ID is
games, and its saved user ID is alsogames. The program should record both user ID values
once at the beginning, like this:
user_user_id = getuid ();
game_user_id = geteuid ();
Then it can turn off game file access with
seteuid (user_user_id);

and turn it on with
seteuid (game_user_id);

Throughout this process, the real user ID remainsjdoeand the file user ID remainsgames,
so the program can always set its effective user ID to either one.

On other systems that don¡¯t support file user IDs, you can turn setuid access on and off
by usingsetreuidto swap the real and effective user IDs of the process, as follows:
setreuid (geteuid (), getuid ());


Chapter 30: Users and Groups 852

This special case is always allowed¡ªit cannot fail.

Why does this have the effect of toggling the setuid access? Suppose a game program has
just started, and its real user ID isjdoewhile its effective user ID isgames. In this state,
the game can write the scores file. If it swaps the two uids, the real becomesgamesand
the effective becomesjdoe; now the program has onlyjdoeaccess. Another swap brings
gamesback to the effective user ID and restores access to the scores file.

In order to handle both kinds of systems, test for the saved user ID feature with a
preprocessor conditional, like this:
#ifdef _POSIX_SAVED_IDS
seteuid (user_user_id);
#else
setreuid (geteuid (), getuid ());
#endif

30.9 Setuid Program Example

Here¡¯s an example showing how to set up a program that changes its effective user ID.

This is part of a game program calledcaber-tossthat manipulates a filescoresthat
should be writable only by the game program itself. The program assumes that its ex-
ecutable file will be installed with the setuid bit set and owned by the same user as the
scoresfile. Typically, a system administrator will set up an account likegamesfor this
purpose.

The executable file is given mode 4755 , so that doing an ¡®ls -l¡¯ on it produces output
like:
-rwsr-xr-x 1 games 184422 Jul 30 15:17 caber-toss

The setuid bit shows up in the file modes as the ¡®s¡¯.

The scores file is given mode 644 , and doing an ¡®ls -l¡¯ on it shows:
-rw-r--r-- 1 games 0 Jul 31 15:33 scores
Here are the parts of the program that show how to set up the changed user ID. This
program is conditionalized so that it makes use of the file IDs feature if it is supported, and
otherwise usessetreuidto swap the effective and real user IDs.
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

```
/*Remember the effective and real UIDs.*/
```
```
static uid_t euid, ruid;
```
```
/*Restore the effective UID to its original value.*/
```
```
void
do_setuid (void)
{
int status;
```
```
#ifdef _POSIX_SAVED_IDS
```

Chapter 30: Users and Groups 853

```
status = seteuid (euid);
#else
status = setreuid (ruid, euid);
#endif
if (status < 0) {
fprintf (stderr, "Couldn't set uid.\n");
exit (status);
}
}
```
```
/*Set the effective UID to the real UID.*/
```
```
void
undo_setuid (void)
{
int status;
```
```
#ifdef _POSIX_SAVED_IDS
status = seteuid (ruid);
#else
status = setreuid (euid, ruid);
#endif
if (status < 0) {
fprintf (stderr, "Couldn't set uid.\n");
exit (status);
}
}
```
```
/*Main program.*/
```
```
int
main (void)
{
/*Remember the real and effective user IDs. */
ruid = getuid ();
euid = geteuid ();
undo_setuid ();
```
/*Do the game and record the score. */
...
}
Notice how the first thing themainfunction does is to set the effective user ID back to
the real user ID. This is so that any other file accesses that are performed while the user is
playing the game use the real user ID for determining permissions. Only when the program
needs to open the scores file does it switch back to the file user ID, like this:
/*Record the score.*/

```
int
record_score (int score)
{
FILE *stream;
char *myname;
```
```
/*Open the scores file.*/
do_setuid ();
stream = fopen (SCORES_FILE, "a");
```

Chapter 30: Users and Groups 854

```
undo_setuid ();
```
```
/*Write the score to the file.*/
if (stream)
{
myname = cuserid (NULL);
if (score < 0)
fprintf (stream, "%10s: Couldn't lift the caber.\n", myname);
else
fprintf (stream, "%10s: %d feet.\n", myname, score);
fclose (stream);
return 0;
}
else
return -1;
}
```
30.10 Tips for Writing Setuid Programs

It is easy for setuid programs to give the user access that isn¡¯t intended¡ªin fact, if you want
to avoid this, you need to be careful. Here are some guidelines for preventing unintended
access and minimizing its consequences when it does occur:

- Don¡¯t havesetuidprograms with privileged user IDs such asrootunless it is absolutely
    necessary. If the resource is specific to your particular program, it¡¯s better to define a
    new, nonprivileged user ID or group ID just to manage that resource. It¡¯s better if you
    can write your program to use a special group than a special user.
- Be cautious about using theexecfunctions in combination with changing the effective
    user ID. Don¡¯t let users of your program execute arbitrary programs under a changed
    user ID. Executing a shell is especially bad news. Less obviously, theexeclpand
    execvpfunctions are a potential risk (since the program they execute depends on the
    user¡¯sPATHenvironment variable).
    If you mustexecanother program under a changed ID, specify an absolute file name
    (seeSection 11.2.2 [File Name Resolution], page 264) for the executable, and make
    sure that the protections on that executable andall containing directories are such
    that ordinary users cannot replace it with some other program.
    You should also check the arguments passed to the program to make sure they do
    not have unexpected effects. Likewise, you should examine the environment variables.
    Decide which arguments and variables are safe, and reject all others.
    You should never usesystemin a privileged program, because it invokes a shell.
- Only use the user ID controlling the resource in the part of the program that actually
    uses that resource. When you¡¯re finished with it, restore the effective user ID back
    to the actual user¡¯s user ID. SeeSection 30.8 [Enabling and Disabling Setuid Access],
    page 851.
- If thesetuidpart of your program needs to access other files besides the controlled
    resource, it should verify that the real user would ordinarily have permission to access
    those files. You can use theaccessfunction (seeSection 14.9.6 [How Your Access to
    a File is Decided], page 436) to check this; it uses the real user and group IDs, rather
    than the effective IDs.


Chapter 30: Users and Groups 855

30.11 Identifying Who Logged In

You can use the functions listed in this section to determine the login name of the user
who is running a process, and the name of the user who logged in the current session. See
also the functiongetuidand friends (seeSection 30.5 [Reading the Persona of a Process],
page 847). How this information is collected by the system and how to control/add/remove
information from the background storage is described inSection 30.12 [The User Accounting
Database], page 856.

Thegetloginfunction is declared in unistd.h, whilecuseridandL_cuseridare
declared instdio.h.

char * getlogin (void) [Function]
Preliminary: |MT-Unsafe race:getlogin race:utent sig:ALRM timer locale|AS-
Unsafe dlopen plugin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.

```
Thegetloginfunction returns a pointer to a string containing the name of the user
logged in on the controlling terminal of the process, or a null pointer if this information
cannot be determined. The string is statically allocated and might be overwritten on
subsequent calls to this function or tocuserid.
```
char * cuserid(char *string) [Function]
Preliminary:|MT-Unsafe race:cuserid/!string locale|AS-Unsafe dlopen plugin heap
lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.

```
Thecuseridfunction returns a pointer to a string containing a user name associated
with the effective ID of the process. Ifstring is not a null pointer, it should be
an array that can hold at leastL_cuseridcharacters; the string is returned in this
array. Otherwise, a pointer to a string in a static area is returned. This string is
statically allocated and might be overwritten on subsequent calls to this function or
togetlogin.
```
```
The use of this function is deprecated since it is marked to be withdrawn in XPG4.2
and has already been removed from newer revisions of POSIX.1.
```
int L_cuserid [Macro]
An integer constant that indicates how long an array you might need to store a user
name.

These functions let your program identify positively the user who is running or the
user who logged in this session. (These can differ when setuid programs are involved; see
Section 30.2 [The Persona of a Process], page 845.) The user cannot do anything to fool
these functions.

For most purposes, it is more useful to use the environment variableLOGNAMEto find out
who the user is. This is more flexible precisely because the user can setLOGNAMEarbitrarily.
SeeSection 25.4.2 [Standard Environment Variables], page 795.


Chapter 30: Users and Groups 856

30.12 The User Accounting Database

Most Unix-like operating systems keep track of logged in users by maintaining a user ac-
counting database. This user accounting database stores for each terminal, who has logged
on, at what time, the process ID of the user¡¯s login shell, etc., etc., but also stores infor-
mation about the run level of the system, the time of the last system reboot, and possibly
more.

The user accounting database typically lives in /etc/utmp, /var/adm/utmp or
/var/run/utmp. However, these files should never be accessed directly. For reading
information from and writing information to the user accounting database, the functions
described in this section should be used.

30.12.1 Manipulating the User Accounting Database

These functions and the corresponding data structures are declared in the header fileutmp.h.

struct exit_status [Data Type]
Theexit_statusdata structure is used to hold information about the exit status of
processes marked asDEAD_PROCESSin the user accounting database.

```
short int e_termination
The exit status of the process.
short int e_exit
The exit status of the process.
```
struct utmp [Data Type]
Theutmpdata structure is used to hold information about entries in the user ac-
counting database. On GNU systems it has the following members:

```
short int ut_type
Specifies the type of login; one of EMPTY, RUN_LVL, BOOT_TIME, OLD_
TIME,NEW_TIME,INIT_PROCESS,LOGIN_PROCESS,USER_PROCESS,DEAD_
PROCESSorACCOUNTING.
pid_t ut_pid
The process ID number of the login process.
char ut_line[]
The device name of the tty (without/dev/).
```
```
char ut_id[]
The inittab ID of the process.
```
```
char ut_user[]
The user¡¯s login name.
```
```
char ut_host[]
The name of the host from which the user logged in.
```
```
struct exit_status ut_exit
The exit status of a process marked asDEAD_PROCESS.
```

Chapter 30: Users and Groups 857

```
long ut_session
The Session ID, used for windowing.
struct timeval ut_tv
Time the entry was made. For entries of typeOLD_TIMEthis is the time
when the system clock changed, and for entries of typeNEW_TIMEthis is
the time the system clock was set to.
int32_t ut_addr_v6[4]
The Internet address of a remote host.
```
Theut_type,ut_pid,ut_id,ut_tv, andut_hostfields are not available on all systems.
Portable applications therefore should be prepared for these situations. To help do this the
utmp.hheader provides macros_HAVE_UT_TYPE,_HAVE_UT_PID,_HAVE_UT_ID,_HAVE_UT_
TV, and_HAVE_UT_HOSTif the respective field is available. The programmer can handle the
situations by using#ifdefin the program code.

The following macros are defined for use as values for theut_typemember of theutmp
structure. The values are integer constants.

EMPTY This macro is used to indicate that the entry contains no valid user accounting
information.

RUN_LVL This macro is used to identify the system¡¯s runlevel.

BOOT_TIME
This macro is used to identify the time of system boot.

OLD_TIME This macro is used to identify the time when the system clock changed.

NEW_TIME This macro is used to identify the time after the system clock changed.

INIT_PROCESS
This macro is used to identify a process spawned by the init process.

LOGIN_PROCESS
This macro is used to identify the session leader of a logged in user.

USER_PROCESS
This macro is used to identify a user process.

DEAD_PROCESS
This macro is used to identify a terminated process.

ACCOUNTING
???
The size of theut_line,ut_id,ut_userandut_hostarrays can be found using the
sizeofoperator.

Many older systems have, instead of anut_tvmember, anut_timemember, usually of
typetime_t, for representing the time associated with the entry. Therefore, for backwards
compatibility only,utmp.hdefinesut_timeas an alias forut_tv.tv_sec.

void setutent(void) [Function]
Preliminary: |MT-Unsafe race:utent|AS-Unsafe lock|AC-Unsafe lock fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 30: Users and Groups 858

```
This function opens the user accounting database to begin scanning it. You can then
callgetutent,getutidorgetutlineto read entries andpututlineto write entries.
If the database is already open, it resets the input to the beginning of the database.
```
struct utmp * getutent (void) [Function]
Preliminary:|MT-Unsafe init race:utent race:utentbuf sig:ALRM timer|AS-Unsafe
heap lock|AC-Unsafe lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegetutentfunction reads the next entry from the user accounting database. It
returns a pointer to the entry, which is statically allocated and may be overwritten
by subsequent calls togetutent. You must copy the contents of the structure if you
wish to save the information or you can use thegetutent_rfunction which stores
the data in a user-provided buffer.
A null pointer is returned in case no further entry is available.

void endutent(void) [Function]
Preliminary: |MT-Unsafe race:utent|AS-Unsafe lock|AC-Unsafe lock fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function closes the user accounting database.

struct utmp * getutid(const struct utmp *id) [Function]
Preliminary:|MT-Unsafe init race:utent sig:ALRM timer|AS-Unsafe lock heap|
AC-Unsafe lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function searches forward from the current point in the database for an entry
that matchesid. If theut_typemember of theidstructure is one ofRUN_LVL,BOOT_
TIME,OLD_TIMEorNEW_TIMEthe entries match if theut_typemembers are identical.
If theut_typemember of theidstructure isINIT_PROCESS,LOGIN_PROCESS,USER_
PROCESSorDEAD_PROCESS, the entries match if theut_typemember of the entry
read from the database is one of these four, and theut_idmembers match. However
if theut_idmember of either theidstructure or the entry read from the database
is empty it checks if theut_linemembers match instead. If a matching entry is
found,getutidreturns a pointer to the entry, which is statically allocated, and may
be overwritten by a subsequent call togetutent,getutidorgetutline. You must
copy the contents of the structure if you wish to save the information.
A null pointer is returned in case the end of the database is reached without a match.
Thegetutidfunction may cache the last read entry. Therefore, if you are using
getutidto search for multiple occurrences, it is necessary to zero out the static data
after each call. Otherwisegetutidcould just return a pointer to the same entry over
and over again.

struct utmp * getutline (const struct utmp *line) [Function]
Preliminary:|MT-Unsafe init race:utent sig:ALRM timer|AS-Unsafe heap lock|
AC-Unsafe lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function searches forward from the current point in the database until it finds
an entry whoseut_typevalue isLOGIN_PROCESSorUSER_PROCESS, and whoseut_
linemember matches theut_linemember of theline structure. If it finds such


Chapter 30: Users and Groups 859

```
an entry, it returns a pointer to the entry which is statically allocated, and may be
overwritten by a subsequent call togetutent,getutidorgetutline. You must copy
the contents of the structure if you wish to save the information.
A null pointer is returned in case the end of the database is reached without a match.
Thegetutlinefunction may cache the last read entry. Therefore if you are using
getutlineto search for multiple occurrences, it is necessary to zero out the static
data after each call. Otherwisegetutlinecould just return a pointer to the same
entry over and over again.
```
struct utmp * pututline (const struct utmp *utmp) [Function]
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock|AC-Unsafe
lock fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thepututlinefunction inserts the entry*utmpat the appropriate place in the user
accounting database. If it finds that it is not already at the correct place in the
database, it usesgetutidto search for the position to insert the entry, however this
will not modify the static structure returned bygetutent,getutidandgetutline.
If this search fails, the entry is appended to the database.
Thepututlinefunction returns a pointer to a copy of the entry inserted in the user
accounting database, or a null pointer if the entry could not be added. The following
errnoerror conditions are defined for this function:

```
EPERM The process does not have the appropriate privileges; you cannot modify
the user accounting database.
```
All theget*functions mentioned before store the information they return in a static
buffer. This can be a problem in multi-threaded programs since the data returned for the
request is overwritten by the return value data in another thread. Therefore the GNU C
Library provides as extensions three more functions which return the data in a user-provided
buffer.

int getutent_r(struct utmp *buffer, struct utmp **result) [Function]
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock|AC-Unsafe
lock fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetutent_ris equivalent to thegetutentfunction. It returns the next entry
from the database. But instead of storing the information in a static buffer it stores
it in the buffer pointed to by the parameterbuffer.
If the call was successful, the function returns 0 and the pointer variable pointed to
by the parameterresultcontains a pointer to the buffer which contains the result
(this is most probably the same value asbuffer). If something went wrong during the
execution ofgetutent_rthe function returns-1.
This function is a GNU extension.

int getutid_r(const struct utmp *id, struct utmp *buffer, struct [Function]
utmp **result)
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock|AC-Unsafe
lock fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 30: Users and Groups 860

```
This function retrieves just likegetutidthe next entry matching the information
stored inid. But the result is stored in the buffer pointed to by the parameterbuffer.
If successful the function returns 0 and the pointer variable pointed to by the pa-
rameterresultcontains a pointer to the buffer with the result (probably the same as
result. If not successful the function return-1.
This function is a GNU extension.
```
int getutline_r (const struct utmp *line, struct utmp *buffer, [Function]
struct utmp **result)
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock|AC-Unsafe
lock fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function retrieves just likegetutlinethe next entry matching the information
stored inline. But the result is stored in the buffer pointed to by the parameter
buffer.
If successful the function returns 0 and the pointer variable pointed to by the pa-
rameterresultcontains a pointer to the buffer with the result (probably the same as
result. If not successful the function return-1.
This function is a GNU extension.

In addition to the user accounting database, most systems keep a number of similar
databases. For example most systems keep a log file with all previous logins (usually in
/etc/wtmpor/var/log/wtmp).

```
For specifying which database to examine, the following function should be used.
```
int utmpname (const char *file) [Function]
Preliminary:|MT-Unsafe race:utent|AS-Unsafe lock heap|AC-Unsafe lock mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theutmpnamefunction changes the name of the database to be examined tofile, and
closes any previously opened database. By defaultgetutent,getutid,getutline
andpututlineread from and write to the user accounting database.
The following macros are defined for use as thefileargument:

```
char * _PATH_UTMP [Macro]
This macro is used to specify the user accounting database.
```
```
char * _PATH_WTMP [Macro]
This macro is used to specify the user accounting log file.
```
```
Theutmpnamefunction returns a value of 0 if the new name was successfully stored,
and a value of-1to indicate an error. Note thatutmpnamedoes not try to open the
database, and that therefore the return value does not say anything about whether
the database can be successfully opened.
```
Specially for maintaining log-like databases the GNU C Library provides the following
function:


Chapter 30: Users and Groups 861

void updwtmp (const char *wtmp_file, const struct utmp *utmp) [Function]
Preliminary: |MT-Unsafe sig:ALRM timer|AS-Unsafe |AC-Unsafe fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The updwtmp function appends the entry *utmp to the database specified by
wtmpfile. For possible values for the wtmpfile argument see the utmpname
function.
Portability Note:Although many operating systems provide a subset of these functions,
they are not standardized. There are often subtle differences in the return types, and there
are considerable differences between the various definitions ofstruct utmp. When pro-
gramming for the GNU C Library, it is probably best to stick with the functions described
in this section. If however, you want your program to be portable, consider using the
XPG functions described inSection 30.12.2 [XPG User Accounting Database Functions],
page 861, or take a look at the BSD compatible functions inSection 30.12.3 [Logging In
and Out], page 863.

30.12.2 XPG User Accounting Database Functions

These functions, described in the X/Open Portability Guide, are declared in the header file
utmpx.h.

struct utmpx [Data Type]
Theutmpxdata structure contains at least the following members:
short int ut_type
Specifies the type of login; one of EMPTY, RUN_LVL, BOOT_TIME,
OLD_TIME,NEW_TIME,INIT_PROCESS,LOGIN_PROCESS,USER_PROCESSor
DEAD_PROCESS.
pid_t ut_pid
The process ID number of the login process.
char ut_line[]
The device name of the tty (without/dev/).
char ut_id[]
The inittab ID of the process.
char ut_user[]
The user¡¯s login name.
struct timeval ut_tv
Time the entry was made. For entries of typeOLD_TIMEthis is the time
when the system clock changed, and for entries of typeNEW_TIMEthis is
the time the system clock was set to.
In the GNU C Library,struct utmpxis identical tostruct utmpexcept for the fact
that includingutmpx.hdoes not make visible the declaration ofstruct exit_status.
The following macros are defined for use as values for theut_typemember of theutmpx
structure. The values are integer constants and are, in the GNU C Library, identical to the
definitions inutmp.h.

EMPTY This macro is used to indicate that the entry contains no valid user accounting
information.


Chapter 30: Users and Groups 862

RUN_LVL This macro is used to identify the system¡¯s runlevel.

BOOT_TIME
This macro is used to identify the time of system boot.

OLD_TIME This macro is used to identify the time when the system clock changed.

NEW_TIME This macro is used to identify the time after the system clock changed.

INIT_PROCESS
This macro is used to identify a process spawned by the init process.

LOGIN_PROCESS
This macro is used to identify the session leader of a logged in user.

USER_PROCESS
This macro is used to identify a user process.

DEAD_PROCESS
This macro is used to identify a terminated process.
The size of theut_line,ut_idandut_userarrays can be found using thesizeof
operator.

void setutxent(void) [Function]
Preliminary: |MT-Unsafe race:utent|AS-Unsafe lock|AC-Unsafe lock fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tosetutent. In the GNU C Library it is simply an alias for
setutent.

struct utmpx * getutxent(void) [Function]
Preliminary:|MT-Unsafe init race:utent sig:ALRM timer|AS-Unsafe heap lock|
AC-Unsafe lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetutxentfunction is similar togetutent, but returns a pointer to astruct
utmpxinstead of struct utmp. In the GNU C Library it simply is an alias for
getutent.

void endutxent(void) [Function]
Preliminary: |MT-Unsafe race:utent| AS-Unsafe lock|AC-Unsafe lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar toendutent. In the GNU C Library it is simply an alias for
endutent.

struct utmpx * getutxid (const struct utmpx *id) [Function]
Preliminary:|MT-Unsafe init race:utent sig:ALRM timer|AS-Unsafe lock heap|
AC-Unsafe lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar togetutid, but usesstruct utmpxinstead ofstruct utmp.
In the GNU C Library it is simply an alias forgetutid.

struct utmpx * getutxline(const struct utmpx *line) [Function]
Preliminary:|MT-Unsafe init race:utent sig:ALRM timer|AS-Unsafe heap lock|
AC-Unsafe lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar togetutid, but usesstruct utmpxinstead ofstruct utmp.
In the GNU C Library it is simply an alias forgetutline.


Chapter 30: Users and Groups 863

struct utmpx * pututxline(const struct utmpx *utmp) [Function]
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock|AC-Unsafe
lock fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thepututxlinefunction is functionally identical topututline, but usesstruct
utmpxinstead ofstruct utmp. In the GNU C Library,pututxlineis simply an alias
forpututline.

int utmpxname(const char *file) [Function]
Preliminary:|MT-Unsafe race:utent|AS-Unsafe lock heap|AC-Unsafe lock mem
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Theutmpxnamefunction is functionally identical toutmpname. In the GNU C Library,
utmpxnameis simply an alias forutmpname.

You can translate between a traditionalstruct utmpand an XPGstruct utmpxwith
the following functions. In the GNU C Library, these functions are merely copies, since the
two structures are identical.

int getutmp(const struct utmpx *utmpx, struct utmp *utmp) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
getutmpcopies the information, insofar as the structures are compatible, fromutmpx
toutmp.

int getutmpx (const struct utmp *utmp, struct utmpx *utmpx) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
getutmpxcopies the information, insofar as the structures are compatible, fromutmp
toutmpx.

30.12.3 Logging In and Out

These functions, derived from BSD, are available in the separatelibutil library, and
declared inutmp.h.

Note that theut_usermember ofstruct utmpis calledut_namein BSD. Therefore,
ut_nameis defined as an alias forut_userinutmp.h.

int login_tty(intfiledes) [Function]
Preliminary:|MT-Unsafe race:ttyname|AS-Unsafe heap lock|AC-Unsafe lock fd
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function makesfiledesthe controlling terminal of the current process, redirects
standard input, standard output and standard error output to this terminal, and
closesfiledes.
This function returns 0 on successful completion, and-1on error.

void login(const struct utmp *entry) [Function]
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock heap|AC-
Unsafe lock corrupt fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 30: Users and Groups 864

```
Theloginfunctions inserts an entry into the user accounting database. Theut_line
member is set to the name of the terminal on standard input. If standard input is
not a terminalloginuses standard output or standard error output to determine
the name of the terminal. Ifstruct utmphas aut_typemember,loginsets it to
USER_PROCESS, and if there is anut_pidmember, it will be set to the process ID of
the current process. The remaining entries are copied fromentry.
A copy of the entry is written to the user accounting log file.
```
int logout(const char *ut_line) [Function]
Preliminary:|MT-Unsafe race:utent sig:ALRM timer|AS-Unsafe lock heap|AC-
Unsafe lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function modifies the user accounting database to indicate that the user on
utlinehas logged out.
Thelogoutfunction returns 1 if the entry was successfully written to the database,
or 0 on error.

void logwtmp (const char *ut_line, const char *ut_name, const [Function]
char *ut_host)
Preliminary: |MT-Unsafe sig:ALRM timer|AS-Unsafe |AC-Unsafe fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thelogwtmpfunction appends an entry to the user accounting log file, for the current
time and the information provided in theutline,utnameanduthostarguments.

Portability Note:The BSDstruct utmponly has theut_line,ut_name,ut_hostand
ut_timemembers. Older systems do not even have theut_hostmember.

30.13 User Database

This section describes how to search and scan the database of registered users. The database
itself is kept in the file/etc/passwdon most systems, but on some systems a special network
server gives access to it.

Historically, this database included one-way hashes of user passphrases (seeSection 33.1
[Passphrase Storage], page 912) as well as public information about each user (such as their
user ID and full name). Many of the functions and data structures associated with this
database, and the filename/etc/passwditself, reflect this history. However, the informa-
tion in this database is available to all users, and it is no longer considered safe to make
passphrase hashes available to all users, so they have been moved to a ¡°shadow¡± database
that can only be accessed with special privileges.

30.13.1 The Data Structure that Describes a User

The functions and data structures for accessing the system user database are declared in
the header filepwd.h.

struct passwd [Data Type]
Thepasswddata structure is used to hold information about entries in the system
user data base. It has at least the following members:
char *pw_name
The user¡¯s login name.


Chapter 30: Users and Groups 865

```
char *pw_passwd
Historically, this field would hold the one-way hash of the user¡¯s
passphrase. Nowadays, it will almost always be the single character ¡®x¡¯,
indicating that the hash is in the shadow database.
```
```
uid_t pw_uid
The user ID number.
gid_t pw_gid
The user¡¯s default group ID number.
```
```
char *pw_gecos
A string typically containing the user¡¯s real name, and possibly other
information such as a phone number.
```
```
char *pw_dir
The user¡¯s home directory, or initial working directory. This might be a
null pointer, in which case the interpretation is system-dependent.
char *pw_shell
The user¡¯s default shell, or the initial program run when the user logs in.
This might be a null pointer, indicating that the system default should
be used.
```
30.13.2 Looking Up One User

You can search the system user database for information about a specific user using
getpwuidorgetpwnam. These functions are declared inpwd.h.

struct passwd * getpwuid(uidtuid) [Function]
Preliminary: |MT-Unsafe race:pwuid locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns a pointer to a statically-allocated structure containing infor-
mation about the user whose user ID isuid. This structure may be overwritten on
subsequent calls togetpwuid.
A null pointer value indicates there is no user in the data base with user IDuid.

int getpwuid_r(uidtuid, struct passwd *result_buf, char [Function]
*buffer, size tbuflen, struct passwd **result)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar togetpwuidin that it returns information about the user
whose user ID isuid. However, it fills the user supplied structure pointed to by
resultbuf with the information instead of using a static buffer. The firstbuflen
bytes of the additional buffer pointed to bybuffer are used to contain additional
information, normally strings which are pointed to by the elements of the result
structure.
If a user with IDuidis found, the pointer returned inresultpoints to the record
which contains the wanted data (i.e.,resultcontains the valueresultbuf). If no user


Chapter 30: Users and Groups 866

```
is found or if an error occurred, the pointer returned inresultis a null pointer. The
function returns zero or an error code. If the bufferbufferis too small to contain all
the needed information, the error codeERANGEis returned anderrnois set toERANGE.
```
struct passwd * getpwnam(const char *name) [Function]
Preliminary: |MT-Unsafe race:pwnam locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns a pointer to a statically-allocated structure containing informa-
tion about the user whose user name isname. This structure may be overwritten on
subsequent calls togetpwnam.
A null pointer return indicates there is no user namedname.

int getpwnam_r(const char *name, struct passwd *result_buf, [Function]
char *buffer, sizetbuflen, struct passwd **result)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar togetpwnamin that it returns information about the user
whose user name isname. However, likegetpwuid_r, it fills the user supplied buffers
inresultbuf andbufferwith the information instead of using a static buffer.
The return values are the same as forgetpwuid_r.

30.13.3 Scanning the List of All Users

This section explains how a program can read the list of all users in the system, one user
at a time. The functions described here are declared inpwd.h.

```
You can use thefgetpwentfunction to read user entries from a particular file.
```
struct passwd * fgetpwent(FILE *stream) [Function]
Preliminary:|MT-Unsafe race:fpwent|AS-Unsafe corrupt lock|AC-Unsafe corrupt
lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function reads the next user entry fromstreamand returns a pointer to the
entry. The structure is statically allocated and is rewritten on subsequent calls to
fgetpwent. You must copy the contents of the structure if you wish to save the
information.
The stream must correspond to a file in the same format as the standard user database
file.

int fgetpwent_r (FILE *stream, struct passwd *result_buf, char [Function]
*buffer, size tbuflen, struct passwd **result)
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofgetpwentin that it reads the next user entry fromstream.
But the result is returned in the structure pointed to byresultbuf. The firstbuflen
bytes of the additional buffer pointed to bybuffer are used to contain additional
information, normally strings which are pointed to by the elements of the result
structure.


Chapter 30: Users and Groups 867

```
The stream must correspond to a file in the same format as the standard user database
file.
If the function returns zeroresultpoints to the structure with the wanted data (nor-
mally this is inresultbuf). If errors occurred the return value is nonzero andresult
contains a null pointer.
```
The way to scan all the entries in the user database is withsetpwent,getpwent, and
endpwent.

void setpwent(void) [Function]
Preliminary: |MT-Unsafe race:pwent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function initializes a stream whichgetpwentandgetpwent_ruse to read the
user database.

struct passwd * getpwent(void) [Function]
Preliminary:|MT-Unsafe race:pwent race:pwentbuf locale|AS-Unsafe dlopen plu-
gin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetpwentfunction reads the next entry from the stream initialized bysetpwent.
It returns a pointer to the entry. The structure is statically allocated and is rewritten
on subsequent calls togetpwent. You must copy the contents of the structure if you
wish to save the information.
A null pointer is returned when no more entries are available.

int getpwent_r(struct passwd *result_buf, char *buffer, size t [Function]
buflen, struct passwd **result)
Preliminary: |MT-Unsafe race:pwent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function is similar togetpwentin that it returns the next entry from the stream
initialized bysetpwent. Likefgetpwent_r, it uses the user-supplied buffers inre-
sultbuf andbufferto return the information requested.
The return values are the same as forfgetpwent_r.

void endpwent(void) [Function]
Preliminary: |MT-Unsafe race:pwent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function closes the internal stream used bygetpwentorgetpwent_r.

30.13.4 Writing a User Entry

int putpwent (const struct passwd *p, FILE *stream) [Function]
Preliminary:|MT-Safe locale|AS-Unsafe corrupt|AC-Unsafe lock corrupt|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 30: Users and Groups 868

```
This function writes the user entry*pto the streamstream, in the format used for
the standard user database file. The return value is zero on success and nonzero on
failure.
This function exists for compatibility with SVID. We recommend that you avoid using
it, because it makes sense only on the assumption that thestruct passwdstructure
has no members except the standard ones; on a system which merges the traditional
Unix data base with other extended information about users, adding an entry using
this function would inevitably leave out much of the important information.
The group and user ID fields are left empty if the group or user name starts with a -
or+.
The functionputpwentis declared inpwd.h.
```
30.14 Group Database

This section describes how to search and scan the database of registered groups. The
database itself is kept in the file/etc/groupon most systems, but on some systems a
special network service provides access to it.

30.14.1 The Data Structure for a Group

The functions and data structures for accessing the system group database are declared in
the header filegrp.h.

struct group [Data Type]
Thegroupstructure is used to hold information about an entry in the system group
database. It has at least the following members:
char *gr_name
The name of the group.
gid_t gr_gid
The group ID of the group.
char **gr_mem
A vector of pointers to the names of users in the group. Each user name
is a null-terminated string, and the vector itself is terminated by a null
pointer.

30.14.2 Looking Up One Group

You can search the group database for information about a specific group usinggetgrgid
orgetgrnam. These functions are declared ingrp.h.

struct group * getgrgid (gidtgid) [Function]
Preliminary: |MT-Unsafe race:grgid locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns a pointer to a statically-allocated structure containing informa-
tion about the group whose group ID isgid. This structure may be overwritten by
subsequent calls togetgrgid.
A null pointer indicates there is no group with IDgid.


Chapter 30: Users and Groups 869

int getgrgid_r(gidtgid, struct group *result_buf, char [Function]
*buffer, size tbuflen, struct group **result)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar togetgrgidin that it returns information about the group
whose group ID isgid. However, it fills the user supplied structure pointed to by
resultbuf with the information instead of using a static buffer. The firstbuflen
bytes of the additional buffer pointed to bybuffer are used to contain additional
information, normally strings which are pointed to by the elements of the result
structure.
If a group with IDgidis found, the pointer returned inresultpoints to the record
which contains the wanted data (i.e.,resultcontains the valueresultbuf). If no
group is found or if an error occurred, the pointer returned inresultis a null pointer.
The function returns zero or an error code. If the bufferbufferis too small to contain
all the needed information, the error codeERANGEis returned anderrnois set to
ERANGE.

struct group * getgrnam (const char *name) [Function]
Preliminary: |MT-Unsafe race:grnam locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns a pointer to a statically-allocated structure containing informa-
tion about the group whose group name isname. This structure may be overwritten
by subsequent calls togetgrnam.
A null pointer indicates there is no group namedname.

int getgrnam_r(const char *name, struct group *result_buf, char [Function]
*buffer, size tbuflen, struct group **result)
Preliminary: |MT-Safe locale|AS-Unsafe dlopen plugin heap lock|AC-Unsafe
corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar togetgrnamin that it returns information about the group
whose group name isname. Likegetgrgid_r, it uses the user supplied buffers in
resultbuf andbuffer, not a static buffer.
The return values are the same as forgetgrgid_r.

30.14.3 Scanning the List of All Groups

This section explains how a program can read the list of all groups in the system, one group
at a time. The functions described here are declared ingrp.h.

```
You can use thefgetgrentfunction to read group entries from a particular file.
```
struct group * fgetgrent(FILE *stream) [Function]
Preliminary:|MT-Unsafe race:fgrent|AS-Unsafe corrupt lock|AC-Unsafe corrupt
lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thefgetgrentfunction reads the next entry fromstream. It returns a pointer to
the entry. The structure is statically allocated and is overwritten on subsequent calls


Chapter 30: Users and Groups 870

```
tofgetgrent. You must copy the contents of the structure if you wish to save the
information.
The stream must correspond to a file in the same format as the standard group
database file.
```
int fgetgrent_r (FILE *stream, struct group *result_buf, char [Function]
*buffer, size tbuflen, struct group **result)
Preliminary: | MT-Safe |AS-Unsafe corrupt |AC-Unsafe corrupt lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is similar tofgetgrentin that it reads the next user entry fromstream.
But the result is returned in the structure pointed to byresultbuf. The firstbuflen
bytes of the additional buffer pointed to bybuffer are used to contain additional
information, normally strings which are pointed to by the elements of the result
structure.
This stream must correspond to a file in the same format as the standard group
database file.
If the function returns zeroresultpoints to the structure with the wanted data (nor-
mally this is inresultbuf). If errors occurred the return value is non-zero andresult
contains a null pointer.

The way to scan all the entries in the group database is withsetgrent,getgrent, and
endgrent.

void setgrent(void) [Function]
Preliminary: |MT-Unsafe race:grent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function initializes a stream for reading from the group data base. You use this
stream by callinggetgrentorgetgrent_r.

struct group * getgrent (void) [Function]
Preliminary:|MT-Unsafe race:grent race:grentbuf locale|AS-Unsafe dlopen plugin
heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thegetgrentfunction reads the next entry from the stream initialized bysetgrent.
It returns a pointer to the entry. The structure is statically allocated and is overwrit-
ten on subsequent calls togetgrent. You must copy the contents of the structure if
you wish to save the information.

int getgrent_r(struct group *result_buf, char *buffer, sizet [Function]
buflen, struct group **result)
Preliminary: |MT-Unsafe race:grent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function is similar togetgrentin that it returns the next entry from the stream
initialized bysetgrent. Likefgetgrent_r, it places the result in user-supplied
buffers pointed to byresultbuf andbuffer.


Chapter 30: Users and Groups 871

```
If the function returns zeroresultcontains a pointer to the data (normally equal to
resultbuf). If errors occurred the return value is non-zero andresultcontains a null
pointer.
```
void endgrent(void) [Function]
Preliminary: |MT-Unsafe race:grent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function closes the internal stream used bygetgrentorgetgrent_r.

30.15 User and Group Database Example

Here is an example program showing the use of the system database inquiry functions. The
program prints some information about the user running the program.

```
#include <grp.h>
#include <pwd.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
```
```
int
main (void)
{
uid_t me;
struct passwd *my_passwd;
struct group *my_group;
char **members;
```
```
/*Get information about the user ID.*/
me = getuid ();
my_passwd = getpwuid (me);
if (!my_passwd)
{
printf ("Couldn't find out about user %d.\n", (int) me);
exit (EXIT_FAILURE);
}
```
```
/*Print the information.*/
printf ("I am %s.\n", my_passwd->pw_gecos);
printf ("My login name is %s.\n", my_passwd->pw_name);
printf ("My uid is %d.\n", (int) (my_passwd->pw_uid));
printf ("My home directory is %s.\n", my_passwd->pw_dir);
printf ("My default shell is %s.\n", my_passwd->pw_shell);
```
```
/*Get information about the default group ID.*/
my_group = getgrgid (my_passwd->pw_gid);
if (!my_group)
{
printf ("Couldn't find out about group %d.\n",
(int) my_passwd->pw_gid);
exit (EXIT_FAILURE);
}
```
```
/*Print the information.*/
printf ("My default group is %s (%d).\n",
```

Chapter 30: Users and Groups 872

```
my_group->gr_name, (int) (my_passwd->pw_gid));
printf ("The members of this group are:\n");
members = my_group->gr_mem;
while (*members)
{
printf (" %s\n", *(members));
members++;
}
```
```
return EXIT_SUCCESS;
}
Here is some output from this program:
I am Throckmorton Snurd.
My login name is snurd.
My uid is 31093.
My home directory is /home/fsg/snurd.
My default shell is /bin/sh.
My default group is guest (12).
The members of this group are:
friedman
tami
```
30.16 Netgroup Database

30.16.1 Netgroup Data

Sometimes it is useful to group users according to other criteria (seeSection 30.14 [Group
Database], page 868). E.g., it is useful to associate a certain group of users with a certain
machine. On the other hand grouping of host names is not supported so far.

In Sun Microsystems¡¯ SunOS appeared a new kind of database, the netgroup database.
It allows grouping hosts, users, and domains freely, giving them individual names. To be
more concrete, a netgroup is a list of triples consisting of a host name, a user name, and
a domain name where any of the entries can be a wildcard entry matching all inputs. A
last possibility is that names of other netgroups can also be given in the list specifying a
netgroup. So one can construct arbitrary hierarchies without loops.

Sun¡¯s implementation allows netgroups only for the nis or nisplus service, see
Section 29.2.1 [Services in the NSS configuration File], page 836. The implementation in
the GNU C Library has no such restriction. An entry in either of the input services must
have the following form:
groupname(groupname| (hostname,username,domainname) )+
Any of the fields in the triple can be empty which means anything matches. While
describing the functions we will see that the opposite case is useful as well. I.e., there may
be entries which will not match any input. For entries like this, a name consisting of the
single character-shall be used.

30.16.2 Looking up one Netgroup

The lookup functions for netgroups are a bit different than all other system database han-
dling functions. Since a single netgroup can contain many entries a two-step process is
needed. First a single netgroup is selected and then one can iterate over all entries in this
netgroup. These functions are declared innetdb.h.


Chapter 30: Users and Groups 873

int setnetgrent (const char *netgroup) [Function]
Preliminary:|MT-Unsafe race:netgrent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
A call to this function initializes the internal state of the library to allow following
calls ofgetnetgrentto iterate over all entries in the netgroup with namenetgroup.
When the call is successful (i.e., when a netgroup with this name exists) the return
value is 1. When the return value is 0 no netgroup of this name is known or some
other error occurred.

It is important to remember that there is only one single state for iterating the netgroups.
Even if the programmer uses thegetnetgrent_rfunction the result is not really reentrant
since always only one single netgroup at a time can be processed. If the program needs
to process more than one netgroup simultaneously she must protect this by using external
locking. This problem was introduced in the original netgroups implementation in SunOS
and since we must stay compatible it is not possible to change this.

Some other functions also use the netgroups state. Currently these are theinnetgr
function and parts of the implementation of thecompatservice part of the NSS implemen-
tation.

int getnetgrent (char **hostp, char **userp, char **domainp) [Function]
Preliminary:|MT-Unsafe race:netgrent race:netgrentbuf locale|AS-Unsafe dlopen
plugin heap lock|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
This function returns the next unprocessed entry of the currently selected netgroup.
The string pointers, in which addresses are passed in the argumentshostp,userp, and
domainp, will contain after a successful call pointers to appropriate strings. If the
string in the next entry is empty the pointer has the valueNULL. The returned string
pointers are only valid if none of the netgroup related functions are called.
The return value is 1 if the next entry was successfully read. A value of 0 means no
further entries exist or internal errors occurred.

int getnetgrent_r(char **hostp, char **userp, char **domainp, [Function]
char *buffer, sizetbuflen)
Preliminary:|MT-Unsafe race:netgrent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function is similar togetnetgrentwith only one exception: the strings the three
string pointershostp,userp, anddomainppoint to, are placed in the buffer ofbuflen
bytes starting atbuffer. This means the returned values are valid even after other
netgroup related functions are called.
The return value is 1 if the next entry was successfully read and the buffer contains
enough room to place the strings in it. 0 is returned in case no more entries are found,
the buffer is too small, or internal errors occurred.
This function is a GNU extension. The original implementation in the SunOS libc
does not provide this function.


Chapter 30: Users and Groups 874

void endnetgrent (void) [Function]
Preliminary:|MT-Unsafe race:netgrent|AS-Unsafe dlopen plugin heap lock|AC-
Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function frees all buffers which were allocated to process the last selected net-
group. As a result all string pointers returned by calls togetnetgrentare invalid
afterwards.

30.16.3 Testing for Netgroup Membership

It is often not necessary to scan the whole netgroup since often the only interesting question
is whether a given entry is part of the selected netgroup.

int innetgr(const char *netgroup, const char *host, const char [Function]
*user, const char *domain)
Preliminary:|MT-Unsafe race:netgrent locale|AS-Unsafe dlopen plugin heap lock
|AC-Unsafe corrupt lock fd mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function tests whether the triple specified by the parametershost,user, and
domainis part of the netgroupnetgroup. Using this function has the advantage that

1. no other netgroup function can use the global netgroup state since internal locking
    is used and
2. the function is implemented more efficiently than successive calls to the other
    set/get/endnetgrentfunctions.
Any of the pointershost, user, ordomaincan beNULLwhich means any value is
accepted in this position. This is also true for the name-which should not match
any other string otherwise.
The return value is 1 if an entry matching the given triple is found in the netgroup.
The return value is 0 if the netgroup itself is not found, the netgroup does not contain
the triple or internal errors occurred.


### 875

## 31 System Management.................................

This chapter describes facilities for controlling the system that underlies a process (including
the operating system and hardware) and for getting information about it. Anyone can
generally use the informational facilities, but usually only a properly privileged process can
make changes.

To get information on parameters of the system that are built into the system, such as the
maximum length of a filename,Chapter 32 [System Configuration Parameters], page 890.

31.1 Host Identification

This section explains how to identify the particular system on which your program is run-
ning. First, let¡¯s review the various ways computer systems are named, which is a little
complicated because of the history of the development of the Internet.

Every Unix system (also known as a host) has a host name, whether it¡¯s connected to a
network or not. In its simplest form, as used before computer networks were an issue, it¡¯s
just a word like ¡®chicken¡¯.

But any system attached to the Internet or any network like it conforms to a more
rigorous naming convention as part of the Domain Name System (DNS). In the DNS, every
host name is composed of two parts:

1. hostname
2. domain name

You will note that ¡°hostname¡± looks a lot like ¡°host name¡±, but is not the same thing,
and that people often incorrectly refer to entire host names as ¡°domain names.¡±

In the DNS, the full host name is properly called the FQDN (Fully Qualified Domain
Name) and consists of the hostname, then a period, then the domain name. The domain
name itself usually has multiple components separated by periods. So for example, a sys-
tem¡¯s hostname may be ¡®chicken¡¯ and its domain name might be ¡®ai.mit.edu¡¯, so its
FQDN (which is its host name) is ¡®chicken.ai.mit.edu¡¯.

Adding to the confusion, though, is that the DNS is not the only name space in which
a computer needs to be known. Another name space is the NIS (aka YP) name space. For
NIS purposes, there is another domain name, which is called the NIS domain name or the
YP domain name. It need not have anything to do with the DNS domain name.

Confusing things even more is the fact that in the DNS, it is possible for multiple FQDNs
to refer to the same system. However, there is always exactly one of them that is the true
host name, and it is called the canonical FQDN.

```
In some contexts, the host name is called a ¡°node name.¡±
For more information on DNS host naming, seeSection 16.6.2.4 [Host Names], page 469.
Prototypes for these functions appear inunistd.h.
The programshostname,hostid, anddomainnamework by calling these functions.
```
int gethostname (char *name, sizetsize) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 31: System Management 876

```
This function returns the host name of the system on which it is called, in the array
name. Thesizeargument specifies the size of this array, in bytes. Note that this is
notthe DNS hostname. If the system participates in the DNS, this is the FQDN (see
above).
The return value is 0 on success and -1 on failure. In the GNU C Library,
gethostnamefails ifsizeis not large enough; then you can try again with a larger
array. The followingerrnoerror condition is defined for this function:
ENAMETOOLONG
Thesizeargument is less than the size of the host name plus one.
On some systems, there is a symbol for the maximum possible host name length:
MAXHOSTNAMELEN. It is defined insys/param.h. But you can¡¯t count on this to exist,
so it is cleaner to handle failure and try again.
gethostnamestores the beginning of the host name innameeven if the host name
won¡¯t entirely fit. For some purposes, a truncated host name is good enough. If it is,
you can ignore the error code.
```
int sethostname (const char *name, size tlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Thesethostnamefunction sets the host name of the system that calls it toname, a
string with lengthlength. Only privileged processes are permitted to do this.
Usuallysethostnamegets called just once, at system boot time. Often, the program
that calls it sets it to the value it finds in the file/etc/hostname.
Be sure to set the host name to the full host name, not just the DNS hostname (see
above).
The return value is 0 on success and-1on failure. The followingerrnoerror condition
is defined for this function:
EPERM This process cannot set the host name because it is not privileged.

int getdomainnname(char *name, sizetlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
getdomainnamereturns the NIS (aka YP) domain name of the system on which it
is called. Note that this is not the more popular DNS domain name. Get that with
gethostname.
The specifics of this function are analogous togethostname, above.

int setdomainname(const char *name, sizetlength) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
setdomainnamesets the NIS (aka YP) domain name of the system on which it is
called. Note that this is not the more popular DNS domain name. Set that with
sethostname.
The specifics of this function are analogous tosethostname, above.


Chapter 31: System Management 877

long int gethostid(void) [Function]
Preliminary: |MT-Safe hostid env locale|AS-Unsafe dlopen plugin corrupt heap
lock|AC-Unsafe lock corrupt mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function returns the ¡°host ID¡± of the machine the program is running on. By
convention, this is usually the primary Internet IP address of that machine, converted
to along int. However, on some systems it is a meaningless but unique number which
is hard-coded for each machine.
This is not widely used. It arose in BSD 4.2, but was dropped in BSD 4.4. It is not
required by POSIX.
The proper way to query the IP address is to usegethostbyname on the results
ofgethostname. For more information on IP addresses, SeeSection 16.6.2 [Host
Addresses], page 465.

int sethostid(long intid) [Function]
Preliminary:|MT-Unsafe const:hostid|AS-Unsafe |AC-Unsafe corrupt fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesethostidfunction sets the ¡°host ID¡± of the host machine toid. Only privileged
processes are permitted to do this. Usually it happens just once, at system boot time.
The proper way to establish the primary IP address of a system is to configure the IP
address resolver to associate that IP address with the system¡¯s host name as returned
bygethostname. For example, put a record for the system in/etc/hosts.
Seegethostidabove for more information on host ids.
The return value is 0 on success and-1on failure. The followingerrnoerror condi-
tions are defined for this function:

```
EPERM This process cannot set the host name because it is not privileged.
ENOSYS The operating system does not support setting the host ID. On some
systems, the host ID is a meaningless but unique number hard-coded for
each machine.
```
31.2 Platform Type Identification

You can use theunamefunction to find out some information about the type of computer
your program is running on. This function and the associated data type are declared in the
header filesys/utsname.h.

As a bonus,unamealso gives some information identifying the particular system your
program is running on. This is the same information which you can get with functions
targeted to this purpose described inSection 31.1 [Host Identification], page 875.

struct utsname [Data Type]
Theutsnamestructure is used to hold information returned by theunamefunction.
It has the following members:

```
char sysname[]
This is the name of the operating system in use.
```

Chapter 31: System Management 878

```
char release[]
This is the current release level of the operating system implementation.
char version[]
This is the current version level within the release of the operating system.
char machine[]
This is a description of the type of hardware that is in use.
Some systems provide a mechanism to interrogate the kernel directly
for this information. On systems without such a mechanism, the GNU
C Library fills in this field based on the configuration name that was
specified when building and installing the library.
GNU uses a three-part name to describe a system configuration; the three
parts arecpu, manufacturerandsystem-type, and they are separated
with dashes. Any possible combination of three names is potentially
meaningful, but most such combinations are meaningless in practice and
even the meaningful ones are not necessarily supported by any particular
GNU program.
Since the value in machine is supposed to describe just the
hardware, it consists of the first two parts of the configuration name:
¡®cpu-manufacturer¡¯. For example, it might be one of these:
"sparc-sun","i386-anything","m68k-hp","m68k-sony",
"m68k-sun","mips-dec"
char nodename[]
This is the host name of this particular computer. In the GNU C Library,
the value is the same as that returned bygethostname; seeSection 31.1
[Host Identification], page 875.
gethostnameis implemented with a call touname.
char domainname[]
This is the NIS or YP domain name. It is the same value returned by
getdomainname; seeSection 31.1 [Host Identification], page 875. This
element is a relatively recent invention and use of it is not as portable as
use of the rest of the structure.
```
int uname (struct utsname *info) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theunamefunction fills in the structure pointed to byinfowith information about
the operating system and host machine. A non-negative return value indicates that
the data was successfully stored.
-1as the return value indicates an error. The only error possible isEFAULT, which
we normally don¡¯t mention as it is always a possibility.

31.3 Controlling and Querying Mounts

All files are in filesystems, and before you can access any file, its filesystem must be mounted.
Because of Unix¡¯s concept of Everything is a file, mounting of filesystems is central to


Chapter 31: System Management 879

doing almost anything. This section explains how to find out what filesystems are cur-
rently mounted and what filesystems are available for mounting, and how to change what
is mounted.

The classic filesystem is the contents of a disk drive. The concept is considerably more
abstract, though, and lots of things other than disk drives can be mounted.

Some block devices don¡¯t correspond to traditional devices like disk drives. For example,
a loop device is a block device whose driver uses a regular file in another filesystem as its
medium. So if that regular file contains appropriate data for a filesystem, you can by
mounting the loop device essentially mount a regular file.

Some filesystems aren¡¯t based on a device of any kind. The ¡°proc¡± filesystem, for exam-
ple, contains files whose data is made up by the filesystem driver on the fly whenever you
ask for it. And when you write to it, the data you write causes changes in the system. No
data gets stored.

31.3.1 Mount Information

For some programs it is desirable and necessary to access information about whether a
certain filesystem is mounted and, if it is, where, or simply to get lists of all the avail-
able filesystems. The GNU C Library provides some functions to retrieve this information
portably.

Traditionally Unix systems have a file named/etc/fstabwhich describes all possibly
mounted filesystems. Themountprogram uses this file to mount at startup time of the
system all the necessary filesystems. The information about all the filesystems actually
mounted is normally kept in a file named either/var/run/mtabor/etc/mtab. Both files
share the same syntax and it is crucial that this syntax is followed all the time. Therefore
it is best to never directly write to the files. The functions described in this section can do
this and they also provide the functionality to convert the external textual representation
to the internal representation.

Note that thefstabandmtabfiles are maintained on a system byconvention. It is
possible for the files not to exist or not to be consistent with what is really mounted or
available to mount, if the system¡¯s administration policy allows it. But programs that
mount and unmount filesystems typically maintain and use these files as described herein.

The filenames given above should never be used directly. The portable way to handle
these files is to use the macros_PATH_FSTAB, defined infstab.h, or_PATH_MNTTAB, de-
fined inmntent.handpaths.h, forfstab; and the macro_PATH_MOUNTED, also defined
inmntent.handpaths.h, formtab. There are also two alternate macro namesFSTAB,
MNTTAB, andMOUNTEDdefined but these names are deprecated and kept only for backward
compatibility. The names_PATH_MNTTABand_PATH_MOUNTEDshould always be used.

31.3.1.1 Thefstabfile

The internal representation for entries of the file isstruct fstab, defined infstab.h.

struct fstab [Data Type]
This structure is used with thegetfsent,getfsspec, andgetfsfilefunctions.
char *fs_spec
This element describes the device from which the filesystem is mounted.
Normally this is the name of a special device, such as a hard disk partition,


Chapter 31: System Management 880

```
but it could also be a more or less generic string. ForNFSit would be a
hostname and directory name combination.
Even though the element is not declaredconstit shouldn¡¯t be modi-
fied. The missingconsthas historic reasons, since this function predates
ISO C. The same is true for the other string elements of this structure.
char *fs_file
This describes the mount point on the local system. I.e., accessing any
file in this filesystem has implicitly or explicitly this string as a prefix.
char *fs_vfstype
This is the type of the filesystem. Depending on what the underlying
kernel understands it can be any string.
char *fs_mntops
This is a string containing options passed to the kernel with themount
call. Again, this can be almost anything. There can be more than one
option, separated from the others by a comma. Each option consists of a
name and an optional value part, introduced by an=character.
If the value of this element must be processed it should ideally be done us-
ing thegetsuboptfunction; seeSection 25.3.12.1 [Parsing of Suboptions],
page 790.
const char *fs_type
This name is poorly chosen. This element points to a string (possibly in
thefs_mntopsstring) which describes the modes with which the filesys-
tem is mounted.fstabdefines five macros to describe the possible values:
FSTAB_RW The filesystem gets mounted with read and write enabled.
FSTAB_RQ The filesystem gets mounted with read and write enabled.
Write access is restricted by quotas.
FSTAB_RO The filesystem gets mounted read-only.
FSTAB_SW This is not a real filesystem, it is a swap device.
FSTAB_XX This entry from thefstabfile is totally ignored.
Testing for equality with these values must happen usingstrcmpsince
these are all strings. Comparing the pointer will probably always fail.
int fs_freq
This element describes the dump frequency in days.
int fs_passno
This element describes the pass number on parallel dumps. It is closely
related to thedumputility used on Unix systems.
```
To read the entire content of the of thefstabfile the GNU C Library contains a set of
three functions which are designed in the usual way.

int setfsent (void) [Function]
Preliminary: |MT-Unsafe race:fsent|AS-Unsafe heap corrupt lock|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 31: System Management 881

```
This function makes sure that the internal read pointer for thefstabfile is at the
beginning of the file. This is done by either opening the file or resetting the read
pointer.
Since the file handle is internal to the libc this function is not thread-safe.
This function returns a non-zero value if the operation was successful and thegetfs*
functions can be used to read the entries of the file.
```
void endfsent(void) [Function]
Preliminary: |MT-Unsafe race:fsent|AS-Unsafe heap corrupt lock|AC-Unsafe
corrupt lock mem fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function makes sure that all resources acquired by a prior call tosetfsent
(explicitly or implicitly by callinggetfsent) are freed.

struct fstab * getfsent (void) [Function]
Preliminary: |MT-Unsafe race:fsent locale|AS-Unsafe corrupt heap lock|AC-
Unsafe corrupt lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns the next entry of thefstabfile. If this is the first call to any
of the functions handlingfstabsince program start or the last call ofendfsent, the
file will be opened.
The function returns a pointer to a variable of typestruct fstab. This variable
is shared by all threads and therefore this function is not thread-safe. If an error
occurredgetfsentreturns aNULLpointer.

struct fstab * getfsspec(const char *name) [Function]
Preliminary: |MT-Unsafe race:fsent locale|AS-Unsafe corrupt heap lock|AC-
Unsafe corrupt lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns the next entry of thefstabfile which has a string equal to
namepointed to by thefs_specelement. Since there is normally exactly one entry
for each special device it makes no sense to call this function more than once for the
same argument. If this is the first call to any of the functions handlingfstabsince
program start or the last call ofendfsent, the file will be opened.
The function returns a pointer to a variable of typestruct fstab. This variable
is shared by all threads and therefore this function is not thread-safe. If an error
occurredgetfsentreturns aNULLpointer.

struct fstab * getfsfile(const char *name) [Function]
Preliminary: |MT-Unsafe race:fsent locale|AS-Unsafe corrupt heap lock|AC-
Unsafe corrupt lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
This function returns the next entry of thefstabfile which has a string equal to
namepointed to by thefs_fileelement. Since there is normally exactly one entry
for each mount point it makes no sense to call this function more than once for the
same argument. If this is the first call to any of the functions handlingfstabsince
program start or the last call ofendfsent, the file will be opened.
The function returns a pointer to a variable of typestruct fstab. This variable
is shared by all threads and therefore this function is not thread-safe. If an error
occurredgetfsentreturns aNULLpointer.


Chapter 31: System Management 882

31.3.1.2 Themtabfile

The following functions and data structure access themtabfile.

struct mntent [Data Type]
This structure is used with thegetmntent,getmntent_r,addmntent, andhasmntopt
functions.

```
char *mnt_fsname
This element contains a pointer to a string describing the name of the
special device from which the filesystem is mounted. It corresponds to
thefs_specelement instruct fstab.
```
```
char *mnt_dir
This element points to a string describing the mount point of the filesys-
tem. It corresponds to thefs_fileelement instruct fstab.
```
```
char *mnt_type
mnt_typedescribes the filesystem type and is therefore equivalent tofs_
vfstypeinstruct fstab. mntent.hdefines a few symbolic names for
some of the values this string can have. But since the kernel can support
arbitrary filesystems it does not make much sense to give them symbolic
names. If one knows the symbol name one also knows the filesystem name.
Nevertheless here follows the list of the symbols provided inmntent.h.
```
```
MNTTYPE_IGNORE
This symbol expands to"ignore". The value is sometimes
used infstabfiles to make sure entries are not used without
removing them.
```
```
MNTTYPE_NFS
Expands to"nfs". Using this macro sometimes could make
sense since it names the default NFS implementation, in case
both version 2 and 3 are supported.
```
```
MNTTYPE_SWAP
This symbol expands to"swap". It names the specialfstab
entry which names one of the possibly multiple swap parti-
tions.
```
```
char *mnt_opts
The element contains a string describing the options used while mounting
the filesystem. As for the equivalent elementfs_mntopsofstruct fstab
it is best to use the functiongetsubopt(seeSection 25.3.12.1 [Parsing of
Suboptions], page 790) to access the parts of this string.
Themntent.hfile defines a number of macros with string values which
correspond to some of the options understood by the kernel. There might
be many more options which are possible so it doesn¡¯t make much sense
to rely on these macros but to be consistent here is the list:
```

Chapter 31: System Management 883

### MNTOPT_DEFAULTS

```
Expands to"defaults". This option should be used alone
since it indicates all values for the customizable values are
chosen to be the default.
MNTOPT_RO
Expands to "ro". See theFSTAB_ROvalue, it means the
filesystem is mounted read-only.
MNTOPT_RW
Expands to "rw". See theFSTAB_RWvalue, it means the
filesystem is mounted with read and write permissions.
MNTOPT_SUID
Expands to "suid". This means that the SUID bit (see
Section 30.4 [How an Application Can Change Persona],
page 846) is respected when a program from the filesystem
is started.
MNTOPT_NOSUID
Expands to"nosuid". This is the opposite ofMNTOPT_SUID,
the SUID bit for all files from the filesystem is ignored.
MNTOPT_NOAUTO
Expands to"noauto". At startup time themountprogram
will ignore this entry if it is started with the-aoption to
mount all filesystems mentioned in thefstabfile.
As for theFSTAB_*entries introduced above it is important to usestrcmp
to check for equality.
mnt_freq This elements corresponds tofs_freqand also specifies the frequency in
days in which dumps are made.
mnt_passno
This element is equivalent tofs_passnowith the same meaning which is
uninteresting for all programs besidedump.
```
For accessing themtabfile there is again a set of three functions to access all entries in
a row. Unlike the functions to handlefstabthese functions do not access a fixed file and
there is even a thread safe variant of the get function. Besides this the GNU C Library
contains functions to alter the file and test for specific options.

FILE * setmntent (const char *file, const char *mode) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe mem fd lock |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Thesetmntentfunction prepares the file namedFILEwhich must be in the format
of afstabandmtabfile for the upcoming processing through the other functions of
the family. Themodeparameter can be chosen in the way theopentypeparameter
forfopen(seeSection 12.3 [Opening Streams], page 267) can be chosen. If the file is
opened for writing the file is also allowed to be empty.
If the file was successfully openedsetmntentreturns a file handle for future use.
Otherwise the return value isNULLanderrnois set accordingly.


Chapter 31: System Management 884

int endmntent(FILE *stream) [Function]
Preliminary: |MT-Safe |AS-Unsafe heap lock|AC-Unsafe lock mem fd |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function takes for thestreamparameter a file handle which previously was
returned from thesetmntentcall.endmntentcloses the stream and frees all resources.
The return value is 1 unless an error occurred in which case it is 0.

struct mntent * getmntent(FILE *stream) [Function]
Preliminary: |MT-Unsafe race:mntentbuf locale|AS-Unsafe corrupt heap init|
AC-Unsafe init corrupt lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Thegetmntentfunction takes as the parameter a file handle previously returned by
a successful call tosetmntent. It returns a pointer to a static variable of typestruct
mntentwhich is filled with the information from the next entry from the file currently
read.
The file format used prescribes the use of spaces or tab characters to separate the
fields. This makes it harder to use names containing one of these characters (e.g.,
mount points using spaces). Therefore these characters are encoded in the files and
thegetmntentfunction takes care of the decoding while reading the entries back in.
'\040'is used to encode a space character,'\011'to encode a tab character,'\012'
to encode a newline character, and'\\'to encode a backslash.
If there was an error or the end of the file is reached the return value isNULL.
This function is not thread-safe since all calls to this function return a pointer to
the same static variable. getmntent_rshould be used in situations where multiple
threads access the file.

struct mntent * getmntent_r (FILE *stream, struct mntent [Function]
*result, char *buffer, intbufsize)
Preliminary: |MT-Safe locale|AS-Unsafe corrupt heap|AC-Unsafe corrupt lock
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thegetmntent_rfunction is the reentrant variant ofgetmntent. It also returns the
next entry from the file and returns a pointer. The actual variable the values are
stored in is not static, though. Instead the function stores the values in the variable
pointed to by theresultparameter. Additional information (e.g., the strings pointed
to by the elements of the result) are kept in the buffer of sizebufsizepointed to by
buffer.
Escaped characters (space, tab, backslash) are converted back in the same way as it
happens forgetmentent.
The function returns aNULLpointer in error cases. Errors could be:

- error while reading the file,
- end of file reached,
- bufsizeis too small for reading a complete new entry.

int addmntent(FILE *stream, const struct mntent *mnt) [Function]
Preliminary:|MT-Safe race:stream locale|AS-Unsafe corrupt|AC-Unsafe corrupt
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.


Chapter 31: System Management 885

```
Theaddmntentfunction allows adding a new entry to the file previously opened with
setmntent. The new entries are always appended. I.e., even if the position of the
file descriptor is not at the end of the file this function does not overwrite an existing
entry following the current position.
The implication of this is that to remove an entry from a file one has to create a new
file while leaving out the entry to be removed and after closing the file remove the
old one and rename the new file to the chosen name.
This function takes care of spaces and tab characters in the names to be written to
the file. It converts them and the backslash character into the format described in
thegetmntentdescription above.
This function returns 0 in case the operation was successful. Otherwise the return
value is 1 anderrnois set appropriately.
```
char * hasmntopt (const struct mntent *mnt, const char *opt) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function can be used to check whether the string pointed to by themnt_opts
element of the variable pointed to bymntcontains the optionopt. If this is true a
pointer to the beginning of the option in themnt_optselement is returned. If no
such option exists the function returnsNULL.
This function is useful to test whether a specific option is present but when all options
have to be processed one is better off with using thegetsuboptfunction to iterate
over all options in the string.

31.3.1.3 Other (Non-libc) Sources of Mount Information

On a system with a Linux kernel and theprocfilesystem, you can get information on
currently mounted filesystems from the filemountsin theprocfilesystem. Its format is
similar to that of themtabfile, but represents what is truly mounted without relying on
facilities outside the kernel to keepmtabup to date.

31.3.2 Mount, Unmount, Remount

This section describes the functions for mounting, unmounting, and remounting filesystems.

Only the superuser can mount, unmount, or remount a filesystem.
These functions do not access thefstabandmtabfiles. You should maintain and use
these separately. SeeSection 31.3.1 [Mount Information], page 879.

```
The symbols in this section are declared insys/mount.h.
```
int mount (const char *special_file, const char *dir, const char [Function]
*fstype, unsigned long intoptions, const void *data)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
mountmounts or remounts a filesystem. The two operations are quite different and are
merged rather unnaturally into this one function. TheMS_REMOUNToption, explained
below, determines whethermountmounts or remounts.


Chapter 31: System Management 886

```
For a mount, the filesystem on the block device represented by the device special
file namedspecialfilegets mounted over the mount pointdir. This means that the
directorydir(along with any files in it) is no longer visible; in its place (and still with
the namedir) is the root directory of the filesystem on the device.
As an exception, if the filesystem type (see below) is one which is not based on a
device (e.g. ¡°proc¡±),mountinstantiates a filesystem and mounts it overdir and
ignoresspecialfile.
For a remount,dirspecifies the mount point where the filesystem to be remounted is
(and remains) mounted andspecialfileis ignored. Remounting a filesystem means
changing the options that control operations on the filesystem while it is mounted. It
does not mean unmounting and mounting again.
For a mount, you must identify the type of the filesystem withfstype. This type
tells the kernel how to access the filesystem and can be thought of as the name
of a filesystem driver. The acceptable values are system dependent. On a system
with a Linux kernel and theprocfilesystem, the list of possible values is in the file
filesystemsin theprocfilesystem (e.g. typecat /proc/filesystemsto see the
list). With a Linux kernel, the types of filesystems thatmountcan mount, and their
type names, depends on what filesystem drivers are configured into the kernel or
loaded as loadable kernel modules. An example of a common value forfstypeisext2.
For a remount,mountignoresfstype.
optionsspecifies a variety of options that apply until the filesystem is unmounted or
remounted. The precise meaning of an option depends on the filesystem and with some
filesystems, an option may have no effect at all. Furthermore, for some filesystems,
some of these options (but neverMS_RDONLY) can be overridden for individual file
accesses viaioctl.
optionsis a bit string with bit fields defined using the following mask and masked
value macros:
```
```
MS_MGC_MASK
This multibit field contains a magic number. If it does not have the value
MS_MGC_VAL,mountassumes all the following bits are zero and thedata
argument is a null string, regardless of their actual values.
```
```
MS_REMOUNT
This bit on means to remount the filesystem. Off means to mount it.
```
```
MS_RDONLY
This bit on specifies that no writing to the filesystem shall be allowed
while it is mounted. This cannot be overridden byioctl. This option is
available on nearly all filesystems.
```
```
MS_NOSUID
This bit on specifies that Setuid and Setgid permissions on files in the
filesystem shall be ignored while it is mounted.
MS_NOEXEC
This bit on specifies that no files in the filesystem shall be executed while
the filesystem is mounted.
```

Chapter 31: System Management 887

```
MS_NODEV This bit on specifies that no device special files in the filesystem shall be
accessible while the filesystem is mounted.
MS_SYNCHRONOUS
This bit on specifies that all writes to the filesystem while it is mounted
shall be synchronous; i.e., data shall be synced before each write com-
pletes rather than held in the buffer cache.
MS_MANDLOCK
This bit on specifies that mandatory locks on files shall be permitted
while the filesystem is mounted.
MS_NOATIME
This bit on specifies that access times of files shall not be updated when
the files are accessed while the filesystem is mounted.
MS_NODIRATIME
This bit on specifies that access times of directories shall not be updated
when the directories are accessed while the filesystem in mounted.
Any bits not covered by the above masks should be set off; otherwise, results are
undefined.
The meaning ofdatadepends on the filesystem type and is controlled entirely by the
filesystem driver in the kernel.
Example:
#include <sys/mount.h>
```
```
mount("/dev/hdb", "/cdrom", "iso9660", MS_MGC_VAL | MS_RDONLY | MS_NOSUID, "");
```
```
mount("/dev/hda2", "/mnt", "", MS_MGC_VAL | MS_REMOUNT, "");
```
```
Appropriate arguments formountare conventionally recorded in thefstabtable. See
Section 31.3.1 [Mount Information], page 879.
The return value is zero if the mount or remount is successful. Otherwise, it is-1and
errnois set appropriately. The values oferrnoare filesystem dependent, but here is
a general list:
EPERM The process is not superuser.
ENODEV The file system typefstypeis not known to the kernel.
ENOTBLK The filedevis not a block device special file.
EBUSY
```
- The device is already mounted.
- The mount point is busy. (E.g. it is some process¡¯ working directory
    or has a filesystem mounted on it already).
- The request is to remount read-only, but there are files open for
    writing.
EINVAL
- A remount was attempted, but there is no filesystem mounted over
the specified mount point.


Chapter 31: System Management 888

- The supposed filesystem has an invalid superblock.
EACCES
- The filesystem is inherently read-only (possibly due to a switch on
the device) and the process attempted to mount it read/write (by
setting theMS_RDONLYbit off).
- specialfileordiris not accessible due to file permissions.
- specialfile is not accessible because it is in a filesystem that is
mounted with theMS_NODEVoption.

```
EM_FILE The table of dummy devices is full. mountneeds to create a dummy
device (aka ¡°unnamed¡± device) if the filesystem being mounted is not
one that uses a device.
```
int umount2(const char *file, intflags) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
umount2unmounts a filesystem.
You can identify the filesystem to unmount either by the device special file that
contains the filesystem or by the mount point. The effect is the same. Specify either
as the stringfile.
flagscontains the one-bit field identified by the following mask macro:

```
MNT_FORCE
This bit on means to force the unmounting even if the filesystem is busy,
by making it unbusy first. If the bit is off and the filesystem is busy,
umount2fails witherrno=EBUSY. Depending on the filesystem, this
may override all, some, or no busy conditions.
```
```
All other bits inflagsshould be set to zero; otherwise, the result is undefined.
Example:
#include <sys/mount.h>
```
```
umount2("/mnt", MNT_FORCE);
```
```
umount2("/dev/hdd1", 0);
```
```
After the filesystem is unmounted, the directory that was the mount point is visible,
as are any files in it.
As part of unmounting,umount2syncs the filesystem.
If the unmounting is successful, the return value is zero. Otherwise, it is-1anderrno
is set accordingly:
EPERM The process is not superuser.
EBUSY The filesystem cannot be unmounted because it is busy. E.g. it contains
a directory that is some process¡¯s working directory or a file that some
process has open. With some filesystems in some cases, you can avoid
this failure with theMNT_FORCEoption.
```

Chapter 31: System Management 889

```
EINVAL filevalidly refers to a file, but that file is neither a mount point nor a
device special file of a currently mounted filesystem.
This function is not available on all systems.
```
int umount(const char *file) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
umountdoes the same thing asumount2withflagsset to zeroes. It is more widely
available than umount2but since it lacks the possibility to forcefully unmount a
filesystem is deprecated whenumount2is also available.


### 890

## 32 System Configuration Parameters.......................

The functions and macros listed in this chapter give information about configuration pa-
rameters of the operating system¡ªfor example, capacity limits, presence of optional POSIX
features, and the default path for executable files (seeSection 32.12 [String-Valued Param-
eters], page 909).

32.1 General Capacity Limits

The POSIX.1 and POSIX.2 standards specify a number of parameters that describe ca-
pacity limitations of the system. These limits can be fixed constants for a given operating
system, or they can vary from machine to machine. For example, some limit values may
be configurable by the system administrator, either at run time or by rebuilding the kernel,
and this should not require recompiling application programs.

Each of the following limit parameters has a macro that is defined inlimits.honly if
the system has a fixed, uniform limit for the parameter in question. If the system allows
different file systems or files to have different limits, then the macro is undefined; use
sysconfto find out the limit that applies at a particular time on a particular machine. See
Section 32.4 [Usingsysconf], page 893.

Each of these parameters also has another macro, with a name starting with ¡®_POSIX¡¯,
which gives the lowest value that the limit is allowed to have onanyPOSIX system. See
Section 32.5 [Minimum Values for General Capacity Limits], page 902.

int ARG_MAX [Macro]
If defined, the unvarying maximum combined length of theargvandenvironargu-
ments that can be passed to theexecfunctions.

int CHILD_MAX [Macro]
If defined, the unvarying maximum number of processes that can exist with the same
real user ID at any one time. In BSD and GNU, this is controlled by theRLIMIT_
NPROCresource limit; seeSection 22.2 [Limiting Resource Usage], page 685.

int OPEN_MAX [Macro]
If defined, the unvarying maximum number of files that a single process can have open
simultaneously. In BSD and GNU, this is controlled by theRLIMIT_NOFILEresource
limit; seeSection 22.2 [Limiting Resource Usage], page 685.

int STREAM_MAX [Macro]
If defined, the unvarying maximum number of streams that a single process can have
open simultaneously. SeeSection 12.3 [Opening Streams], page 267.

int TZNAME_MAX [Macro]
If defined, the unvarying maximum length of a time zone name. SeeSection 21.5.7
[Functions and Variables for Time Zones], page 678.

```
These limit macros are always defined inlimits.h.
```

Chapter 32: System Configuration Parameters 891

int NGROUPS_MAX [Macro]
The maximum number of supplementary group IDs that one process can have.
The value of this macro is actually a lower bound for the maximum. That is, you can
count on being able to have that many supplementary group IDs, but a particular
machine might let you have even more. You can usesysconfto see whether a
particular machine will let you have more (seeSection 32.4 [Usingsysconf], page 893).

ssize_t SSIZE_MAX [Macro]
The largest value that can fit in an object of typessize_t. Effectively, this is the
limit on the number of bytes that can be read or written in a single operation.
This macro is defined in all POSIX systems because this limit is never configurable.

int RE_DUP_MAX [Macro]
The largest number of repetitions you are guaranteed is allowed in the construct
¡®\{min,max\}¡¯ in a regular expression.
The value of this macro is actually a lower bound for the maximum. That is, you can
count on being able to have that many repetitions, but a particular machine might
let you have even more. You can usesysconfto see whether a particular machine
will let you have more (seeSection 32.4 [Usingsysconf], page 893). And even the
value thatsysconftells you is just a lower bound¡ªlarger values might work.
This macro is defined in all POSIX.2 systems, because POSIX.2 says it should always
be defined even if there is no specific imposed limit.

32.2 Overall System Options

POSIX defines certain system-specific options that not all POSIX systems support. Since
these options are provided in the kernel, not in the library, simply using the GNU C Library
does not guarantee any of these features are supported; it depends on the system you are
using.

You can test for the availability of a given option using the macros in this section,
together with the functionsysconf. The macros are defined only if you includeunistd.h.

For the following macros, if the macro is defined inunistd.h, then the option is sup-
ported. Otherwise, the option may or may not be supported; usesysconfto find out. See
Section 32.4 [Usingsysconf], page 893.

int _POSIX_JOB_CONTROL [Macro]
If this symbol is defined, it indicates that the system supports job control. Otherwise,
the implementation behaves as if all processes within a session belong to a single
process group. SeeChapter 28 [Job Control], page 817. Systems conforming to the
2001 revision of POSIX, or newer, will always define this symbol.

int _POSIX_SAVED_IDS [Macro]
If this symbol is defined, it indicates that the system remembers the effective user and
group IDs of a process before it executes an executable file with the set-user-ID or set-
group-ID bits set, and that explicitly changing the effective user or group IDs back to
these values is permitted. If this option is not defined, then if a nonprivileged process
changes its effective user or group ID to the real user or group ID of the process, it


Chapter 32: System Configuration Parameters 892

```
can¡¯t change it back again. SeeSection 30.8 [Enabling and Disabling Setuid Access],
page 851.
```
For the following macros, if the macro is defined inunistd.h, then its value indicates
whether the option is supported. A value of-1means no, and any other value means yes.
If the macro is not defined, then the option may or may not be supported; usesysconfto
find out. SeeSection 32.4 [Usingsysconf], page 893.

int _POSIX2_C_DEV [Macro]
If this symbol is defined, it indicates that the system has the POSIX.2 C compiler
command,c89. The GNU C Library always defines this as 1 , on the assumption that
you would not have installed it if you didn¡¯t have a C compiler.

int _POSIX2_FORT_DEV [Macro]
If this symbol is defined, it indicates that the system has the POSIX.2 Fortran com-
piler command,fort77. The GNU C Library never defines this, because we don¡¯t
know what the system has.

int _POSIX2_FORT_RUN [Macro]
If this symbol is defined, it indicates that the system has the POSIX.2asacommand
to interpret Fortran carriage control. The GNU C Library never defines this, because
we don¡¯t know what the system has.

int _POSIX2_LOCALEDEF [Macro]
If this symbol is defined, it indicates that the system has the POSIX.2localedef
command. The GNU C Library never defines this, because we don¡¯t know what the
system has.

int _POSIX2_SW_DEV [Macro]
If this symbol is defined, it indicates that the system has the POSIX.2 commandsar,
make, andstrip. The GNU C Library always defines this as 1 , on the assumption
that you had to havearandmaketo install the library, and it¡¯s unlikely thatstrip
would be absent when those are present.

32.3 Which Version of POSIX is Supported

long int _POSIX_VERSION [Macro]
This constant represents the version of the POSIX.1 standard to which the implemen-
tation conforms. For an implementation conforming to the 1995 POSIX.1 standard,
the value is the integer199506L.
_POSIX_VERSIONis always defined (inunistd.h) in any POSIX system.
Usage Note: Don¡¯t try to test whether the system supports POSIX by including
unistd.hand then checking whether_POSIX_VERSIONis defined. On a non-POSIX
system, this will probably fail because there is nounistd.h. We do not know ofany
way you can reliably test at compilation time whether your target system supports
POSIX or whetherunistd.hexists.


Chapter 32: System Configuration Parameters 893

long int _POSIX2_C_VERSION [Macro]
This constant represents the version of the POSIX.2 standard which the library and
system kernel support. We don¡¯t know what value this will be for the first version of
the POSIX.2 standard, because the value is based on the year and month in which
the standard is officially adopted.
The value of this symbol says nothing about the utilities installed on the system.
Usage Note:You can use this macro to tell whether a POSIX.1 system library sup-
ports POSIX.2 as well. Any POSIX.1 system containsunistd.h, so include that file
and then testdefined (_POSIX2_C_VERSION).

32.4 Usingsysconf

When your system has configurable system limits, you can use thesysconffunction to
find out the value that applies to any particular machine. The function and the associated
parameterconstants are declared in the header fileunistd.h.

32.4.1 Definition ofsysconf

long int sysconf (intparameter) [Function]
Preliminary:|MT-Safe env|AS-Unsafe lock heap|AC-Unsafe lock mem fd|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is used to inquire about runtime system parameters. Theparameter
argument should be one of the ¡®_SC_¡¯ symbols listed below.
The normal return value fromsysconfis the value you requested. A value of-1is
returned both if the implementation does not impose a limit, and in case of an error.
The followingerrnoerror conditions are defined for this function:
EINVAL The value of theparameteris invalid.

32.4.2 Constants forsysconfParameters

Here are the symbolic constants for use as theparameterargument tosysconf. The values
are all integer constants (more specifically, enumeration type values).

_SC_ARG_MAX
Inquire about the parameter corresponding toARG_MAX.

_SC_CHILD_MAX
Inquire about the parameter corresponding toCHILD_MAX.

_SC_OPEN_MAX
Inquire about the parameter corresponding toOPEN_MAX.

_SC_STREAM_MAX
Inquire about the parameter corresponding toSTREAM_MAX.

_SC_TZNAME_MAX
Inquire about the parameter corresponding toTZNAME_MAX.

_SC_NGROUPS_MAX
Inquire about the parameter corresponding toNGROUPS_MAX.


Chapter 32: System Configuration Parameters 894

### _SC_JOB_CONTROL

```
Inquire about the parameter corresponding to_POSIX_JOB_CONTROL.
```
_SC_SAVED_IDS
Inquire about the parameter corresponding to_POSIX_SAVED_IDS.

_SC_VERSION
Inquire about the parameter corresponding to_POSIX_VERSION.

_SC_CLK_TCK
Inquire about the number of clock ticks per second; seeSection 21.4.1 [CPU
Time Inquiry], page 649. The corresponding parameterCLK_TCKis obsolete.

_SC_CHARCLASS_NAME_MAX
Inquire about the parameter corresponding to maximal length allowed for a
character class name in an extended locale specification. These extensions are
not yet standardized and so this option is not standardized as well.

_SC_REALTIME_SIGNALS
Inquire about the parameter corresponding to_POSIX_REALTIME_SIGNALS.

_SC_PRIORITY_SCHEDULING
Inquire about the parameter corresponding to_POSIX_PRIORITY_SCHEDULING.

_SC_TIMERS
Inquire about the parameter corresponding to_POSIX_TIMERS.

_SC_ASYNCHRONOUS_IO
Inquire about the parameter corresponding to_POSIX_ASYNCHRONOUS_IO.

_SC_PRIORITIZED_IO
Inquire about the parameter corresponding to_POSIX_PRIORITIZED_IO.

_SC_SYNCHRONIZED_IO
Inquire about the parameter corresponding to_POSIX_SYNCHRONIZED_IO.

_SC_FSYNC
Inquire about the parameter corresponding to_POSIX_FSYNC.

_SC_MAPPED_FILES
Inquire about the parameter corresponding to_POSIX_MAPPED_FILES.

_SC_MEMLOCK
Inquire about the parameter corresponding to_POSIX_MEMLOCK.

_SC_MEMLOCK_RANGE
Inquire about the parameter corresponding to_POSIX_MEMLOCK_RANGE.

_SC_MEMORY_PROTECTION
Inquire about the parameter corresponding to_POSIX_MEMORY_PROTECTION.

_SC_MESSAGE_PASSING
Inquire about the parameter corresponding to_POSIX_MESSAGE_PASSING.

_SC_SEMAPHORES
Inquire about the parameter corresponding to_POSIX_SEMAPHORES.


Chapter 32: System Configuration Parameters 895

### _SC_SHARED_MEMORY_OBJECTS

```
Inquire about the parameter corresponding to
_POSIX_SHARED_MEMORY_OBJECTS.
```
_SC_AIO_LISTIO_MAX
Inquire about the parameter corresponding to_POSIX_AIO_LISTIO_MAX.

_SC_AIO_MAX
Inquire about the parameter corresponding to_POSIX_AIO_MAX.

_SC_AIO_PRIO_DELTA_MAX
Inquire about the value by which a process can decrease its asynchronous I/O
priority level from its own scheduling priority. This corresponds to the run-time
invariant valueAIO_PRIO_DELTA_MAX.

_SC_DELAYTIMER_MAX
Inquire about the parameter corresponding to_POSIX_DELAYTIMER_MAX.

_SC_MQ_OPEN_MAX
Inquire about the parameter corresponding to_POSIX_MQ_OPEN_MAX.

_SC_MQ_PRIO_MAX
Inquire about the parameter corresponding to_POSIX_MQ_PRIO_MAX.

_SC_RTSIG_MAX
Inquire about the parameter corresponding to_POSIX_RTSIG_MAX.

_SC_SEM_NSEMS_MAX
Inquire about the parameter corresponding to_POSIX_SEM_NSEMS_MAX.

_SC_SEM_VALUE_MAX
Inquire about the parameter corresponding to_POSIX_SEM_VALUE_MAX.

_SC_SIGQUEUE_MAX
Inquire about the parameter corresponding to_POSIX_SIGQUEUE_MAX.

_SC_TIMER_MAX
Inquire about the parameter corresponding to_POSIX_TIMER_MAX.

_SC_PII Inquire about the parameter corresponding to_POSIX_PII.

_SC_PII_XTI
Inquire about the parameter corresponding to_POSIX_PII_XTI.

_SC_PII_SOCKET
Inquire about the parameter corresponding to_POSIX_PII_SOCKET.

_SC_PII_INTERNET
Inquire about the parameter corresponding to_POSIX_PII_INTERNET.

_SC_PII_OSI
Inquire about the parameter corresponding to_POSIX_PII_OSI.

_SC_SELECT
Inquire about the parameter corresponding to_POSIX_SELECT.

_SC_UIO_MAXIOV
Inquire about the parameter corresponding to_POSIX_UIO_MAXIOV.


Chapter 32: System Configuration Parameters 896

### _SC_PII_INTERNET_STREAM

```
Inquire about the parameter corresponding to_POSIX_PII_INTERNET_STREAM.
```
_SC_PII_INTERNET_DGRAM
Inquire about the parameter corresponding to_POSIX_PII_INTERNET_DGRAM.

_SC_PII_OSI_COTS
Inquire about the parameter corresponding to_POSIX_PII_OSI_COTS.

_SC_PII_OSI_CLTS
Inquire about the parameter corresponding to_POSIX_PII_OSI_CLTS.

_SC_PII_OSI_M
Inquire about the parameter corresponding to_POSIX_PII_OSI_M.

_SC_T_IOV_MAX
Inquire about the value associated with theT_IOV_MAXvariable.

_SC_THREADS
Inquire about the parameter corresponding to_POSIX_THREADS.

_SC_THREAD_SAFE_FUNCTIONS
Inquire about the parameter corresponding to
_POSIX_THREAD_SAFE_FUNCTIONS.

_SC_GETGR_R_SIZE_MAX
Inquire about the parameter corresponding to_POSIX_GETGR_R_SIZE_MAX.

_SC_GETPW_R_SIZE_MAX
Inquire about the parameter corresponding to_POSIX_GETPW_R_SIZE_MAX.

_SC_LOGIN_NAME_MAX
Inquire about the parameter corresponding to_POSIX_LOGIN_NAME_MAX.

_SC_TTY_NAME_MAX
Inquire about the parameter corresponding to_POSIX_TTY_NAME_MAX.

_SC_THREAD_DESTRUCTOR_ITERATIONS
Inquire about the parameter corresponding to_POSIX_THREAD_DESTRUCTOR_
ITERATIONS.

_SC_THREAD_KEYS_MAX
Inquire about the parameter corresponding to_POSIX_THREAD_KEYS_MAX.

_SC_THREAD_STACK_MIN
Inquire about the parameter corresponding to_POSIX_THREAD_STACK_MIN.

_SC_THREAD_THREADS_MAX
Inquire about the parameter corresponding to_POSIX_THREAD_THREADS_MAX.

_SC_THREAD_ATTR_STACKADDR
Inquire about the parameter corresponding to
a_POSIX_THREAD_ATTR_STACKADDR.

_SC_THREAD_ATTR_STACKSIZE
Inquire about the parameter corresponding to
_POSIX_THREAD_ATTR_STACKSIZE.


Chapter 32: System Configuration Parameters 897

### _SC_THREAD_PRIORITY_SCHEDULING

```
Inquire about the parameter corresponding to _POSIX_THREAD_PRIORITY_
SCHEDULING.
```
_SC_THREAD_PRIO_INHERIT
Inquire about the parameter corresponding to_POSIX_THREAD_PRIO_INHERIT.

_SC_THREAD_PRIO_PROTECT
Inquire about the parameter corresponding to_POSIX_THREAD_PRIO_PROTECT.

_SC_THREAD_PROCESS_SHARED
Inquire about the parameter corresponding to _POSIX_THREAD_PROCESS_
SHARED.

_SC_2_C_DEV
Inquire about whether the system has the POSIX.2 C compiler command,c89.

_SC_2_FORT_DEV
Inquire about whether the system has the POSIX.2 Fortran compiler command,
fort77.

_SC_2_FORT_RUN
Inquire about whether the system has the POSIX.2asacommand to interpret
Fortran carriage control.

_SC_2_LOCALEDEF
Inquire about whether the system has the POSIX.2localedefcommand.

_SC_2_SW_DEV
Inquire about whether the system has the POSIX.2 commandsar,make, and
strip.

_SC_BC_BASE_MAX
Inquire about the maximum value ofobasein thebcutility.

_SC_BC_DIM_MAX
Inquire about the maximum size of an array in thebcutility.

_SC_BC_SCALE_MAX
Inquire about the maximum value ofscalein thebcutility.

_SC_BC_STRING_MAX
Inquire about the maximum size of a string constant in thebcutility.

_SC_COLL_WEIGHTS_MAX
Inquire about the maximum number of weights that can necessarily be used in
defining the collating sequence for a locale.

_SC_EXPR_NEST_MAX
Inquire about the maximum number of expressions nested within parentheses
when using theexprutility.

_SC_LINE_MAX
Inquire about the maximum size of a text line that the POSIX.2 text utilities
can handle.


Chapter 32: System Configuration Parameters 898

### _SC_EQUIV_CLASS_MAX

```
Inquire about the maximum number of weights that can be assigned to an entry
of theLC_COLLATEcategory ¡®order¡¯ keyword in a locale definition. The GNU
C Library does not presently support locale definitions.
```
_SC_VERSION
Inquire about the version number of POSIX.1 that the library and kernel sup-
port.

_SC_2_VERSION
Inquire about the version number of POSIX.2 that the system utilities support.

_SC_PAGESIZE
Inquire about the virtual memory page size of the machine. getpagesize
returns the same value (seeSection 22.4.2 [How to get information about the
memory subsystem?], page 702).

_SC_NPROCESSORS_CONF
Inquire about the number of configured processors.

_SC_NPROCESSORS_ONLN
Inquire about the number of processors online.

_SC_PHYS_PAGES
Inquire about the number of physical pages in the system.

_SC_AVPHYS_PAGES
Inquire about the number of available physical pages in the system.

_SC_ATEXIT_MAX
Inquire about the number of functions which can be registered as termination
functions foratexit; seeSection 25.7.3 [Cleanups on Exit], page 800.

_SC_LEVEL1_ICACHE_SIZE
Inquire about the size of the Level 1 instruction cache.

_SC_LEVEL1_ICACHE_ASSOC
Inquire about the associativity of the Level 1 instruction cache.

_SC_LEVEL1_ICACHE_LINESIZE
Inquire about the line length of the Level 1 instruction cache.
On aarch64, the cache line size returned is the minimum instruction cache line
size observable by userspace. This is typically the same as the L1 icache size but
on some cores it may not be so. However, it is specified in the architecture that
operations such as cache line invalidation are consistent with the size reported
with this variable.

_SC_LEVEL1_DCACHE_SIZE
Inquire about the size of the Level 1 data cache.

_SC_LEVEL1_DCACHE_ASSOC
Inquire about the associativity of the Level 1 data cache.

_SC_LEVEL1_DCACHE_LINESIZE
Inquire about the line length of the Level 1 data cache.


Chapter 32: System Configuration Parameters 899

```
On aarch64, the cache line size returned is the minimum data cache line size
observable by userspace. This is typically the same as the L1 dcache size but
on some cores it may not be so. However, it is specified in the architecture that
operations such as cache line invalidation are consistent with the size reported
with this variable.
```
_SC_LEVEL2_CACHE_SIZE
Inquire about the size of the Level 2 cache.

_SC_LEVEL2_CACHE_ASSOC
Inquire about the associativity of the Level 2 cache.

_SC_LEVEL2_CACHE_LINESIZE
Inquire about the line length of the Level 2 cache.

_SC_LEVEL3_CACHE_SIZE
Inquire about the size of the Level 3 cache.

_SC_LEVEL3_CACHE_ASSOC
Inquire about the associativity of the Level 3 cache.

_SC_LEVEL3_CACHE_LINESIZE
Inquire about the line length of the Level 3 cache.

_SC_LEVEL4_CACHE_SIZE
Inquire about the size of the Level 4 cache.

_SC_LEVEL4_CACHE_ASSOC
Inquire about the associativity of the Level 4 cache.

_SC_LEVEL4_CACHE_LINESIZE
Inquire about the line length of the Level 4 cache.

_SC_XOPEN_VERSION
Inquire about the parameter corresponding to_XOPEN_VERSION.

_SC_XOPEN_XCU_VERSION
Inquire about the parameter corresponding to_XOPEN_XCU_VERSION.

_SC_XOPEN_UNIX
Inquire about the parameter corresponding to_XOPEN_UNIX.

_SC_XOPEN_REALTIME
Inquire about the parameter corresponding to_XOPEN_REALTIME.

_SC_XOPEN_REALTIME_THREADS
Inquire about the parameter corresponding to_XOPEN_REALTIME_THREADS.

_SC_XOPEN_LEGACY
Inquire about the parameter corresponding to_XOPEN_LEGACY.

_SC_XOPEN_CRYPT
Inquire about the parameter corresponding to _XOPEN_CRYPT. The GNU
C Libraryno longer implements the_XOPEN_CRYPT extensions, so ¡®sysconf
(_SC_XOPEN_CRYPT)¡¯ always returns-1.


Chapter 32: System Configuration Parameters 900

### _SC_XOPEN_ENH_I18N

```
Inquire about the parameter corresponding to_XOPEN_ENH_I18N.
```
_SC_XOPEN_SHM
Inquire about the parameter corresponding to_XOPEN_SHM.

_SC_XOPEN_XPG2
Inquire about the parameter corresponding to_XOPEN_XPG2.

_SC_XOPEN_XPG3
Inquire about the parameter corresponding to_XOPEN_XPG3.

_SC_XOPEN_XPG4
Inquire about the parameter corresponding to_XOPEN_XPG4.

_SC_CHAR_BIT
Inquire about the number of bits in a variable of typechar.

_SC_CHAR_MAX
Inquire about the maximum value which can be stored in a variable of type
char.

_SC_CHAR_MIN
Inquire about the minimum value which can be stored in a variable of type
char.

_SC_INT_MAX
Inquire about the maximum value which can be stored in a variable of type
int.

_SC_INT_MIN
Inquire about the minimum value which can be stored in a variable of typeint.

_SC_LONG_BIT
Inquire about the number of bits in a variable of typelong int.

_SC_WORD_BIT
Inquire about the number of bits in a variable of a register word.

_SC_MB_LEN_MAX
Inquire about the maximum length of a multi-byte representation of a wide
character value.

_SC_NZERO
Inquire about the value used to internally represent the zero priority level for
the process execution.

_SC_SSIZE_MAX
Inquire about the maximum value which can be stored in a variable of type
ssize_t.

_SC_SCHAR_MAX
Inquire about the maximum value which can be stored in a variable of type
signed char.


Chapter 32: System Configuration Parameters 901

### _SC_SCHAR_MIN

```
Inquire about the minimum value which can be stored in a variable of type
signed char.
```
_SC_SHRT_MAX
Inquire about the maximum value which can be stored in a variable of type
short int.

_SC_SHRT_MIN
Inquire about the minimum value which can be stored in a variable of type
short int.

_SC_UCHAR_MAX
Inquire about the maximum value which can be stored in a variable of type
unsigned char.

_SC_UINT_MAX
Inquire about the maximum value which can be stored in a variable of type
unsigned int.

_SC_ULONG_MAX
Inquire about the maximum value which can be stored in a variable of type
unsigned long int.

_SC_USHRT_MAX
Inquire about the maximum value which can be stored in a variable of type
unsigned short int.

_SC_NL_ARGMAX
Inquire about the parameter corresponding toNL_ARGMAX.

_SC_NL_LANGMAX
Inquire about the parameter corresponding toNL_LANGMAX.

_SC_NL_MSGMAX
Inquire about the parameter corresponding toNL_MSGMAX.

_SC_NL_NMAX
Inquire about the parameter corresponding toNL_NMAX.

_SC_NL_SETMAX
Inquire about the parameter corresponding toNL_SETMAX.

_SC_NL_TEXTMAX
Inquire about the parameter corresponding toNL_TEXTMAX.

32.4.3 Examples ofsysconf

We recommend that you first test for a macro definition for the parameter you are interested
in, and callsysconfonly if the macro is not defined. For example, here is how to test
whether job control is supported:


Chapter 32: System Configuration Parameters 902

```
int
have_job_control (void)
{
#ifdef _POSIX_JOB_CONTROL
return 1;
#else
int value = sysconf (_SC_JOB_CONTROL);
if (value < 0)
/*If the system is that badly wedged,
there¡¯s no use trying to go on. */
fatal (strerror (errno));
return value;
#endif
}
Here is how to get the value of a numeric limit:
int
get_child_max ()
{
#ifdef CHILD_MAX
return CHILD_MAX;
#else
int value = sysconf (_SC_CHILD_MAX);
if (value < 0)
fatal (strerror (errno));
return value;
#endif
}
```
32.5 Minimum Values for General Capacity Limits

Here are the names for the POSIX minimum upper bounds for the system limit parameters.
The significance of these values is that you can safely push to these limits without checking
whether the particular system you are using can go that far.

_POSIX_AIO_LISTIO_MAX
The most restrictive limit permitted by POSIX for the maximum number of I/O
operations that can be specified in a list I/O call. The value of this constant is
2 ; thus you can add up to two new entries of the list of outstanding operations.

_POSIX_AIO_MAX
The most restrictive limit permitted by POSIX for the maximum number of
outstanding asynchronous I/O operations. The value of this constant is 1. So
you cannot expect that you can issue more than one operation and immediately
continue with the normal work, receiving the notifications asynchronously.

_POSIX_ARG_MAX
The value of this macro is the most restrictive limit permitted by POSIX for
the maximum combined length of theargvandenvironarguments that can be
passed to theexecfunctions. Its value is 4096.

_POSIX_CHILD_MAX
The value of this macro is the most restrictive limit permitted by POSIX for
the maximum number of simultaneous processes per real user ID. Its value is
6.


Chapter 32: System Configuration Parameters 903

### _POSIX_NGROUPS_MAX

```
The value of this macro is the most restrictive limit permitted by POSIX for
the maximum number of supplementary group IDs per process. Its value is 0.
```
_POSIX_OPEN_MAX
The value of this macro is the most restrictive limit permitted by POSIX for the
maximum number of files that a single process can have open simultaneously.
Its value is 16.

_POSIX_SSIZE_MAX
The value of this macro is the most restrictive limit permitted by POSIX for
the maximum value that can be stored in an object of typessize_t. Its value
is 32767.

_POSIX_STREAM_MAX
The value of this macro is the most restrictive limit permitted by POSIX for
the maximum number of streams that a single process can have open simulta-
neously. Its value is 8.

_POSIX_TZNAME_MAX
The value of this macro is the most restrictive limit permitted by POSIX for
the maximum length of a time zone name. Its value is 3.

_POSIX2_RE_DUP_MAX
The value of this macro is the most restrictive limit permitted by POSIX for
the numbers used in the ¡®\{min,max\}¡¯ construct in a regular expression. Its
value is 255.

32.6 Limits on File System Capacity

The POSIX.1 standard specifies a number of parameters that describe the limitations of
the file system. It¡¯s possible for the system to have a fixed, uniform limit for a parameter,
but this isn¡¯t the usual case. On most systems, it¡¯s possible for different file systems (and,
for some parameters, even different files) to have different maximum limits. For example,
this is very likely if you use NFS to mount some of the file systems from other machines.

Each of the following macros is defined inlimits.honly if the system has a fixed,
uniform limit for the parameter in question. If the system allows different file systems or
files to have different limits, then the macro is undefined; usepathconforfpathconfto find
out the limit that applies to a particular file. SeeSection 32.9 [Usingpathconf], page 906.

Each parameter also has another macro, with a name starting with ¡®_POSIX¡¯, which gives
the lowest value that the limit is allowed to have onanyPOSIX system. SeeSection 32.8
[Minimum Values for File System Limits], page 905.

int LINK_MAX [Macro]
The uniform system limit (if any) for the number of names for a given file. See
Section 14.4 [Hard Links], page 418.

int MAX_CANON [Macro]
The uniform system limit (if any) for the amount of text in a line of input when
input editing is enabled. SeeSection 17.3 [Two Styles of Input: Canonical or Not],
page 504.


Chapter 32: System Configuration Parameters 904

int MAX_INPUT [Macro]
The uniform system limit (if any) for the total number of characters typed ahead as
input. SeeSection 17.2 [I/O Queues], page 504.

int NAME_MAX [Macro]
The uniform system limit (if any) for the length of a file name component, not in-
cluding the terminating null character.
Portability Note:On some systems, the GNU C Library definesNAME_MAX, but does
not actually enforce this limit.

int PATH_MAX [Macro]
The uniform system limit (if any) for the length of an entire file name (that is, the
argument given to system calls such asopen), including the terminating null character.
Portability Note: The GNU C Library does not enforce this limit even ifPATH_MAX
is defined.

int PIPE_BUF [Macro]
The uniform system limit (if any) for the number of bytes that can be written atomi-
cally to a pipe. If multiple processes are writing to the same pipe simultaneously, out-
put from different processes might be interleaved in chunks of this size. SeeChapter 15
[Pipes and FIFOs], page 450.

```
These are alternative macro names for some of the same information.
```
int MAXNAMLEN [Macro]
This is the BSD name forNAME_MAX. It is defined indirent.h.

int FILENAME_MAX [Macro]
The value of this macro is an integer constant expression that represents the maximum
length of a file name string. It is defined instdio.h.
UnlikePATH_MAX, this macro is defined even if there is no actual limit imposed. In
such a case, its value is typically a very large number. This is always the case on
GNU/Hurd systems.
Usage Note: Don¡¯t useFILENAME_MAXas the size of an array in which to store a
file name! You can¡¯t possibly make an array that big! Use dynamic allocation (see
Section 3.2 [Allocating Storage For Program Data], page 43) instead.

32.7 Optional Features in File Support

POSIX defines certain system-specific options in the system calls for operating on files.
Some systems support these options and others do not. Since these options are provided
in the kernel, not in the library, simply using the GNU C Library does not guarantee that
any of these features is supported; it depends on the system you are using. They can also
vary between file systems on a single machine.

This section describes the macros you can test to determine whether a particular option
is supported on your machine. If a given macro is defined inunistd.h, then its value says
whether the corresponding feature is supported. (A value of-1indicates no; any other


Chapter 32: System Configuration Parameters 905

value indicates yes.) If the macro is undefined, it means particular files may or may not
support the feature.

Since all the machines that support the GNU C Library also support NFS, one can
never make a general statement about whether all file systems support the_POSIX_CHOWN_
RESTRICTEDand_POSIX_NO_TRUNCfeatures. So these names are never defined as macros
in the GNU C Library.

int _POSIX_CHOWN_RESTRICTED [Macro]
If this option is in effect, thechownfunction is restricted so that the only changes
permitted to nonprivileged processes is to change the group owner of a file to either
be the effective group ID of the process, or one of its supplementary group IDs. See
Section 14.9.4 [File Owner], page 433.

int _POSIX_NO_TRUNC [Macro]
If this option is in effect, file name components longer thanNAME_MAXgenerate an
ENAMETOOLONGerror. Otherwise, file name components that are too long are silently
truncated.

unsigned char _POSIX_VDISABLE [Macro]
This option is only meaningful for files that are terminal devices. If it is enabled, then
handling for special control characters can be disabled individually. SeeSection 17.4.9
[Special Characters], page 516.

If one of these macros is undefined, that means that the option might be in effect for
some files and not for others. To inquire about a particular file, callpathconforfpathconf.
SeeSection 32.9 [Usingpathconf], page 906.

32.8 Minimum Values for File System Limits

Here are the names for the POSIX minimum upper bounds for some of the above parameters.
The significance of these values is that you can safely push to these limits without checking
whether the particular system you are using can go that far. In most cases GNU systems
do not have these strict limitations. The actual limit should be requested if necessary.

_POSIX_LINK_MAX
The most restrictive limit permitted by POSIX for the maximum value of a
file¡¯s link count. The value of this constant is 8 ; thus, you can always make up
to eight names for a file without running into a system limit.

_POSIX_MAX_CANON
The most restrictive limit permitted by POSIX for the maximum number of
bytes in a canonical input line from a terminal device. The value of this constant
is 255.

_POSIX_MAX_INPUT
The most restrictive limit permitted by POSIX for the maximum number of
bytes in a terminal device input queue (or typeahead buffer). SeeSection 17.4.4
[Input Modes], page 508. The value of this constant is 255.

_POSIX_NAME_MAX
The most restrictive limit permitted by POSIX for the maximum number of
bytes in a file name component. The value of this constant is 14.


Chapter 32: System Configuration Parameters 906

### _POSIX_PATH_MAX

```
The most restrictive limit permitted by POSIX for the maximum number of
bytes in a file name. The value of this constant is 256.
```
_POSIX_PIPE_BUF
The most restrictive limit permitted by POSIX for the maximum number of
bytes that can be written atomically to a pipe. The value of this constant is
512.

SYMLINK_MAX
Maximum number of bytes in a symbolic link.

POSIX_REC_INCR_XFER_SIZE
Recommended increment for file transfer sizes between thePOSIX_REC_MIN_
XFER_SIZEandPOSIX_REC_MAX_XFER_SIZEvalues.

POSIX_REC_MAX_XFER_SIZE
Maximum recommended file transfer size.

POSIX_REC_MIN_XFER_SIZE
Minimum recommended file transfer size.

POSIX_REC_XFER_ALIGN
Recommended file transfer buffer alignment.

32.9 Usingpathconf

When your machine allows different files to have different values for a file system parameter,
you can use the functions in this section to find out the value that applies to any particular
file.

These functions and the associated constants for theparameterargument are declared
in the header fileunistd.h.

long int pathconf(const char *filename, intparameter) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock heap|AC-Unsafe lock fd mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This function is used to inquire about the limits that apply to the file namedfilename.
Theparameterargument should be one of the ¡®_PC_¡¯ constants listed below.
The normal return value frompathconfis the value you requested. A value of-1is
returned both if the implementation does not impose a limit, and in case of an error.
In the former case,errnois not set, while in the latter case,errnois set to indicate
the cause of the problem. So the only way to use this function robustly is to store 0
intoerrnojust before calling it.
Besides the usual file name errors (seeSection 11.2.3 [File Name Errors], page 264),
the following error condition is defined for this function:

```
EINVAL The value ofparameteris invalid, or the implementation doesn¡¯t support
theparameterfor the specific file.
```

Chapter 32: System Configuration Parameters 907

long int fpathconf(intfiledes, intparameter) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock heap|AC-Unsafe lock fd mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
This is just likepathconfexcept that an open file descriptor is used to specify the
file for which information is requested, instead of a file name.
The followingerrnoerror conditions are defined for this function:
EBADF Thefiledesargument is not a valid file descriptor.
EINVAL The value ofparameteris invalid, or the implementation doesn¡¯t support
theparameterfor the specific file.

Here are the symbolic constants that you can use as theparameterargument topathconf
andfpathconf. The values are all integer constants.

_PC_LINK_MAX
Inquire about the value ofLINK_MAX.

_PC_MAX_CANON
Inquire about the value ofMAX_CANON.

_PC_MAX_INPUT
Inquire about the value ofMAX_INPUT.

_PC_NAME_MAX
Inquire about the value ofNAME_MAX.

_PC_PATH_MAX
Inquire about the value ofPATH_MAX.

_PC_PIPE_BUF
Inquire about the value ofPIPE_BUF.

_PC_CHOWN_RESTRICTED
Inquire about the value of_POSIX_CHOWN_RESTRICTED.

_PC_NO_TRUNC
Inquire about the value of_POSIX_NO_TRUNC.

_PC_VDISABLE
Inquire about the value of_POSIX_VDISABLE.

_PC_SYNC_IO
Inquire about the value of_POSIX_SYNC_IO.

_PC_ASYNC_IO
Inquire about the value of_POSIX_ASYNC_IO.

_PC_PRIO_IO
Inquire about the value of_POSIX_PRIO_IO.

_PC_FILESIZEBITS
Inquire about the availability of large files on the filesystem.

_PC_REC_INCR_XFER_SIZE
Inquire about the value ofPOSIX_REC_INCR_XFER_SIZE.


Chapter 32: System Configuration Parameters 908

### _PC_REC_MAX_XFER_SIZE

```
Inquire about the value ofPOSIX_REC_MAX_XFER_SIZE.
```
_PC_REC_MIN_XFER_SIZE
Inquire about the value ofPOSIX_REC_MIN_XFER_SIZE.

_PC_REC_XFER_ALIGN
Inquire about the value ofPOSIX_REC_XFER_ALIGN.
Portability Note:On some systems, the GNU C Library does not enforce_PC_NAME_MAX
or_PC_PATH_MAXlimits.

32.10 Utility Program Capacity Limits

The POSIX.2 standard specifies certain system limits that you can access throughsysconf
that apply to utility behavior rather than the behavior of the library or the operating
system.

The GNU C Library defines macros for these limits, andsysconfreturns values for
them if you ask; but these values convey no meaningful information. They are simply the
smallest values that POSIX.2 permits.

int BC_BASE_MAX [Macro]
The largest value ofobasethat thebcutility is guaranteed to support.

int BC_DIM_MAX [Macro]
The largest number of elements in one array that thebcutility is guaranteed to
support.

int BC_SCALE_MAX [Macro]
The largest value ofscalethat thebcutility is guaranteed to support.

int BC_STRING_MAX [Macro]
The largest number of characters in one string constant that thebcutility is guaran-
teed to support.

int COLL_WEIGHTS_MAX [Macro]
The largest number of weights that can necessarily be used in defining the collating
sequence for a locale.

int EXPR_NEST_MAX [Macro]
The maximum number of expressions that can be nested within parentheses by the
exprutility.

int LINE_MAX [Macro]
The largest text line that the text-oriented POSIX.2 utilities can support. (If you are
using the GNU versions of these utilities, then there is no actual limit except that
imposed by the available virtual memory, but there is no way that the library can tell
you this.)

int EQUIV_CLASS_MAX [Macro]
The maximum number of weights that can be assigned to an entry of theLC_COLLATE
category ¡®order¡¯ keyword in a locale definition. The GNU C Library does not
presently support locale definitions.


Chapter 32: System Configuration Parameters 909

32.11 Minimum Values for Utility Limits

_POSIX2_BC_BASE_MAX
The most restrictive limit permitted by POSIX.2 for the maximum value of
obasein thebcutility. Its value is 99.

_POSIX2_BC_DIM_MAX
The most restrictive limit permitted by POSIX.2 for the maximum size of an
array in thebcutility. Its value is 2048.

_POSIX2_BC_SCALE_MAX
The most restrictive limit permitted by POSIX.2 for the maximum value of
scalein thebcutility. Its value is 99.

_POSIX2_BC_STRING_MAX
The most restrictive limit permitted by POSIX.2 for the maximum size of a
string constant in thebcutility. Its value is 1000.

_POSIX2_COLL_WEIGHTS_MAX
The most restrictive limit permitted by POSIX.2 for the maximum number of
weights that can necessarily be used in defining the collating sequence for a
locale. Its value is 2.

_POSIX2_EXPR_NEST_MAX
The most restrictive limit permitted by POSIX.2 for the maximum number of
expressions nested within parenthesis when using theexprutility. Its value is
32.

_POSIX2_LINE_MAX
The most restrictive limit permitted by POSIX.2 for the maximum size of a
text line that the text utilities can handle. Its value is 2048.

_POSIX2_EQUIV_CLASS_MAX
The most restrictive limit permitted by POSIX.2 for the maximum number of
weights that can be assigned to an entry of theLC_COLLATEcategory ¡®order¡¯
keyword in a locale definition. Its value is 2. The GNU C Library does not
presently support locale definitions.

32.12 String-Valued Parameters

POSIX.2 defines a way to get string-valued parameters from the operating system with the
functionconfstr:

size_t confstr(intparameter, char *buf, sizetlen) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function reads the value of a string-valued system parameter, storing the string
intolenbytes of memory space starting atbuf. Theparameterargument should be
one of the ¡®_CS_¡¯ symbols listed below.
The normal return value fromconfstris the length of the string value that you asked
for. If you supply a null pointer forbuf, thenconfstrdoes not try to store the string;
it just returns its length. A value of 0 indicates an error.


Chapter 32: System Configuration Parameters 910

```
If the string you asked for is too long for the buffer (that is, longer thanlen- 1),
thenconfstrstores just that much (leaving room for the terminating null character).
You can tell that this has happened becauseconfstrreturns a value greater than or
equal tolen.
The followingerrnoerror conditions are defined for this function:
EINVAL The value of theparameteris invalid.
```
```
Currently there is just one parameter you can read withconfstr:
```
_CS_PATH This parameter¡¯s value is the recommended default path for searching for
executable files. This is the path that a user has by default just after logging
in.

_CS_LFS_CFLAGS
The returned string specifies which additional flags must be given to the C
compiler if a source is compiled using the_LARGEFILE_SOURCEfeature select
macro; seeSection 1.3.4 [Feature Test Macros], page 15.

_CS_LFS_LDFLAGS
The returned string specifies which additional flags must be given to the linker
if a source is compiled using the_LARGEFILE_SOURCEfeature select macro; see
Section 1.3.4 [Feature Test Macros], page 15.

_CS_LFS_LIBS
The returned string specifies which additional libraries must be linked to the
application if a source is compiled using the_LARGEFILE_SOURCEfeature select
macro; seeSection 1.3.4 [Feature Test Macros], page 15.

_CS_LFS_LINTFLAGS
The returned string specifies which additional flags must be given to the lint
tool if a source is compiled using the_LARGEFILE_SOURCEfeature select macro;
seeSection 1.3.4 [Feature Test Macros], page 15.

_CS_LFS64_CFLAGS
The returned string specifies which additional flags must be given to the C
compiler if a source is compiled using the_LARGEFILE64_SOURCEfeature select
macro; seeSection 1.3.4 [Feature Test Macros], page 15.

_CS_LFS64_LDFLAGS
The returned string specifies which additional flags must be given to the linker
if a source is compiled using the_LARGEFILE64_SOURCEfeature select macro;
seeSection 1.3.4 [Feature Test Macros], page 15.

_CS_LFS64_LIBS
The returned string specifies which additional libraries must be linked to the
application if a source is compiled using the_LARGEFILE64_SOURCEfeature
select macro; seeSection 1.3.4 [Feature Test Macros], page 15.

_CS_LFS64_LINTFLAGS
The returned string specifies which additional flags must be given to the lint tool
if a source is compiled using the_LARGEFILE64_SOURCEfeature select macro;
seeSection 1.3.4 [Feature Test Macros], page 15.


Chapter 32: System Configuration Parameters 911

The way to useconfstrwithout any arbitrary limit on string size is to call it twice:
first call it to get the length, allocate the buffer accordingly, and then callconfstragain
to fill the buffer, like this:
char *
get_default_path (void)
{
size_t len = confstr (_CS_PATH, NULL, 0);
char *buffer = (char *) xmalloc (len);

```
if (confstr (_CS_PATH, buf, len + 1) == 0)
{
free (buffer);
return NULL;
}
```
```
return buffer;
}
```

### 912

## 33 Cryptographic Functions..............................

The GNU C Library includes only a few special-purpose cryptographic functions: one-way
hash functions for passphrase storage, and access to a cryptographic randomness source, if
one is provided by the operating system. Programs that need general-purpose cryptography
should use a dedicated cryptography library, such aslibgcrypt.

Many countries place legal restrictions on the import, export, possession, or use of cryp-
tographic software. We deplore these restrictions, but we must still warn you that the GNU
C Library may be subject to them, even if you do not use the functions in this chapter
yourself. The restrictions vary from place to place and are changed often, so we cannot give
any more specific advice than this warning.

33.1 Passphrase Storage

Sometimes it is necessary to be sure that a user is authorized to use some service a machine
provides¡ªfor instance, to log in as a particular user id (seeChapter 30 [Users and Groups],
page 845). One traditional way of doing this is for each user to choose a secretpassphrase;
then, the system can ask someone claiming to be a user what the user¡¯s passphrase is,
and if the person gives the correct passphrase then the system can grant the appropriate
privileges. (Traditionally, these were called ¡°passwords,¡± but nowadays a single word is too
easy to guess.)

Programs that handle passphrases must take special care not to reveal them to anyone,
no matter what. It is not enough to keep them in a file that is only accessible with special
privileges. The file might be ¡°leaked¡± via a bug or misconfiguration, and system admin-
istrators shouldn¡¯t learn everyone¡¯s passphrase even if they have to edit that file for some
reason. To avoid this, passphrases should also be converted intoone-way hashes, using a
one-way function, before they are stored.

A one-way function is easy to compute, but there is no known way to compute its inverse.
This means the system can easily check passphrases, by hashing them and comparing the
result with the stored hash. But an attacker who discovers someone¡¯s passphrase hash
can only discover the passphrase it corresponds to by guessing and checking. The one-way
functions are designed to make this process impractically slow, for all but the most obvious
guesses. (Do not use a word from the dictionary as your passphrase.)

The GNU C Library provides an interface to four one-way functions, based on the SHA-
2-512, SHA-2-256, MD5, and DES cryptographic primitives. New passphrases should be
hashed with either of the SHA-based functions. The others are too weak for newly set
passphrases, but we continue to support them for verifying old passphrases. The DES-
based hash is especially weak, because it ignores all but the first eight characters of its
input.

char * crypt (const char *phrase, const char *salt) [Function]
Preliminary: |MT-Unsafe race:crypt|AS-Unsafe corrupt lock heap dlopen|AC-
Unsafe lock mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
The functioncryptconverts a passphrase string,phrase, into a one-way hash suitable
for storage in the user database. The string that it returns will consist entirely of
printable ASCII characters. It will not contain whitespace, nor any of the characters
¡®:¡¯, ¡®;¡¯, ¡®*¡¯, ¡®!¡¯, or ¡®\¡¯.


Chapter 33: Cryptographic Functions 913

```
Thesaltparameter controls which one-way function is used, and it also ensures that
the output of the one-way function is different for every user, even if they have
the same passphrase. This makes it harder to guess passphrases from a large user
database. Without salt, the attacker could make a guess, runcrypton it once, and
compare the result with all the hashes. Salt forces the attacker to make separate calls
tocryptfor each user.
To verify a passphrase, pass the previously hashed passphrase as thesalt. To hash a
new passphrase for storage, setsaltto a string consisting of a prefix plus a sequence
of randomly chosen characters, according to this table:
```
```
One-way
function
```
```
Prefix Random sequence
```
```
SHA-2-512 ¡®$6$¡¯ 16 characters
SHA-2-256 ¡®$5$¡¯ 16 characters
MD5 ¡®$1$¡¯ 8 characters
DES ¡®¡¯ 2 characters
```
```
In all cases, the random characters should be chosen from the alphabet./0-9A-Za-z.
With all of the hash functionsexceptDES,phrasecan be arbitrarily long, and all
eight bits of each byte are significant. With DES, only the first eight characters of
phraseaffect the output, and the eighth bit of each byte is also ignored.
cryptcan fail. Some implementations returnNULLon failure, and others return an
invalidhashed passphrase, which will begin with a ¡®*¡¯ and will not be the same as
salt. In either case,errnowill be set to indicate the problem. Some of the possible
error codes are:
```
```
EINVAL saltis invalid; neither a previously hashed passphrase, nor a well-formed
new salt for any of the supported hash functions.
```
```
EPERM The system configuration forbids use of the hash function selected bysalt.
```
```
ENOMEM Failed to allocate internal scratch storage.
```
```
ENOSYS
EOPNOTSUPP
Hashing passphrases is not supported at all, or the hash function selected
bysaltis not supported. The GNU C Library does not use these error
codes, but they may be encountered on other operating systems.
```
```
cryptuses static storage for both internal scratchwork and the string it returns. It is
not safe to callcryptfrom multiple threads simultaneously, and the string it returns
will be overwritten by any subsequent call tocrypt.
cryptis specified in the X/Open Portability Guide and is present on nearly all his-
torical Unix systems. However, the XPG does not specify any one-way functions.
```
```
cryptis declared inunistd.h. The GNU C Library also declares this function in
crypt.h.
```

Chapter 33: Cryptographic Functions 914

char * crypt_r(const char *phrase, const char *salt, struct [Function]
cryptdata *data)
Preliminary: |MT-Safe |AS-Unsafe corrupt lock heap dlopen|AC-Unsafe lock
mem|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
The functioncrypt_ris a thread-safe version ofcrypt. Instead of static storage,
it uses the memory pointed to by itsdataargument for both scratchwork and the
string it returns. It can safely be used from multiple threads, as long as different
dataobjects are used in each thread. The string it returns will still be overwritten
by another call with the samedata.
datamust point to astruct crypt_dataobject allocated by the caller. All of the
fields ofstruct crypt_dataare private, but before one of these objects is used for
the first time, it must be initialized to all zeroes, usingmemsetor similar. After
that, it can be reused for many calls tocrypt_rwithout erasing it again. struct
crypt_datais very large, so it is best to allocate it withmallocrather than as a
local variable. SeeSection 3.2 [Allocating Storage For Program Data], page 43.
crypt_ris a GNU extension. It is declared incrypt.h, as isstruct crypt_data.

The following program shows how to usecryptthe first time a passphrase is entered. It
usesgetentropyto make the salt as unpredictable as possible; seeSection 33.2 [Generating
Unpredictable Bytes], page 916.

```
#include <stdio.h>
#include <unistd.h>
#include <crypt.h>
```
```
int
main(void)
{
unsigned char ubytes[16];
char salt[20];
const char *const saltchars =
"./0123456789ABCDEFGHIJKLMNOPQRST"
"UVWXYZabcdefghijklmnopqrstuvwxyz";
char *hash;
int i;
```
```
/*Retrieve 16 unpredictable bytes from the operating system.*/
if (getentropy (ubytes, sizeof ubytes))
{
perror ("getentropy");
return 1;
}
```
```
/*Use them to fill in the salt string.*/
salt[0] = '$';
salt[1] = '5'; /*SHA-256*/
salt[2] = '$';
for (i = 0; i < 16; i++)
salt[3+i] = saltchars[ubytes[i] & 0x3f];
salt[3+i] = '\0';
```
```
/*Read in the user¡¯s passphrase and hash it. */
hash = crypt (getpass ("Enter new passphrase: "), salt);
```

Chapter 33: Cryptographic Functions 915

```
if (!hash || hash[0] == '*')
{
perror ("crypt");
return 1;
}
```
/*Print the results.*/
puts (hash);
return 0;
}
The next program demonstrates how to verify a passphrase. It checks a hash hardcoded
into the program, because looking up real users¡¯ hashed passphrases may require special
privileges (seeSection 30.13 [User Database], page 864). It also shows that different one-way
functions produce different hashes for the same passphrase.

```
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <crypt.h>
```
```
/*¡®GNU's Not Unix¡¯ hashed using SHA-256, MD5, and DES.*/
static const char hash_sha[] =
"$5$DQ2z5NHf1jNJnChB$kV3ZTR0aUaosujPhLzR84Llo3BsspNSe4/tsp7VoEn6";
static const char hash_md5[] = "$1$A3TxDv41$rtXVTUXl2LkeSV0UU5xxs1";
static const char hash_des[] = "FgkTuF98w5DaI";
```
```
int
main(void)
{
char *phrase;
int status = 0;
```
```
/*Prompt for a passphrase. */
phrase = getpass ("Enter passphrase: ");
```
```
/*Compare against the stored hashes. Any input that begins with
¡®GNU's No¡¯ will match the DES hash, but the other two will
only match ¡®GNU's Not Unix¡¯.*/
```
```
if (strcmp (crypt (phrase, hash_sha), hash_sha))
{
puts ("SHA: not ok");
status = 1;
}
else
puts ("SHA: ok");
```
```
if (strcmp (crypt (phrase, hash_md5), hash_md5))
{
puts ("MD5: not ok");
status = 1;
}
else
puts ("MD5: ok");
```
```
if (strcmp (crypt (phrase, hash_des), hash_des))
{
```

Chapter 33: Cryptographic Functions 916

```
puts ("DES: not ok");
status = 1;
}
else
puts ("DES: ok");
```
```
return status;
}
```
33.2 Generating Unpredictable Bytes

Cryptographic applications often need some random data that will be as difficult as pos-
sible for a hostile eavesdropper to guess. For instance, encryption keys should be chosen
at random, and the ¡°salt¡± strings used bycrypt(seeSection 33.1 [Passphrase Storage],
page 912) should also be chosen at random.

Some pseudo-random number generators do not provide unpredictable-enough output for
cryptographic applications; seeSection 19.8 [Pseudo-Random Numbers], page 591. Such
applications need to use acryptographic random number generator(CRNG), also some-
times called acryptographically strong pseudo-random number generator (CSPRNG) or
deterministic random bit generator(DRBG).

Currently, the GNU C Library does not provide a cryptographic random number gen-
erator, but it does provide functions that read random data from arandomness source
supplied by the operating system. The randomness source is a CRNG at heart, but it also
continually ¡°re-seeds¡± itself from physical sources of randomness, such as electronic noise
and clock jitter. This means applications do not need to do anything to ensure that the
random numbers it produces are different on each run.

The catch, however, is that these functions will only produce relatively short random
strings in any one call. Often this is not a problem, but applications that need more than a
few kilobytes of cryptographically strong random data should call these functions once and
use their output to seed a CRNG.

Most applications should usegetentropy. Thegetrandomfunction is intended for low-
level applications which need additional control over blocking behavior.

int getentropy(void *buffer, sizetlength) [Function]
|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function writes exactlylengthbytes of random data to the array starting at
buffer. lengthcan be no more than 256. On success, it returns zero. On failure, it
returns?1, anderrnois set to indicate the problem. Some of the possible errors are
listed below.
ENOSYS The operating system does not implement a randomness source, or does
not support this way of accessing it. (For instance, the system call used
by this function was added to the Linux kernel in version 3.17.)
EFAULT The combination ofbufferandlengtharguments specifies an invalid mem-
ory range.
EIO lengthis larger than 256, or the kernel entropy pool has suffered a catas-
trophic failure.


Chapter 33: Cryptographic Functions 917

```
A call togetentropycan only block when the system has just booted and the ran-
domness source has not yet been initialized. However, if it does block, it cannot be
interrupted by signals or thread cancellation. Programs intended to run in very early
stages of the boot process may need to usegetrandomin non-blocking mode instead,
and be prepared to cope with random data not being available at all.
Thegetentropyfunction is declared in the header filesys/random.h. It is derived
from OpenBSD.
```
ssize_t getrandom(void *buffer, sizetlength, unsigned int [Function]
flags)
|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
This function writes up tolengthbytes of random data to the array starting atbuffer.
Theflagsargument should be either zero, or the bitwise OR of some of the following
flags:
GRND_RANDOM
Use the /dev/random (blocking) source instead of the/dev/urandom
(non-blocking) source to obtain randomness.
If this flag is specified, the call may block, potentially for quite some
time, even after the randomness source has been initialized. If it is not
specified, the call can only block when the system has just booted and
the randomness source has not yet been initialized.
GRND_NONBLOCK
Instead of blocking, return to the caller immediately if no data is available.
GRND_INSECURE
Write random data that may not be cryptographically secure.
Unlikegetentropy, thegetrandomfunction is a cancellation point, and if it blocks,
it can be interrupted by signals.
On success,getrandomreturns the number of bytes which have been written to the
buffer, which may be less thanlength. On error, it returns?1, anderrnois set to
indicate the problem. Some of the possible errors are:
ENOSYS The operating system does not implement a randomness source, or does
not support this way of accessing it. (For instance, the system call used
by this function was added to the Linux kernel in version 3.17.)
EAGAIN No random data was available andGRND_NONBLOCKwas specified inflags.
EFAULT The combination ofbufferandlengtharguments specifies an invalid mem-
ory range.
EINTR The system call was interrupted. During the system boot process, before
the kernel randomness pool is initialized, this can happen even ifflagsis
zero.
EINVAL Theflagsargument contains an invalid combination of flags.
Thegetrandomfunction is declared in the header filesys/random.h. It is a GNU
extension.


### 918

## 34 Debugging support

Applications are usually debugged using dedicated debugger programs. But sometimes
this is not possible and, in any case, it is useful to provide the developer with as much
information as possible at the time the problems are experienced. For this reason a few
functions are provided which a program can use to help the developer more easily locate
the problem.

34.1 Backtraces

Abacktraceis a list of the function calls that are currently active in a thread. The usual way
to inspect a backtrace of a program is to use an external debugger such as gdb. However,
sometimes it is useful to obtain a backtrace programmatically from within a program, e.g.,
for the purposes of logging or diagnostics.

The header fileexecinfo.hdeclares three functions that obtain and manipulate back-
traces of the current thread.

int backtrace(void **buffer, intsize) [Function]
Preliminary:|MT-Safe |AS-Unsafe init heap dlopen plugin lock|AC-Unsafe init
mem lock fd|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Thebacktracefunction obtains a backtrace for the current thread, as a list of point-
ers, and places the information intobuffer. The argumentsizeshould be the number
ofvoid *elements that will fit intobuffer. The return value is the actual number of
entries ofbufferthat are obtained, and is at mostsize.
The pointers placed inbufferare actually return addresses obtained by inspecting
the stack, one return address per stack frame.
Note that certain compiler optimizations may interfere with obtaining a valid back-
trace. Function inlining causes the inlined function to not have a stack frame; tail
call optimization replaces one stack frame with another; frame pointer elimination
will stopbacktracefrom interpreting the stack contents correctly.

char ** backtrace_symbols(void *const *buffer, intsize) [Function]
Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem lock | See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
The backtrace_symbols function translates the information obtained from the
backtracefunction into an array of strings. The argument buffer should be a
pointer to an array of addresses obtained via thebacktracefunction, andsizeis the
number of entries in that array (the return value ofbacktrace).
The return value is a pointer to an array of strings, which hassizeentries just like
the arraybuffer. Each string contains a printable representation of the corresponding
element ofbuffer. It includes the function name (if this can be determined), an offset
into the function, and the actual return address (in hexadecimal).
Currently, the function name and offset can only be obtained on systems that use the
ELF binary format for programs and libraries. On other systems, only the hexadec-
imal return address will be present. Also, you may need to pass additional flags to
the linker to make the function names available to the program. (For example, on
systems using GNU ld, you must pass-rdynamic.)


Chapter 34: Debugging support 919

```
The return value ofbacktrace_symbolsis a pointer obtained via themallocfunction,
and it is the responsibility of the caller tofreethat pointer. Note that only the return
value need be freed, not the individual strings.
The return value isNULLif sufficient memory for the strings cannot be obtained.
```
void backtrace_symbols_fd(void *const *buffer, intsize, intfd) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX
Safety Concepts], page 2.
Thebacktrace_symbols_fdfunction performs the same translation as the function
backtrace_symbolsfunction. Instead of returning the strings to the caller, it writes
the strings to the file descriptorfd, one per line. It does not use themallocfunction,
and can therefore be used in situations where that function might fail.

The following program illustrates the use of these functions. Note that the array to
contain the return addresses returned bybacktraceis allocated on the stack. Therefore
code like this can be used in situations where the memory handling viamallocdoes not
work anymore (in which case thebacktrace_symbolshas to be replaced by abacktrace_
symbols_fdcall as well). The number of return addresses is normally not very large. Even
complicated programs rather seldom have a nesting level of more than, say, 50 and with
200 possible entries probably all programs should be covered.

```
#include <execinfo.h>
#include <stdio.h>
#include <stdlib.h>
```
```
/*Obtain a backtrace and print it tostdout.*/
void
print_trace (void)
{
void *array[10];
char **strings;
int size, i;
```
```
size = backtrace (array, 10);
strings = backtrace_symbols (array, size);
if (strings != NULL)
{
```
```
printf ("Obtained %d stack frames.\n", size);
for (i = 0; i < size; i++)
printf ("%s\n", strings[i]);
}
```
```
free (strings);
}
```
```
/*A dummy function to make the backtrace more interesting.*/
void
dummy_function (void)
{
print_trace ();
}
```
```
int
```

Chapter 34: Debugging support 920

```
main (void)
{
dummy_function ();
return 0;
}
```

### 921

## 35 Threads...........................................

This chapter describes functions used for managing threads. The GNU C Library provides
two threading implementations: ISO C threads and POSIX threads.

35.1 ISO C Threads

This section describes the GNU C Library ISO C threads implementation. To have a deeper
understanding of this API, it is strongly recommended to read ISO/IEC 9899:2011, section
7.26, in which ISO C threads were originally specified. All types and function prototypes
are declared in the header filethreads.h.

35.1.1 Return Values

The ISO C thread specification provides the following enumeration constants for return
values from functions in the API:

thrd_timedout
A specified time was reached without acquiring the requested resource, usually
a mutex or condition variable.

thrd_success
The requested operation succeeded.

thrd_busy
The requested operation failed because a requested resource is already in use.

thrd_error
The requested operation failed.

thrd_nomem
The requested operation failed because it was unable to allocate enough mem-
ory.

35.1.2 Creation and Control

The GNU C Library implements a set of functions that allow the user to easily create and
use threads. Additional functionality is provided to control the behavior of threads.

```
The following data types are defined for managing threads:
```
thrd_t [Data Type]
A unique object that identifies a thread.

thrd_start_t [Data Type]
This data type is anint (*) (void *)typedef that is passed tothrd_createwhen
creating a new thread. It should point to the first function that thread will run.

```
The following functions are used for working with threads:
```
int thrd_create (thrdt *thr, thrdstarttfunc, void *arg) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.


Chapter 35: Threads 922

```
thrd_createcreates a new thread that will execute the functionfunc. The object
pointed to byargwill be used as the argument tofunc. If successful,thris set to the
new thread identifier.
This function may returnthrd_success,thrd_nomem, orthrd_error.
```
thrd_t thrd_current (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This function returns the identifier of the calling thread.

int thrd_equal(thrdtlhs, thrdtrhs) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
thrd_equalchecks whetherlhsandrhsrefer to the same thread. Iflhsandrhsare
different threads, this function returns 0; otherwise, the return value is non-zero.

int thrd_sleep(const struct timespec *time_point, struct [Function]
timespec *remaining)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
thrd_sleepblocks the execution of the current thread for at least until the elapsed
time pointed to bytimepointhas been reached. This function does not take an ab-
solute time, but a duration that the thread is required to be blocked. SeeSection 21.1
[Time Basics], page 646, andSection 21.2 [Time Types], page 647.
The thread may wake early if a signal that is not ignored is received. In such a case, if
remainingis not NULL, the remaining time duration is stored in the object pointed
to byremaining.
thrd_sleepreturns 0 if it blocked for at least the amount of time intime_point,? 1
if it was interrupted by a signal, or a negative number on failure.

void thrd_yield (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
thrd_yieldprovides a hint to the implementation to reschedule the execution of the
current thread, allowing other threads to run.

_Noreturn void thrd_exit(intres) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
thrd_exitterminates execution of the calling thread and sets its result code tores.
If this function is called from a single-threaded process, the call is equivalent to calling
exitwithEXIT_SUCCESS(seeSection 25.7.1 [Normal Termination], page 799). Also
note that returning from a function that started a thread is equivalent to calling
thrd_exit.


Chapter 35: Threads 923

int thrd_detach (thrdtthr) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
thrd_detachdetaches the thread identified bythrfrom the current control thread.
The resources held by the detached thread will be freed automatically once the thread
exits. The parent thread will never be notified by anythrsignal.
Callingthrd_detachon a thread that was previously detached or joined by another
thread results in undefined behavior.
This function returns eitherthrd_successorthrd_error.

int thrd_join(thrdtthr, int *res) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
thrd_joinblocks the current thread until the thread identified bythrfinishes ex-
ecution. Ifresis not NULL, the result code of the thread is put into the location
pointed to byres. The termination of the threadsynchronizes-withthe completion
of this function, meaning both threads have arrived at a common point in their exe-
cution.
Callingthrd_joinon a thread that was previously detached or joined by another
thread results in undefined behavior.
This function returns eitherthrd_successorthrd_error.

35.1.3 Call Once

In order to guarantee single access to a function, the GNU C Library implements acall
once functionto ensure a function is only called once in the presence of multiple, potentially
calling threads.

once_flag [Data Type]
A complete object type capable of holding a flag used bycall_once.

ONCE_FLAG_INIT [Macro]
This value is used to initialize an object of typeonce_flag.

void call_once(onceflag *flag, void(*func)(void)) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
call_oncecalls functionfuncexactly once, even if invoked from several threads. The
completion of the functionfuncsynchronizes-with all previous or subsequent calls to
call_oncewith the sameflagvariable.

35.1.4 Mutexes

To have better control of resources and how threads access them, the GNU C Library
implements amutexobject, which can help avoid race conditions and other concurrency
issues. The term ¡°mutex¡± refers to mutual exclusion.

```
The fundamental data type for a mutex is themtx_t:
```

Chapter 35: Threads 924

mtx_t [Data Type]
Themtx_tdata type uniquely identifies a mutex object.

The ISO C standard defines several types of mutexes. They are represented by the
following symbolic constants:

mtx_plain
A mutex that does not support timeout, or test and return.

mtx_recursive
A mutex that supports recursive locking, which means that the owning thread
can lock it more than once without causing deadlock.

mtx_timed
A mutex that supports timeout.

```
The following functions are used for working with mutexes:
```
int mtx_init (mtxt *mutex, inttype) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
mtx_initcreates a new mutex object with typetype. The object pointed to bymutex
is set to the identifier of the newly created mutex.
Not all combinations of mutex types are valid for thetypeargument. Valid uses of
mutex types for thetypeargument are:

```
mtx_plain
A non-recursive mutex that does not support timeout.
```
```
mtx_timed
A non-recursive mutex that does support timeout.
```
```
mtx_plain | mtx_recursive
A recursive mutex that does not support timeout.
```
```
mtx_timed | mtx_recursive
A recursive mutex that does support timeout.
```
```
This function returns eitherthrd_successorthrd_error.
```
int mtx_lock (mtxt *mutex) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
mtx_lockblocks the current thread until the mutex pointed to bymutexis locked.
The behavior is undefined if the current thread has already locked the mutex and the
mutex is not recursive.
Prior calls tomtx_unlockon the same mutex synchronize-with this operation (if this
operation succeeds), and all lock/unlock operations on any given mutex form a single
total order (similar to the modification order of an atomic).
This function returns eitherthrd_successorthrd_error.


Chapter 35: Threads 925

int mtx_timedlock(mtxt *restrictmutex, const struct timespec [Function]
*restricttime_point)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
mtx_timedlockblocks the current thread until the mutex pointed to bymutex is
locked or until the calendar time pointed to bytimepointhas been reached. Since
this function takes an absolute time, if a duration is required, the calendar time must
be calculated manually. SeeSection 21.1 [Time Basics], page 646, andSection 21.5
[Calendar Time], page 651.
If the current thread has already locked the mutex and the mutex is not recursive, or
if the mutex does not support timeout, the behavior of this function is undefined.
Prior calls tomtx_unlockon the same mutex synchronize-with this operation (if this
operation succeeds), and all lock/unlock operations on any given mutex form a single
total order (similar to the modification order of an atomic).
This function returns eitherthrd_successorthrd_error.

int mtx_trylock (mtxt *mutex) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
mtx_trylocktries to lock the mutex pointed to bymutexwithout blocking. It returns
immediately if the mutex is already locked.
Prior calls tomtx_unlockon the same mutex synchronize-with this operation (if this
operation succeeds), and all lock/unlock operations on any given mutex form a single
total order (similar to the modification order of an atomic).
This function returnsthrd_successif the lock was obtained,thrd_busyif the mutex
is already locked, andthrd_erroron failure.

int mtx_unlock(mtxt *mutex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
mtx_unlockunlocks the mutex pointed to bymutex. The behavior is undefined if
the mutex is not locked by the calling thread.
This function synchronizes-with subsequent mtx_lock, mtx_trylock, and
mtx_timedlockcalls on the same mutex. All lock/unlock operations on any given
mutex form a single total order (similar to the modification order of an atomic).
This function returns eitherthrd_successorthrd_error.

void mtx_destroy (mtxt *mutex) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
mtx_destroydestroys the mutex pointed to by mutex. If there are any threads
waiting on the mutex, the behavior is undefined.


Chapter 35: Threads 926

35.1.5 Condition Variables

Mutexes are not the only synchronization mechanisms available. For some more complex
tasks, the GNU C Library also implementscondition variables, which allow the programmer
to think at a higher level when solving complex synchronization problems. They are used
to synchronize threads waiting on a certain condition to happen.

```
The fundamental data type for condition variables is thecnd_t:
```
cnd_t [Data Type]
Thecnd_tuniquely identifies a condition variable object.

```
The following functions are used for working with condition variables:
```
int cnd_init (cndt *cond) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
cnd_initinitializes a new condition variable, identified bycond.
This function may returnthrd_success,thrd_nomem, orthrd_error.

int cnd_signal(cndt *cond) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
cnd_signalunblocks one thread that is currently waiting on the condition variable
pointed to bycond. If a thread is successfully unblocked, this function returnsthrd_
success. If no threads are blocked, this function does nothing and returnsthrd_
success. Otherwise, this function returnsthrd_error.

int cnd_broadcast(cndt *cond) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
cnd_broadcastunblocks all the threads that are currently waiting on the condition
variable pointed to bycond. This function returnsthrd_successon success. If no
threads are blocked, this function does nothing and returnsthrd_success. Other-
wise, this function returnsthrd_error.

int cnd_wait (cndt *cond, mtxt *mutex) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
cnd_waitatomically unlocks the mutex pointed to bymutexand blocks on the con-
dition variable pointed to bycond until the thread is signaled bycnd_signalor
cnd_broadcast. The mutex is locked again before the function returns.
This function returns eitherthrd_successorthrd_error.

int cnd_timedwait(cndt *restrictcond, mtxt *restrictmutex, [Function]
const struct timespec *restricttime_point)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
cnd_timedwaitatomically unlocks the mutex pointed to bymutexand blocks on the
condition variable pointed to byconduntil the thread is signaled bycnd_signalor


Chapter 35: Threads 927

```
cnd_broadcast, or until the calendar time pointed to bytimepointhas been reached.
The mutex is locked again before the function returns.
As formtx_timedlock, since this function takes an absolute time, if a duration is
required, the calendar time must be calculated manually. SeeSection 21.1 [Time
Basics], page 646, andSection 21.5 [Calendar Time], page 651.
This function may returnthrd_success,thrd_nomem, orthrd_error.
```
void cnd_destroy (cndt *cond) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
cnd_destroydestroys the condition variable pointed to bycond. If there are threads
waiting oncond, the behavior is undefined.

35.1.6 Thread-local Storage

The GNU C Library implements functions to providethread-local storage, a mechanism by
which variables can be defined to have unique per-thread storage, lifetimes that match the
thread lifetime, and destructors that cleanup the unique per-thread storage.

```
Several data types and macros exist for working with thread-local storage:
```
tss_t [Data Type]
Thetss_tdata type identifies a thread-specific storage object. Even if shared, every
thread will have its own instance of the variable, with different values.

tss_dtor_t [Data Type]
Thetss_dtor_t is a function pointer of typevoid (*) (void *), to be used as
a thread-specific storage destructor. The function will be called when the current
thread callsthrd_exit(but never when callingtss_deleteorexit).

thread_local [Macro]
thread_localis used to mark a variable with thread storage duration, which means
it is created when the thread starts and cleaned up when the thread ends.
Note:For C++, C++11 or later is required to use thethread_localkeyword.

TSS_DTOR_ITERATIONS [Macro]
TSS_DTOR_ITERATIONSis an integer constant expression representing the maximum
number of iterations over all thread-local destructors at the time of thread termina-
tion. This value provides a bounded limit to the destruction of thread-local storage;
e.g., consider a destructor that creates more thread-local storage.

```
The following functions are used to manage thread-local storage:
```
int tss_create(tsst *tss_key, tss dtortdestructor) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
tss_createcreates a new thread-specific storage key and stores it in the object
pointed to bytsskey. Although the same key value may be used by different threads,
the values bound to the key bytss_setare maintained on a per-thread basis and
persist for the life of the calling thread.


Chapter 35: Threads 928

```
Ifdestructoris not NULL, a destructor function will be set, and called when the
thread finishes its execution by callingthrd_exit.
This function returnsthrd_successiftss_keyis successfully set to a unique value for
the thread; otherwise,thrd_erroris returned and the value oftss_keyis undefined.
```
int tss_set(tssttss_key, void *val) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
tss_setsets the value of the thread-specific storage identified bytsskey for the
current thread toval. Different threads may set different values to the same key.
This function returns eitherthrd_successorthrd_error.

void * tss_get(tssttss_key) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
tss_getreturns the value identified bytsskeyheld in thread-specific storage for the
current thread. Different threads may get different values identified by the same key.
On failure,tss_getreturns zero.

void tss_delete (tssttss_key) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
tss_deletedestroys the thread-specific storage identified bytsskey.

35.2 POSIX Threads

This section describes the GNU C Library POSIX Threads implementation.

35.2.1 Thread-specific Data

The GNU C Library implements functions to allow users to create and manage data specific
to a thread. Such data may be destroyed at thread exit, if a destructor is provided. The
following functions are defined:

int pthread_key_create (pthreadkeyt *key, void [Function]
(*destructor)(void*))
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Create a thread-specific data key for the calling thread, referenced bykey.
Objects declared with the C++ 11 thread_localkeyword are destroyed before thread-
specific data, so they should not be used in thread-specific data destructors or even
as members of the thread-specific data, since the latter is passed as an argument to
the destructor function.

int pthread_key_delete (pthreadkeytkey) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Destroy the thread-specific datakeyin the calling thread. The destructor for the
thread-specific data is not called during destruction, nor is it called during thread
exit.


Chapter 35: Threads 929

void *pthread_getspecific(pthreadkeytkey) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Return the thread-specific data associated withkeyin the calling thread.

int pthread_setspecific (pthreadkeytkey, const void *value) [Function]
Preliminary:|MT-Safe |AS-Unsafe corrupt heap|AC-Unsafe corrupt mem|See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Associate the thread-specificvaluewithkeyin the calling thread.

35.2.2 Non-POSIX Extensions

In addition to implementing the POSIX API for threads, the GNU C Library provides
additional functions and interfaces to provide functionality not specified in the standard.

35.2.2.1 Setting Process-wide defaults for thread attributes

The GNU C Library provides non-standard API functions to set and get the default at-
tributes used in the creation of threads in a process.

int pthread_getattr_default_np (pthreadattrt *attr) [Function]
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Get the default attribute values and setattrto match. This function returns 0 on
success and a non-zero error code on failure.

int pthread_setattr_default_np (pthreadattrt *attr) [Function]
Preliminary: | MT-Safe |AS-Unsafe heap lock | AC-Unsafe lock mem |See
Section 1.2.2.1 [POSIX Safety Concepts], page 2.
Set the default attribute values to match the values inattr. The function returns 0
on success and a non-zero error code on failure. The following error codes are defined
for this function:
EINVAL At least one of the values inattrdoes not qualify as valid for the attributes
or the stack address is set in the attribute.
ENOMEM The system does not have sufficient memory.

35.2.2.2 Controlling the Initial Signal Mask of a New Thread

The GNU C Library provides a way to specify the initial signal mask of a thread created
usingpthread_create, passing a thread attribute object configured for this purpose.

int pthread_attr_setsigmask_np (pthreadattrt *attr, const [Function]
sigsett *sigmask)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Change the initial signal mask specified byattr. Ifsigmaskis notNULL, the initial
signal mask for new threads created withattris set to*sigmask. IfsigmaskisNULL,
attrwill no longer specify an explicit signal mask, so that the initial signal mask of
the new thread is inherited from the thread that callspthread_create.
This function returns zero on success, andENOMEMon memory allocation failure.


Chapter 35: Threads 930

int pthread_attr_getsigmask_np (const pthreadattrt *attr, [Function]
sigsett *sigmask)
Preliminary:|MT-Safe |AS-Unsafe heap|AC-Unsafe mem|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Retrieve the signal mask stored inattrand copy it to*sigmask. If the signal mask has
not been set, return the special constantPTHREAD_ATTR_NO_SIGMASK_NP, otherwise
return zero.
Obtaining the signal mask only works if it has been previously stored bypthread_
attr_setsigmask_np. For example, thepthread_getattr_npfunction does not ob-
tain the current signal mask of the specified thread, andpthread_attr_getsigmask_
npwill subsequently report the signal mask as unset.

int PTHREAD_ATTR_NO_SIGMASK_NP [Macro]
The special value returned bypthread_attr_setsigmask_npto indicate that no
signal mask has been set for the attribute.

It is possible to create a new thread with a specific signal mask without using these
functions. On the thread that callspthread_create, the required steps for the general case
are:

1. Mask all signals, and save the old signal mask, usingpthread_sigmask. This ensures
    that the new thread will be created with all signals masked, so that no signals can be
    delivered to the thread until the desired signal mask is set.
2. Callpthread_createto create the new thread, passing the desired signal mask to the
    thread start routine (which could be a wrapper function for the actual thread start
    routine). It may be necessary to make a copy of the desired signal mask on the heap,
    so that the life-time of the copy extends to the point when the start routine needs to
    access the signal mask.
3. Restore the thread¡¯s signal mask, to the set that was saved in the first step.
    The start routine for the created thread needs to locate the desired signal mask and
usepthread_sigmaskto apply it to the thread. If the signal mask was copied to a heap
allocation, the copy should be freed.

35.2.2.3 Functions for Waiting According to a Specific Clock

The GNU C Library provides several waiting functions that expect an explicitclockid_t
argument.

int sem_clockwait(sem t *sem, clockidtclockid, [Function]
const struct timespec *abstime) Behaves likesem_timedwaitexcept the timeabstime
is measured against the clock specified byclockidrather thanCLOCK_REALTIME. Cur-
rently,clockidmust be eitherCLOCK_MONOTONICorCLOCK_REALTIME.

int pthread_cond_clockwait (pthreadcondt *cond, [Function]
pthreadmutext *mutex,
clockidtclockid, const struct timespec *abstime) Preliminary: |MT-Safe |AS-
Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Behaves likepthread_cond_timedwaitexcept the timeabstimeis measured against
the clock specified by clockid rather than the clock specified or defaulted when


Chapter 35: Threads 931

```
pthread_cond_initwas called. Currently,clockidmust be eitherCLOCK_MONOTONIC
orCLOCK_REALTIME.
```
int pthread_rwlock_clockrdlock (pthreadrwlockt *rwlock, [Function]
clockidtclockid, const struct timespec *abstime)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Behaves likepthread_rwlock_timedrdlockexcept the timeabstime is measured
against the clock specified byclockidrather thanCLOCK_REALTIME. Currently,clockid
must be eitherCLOCK_MONOTONICorCLOCK_REALTIME, otherwiseEINVALis returned.

int pthread_rwlock_clockwrlock (pthreadrwlockt *rwlock, [Function]
clockidtclockid, const struct timespec *abstime)
Preliminary: |MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Behaves likepthread_rwlock_timedwrlockexcept the timeabstime is measured
against the clock specified byclockidrather thanCLOCK_REALTIME. Currently,clockid
must be eitherCLOCK_MONOTONICorCLOCK_REALTIME, otherwiseEINVALis returned.

int pthread_tryjoin_np (pthreadt *thread, [Function]
void **threadreturn) Preliminary:|MT-Safe |AS-Unsafe lock|AC-Unsafe lock
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Behaves likepthread_joinexcept that it will returnEBUSYimmediately if the thread
specified bythreadhas not yet terminated.

int pthread_timedjoin_np(pthreadt *thread, [Function]
void **threadreturn, const struct timespec *abstime) Preliminary: |MT-Safe |
AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX Safety Concepts],
page 2.
Behaves likepthread_tryjoin_npexcept that it will block until the absolute time
abstimemeasured againstCLOCK_REALTIMEis reached if the thread has not terminated
by that time and returnEBUSY. Ifabstime is equal toNULLthen the function will
wait forever in the same way aspthread_join.

int pthread_clockjoin_np(pthreadt *thread, [Function]
void **threadreturn, clockidtclockid, const struct timespec *abstime) Preliminary:
|MT-Safe |AS-Unsafe lock|AC-Unsafe lock|SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Behaves likepthread_timedjoin_npexcept that the absolute time in abstime is
measured against the clock specified byclockid. Currently,clockidmust be either
CLOCK_MONOTONICorCLOCK_REALTIME.

35.2.2.4 Detecting Single-Threaded Execution

Multi-threaded programs require synchronization among threads. This synchronization
can be costly even if there is just a single thread and no data is shared between multiple
processors. The GNU C Library offers an interface to detect whether the process is in single-
threaded mode. Applications can use this information to avoid synchronization, for example


Chapter 35: Threads 932

by using regular instructions to load and store memory instead of atomic instructions, or
using relaxed memory ordering instead of stronger memory ordering.

char __libc_single_threaded [Variable]
This variable is non-zero if the current process is definitely single-threaded. If it is
zero, the process may be multi-threaded, or the GNU C Library cannot determine at
this point of the program execution whether the process is single-threaded or not.
Applications must never write to this variable.

Most applications should perform the same actions whether or not__libc_single_
threadedis true, except with less synchronization. If this rule is followed, a process that
subsequently becomes multi-threaded is already in a consistent state. For example, in order
to increment a reference count, the following code can be used:
if (__libc_single_threaded)
atomic_fetch_add (&reference_count, 1, memory_order_relaxed);
else
atomic_fetch_add (&reference_count, 1, memory_order_acq_rel);
This still requires some form of synchronization on the single-threaded branch, so it can
be beneficial not to declare the reference count as_Atomic, and use the GCC__atomic
built-ins. SeeSection ¡°Built-in Functions for Memory Model Aware Atomic Operations¡± in
Using the GNU Compiler Collection (GCC). Then the code to increment a reference count
looks like this:
if (__libc_single_threaded)
++reference_count;
else
__atomic_fetch_add (&reference_count, 1, __ATOMIC_ACQ_REL);
(Depending on the data associated with the reference count, it may be possible to use
the weaker__ATOMIC_RELAXEDmemory ordering on the multi-threaded branch.)

Several functions in the GNU C Library can change the value of the__libc_single_
threadedvariable. For example, creating new threads using thepthread_createorthrd_
createfunction sets the variable to false. This can also happen indirectly, say via a call
todlopen. Therefore, applications need to make a copy of the value of__libc_single_
threadedif after such a function call, behavior must match the value as it was before the
call, like this:
bool single_threaded = __libc_single_threaded;
if (single_threaded)
prepare_single_threaded ();
else
prepare_multi_thread ();

```
void *handle = dlopen (shared_library_name, RTLD_NOW);
lookup_symbols (handle);
```
if (single_threaded)
cleanup_single_threaded ();
else
cleanup_multi_thread ();
Since the value of__libc_single_threadedcan change from true to false during the
execution of the program, it is not useful for selecting optimized function implementations
in IFUNC resolvers.


Chapter 35: Threads 933

Atomic operations can also be used on mappings shared among single-threaded processes.
This means that a compiler must not use__libc_single_threadedto optimize atomic
operations, unless it is able to prove that the memory is not shared.

Implementation Note: The __libc_single_threaded variable is not declared as
volatilebecause it is expected that compilers optimize a sequence of single-threaded
checks into one check, for example if several reference counts are updated. The current
implementation in the GNU C Library does not set the__libc_single_threadedvariable
to a true value if a process turns single-threaded again. Future versions of the GNU
C Library may do this, but only as the result of function calls which imply an acquire
(compiler) barrier. (Some compilers assume that well-known functions such as malloc
do not write to global variables, and setting__libc_single_threadedwould introduce
a data race and undefined behavior.) In any case, an application must not write to
__libc_single_threadedeven if it has joined the last application-created thread because
future versions of the GNU C Library may create background threads after the first thread
has been created, and the application has no way of knowning that these threads are
present.


### 934

## 36 Internal probes......................................

In order to aid in debugging and monitoring internal behavior, the GNU C Library exposes
nearly-zero-overhead SystemTap probes marked with thelibcprovider.

These probes are not part of the GNU C Library stable ABI, and they are subject to
change or removal across releases. Our only promise with regard to them is that, if we
find a need to remove or modify the arguments of a probe, the modified probe will have a
different name, so that program monitors relying on the old probe will not get unexpected
arguments.

36.1 Memory Allocation Probes

These probes are designed to signal relatively unusual situations within the virtual memory
subsystem of the GNU C Library.

memory_sbrk_more (void *$arg1, sizet $arg2) [Probe]
This probe is triggered after the main arena is extended by callingsbrk. Argument
$arg1is the additional size requested tosbrk, and$arg2is the pointer that marks
the end of thesbrkarea, returned in response to the request.

memory_sbrk_less (void *$arg1, sizet $arg2) [Probe]
This probe is triggered after the size of the main arena is decreased by callingsbrk.
Argument$arg1 is the size released bysbrk(the positive value, rather than the
negative value passed tosbrk), and$arg2is the pointer that marks the end of the
sbrkarea, returned in response to the request.

memory_heap_new (void *$arg1, sizet $arg2) [Probe]
This probe is triggered after a new heap ismmaped. Argument$arg1is a pointer to
the base of the memory area, where theheap_infodata structure is held, and$arg2
is the size of the heap.

memory_heap_free (void *$arg1, sizet $arg2) [Probe]
This probe is triggeredbefore (unlike the other sbrk and heap probes) a heap is
completely removed viamunmap. Argument$arg1is a pointer to the heap, and$arg2
is the size of the heap.

memory_heap_more (void *$arg1, sizet $arg2) [Probe]
This probe is triggered after a trailing portion of anmmaped heap is extended. Argu-
ment$arg1is a pointer to the heap, and$arg2is the new size of the heap.

memory_heap_less (void *$arg1, sizet $arg2) [Probe]
This probe is triggered after a trailing portion of anmmaped heap is released. Argu-
ment$arg1is a pointer to the heap, and$arg2is the new size of the heap.

memory_malloc_retry (sizet $arg1) [Probe]
memory_realloc_retry(sizet $arg1, void *$arg2) [Probe]
memory_memalign_retry(sizet $arg1, sizet $arg2) [Probe]
memory_calloc_retry (sizet $arg1) [Probe]
These probes are triggered when the corresponding functions fail to obtain the re-
quested amount of memory from the arena in use, before they callarena_get_retry


Chapter 36: Internal probes 935

```
to select an alternate arena in which to retry the allocation. Argument$arg1is the
amount of memory requested by the user; in thecalloccase, that is the total size
computed from both function arguments. In therealloccase,$arg2is the pointer
to the memory area being resized. In thememaligncase,$arg2is the alignment to
be used for the request, which may be stricter than the value passed to thememalign
function. Amemalignprobe is also used by functionsposix_memalign, vallocand
pvalloc.
Note that the argument order doesnotmatch that of the corresponding two-argument
functions, so that in all of these probes the user-requested allocation size is in$arg1.
```
memory_arena_retry(sizet $arg1, void *$arg2) [Probe]
This probe is triggered withinarena_get_retry(the function called to select the
alternate arena in which to retry an allocation that failed on the first attempt), before
the selection of an alternate arena. This probe is redundant, but much easier to use
when it¡¯s not important to determine which of the various memory allocation functions
is failing to allocate on the first try. Argument$arg1is the same as in the function-
specific probes, except for extra room for padding introduced by functions that have
to ensure stricter alignment. Argument$arg2is the arena in which allocation failed.

memory_arena_new (void *$arg1, sizet $arg2) [Probe]
This probe is triggered whenmallocallocates and initializes an additional arena (not
the main arena), but before the arena is assigned to the running thread or inserted into
the internal linked list of arenas. The arena¡¯smalloc_stateinternal data structure
is located at$arg1, within a newly-allocated heap big enough to hold at least$arg2
bytes.

memory_arena_reuse(void *$arg1, void *$arg2) [Probe]
This probe is triggered whenmalloc has just selected an existing arena to reuse,
and (temporarily) reserved it for exclusive use. Argument$arg1is a pointer to the
newly-selected arena, and$arg2 is a pointer to the arena previously used by that
thread.
This occurs withinreused_arena, right after the mutex mentioned in probememory_
arena_reuse_waitis acquired; argument$arg1will point to the same arena. In this
configuration, this will usually only occur once per thread. The exception is when a
thread first selected the main arena, but a subsequent allocation from it fails: then,
and only then, may we switch to another arena to retry that allocation, and for further
allocations within that thread.

memory_arena_reuse_wait (void *$arg1, void *$arg2, void *$arg3) [Probe]
This probe is triggered whenmallocis about to wait for an arena to become available
for reuse. Argument$arg1holds a pointer to the mutex the thread is going to wait
on,$arg2is a pointer to a newly-chosen arena to be reused, and$arg3is a pointer
to the arena previously used by that thread.
This occurs withinreused_arena, when a thread first tries to allocate memory or
needs a retry after a failure to allocate from the main arena, there isn¡¯t any free arena,
the maximum number of arenas has been reached, and an existing arena was chosen
for reuse, but its mutex could not be immediately acquired. The mutex in$arg1is
the mutex of the selected arena.


Chapter 36: Internal probes 936

memory_arena_reuse_free_list(void *$arg1) [Probe]
This probe is triggered whenmallochas chosen an arena that is in the free list for
use by a thread, within theget_free_listfunction. The argument$arg1holds a
pointer to the selected arena.

memory_mallopt(int $arg1, int $arg2) [Probe]
This probe is triggered when functionmalloptis called to changemallocinternal
configuration parameters, before any change to the parameters is made. The argu-
ments$arg1and$arg2are the ones passed to themalloptfunction.

memory_mallopt_mxfast(int $arg1, int $arg2) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_MXFAST, and the requested value is in an acceptable range. Ar-
gument$arg1is the requested value, and$arg2is the previous value of thismalloc
parameter.

memory_mallopt_trim_threshold(int $arg1, int $arg2, int $arg3) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_TRIM_THRESHOLD. Argument$arg1is the requested value,$arg2
is the previous value of thismalloc parameter, and$arg3 is nonzero if dynamic
threshold adjustment was already disabled.

memory_mallopt_top_pad (int $arg1, int $arg2, int $arg3) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_TOP_PAD. Argument$arg1 is the requested value,$arg2 is the
previous value of thismallocparameter, and$arg3is nonzero if dynamic threshold
adjustment was already disabled.

memory_mallopt_mmap_threshold(int $arg1, int $arg2, int $arg3) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_MMAP_THRESHOLD, and the requested value is in an acceptable
range. Argument$arg1 is the requested value,$arg2 is the previous value of this
mallocparameter, and$arg3is nonzero if dynamic threshold adjustment was already
disabled.

memory_mallopt_mmap_max (int $arg1, int $arg2, int $arg3) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_MMAP_MAX. Argument$arg1is the requested value,$arg2is the
previous value of thismallocparameter, and$arg3is nonzero if dynamic threshold
adjustment was already disabled.

memory_mallopt_perturb (int $arg1, int $arg2) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_PERTURB. Argument$arg1is the requested value, and$arg2 is
the previous value of thismallocparameter.

memory_mallopt_arena_test(int $arg1, int $arg2) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_ARENA_TEST, and the requested value is in an acceptable range.
Argument$arg1is the requested value, and$arg2is the previous value of thismalloc
parameter.


Chapter 36: Internal probes 937

memory_mallopt_arena_max(int $arg1, int $arg2) [Probe]
This probe is triggered shortly after thememory_malloptprobe, when the parameter
to be changed isM_ARENA_MAX, and the requested value is in an acceptable range.
Argument$arg1is the requested value, and$arg2is the previous value of thismalloc
parameter.

memory_mallopt_free_dyn_thresholds (int $arg1, int $arg2) [Probe]
This probe is triggered when functionfreedecides to adjust the dynamic brk/mmap
thresholds. Argument$arg1and$arg2are the adjusted mmap and trim thresholds,
respectively.

memory_tunable_tcache_max_bytes(int $arg1, int $arg2) [Probe]
This probe is triggered when theglibc.malloc.tcache_maxtunable is set. Argu-
ment$arg1is the requested value, and$arg2is the previous value of this tunable.

memory_tunable_tcache_count (int $arg1, int $arg2) [Probe]
This probe is triggered when theglibc.malloc.tcache_counttunable is set. Argu-
ment$arg1is the requested value, and$arg2is the previous value of this tunable.

memory_tunable_tcache_unsorted_limit(int $arg1, int $arg2) [Probe]
This probe is triggered when theglibc.malloc.tcache_unsorted_limittunable is
set. Argument$arg1is the requested value, and$arg2is the previous value of this
tunable.

memory_tcache_double_free(void *$arg1, int $arg2) [Probe]
This probe is triggered whenfreedetermines that the memory being freed has prob-
ably already been freed, and resides in the per-thread cache. Note that there is an
extremely unlikely chance that this probe will trigger due to random payload data
remaining in the allocated memory matching the key used to detect double frees.
This probe actually indicates that an expensive linear search of the tcache, looking
for a double free, has happened. Argument$arg1is the memory location as passed
tofree, Argument$arg2is the tcache bin it resides in.

36.2 Mathematical Function Probes

Some mathematical functions fall back to multiple precision arithmetic for some inputs to
get last bit precision for their return values. This multiple precision fallback is much slower
than the default algorithms and may have a significant impact on application performance.
The systemtap probe markers described in this section may help you determine if your
application calls mathematical functions with inputs that may result in multiple-precision
arithmetic.

Unless explicitly mentioned otherwise, a precision of 1 implies 24 bits of precision in the
mantissa of the multiple precision number. Hence, a precision level of 32 implies 768 bits
of precision in the mantissa.

slowatan2 (int $arg1, double $arg2, double $arg3, double $arg4) [Probe]
This probe is triggered when theatan2function is called with an input that results
in multiple precision computation. Argument$arg1is the precision with which com-
putation succeeded. Arguments$arg2and$arg3 are inputs to theatan2function
and$arg4is the computed result.


Chapter 36: Internal probes 938

slowatan2_inexact(int $arg1, double $arg2, double $arg3, double [Probe]
$arg4)
This probe is triggered when theatanfunction is called with an input that results
in multiple precision computation and none of the multiple precision computations
result in an accurate result. Argument$arg1is the maximum precision with which
computations were performed. Arguments$arg2and$arg3are inputs to theatan2
function and$arg4is the computed result.

slowatan (int $arg1, double $arg2, double $arg3) [Probe]
This probe is triggered when theatanfunction is called with an input that results in
multiple precision computation. Argument$arg1is the precision with which compu-
tation succeeded. Argument$arg2is the input to theatanfunction and$arg3is the
computed result.

slowatan_inexact (int $arg1, double $arg2, double $arg3) [Probe]
This probe is triggered when theatanfunction is called with an input that results
in multiple precision computation and none of the multiple precision computations
result in an accurate result. Argument$arg1is the maximum precision with which
computations were performed. Argument$arg2is the input to theatanfunction and
$arg3is the computed result.

slowtan(double $arg1, double $arg2) [Probe]
This probe is triggered when thetanfunction is called with an input that results in
multiple precision computation with precision 32. Argument$arg1 is the input to
the function and$arg2is the computed result.

slowsin(double $arg1, double $arg2) [Probe]
This probe is triggered when thesinfunction is called with an input that results in
multiple precision computation with precision 32. Argument$arg1 is the input to
the function and$arg2is the computed result.

slowcos(double $arg1, double $arg2) [Probe]
This probe is triggered when thecosfunction is called with an input that results in
multiple precision computation with precision 32. Argument$arg1 is the input to
the function and$arg2is the computed result.

slowsin_dx(double $arg1, double $arg2, double $arg3) [Probe]
This probe is triggered when thesinfunction is called with an input that results in
multiple precision computation with precision 32. Argument$arg1 is the input to
the function,$arg2is the error bound of$arg1and$arg3is the computed result.

slowcos_dx(double $arg1, double $arg2, double $arg3) [Probe]
This probe is triggered when thecosfunction is called with an input that results in
multiple precision computation with precision 32. Argument$arg1 is the input to
the function,$arg2is the error bound of$arg1and$arg3is the computed result.


Chapter 36: Internal probes 939

36.3 Non-local Goto Probes

These probes are used to signal calls tosetjmp,sigsetjmp,longjmporsiglongjmp.

setjmp(void *$arg1, int $arg2, void *$arg3) [Probe]
This probe is triggered wheneversetjmporsigsetjmpis called. Argument$arg1is
a pointer to thejmp_bufpassed as the first argument ofsetjmporsigsetjmp,$arg2
is the second argument ofsigsetjmpor zero if this is a call tosetjmpand$arg3is
a pointer to the return address that will be stored in thejmp_buf.

longjmp(void *$arg1, int $arg2, void *$arg3) [Probe]
This probe is triggered wheneverlongjmporsiglongjmpis called. Argument$arg1
is a pointer to thejmp_bufpassed as the first argument oflongjmporsiglongjmp,
$arg2is the return value passed as the second argument oflongjmporsiglongjmp
and$arg3is a pointer to the return addresslongjmporsiglongjmpwill return to.
Thelongjmpprobe is triggered at a point where the registers have not yet been
restored to the values in thejmp_bufand unwinding will show a call stack including
the caller oflongjmporsiglongjmp.

longjmp_target(void *$arg1, int $arg2, void *$arg3) [Probe]
This probe is triggered under the same conditions and with the same arguments as
thelongjmpprobe.
Thelongjmp_targetprobe is triggered at a point where the registers have been
restored to the values in thejmp_bufand unwinding will show a call stack including
the caller ofsetjmporsigsetjmp.


### 940

## 37 Tunables...........................................

Tunablesare a feature in the GNU C Library that allows application authors and distri-
bution maintainers to alter the runtime library behavior to match their workload. These
are implemented as a set of switches that may be modified in different ways. The current
default method to do this is via theGLIBC_TUNABLESenvironment variable by setting it to
a string of colon-separatedname=valuepairs. For example, the following example enables
malloc checking and sets the malloc trim threshold to 128 bytes:

GLIBC_TUNABLES=glibc.malloc.trim_threshold=128:glibc.malloc.check=3
export GLIBC_TUNABLES
Tunables are not part of the GNU C Library stable ABI, and they are subject to change
or removal across releases. Additionally, the method to modify tunable values may change
between releases and across distributions. It is possible to implement multiple ¡®frontends¡¯
for the tunables allowing distributions to choose their preferred method at build time.

Finally, the set of tunables available may vary between distributions as the tunables
feature allows distributions to add their own tunables under their own namespace.

Passing--list-tunablesto the dynamic loader to print all tunables with minimum
and maximum values:

```
$ /lib64/ld-linux-x86-64.so.2 --list-tunables
glibc.rtld.nns: 0x4 (min: 0x1, max: 0x10)
glibc.elision.skip_lock_after_retries: 3 (min: -2147483648, max: 2147483647)
glibc.malloc.trim_threshold: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.malloc.perturb: 0 (min: 0, max: 255)
glibc.cpu.x86_shared_cache_size: 0x100000 (min: 0x0, max: 0xffffffffffffffff)
glibc.mem.tagging: 0 (min: 0, max: 255)
glibc.elision.tries: 3 (min: -2147483648, max: 2147483647)
glibc.elision.enable: 0 (min: 0, max: 1)
glibc.cpu.x86_rep_movsb_threshold: 0x1000 (min: 0x100, max: 0xffffffffffffffff)
glibc.malloc.mxfast: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.elision.skip_lock_busy: 3 (min: -2147483648, max: 2147483647)
glibc.malloc.top_pad: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.cpu.x86_rep_stosb_threshold: 0x800 (min: 0x1, max: 0xffffffffffffffff)
glibc.cpu.x86_non_temporal_threshold: 0xc0000 (min: 0x0, max: 0xffffffffffffffff)
glibc.cpu.x86_shstk:
glibc.cpu.hwcap_mask: 0x6 (min: 0x0, max: 0xffffffffffffffff)
glibc.malloc.mmap_max: 0 (min: -2147483648, max: 2147483647)
glibc.elision.skip_trylock_internal_abort: 3 (min: -2147483648, max: 2147483647)
glibc.malloc.tcache_unsorted_limit: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.cpu.x86_ibt:
glibc.cpu.hwcaps:
glibc.elision.skip_lock_internal_abort: 3 (min: -2147483648, max: 2147483647)
glibc.malloc.arena_max: 0x0 (min: 0x1, max: 0xffffffffffffffff)
glibc.malloc.mmap_threshold: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.cpu.x86_data_cache_size: 0x8000 (min: 0x0, max: 0xffffffffffffffff)
glibc.malloc.tcache_count: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.malloc.arena_test: 0x0 (min: 0x1, max: 0xffffffffffffffff)
```

Chapter 37: Tunables 941

```
glibc.pthread.mutex_spin_count: 100 (min: 0, max: 32767)
glibc.rtld.optional_static_tls: 0x200 (min: 0x0, max: 0xffffffffffffffff)
glibc.malloc.tcache_max: 0x0 (min: 0x0, max: 0xffffffffffffffff)
glibc.malloc.check: 0 (min: 0, max: 3)
```
37.1 Tunable names

A tunable name is split into three components, a top namespace, a tunable namespace and
the tunable name. The top namespace for tunables implemented in the GNU C Library is
glibc. Distributions that choose to add custom tunables in their maintained versions of
the GNU C Library may choose to do so under their own top namespace.

The tunable namespace is a logical grouping of tunables in a single module. This cur-
rently holds no special significance, although that may change in the future.

The tunable name is the actual name of the tunable. It is possible that different tunable
namespaces may have tunables within them that have the same name, likewise for top
namespaces. Hence, we only support identification of tunables by their full name, i.e. with
the top namespace, tunable namespace and tunable name, separated by periods.

37.2 Memory Allocation Tunables

glibc.malloc [Tunable namespace]
Memory allocation behavior can be modified by setting any of the following tunables
in themallocnamespace:

glibc.malloc.check [Tunable]
This tunable supersedes theMALLOC_CHECK_environment variable and is identical in
features.
Setting this tunable to a non-zero value enables a special (less efficient) memory
allocator for the malloc family of functions that is designed to be tolerant against
simple errors such as double calls of free with the same argument, or overruns of a
single byte (off-by-one bugs). Not all such errors can be protected against, however,
and memory leaks can result. Any detected heap corruption results in immediate
termination of the process.
LikeMALLOC_CHECK_,glibc.malloc.checkhas a problem in that it diverges from
normal program behavior by writing tostderr, which could by exploited in SUID
and SGID binaries. Therefore,glibc.malloc.checkis disabled by default for SUID
and SGID binaries. This can be enabled again by the system administrator by adding
a file/etc/suid-debug; the content of the file could be anything or even empty.

glibc.malloc.top_pad [Tunable]
This tunable supersedes theMALLOC_TOP_PAD_environment variable and is identical
in features.
This tunable determines the amount of extra memory in bytes to obtain from the
system when any of the arenas need to be extended. It also specifies the number
of bytes to retain when shrinking any of the arenas. This provides the necessary
hysteresis in heap size such that excessive amounts of system calls can be avoided.
The default value of this tunable is ¡® 0 ¡¯.


Chapter 37: Tunables 942

glibc.malloc.perturb [Tunable]
This tunable supersedes theMALLOC_PERTURB_environment variable and is identical
in features.
If set to a non-zero value, memory blocks are initialized with values depending on
some low order bits of this tunable when they are allocated (except when allocated
by calloc) and freed. This can be used to debug the use of uninitialized or freed heap
memory. Note that this option does not guarantee that the freed block will have any
specific values. It only guarantees that the content the block had before it was freed
will be overwritten.
The default value of this tunable is ¡® 0 ¡¯.

glibc.malloc.mmap_threshold [Tunable]
This tunable supersedes theMALLOC_MMAP_THRESHOLD_environment variable and is
identical in features.
When this tunable is set, all chunks larger than this value in bytes are allocated
outside the normal heap, using themmapsystem call. This way it is guaranteed that
the memory for these chunks can be returned to the system onfree. Note that
requests smaller than this threshold might still be allocated viammap.
If this tunable is not set, the default value is set to ¡® 131072 ¡¯ bytes and the threshold
is adjusted dynamically to suit the allocation patterns of the program. If the tunable
is set, the dynamic adjustment is disabled and the value is set as static.

glibc.malloc.trim_threshold [Tunable]
This tunable supersedes theMALLOC_TRIM_THRESHOLD_environment variable and is
identical in features.
The value of this tunable is the minimum size (in bytes) of the top-most, releasable
chunk in an arena that will trigger a system call in order to return memory to the
system from that arena.
If this tunable is not set, the default value is set as 128 KB and the threshold is
adjusted dynamically to suit the allocation patterns of the program. If the tunable is
set, the dynamic adjustment is disabled and the value is set as static.

glibc.malloc.mmap_max [Tunable]
This tunable supersedes theMALLOC_MMAP_MAX_environment variable and is identical
in features.
The value of this tunable is maximum number of chunks to allocate withmmap. Setting
this to zero disables all use ofmmap.
The default value of this tunable is ¡® 65536 ¡¯.

glibc.malloc.arena_test [Tunable]
This tunable supersedes theMALLOC_ARENA_TESTenvironment variable and is identi-
cal in features.
Theglibc.malloc.arena_testtunable specifies the number of arenas that can be
created before the test on the limit to the number of arenas is conducted. The value
is ignored ifglibc.malloc.arena_maxis set.
The default value of this tunable is 2 for 32-bit systems and 8 for 64-bit systems.


Chapter 37: Tunables 943

glibc.malloc.arena_max [Tunable]
This tunable supersedes theMALLOC_ARENA_MAXenvironment variable and is identical
in features.
This tunable sets the number of arenas to use in a process regardless of the number
of cores in the system.
The default value of this tunable is 0 , meaning that the limit on the number of arenas
is determined by the number of CPU cores online. For 32-bit systems the limit is
twice the number of cores online and on 64-bit systems, it is 8 times the number of
cores online.

glibc.malloc.tcache_max [Tunable]
The maximum size of a request (in bytes) which may be met via the per-thread cache.
The default (and maximum) value is 1032 bytes on 64-bit systems and 516 bytes on
32-bit systems.

glibc.malloc.tcache_count [Tunable]
The maximum number of chunks of each size to cache. The default is 7. The upper
limit is 65535. If set to zero, the per-thread cache is effectively disabled.
The approximate maximum overhead of the per-thread cache is thus equal to the
number of bins times the chunk count in each bin times the size of each chunk. With
defaults, the approximate maximum overhead of the per-thread cache is approxi-
mately 236 KB on 64-bit systems and 118 KB on 32-bit systems.

glibc.malloc.tcache_unsorted_limit [Tunable]
When the user requests memory and the request cannot be met via the per-thread
cache, the arenas are used to meet the request. At this time, additional chunks will
be moved from existing arena lists to pre-fill the corresponding cache. While copies
from the fastbins, smallbins, and regular bins are bounded and predictable due to
the bin sizes, copies from the unsorted bin are not bounded, and incur additional
time penalties as they need to be sorted as they¡¯re scanned. To make scanning the
unsorted list more predictable and bounded, the user may set this tunable to limit the
number of chunks that are scanned from the unsorted list while searching for chunks
to pre-fill the per-thread cache with. The default, or when set to zero, is no limit.

glibc.malloc.mxfast [Tunable]
One of the optimizations malloc uses is to maintain a series of ¡°fast bins¡± that hold
chunks up to a specific size. The default and maximum size which may be held this
way is 80 bytes on 32-bit systems or 160 bytes on 64-bit systems. Applications which
value size over speed may choose to reduce the size of requests which are serviced from
fast bins with this tunable. Note that the value specified includes malloc¡¯s internal
overhead, which is normally the size of one pointer, so add 4 on 32-bit systems or 8
on 64-bit systems to the size passed tomallocfor the largest bin size to enable.

37.3 Dynamic Linking Tunables

glibc.rtld [Tunable namespace]
Dynamic linker behavior can be modified by setting the following tunables in the
rtldnamespace:


Chapter 37: Tunables 944

glibc.rtld.nns [Tunable]
Sets the number of supported dynamic link namespaces (seedlmopen). Currently this
limit can be set between 1 and 16 inclusive, the default is 4. Each link namespace
consumes some memory in all thread, and thus raising the limit will increase the
amount of memory each thread uses. Raising the limit is useful when your application
uses more than 4 dynamic link namespaces as created bydlmopenwith an lmid
argument ofLM_ID_NEWLM. Dynamic linker audit modules are loaded in their own
dynamic link namespaces, but they are not accounted for inglibc.rtld.nns. They
implicitly increase the per-thread memory usage as necessary, so this tunable does
not need to be changed to allow many audit modules e.g. viaLD_AUDIT.

glibc.rtld.optional_static_tls [Tunable]
Sets the amount of surplus static TLS in bytes to allocate at program startup. Ev-
ery thread created allocates this amount of specified surplus static TLS. This is a
minimum value and additional space may be allocated for internal purposes includ-
ing alignment. Optional static TLS is used for optimizing dynamic TLS access for
platforms that support such optimizations e.g. TLS descriptors or optimized TLS
access for POWER (DT_PPC64_OPTandDT_PPC_OPT). In order to make the best use
of such optimizations the value should be as many bytes as would be required to hold
all TLS variables in all dynamic loaded shared libraries. The value cannot be known
by the dynamic loader because it doesn¡¯t know the expected set of shared libraries
which will be loaded. The existing static TLS space cannot be changed once allocated
at process startup. The default allocation of optional static TLS is 512 bytes and is
allocated in every thread.

37.4 Elision Tunables

glibc.elision [Tunable namespace]
Contended locks are usually slow and can lead to performance and scalability issues
in multithread code. Lock elision will use memory transactions to under certain
conditions, to elide locks and improve performance. Elision behavior can be modified
by setting the following tunables in theelisionnamespace:

glibc.elision.enable [Tunable]
Theglibc.elision.enabletunable enables lock elision if the feature is supported
by the hardware. If elision is not supported by the hardware this tunable has no
effect.
Elision tunables are supported for 64-bit Intel, IBM POWER, and z System archi-
tectures.

glibc.elision.skip_lock_busy [Tunable]
Theglibc.elision.skip_lock_busy tunable sets how many times to use a non-
transactional lock after a transactional failure has occurred because the lock is already
acquired. Expressed in number of lock acquisition attempts.
The default value of this tunable is ¡® 3 ¡¯.


Chapter 37: Tunables 945

glibc.elision.skip_lock_internal_abort [Tunable]
Theglibc.elision.skip_lock_internal_aborttunable sets how many times the
thread should avoid using elision if a transaction aborted for any reason other than a
different thread¡¯s memory accesses. Expressed in number of lock acquisition attempts.

```
The default value of this tunable is ¡® 3 ¡¯.
```
glibc.elision.skip_lock_after_retries [Tunable]
Theglibc.elision.skip_lock_after_retriestunable sets how many times to try
to elide a lock with transactions, that only failed due to a different thread¡¯s memory
accesses, before falling back to regular lock. Expressed in number of lock elision
attempts.

```
This tunable is supported only on IBM POWER, and z System architectures.
```
```
The default value of this tunable is ¡® 3 ¡¯.
```
glibc.elision.tries [Tunable]
Theglibc.elision.triessets how many times to retry elision if there is chance
for the transaction to finish execution e.g., it wasn¡¯t aborted due to the lock being
already acquired. If elision is not supported by the hardware this tunable is set to ¡® 0 ¡¯
to avoid retries.

```
The default value of this tunable is ¡® 3 ¡¯.
```
glibc.elision.skip_trylock_internal_abort [Tunable]
Theglibc.elision.skip_trylock_internal_aborttunable sets how many times
the thread should avoid trying the lock if a transaction aborted due to reasons other
than a different thread¡¯s memory accesses. Expressed in number of try lock attempts.

```
The default value of this tunable is ¡® 3 ¡¯.
```
37.5 POSIX Thread Tunables

glibc.pthread [Tunable namespace]
The behavior of POSIX threads can be tuned to gain performance improvements
according to specific hardware capabilities and workload characteristics by setting
the following tunables in thepthreadnamespace:

glibc.pthread.mutex_spin_count [Tunable]
Theglibc.pthread.mutex_spin_counttunable sets the maximum number of times
a thread should spin on the lock before calling into the kernel to block. Adaptive spin
is used for mutexes initialized with thePTHREAD_MUTEX_ADAPTIVE_NPGNU extension.
It affects bothpthread_mutex_lockandpthread_mutex_timedlock.

```
The thread spins until either the maximum spin count is reached or the lock is ac-
quired.
```
```
The default value of this tunable is ¡® 100 ¡¯.
```

Chapter 37: Tunables 946

37.6 Hardware Capability Tunables

glibc.cpu [Tunable namespace]
Behavior of the GNU C Library can be tuned to assume specific hardware capabilities
by setting the following tunables in thecpunamespace:

glibc.cpu.hwcap_mask [Tunable]
This tunable supersedes theLD_HWCAP_MASKenvironment variable and is identical in
features.
TheAT_HWCAPkey in the Auxiliary Vector specifies instruction set extensions available
in the processor at runtime for some architectures. Theglibc.cpu.hwcap_mask
tunable allows the user to mask out those capabilities at runtime, thus disabling use
of those extensions.

glibc.cpu.hwcaps [Tunable]
The glibc.cpu.hwcaps=-xxx,yyy,-zzz... tunable allows the user to enable
CPU/ARCH featureyyy, disable CPU/ARCH featurexxxandzzzwhere the feature
name is case-sensitive and has to match the ones insysdeps/x86/cpu-features.h.
This tunable is specific to i386 and x86-64.

glibc.cpu.cached_memopt [Tunable]
Theglibc.cpu.cached_memopt=[0|1]tunable allows the user to enable optimiza-
tions recommended for cacheable memory. If set to 1 , the GNU C Library assumes
that the process memory image consists of cacheable (non-device) memory only. The
default, 0 , indicates that the process may use device memory.
This tunable is specific to powerpc, powerpc64 and powerpc64le.

glibc.cpu.name [Tunable]
Theglibc.cpu.name=xxxtunable allows the user to tell the GNU C Library to
assume that the CPU isxxxwhere xxx may have one of these values: generic,
falkor,thunderxt88,thunderx2t99,thunderx2t99p1,ares,emag,kunpeng.
This tunable is specific to aarch64.

glibc.cpu.x86_data_cache_size [Tunable]
Theglibc.cpu.x86_data_cache_sizetunable allows the user to set data cache size
in bytes for use in memory and string routines.
This tunable is specific to i386 and x86-64.

glibc.cpu.x86_shared_cache_size [Tunable]
Theglibc.cpu.x86_shared_cache_sizetunable allows the user to set shared cache
size in bytes for use in memory and string routines.

glibc.cpu.x86_non_temporal_threshold [Tunable]
Theglibc.cpu.x86_non_temporal_thresholdtunable allows the user to set thresh-
old in bytes for non temporal store. Non temporal stores give a hint to the hardware
to move data directly to memory without displacing other data from the cache. This
tunable is used by some platforms to determine when to use non temporal stores in
operations like memmove and memcpy.
This tunable is specific to i386 and x86-64.


Chapter 37: Tunables 947

glibc.cpu.x86_rep_movsb_threshold [Tunable]
Theglibc.cpu.x86_rep_movsb_thresholdtunable allows the user to set threshold
in bytes to start using"rep movsb". The value must be greater than zero, and
currently defaults to 2048 bytes.
This tunable is specific to i386 and x86-64.

glibc.cpu.x86_rep_stosb_threshold [Tunable]
Theglibc.cpu.x86_rep_stosb_thresholdtunable allows the user to set threshold
in bytes to start using"rep stosb". The value must be greater than zero, and currently
defaults to 2048 bytes.
This tunable is specific to i386 and x86-64.

glibc.cpu.x86_ibt [Tunable]
Theglibc.cpu.x86_ibttunable allows the user to control how indirect branch track-
ing (IBT) should be enabled. Accepted values areon,off, andpermissive. on
always turns on IBT regardless of whether IBT is enabled in the executable and its
dependent shared libraries. offalways turns off IBT regardless of whether IBT is
enabled in the executable and its dependent shared libraries.permissiveis the same
as the default which disables IBT on non-CET executables and shared libraries.
This tunable is specific to i386 and x86-64.

glibc.cpu.x86_shstk [Tunable]
Theglibc.cpu.x86_shstktunable allows the user to control how the shadow stack
(SHSTK) should be enabled. Accepted values areon, off, andpermissive. on
always turns on SHSTK regardless of whether SHSTK is enabled in the executable
and its dependent shared libraries.offalways turns off SHSTK regardless of whether
SHSTK is enabled in the executable and its dependent shared libraries.permissive
changes how dlopen works on non-CET shared libraries. By default, when SHSTK is
enabled, dlopening a non-CET shared library returns an error. Withpermissive, it
turns off SHSTK instead.
This tunable is specific to i386 and x86-64.

37.7 Memory Related Tunables

glibc.mem [Tunable namespace]
This tunable namespace supports operations that affect the way the GNU C Library
and the process manage memory.

glibc.mem.tagging [Tunable]
If the hardware supports memory tagging, this tunable can be used to control the way
the GNU C Library uses this feature. At present this is only supported on AArch64
systems with the MTE extention; it is ignored for all other systems.
This tunable takes a value between 0 and 255 and acts as a bitmask that enables
various capabilities.
Bit 0 (the least significant bit) causes the malloc subsystem to allocate tagged memory,
with each allocation being assigned a random tag.


Chapter 37: Tunables 948

```
Bit 1 enables precise faulting mode for tag violations on systems that support deferred
tag violation reporting. This may cause programs to run more slowly.
Other bits are currently reserved.
The GNU C Library startup code will automatically enable memory tagging support
in the kernel if this tunable has any non-zero value.
The default value is ¡® 0 ¡¯, which disables all memory tagging.
```

### 949

## A C Language Facilities in the Library....................

Some of the facilities implemented by the C library really should be thought of as parts of the
C language itself. These facilities ought to be documented in the C Language Manual, not
in the library manual; but since we don¡¯t have the language manual yet, and documentation
for these features has been written, we are publishing it here.

A.1 Explicitly Checking Internal Consistency

When you¡¯re writing a program, it¡¯s often a good idea to put in checks at strategic places for
¡°impossible¡± errors or violations of basic assumptions. These kinds of checks are helpful in
debugging problems with the interfaces between different parts of the program, for example.

Theassertmacro, defined in the header fileassert.h, provides a convenient way to
abort the program while printing a message about where in the program the error was
detected.

Once you think your program is debugged, you can disable the error checks performed
by theassertmacro by recompiling with the macroNDEBUGdefined. This means you don¡¯t
actually have to change the program source code to disable these checks.

But disabling these consistency checks is undesirable unless they make the program
significantly slower. All else being equal, more error checking is good no matter who is
running the program. A wise user would rather have a program crash, visibly, than have it
return nonsense without indicating anything might be wrong.

void assert(intexpression) [Macro]
Preliminary: |MT-Safe |AS-Unsafe heap corrupt|AC-Unsafe mem lock corrupt
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Verify the programmer¡¯s belief thatexpressionis nonzero at this point in the program.
IfNDEBUGis not defined,asserttests the value ofexpression. If it is false (zero),
assertaborts the program (seeSection 25.7.4 [Aborting a Program], page 801) after
printing a message of the form:
file:linenum:function: Assertion `expression' failed.
on the standard error streamstderr(seeSection 12.2 [Standard Streams], page 266).
The filename and line number are taken from the C preprocessor macros__FILE__
and__LINE__and specify where the call toassert was made. When using the
GNU C compiler, the name of the function which callsassertis taken from the
built-in variable__PRETTY_FUNCTION__; with older compilers, the function name and
following colon are omitted.
If the preprocessor macroNDEBUGis defined beforeassert.his included, theassert
macro is defined to do absolutely nothing.
Warning: Even the argument expressionexpressionis not evaluated ifNDEBUGis in
effect. So never useassertwith arguments that involve side effects. For example,
assert (++i > 0);is a bad idea, because iwill not be incremented ifNDEBUG is
defined.

Sometimes the ¡°impossible¡± condition you want to check for is an error return from an
operating system function. Then it is useful to display not only where the program crashes,
but also what error was returned. Theassert_perrormacro makes this easy.


Appendix A: C Language Facilities in the Library 950

void assert_perror(interrnum) [Macro]
Preliminary: |MT-Safe |AS-Unsafe heap corrupt|AC-Unsafe mem lock corrupt
|SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Similar toassert, but verifies thaterrnumis zero.
IfNDEBUGis not defined,assert_perrortests the value oferrnum. If it is nonzero,
assert_perroraborts the program after printing a message of the form:
file:linenum:function:error text
on the standard error stream. The file name, line number, and function name are as
forassert. The error text is the result ofstrerror (errnum). SeeSection 2.3 [Error
Messages], page 36.
Likeassert, ifNDEBUGis defined beforeassert.his included, theassert_perror
macro does absolutely nothing. It does not evaluate the argument, soerrnumshould
not have any side effects. It is best forerrnumto be just a simple variable reference;
often it will beerrno.
This macro is a GNU extension.

Usage note: Theassertfacility is designed for detectinginternal inconsistency; it is
not suitable for reporting invalid input or improper usage by theuserof the program.

The information in the diagnostic messages printed by theassertandassert_perror
macro is intended to help you, the programmer, track down the cause of a bug, but is
not really useful for telling a user of your program why his or her input was invalid or
why a command could not be carried out. What¡¯s more, your program should not abort
when given invalid input, asassert would do¡ªit should exit with nonzero status (see
Section 25.7.2 [Exit Status], page 799) after printing its error messages, or perhaps read
another command or move on to the next input file.

SeeSection 2.3 [Error Messages], page 36, for information on printing error messages for
problems thatdo notrepresent bugs in the program.

A.2 Variadic Functions

ISO C defines a syntax for declaring a function to take a variable number or type of argu-
ments. (Such functions are referred to asvarargs functionsorvariadic functions.) However,
the language itself provides no mechanism for such functions to access their non-required
arguments; instead, you use the variable arguments macros defined instdarg.h.

This section describes how to declare variadic functions, how to write them, and how to
call them properly.

Compatibility Note:Many older C dialects provide a similar, but incompatible, mecha-
nism for defining functions with variable numbers of arguments, usingvarargs.h.

A.2.1 Why Variadic Functions are Used

Ordinary C functions take a fixed number of arguments. When you define a function, you
specify the data type for each argument. Every call to the function should supply the
expected number of arguments, with types that can be converted to the specified ones.
Thus, if the function ¡®foo¡¯ is declared withint foo (int, char *);then you must call it
with two arguments, a number (any kind will do) and a string pointer.


Appendix A: C Language Facilities in the Library 951

But some functions perform operations that can meaningfully accept an unlimited num-
ber of arguments.

In some cases a function can handle any number of values by operating on all of them
as a block. For example, consider a function that allocates a one-dimensional array with
mallocto hold a specified set of values. This operation makes sense for any number of
values, as long as the length of the array corresponds to that number. Without facilities
for variable arguments, you would have to define a separate function for each possible array
size.

The library functionprintf(seeSection 12.12 [Formatted Output], page 288) is an
example of another class of function where variable arguments are useful. This function
prints its arguments (which can vary in type as well as number) under the control of a
format template string.

These are good reasons to define avariadicfunction which can handle as many arguments
as the caller chooses to pass.

Some functions such asopentake a fixed set of arguments, but occasionally ignore the
last few. Strict adherence to ISO C requires these functions to be defined as variadic; in
practice, however, the GNU C compiler and most other C compilers let you define such a
function to take a fixed set of arguments¡ªthe most it can ever use¡ªand then onlydeclare
the function as variadic (or not declare its arguments at all!).

A.2.2 How Variadic Functions are Defined and Used

Defining and using a variadic function involves three steps:

- Definethe function as variadic, using an ellipsis (¡®...¡¯) in the argument list, and using
    special macros to access the variable arguments. SeeSection A.2.2.2 [Receiving the
    Argument Values], page 952.
- Declarethe function as variadic, using a prototype with an ellipsis (¡®...¡¯), in all the
    files which call it. SeeSection A.2.2.1 [Syntax for Variable Arguments], page 951.
- Callthe function by writing the fixed arguments followed by the additional variable
    arguments. SeeSection A.2.2.4 [Calling Variadic Functions], page 953.

A.2.2.1 Syntax for Variable Arguments

A function that accepts a variable number of arguments must be declared with a prototype
that says so. You write the fixed arguments as usual, and then tack on ¡®...¡¯ to indicate
the possibility of additional arguments. The syntax of ISO C requires at least one fixed
argument before the ¡®...¡¯. For example,
int
func (const char *a, int b, ...)
{
...
}

defines a functionfuncwhich returns anintand takes two required arguments, aconst
char *and anint. These are followed by any number of anonymous arguments.

Portability note: For some C compilers, the last required argument must not be de-
claredregisterin the function definition. Furthermore, this argument¡¯s type must be
self-promoting: that is, the default promotions must not change its type. This rules out


Appendix A: C Language Facilities in the Library 952

array and function types, as well asfloat,char(whether signed or not) andshort int
(whether signed or not). This is actually an ISO C requirement.

A.2.2.2 Receiving the Argument Values

Ordinary fixed arguments have individual names, and you can use these names to access
their values. But optional arguments have no names¡ªnothing but ¡®...¡¯. How can you
access them?

The only way to access them is sequentially, in the order they were written, and you
must use special macros fromstdarg.hin the following three step process:

1. You initialize an argument pointer variable of typeva_listusingva_start. The
    argument pointer when initialized points to the first optional argument.
2. You access the optional arguments by successive calls tova_arg. The first call tova_
    arggives you the first optional argument, the next call gives you the second, and so
    on.
    You can stop at any time if you wish to ignore any remaining optional arguments. It
    is perfectly all right for a function to access fewer arguments than were supplied in the
    call, but you will get garbage values if you try to access too many arguments.
3. You indicate that you are finished with the argument pointer variable by callingva_end.
    (In practice, with most C compilers, callingva_enddoes nothing. This is always true
    in the GNU C compiler. But you might as well callva_endjust in case your program
    is someday compiled with a peculiar compiler.)
SeeSection A.2.2.5 [Argument Access Macros], page 953, for the full definitions ofva_
start,va_argandva_end.

Steps 1 and 3 must be performed in the function that accepts the optional arguments.
However, you can pass theva_listvariable as an argument to another function and perform
all or part of step 2 there.

You can perform the entire sequence of three steps multiple times within a single function
invocation. If you want to ignore the optional arguments, you can do these steps zero times.

You can have more than one argument pointer variable if you like. You can initialize
each variable withva_startwhen you wish, and then you can fetch arguments with each
argument pointer as you wish. Each argument pointer variable will sequence through the
same set of argument values, but at its own pace.

Portability note: With some compilers, once you pass an argument pointer value to a
subroutine, you must not keep using the same argument pointer value after that subroutine
returns. For full portability, you should just pass it tova_end. This is actually an ISO C
requirement, but most ANSI C compilers work happily regardless.

A.2.2.3 How Many Arguments Were Supplied

There is no general way for a function to determine the number and type of the optional
arguments it was called with. So whoever designs the function typically designs a convention
for the caller to specify the number and type of arguments. It is up to you to define an
appropriate calling convention for each variadic function, and write all calls accordingly.

One kind of calling convention is to pass the number of optional arguments as one of the
fixed arguments. This convention works provided all of the optional arguments are of the
same type.


Appendix A: C Language Facilities in the Library 953

A similar alternative is to have one of the required arguments be a bit mask, with a bit
for each possible purpose for which an optional argument might be supplied. You would
test the bits in a predefined sequence; if the bit is set, fetch the value of the next argument,
otherwise use a default value.

A required argument can be used as a pattern to specify both the number and types of
the optional arguments. The format string argument toprintfis one example of this (see
Section 12.12.7 [Formatted Output Functions], page 296).

Another possibility is to pass an ¡°end marker¡± value as the last optional argument. For
example, for a function that manipulates an arbitrary number of pointer arguments, a null
pointer might indicate the end of the argument list. (This assumes that a null pointer
isn¡¯t otherwise meaningful to the function.) Theexeclfunction works in just this way; see
Section 26.5 [Executing a File], page 806.

A.2.2.4 Calling Variadic Functions

You don¡¯t have to do anything special to call a variadic function. Just put the arguments
(required arguments, followed by optional ones) inside parentheses, separated by commas,
as usual. But you must declare the function with a prototype and know how the argument
values are converted.

In principle, functions that aredefinedto be variadic must also bedeclaredto be variadic
using a function prototype whenever you call them. (SeeSection A.2.2.1 [Syntax for Variable
Arguments], page 951, for how.) This is because some C compilers use a different calling
convention to pass the same set of argument values to a function depending on whether
that function takes variable arguments or fixed arguments.

In practice, the GNU C compiler always passes a given set of argument types in the
same way regardless of whether they are optional or required. So, as long as the argument
types are self-promoting, you can safely omit declaring them. Usually it is a good idea to
declare the argument types for variadic functions, and indeed for all functions. But there
are a few functions which it is extremely convenient not to have to declare as variadic¡ªfor
example,openandprintf.

Since the prototype doesn¡¯t specify types for optional arguments, in a call to a variadic
function thedefault argument promotionsare performed on the optional argument values.
This means the objects of typecharorshort int(whether signed or not) are promoted to
eitherintorunsigned int, as appropriate; and that objects of typefloatare promoted
to typedouble. So, if the caller passes acharas an optional argument, it is promoted to
anint, and the function can access it withva_arg (ap, int).

Conversion of the required arguments is controlled by the function prototype in the usual
way: the argument expression is converted to the declared argument type as if it were being
assigned to a variable of that type.

A.2.2.5 Argument Access Macros

Here are descriptions of the macros used to retrieve variable arguments. These macros are
defined in the header filestdarg.h.

va_list [Data Type]
The typeva_listis used for argument pointer variables.


Appendix A: C Language Facilities in the Library 954

void va_start(valistap,last-required) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This macro initializes the argument pointer variableapto point to the first of the
optional arguments of the current function;last-requiredmust be the last required
argument to the function.

type va_arg(valistap,type) [Macro]
Preliminary:|MT-Safe race:ap|AS-Safe |AC-Unsafe corrupt|SeeSection 1.2.2.1
[POSIX Safety Concepts], page 2.
Theva_argmacro returns the value of the next optional argument, and modifies the
value ofapto point to the subsequent argument. Thus, successive uses ofva_arg
return successive optional arguments.
The type of the value returned byva_argistypeas specified in the call.typemust
be a self-promoting type (notcharorshort intorfloat) that matches the type of
the actual argument.

void va_end(valistap) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This ends the use ofap. After ava_endcall, furtherva_argcalls with the sameap
may not work. You should invokeva_endbefore returning from the function in which
va_startwas invoked with the sameapargument.
In the GNU C Library,va_enddoes nothing, and you need not ever use it except for
reasons of portability.

Sometimes it is necessary to parse the list of parameters more than once or one wants
to remember a certain position in the parameter list. To do this, one will have to make a
copy of the current value of the argument. Butva_listis an opaque type and one cannot
necessarily assign the value of one variable of typeva_listto another variable of the same
type.

void va_copy (valistdest, valistsrc) [Macro]
void __va_copy(valistdest, valistsrc) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Theva_copymacro allows copying of objects of typeva_listeven if this is not
an integral type. The argument pointer indestis initialized to point to the same
argument as the pointer insrc.
va_copywas added in ISO C99. When building for strict conformance to ISO C90
(¡®gcc -std=c90¡¯), it is not available. GCC provides__va_copy, as an extension, in
any standards mode; before GCC 3.0, it was the only macro for this functionality.
These macros are no longer provided by the GNU C Library, but rather by the
compiler.

If you want to useva_copyand be portable to pre-C99 systems, you should always be
prepared for the possibility that this macro will not be available. On architectures where


Appendix A: C Language Facilities in the Library 955

a simple assignment is invalid, hopefullyva_copywill be available, so one should always
write something like this if concerned about pre-C99 portability:
{
va_list ap, save;
...
#ifdef va_copy
va_copy (save, ap);
#else
save = ap;
#endif
...
}

A.2.3 Example of a Variadic Function

Here is a complete sample function that accepts a variable number of arguments. The first
argument to the function is the count of remaining arguments, which are added up and the
result returned. While trivial, this function is sufficient to illustrate how to use the variable
arguments facility.

```
#include <stdarg.h>
#include <stdio.h>
```
```
int
add_em_up (int count,...)
{
va_list ap;
int i, sum;
```
```
va_start (ap, count); /*Initialize the argument list.*/
```
```
sum = 0;
for (i = 0; i < count; i++)
sum += va_arg (ap, int); /*Get the next argument value.*/
```
```
va_end (ap); /*Clean up.*/
return sum;
}
```
```
int
main (void)
{
/*This call prints 16.*/
printf ("%d\n", add_em_up (3, 5, 5, 6));
```
```
/*This call prints 55.*/
printf ("%d\n", add_em_up (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
```
```
return 0;
}
```
A.3 Null Pointer Constant

The null pointer constant is guaranteed not to point to any real object. You can assign it
to any pointer variable since it has typevoid *. The preferred way to write a null pointer
constant is withNULL.


Appendix A: C Language Facilities in the Library 956

void * NULL [Macro]
This is a null pointer constant.

You can also use 0 or(void *)0as a null pointer constant, but usingNULLis cleaner
because it makes the purpose of the constant more evident.

If you use the null pointer constant as a function argument, then for complete portability
you should make sure that the function has a prototype declaration. Otherwise, if the
target machine has two different pointer representations, the compiler won¡¯t know which
representation to use for that argument. You can avoid the problem by explicitly casting
the constant to the proper pointer type, but we recommend instead adding a prototype for
the function you are calling.

A.4 Important Data Types

The result of subtracting two pointers in C is always an integer, but the precise data type
varies from C compiler to C compiler. Likewise, the data type of the result ofsizeofalso
varies between compilers. ISO C defines standard aliases for these two types, so you can
refer to them in a portable fashion. They are defined in the header filestddef.h.

ptrdiff_t [Data Type]
This is the signed integer type of the result of subtracting two pointers. For example,
with the declarationchar *p1, *p2;, the expressionp2 - p1is of typeptrdiff_t.
This will probably be one of the standard signed integer types (short int,intor
long int), but might be a nonstandard type that exists only for this purpose.

size_t [Data Type]
This is an unsigned integer type used to represent the sizes of objects. The result of
thesizeofoperator is of this type, and functions such asmalloc(seeSection 3.2.3
[Unconstrained Allocation], page 45) andmemcpy(seeSection 5.4 [Copying Strings
and Arrays], page 101) accept arguments of this type to specify object sizes. On
systems using the GNU C Library, this will beunsigned intorunsigned long int.
Usage Note:size_tis the preferred way to declare any arguments or variables that
hold the size of an object.

Compatibility Note: Implementations of C before the advent of ISO C generally used
unsigned intfor representing object sizes andintfor pointer subtraction results. They
did not necessarily define eithersize_torptrdiff_t. Unix systems did definesize_t, in
sys/types.h, but the definition was usually a signed type.

A.5 Data Type Measurements

Most of the time, if you choose the proper C data type for each object in your program,
you need not be concerned with just how it is represented or how many bits it uses. When
you do need such information, the C language itself does not provide a way to get it. The
header fileslimits.handfloat.hcontain macros which give you this information in full
detail.


Appendix A: C Language Facilities in the Library 957

A.5.1 Width of an Integer Type

TS 18661-1:2014 defines macros for the width of integer types (the number of value and
sign bits). One benefit of these macros is they can be used in#ifpreprocessor directives,
whereassizeofcannot. The following macros are defined inlimits.h.

CHAR_WIDTH
SCHAR_WIDTH
UCHAR_WIDTH
SHRT_WIDTH
USHRT_WIDTH
INT_WIDTH
UINT_WIDTH
LONG_WIDTH
ULONG_WIDTH
LLONG_WIDTH
ULLONG_WIDTH
These are the widths of the typeschar,signed char,unsigned char,short
int,unsigned short int,int,unsigned int,long int,unsigned long int,
long long intandunsigned long long int, respectively.
Further such macros are defined instdint.h. Apart from those for types specified by
width (seeSection 20.1 [Integers], page 601), the following are defined:

INTPTR_WIDTH
UINTPTR_WIDTH
PTRDIFF_WIDTH
SIG_ATOMIC_WIDTH
SIZE_WIDTH
WCHAR_WIDTH
WINT_WIDTH
These are the widths of the typesintptr_t, uintptr_t, ptrdiff_t, sig_
atomic_t,size_t,wchar_tandwint_t, respectively.
A common reason that a program needs to know how many bits are in an integer type
is for using an array ofunsigned long intas a bit vector. You can access the bit at index
nwith:
vector[n/ ULONG_WIDTH] & (1UL << (n% ULONG_WIDTH))
BeforeULONG_WIDTHwas a part of the C language,CHAR_BITwas used to compute the
number of bits in an integer data type.

int CHAR_BIT [Macro]
This is the number of bits in achar. POSIX.1-2001 requires this to be 8.
The number of bits in any data typetypecan be computed like this:
sizeof (type) * CHAR_BIT
That expression includes padding bits as well as value and sign bits. On all systems
supported by the GNU C Library, standard integer types other than_Booldo not have
any padding bits.

Portability Note: One cannot actually easily compute the number of usable bits in a
portable manner.


Appendix A: C Language Facilities in the Library 958

A.5.2 Range of an Integer Type

Suppose you need to store an integer value which can range from zero to one million. Which
is the smallest type you can use? There is no general rule; it depends on the C compiler and
target machine. You can use the ¡®MIN¡¯ and ¡®MAX¡¯ macros inlimits.hto determine which
type will work.

Each signed integer type has a pair of macros which give the smallest and largest values
that it can hold. Each unsigned integer type has one such macro, for the maximum value;
the minimum value is, of course, zero.

The values of these macros are all integer constant expressions. The ¡®MAX¡¯ and ¡®MIN¡¯
macros forcharandshort inttypes have values of typeint. The ¡®MAX¡¯ and ¡®MIN¡¯ macros
for the other types have values of the same type described by the macro¡ªthus,ULONG_MAX
has typeunsigned long int.

SCHAR_MIN
This is the minimum value that can be represented by asigned char.

SCHAR_MAX
UCHAR_MAX
These are the maximum values that can be represented by asigned charand
unsigned char, respectively.

CHAR_MIN

```
This is the minimum value that can be represented by achar. It¡¯s equal to
SCHAR_MINifcharis signed, or zero otherwise.
```
CHAR_MAX

```
This is the maximum value that can be represented by achar. It¡¯s equal to
SCHAR_MAXifcharis signed, orUCHAR_MAXotherwise.
```
SHRT_MIN

```
This is the minimum value that can be represented by asigned short int.
On most machines that the GNU C Library runs on,shortintegers are 16-bit
quantities.
```
SHRT_MAX
USHRT_MAX
These are the maximum values that can be represented by asigned short int
andunsigned short int, respectively.

INT_MIN

```
This is the minimum value that can be represented by asigned int. On most
machines that the GNU C Library runs on, anintis a 32-bit quantity.
```
INT_MAX
UINT_MAX

```
These are the maximum values that can be represented by, respectively, the
typesigned intand the typeunsigned int.
```
LONG_MIN


Appendix A: C Language Facilities in the Library 959

```
This is the minimum value that can be represented by asigned long int.
On most machines that the GNU C Library runs on,longintegers are 32-bit
quantities, the same size asint.
```
LONG_MAX
ULONG_MAX
These are the maximum values that can be represented by asigned long int
andunsigned long int, respectively.

LLONG_MIN
This is the minimum value that can be represented by asigned long long int.
On most machines that the GNU C Library runs on,long longintegers are
64-bit quantities.

LLONG_MAX
ULLONG_MAX
These are the maximum values that can be represented by asigned long long
intandunsigned long long int, respectively.

LONG_LONG_MIN
LONG_LONG_MAX
ULONG_LONG_MAX
These are obsolete names forLLONG_MIN,LLONG_MAX, andULLONG_MAX. They
are only available if_GNU_SOURCEis defined (seeSection 1.3.4 [Feature Test
Macros], page 15). In GCC versions prior to 3.0, these were the only names
available.

WCHAR_MAX
This is the maximum value that can be represented by a wchar_t. See
Section 6.1 [Introduction to Extended Characters], page 140.
The header filelimits.halso defines some additional constants that parameterize var-
ious operating system and file system limits. These constants are described inChapter 32
[System Configuration Parameters], page 890.

A.5.3 Floating Type Macros

The specific representation of floating point numbers varies from machine to machine. Be-
cause floating point numbers are represented internally as approximate quantities, algo-
rithms for manipulating floating point data often need to take account of the precise details
of the machine¡¯s floating point representation.

Some of the functions in the C library itself need this information; for example, the algo-
rithms for printing and reading floating point numbers (see Chapter 12 [Input/Output
on Streams], page 266) and for calculating trigonometric and irrational functions (see
Chapter 19 [Mathematics], page 539) use it to avoid round-off error and loss of accu-
racy. User programs that implement numerical analysis techniques also often need this
information in order to minimize or compute error bounds.

```
The header filefloat.hdescribes the format used by your machine.
```
A.5.3.1 Floating Point Representation Concepts

This section introduces the terminology for describing floating point representations.


Appendix A: C Language Facilities in the Library 960

You are probably already familiar with most of these concepts in terms of scientific or
exponential notation for floating point numbers. For example, the number123456.0could
be expressed in exponential notation as1.23456e+05, a shorthand notation indicating that
the mantissa1.23456is multiplied by the base 10 raised to power 5.

More formally, the internal representation of a floating point number can be characterized
in terms of the following parameters:

- Thesignis either-1or 1.
- Thebaseorradixfor exponentiation, an integer greater than 1. This is a constant for
    a particular representation.
- Theexponentto which the base is raised. The upper and lower bounds of the exponent
    value are constants for a particular representation.
    Sometimes, in the actual bits representing the floating point number, the exponent is
    biasedby adding a constant to it, to make it always be represented as an unsigned
    quantity. This is only important if you have some reason to pick apart the bit fields
    making up the floating point number by hand, which is something for which the GNU
    C Library provides no support. So this is ignored in the discussion that follows.
- Themantissaorsignificandis an unsigned integer which is a part of each floating point
    number.
- Theprecisionof the mantissa. If the base of the representation isb, then the precision
    is the number of base-bdigits in the mantissa. This is a constant for a particular
    representation.
    Many floating point representations have an implicithidden bitin the mantissa. This
    is a bit which is present virtually in the mantissa, but not stored in memory because
    its value is always 1 in a normalized number. The precision figure (see above) includes
    any hidden bits.
    Again, the GNU C Library provides no facilities for dealing with such low-level aspects
    of the representation.
The mantissa of a floating point number represents an implicit fraction whose denomina-
tor is the base raised to the power of the precision. Since the largest representable mantissa
is one less than this denominator, the value of the fraction is always strictly less than 1.
The mathematical value of a floating point number is then the product of this fraction, the
sign, and the base raised to the exponent.

We say that the floating point number isnormalizedif the fraction is at least1/b, where
bis the base. In other words, the mantissa would be too large to fit if it were multiplied
by the base. Non-normalized numbers are sometimes calleddenormal; they contain less
precision than the representation normally can hold.

If the number is not normalized, then you can subtract 1 from the exponent while
multiplying the mantissa by the base, and get another floating point number with the same
value.Normalizationconsists of doing this repeatedly until the number is normalized. Two
distinct normalized floating point numbers cannot be equal in value.

(There is an exception to this rule: if the mantissa is zero, it is considered normalized.
Another exception happens on certain machines where the exponent is as small as the
representation can hold. Then it is impossible to subtract 1 from the exponent, so a number
may be normalized even if its fraction is less than1/b.)


Appendix A: C Language Facilities in the Library 961

A.5.3.2 Floating Point Parameters

These macro definitions can be accessed by including the header filefloat.hin your pro-
gram.

Macro names starting with ¡®FLT_¡¯ refer to thefloattype, while names beginning with
¡®DBL_¡¯ refer to thedoubletype and names beginning with ¡®LDBL_¡¯ refer to thelong double
type. (If GCC does not supportlong doubleas a distinct data type on a target machine
then the values for the ¡®LDBL_¡¯ constants are equal to the corresponding constants for the
doubletype.)

Of these macros, onlyFLT_RADIXis guaranteed to be a constant expression. The other
macros listed here cannot be reliably used in places that require constant expressions, such
as ¡®#if¡¯ preprocessing directives or in the dimensions of static arrays.

Although the ISO C standard specifies minimum and maximum values for most of these
parameters, the GNU C implementation uses whatever values describe the floating point
representation of the target machine. So in principle GNU C actually satisfies the ISO C
requirements only if the target machine is suitable. In practice, all the machines currently
supported are suitable.

FLT_ROUNDS
This value characterizes the rounding mode for floating point addition. The
following values indicate standard rounding modes:
-1 The mode is indeterminable.
0 Rounding is towards zero.
1 Rounding is to the nearest number.
2 Rounding is towards positive infinity.
3 Rounding is towards negative infinity.
Any other value represents a machine-dependent nonstandard rounding mode.
On most machines, the value is 1 , in accordance with the IEEE standard for
floating point.
Here is a table showing how certain values round for each possible value of
FLT_ROUNDS, if the other aspects of the representation match the IEEE single-
precision standard.
0 1 2 3
1.00000003 1.0 1.0 1.00000012 1.0
1.00000007 1.0 1.00000012 1.00000012 1.0
-1.00000003 -1.0 -1.0 -1.0 -1.00000012
-1.00000007 -1.0 -1.00000012 -1.0 -1.00000012

FLT_RADIX
This is the value of the base, or radix, of the exponent representation. This is
guaranteed to be a constant expression, unlike the other macros described in
this section. The value is 2 on all machines we know of except the IBM 360
and derivatives.

FLT_MANT_DIG
This is the number of base-FLT_RADIXdigits in the floating point mantissa
for thefloatdata type. The following expression yields1.0(even though
mathematically it should not) due to the limited number of mantissa digits:


Appendix A: C Language Facilities in the Library 962

```
float radix = FLT_RADIX;
```
```
1.0f + 1.0f / radix / radix / ... / radix
whereradixappearsFLT_MANT_DIGtimes.
```
DBL_MANT_DIG
LDBL_MANT_DIG
This is the number of base-FLT_RADIXdigits in the floating point mantissa for
the data typesdoubleandlong double, respectively.

FLT_DIG

```
This is the number of decimal digits of precision for thefloatdata type.
Technically, ifpandbare the precision and base (respectively) for the rep-
resentation, then the decimal precisionqis the maximum number of decimal
digits such that any floating point number withqbase 10 digits can be rounded
to a floating point number withpbasebdigits and back again, without change
to theqdecimal digits.
The value of this macro is supposed to be at least 6 , to satisfy ISO C.
```
DBL_DIG
LDBL_DIG

```
These are similar toFLT_DIG, but for the data typesdoubleandlong double,
respectively. The values of these macros are supposed to be at least 10.
```
FLT_MIN_EXP
This is the smallest possible exponent value for typefloat. More precisely, it
is the minimum negative integer such that the valueFLT_RADIXraised to this
power minus 1 can be represented as a normalized floating point number of
typefloat.

DBL_MIN_EXP
LDBL_MIN_EXP
These are similar toFLT_MIN_EXP, but for the data types doubleandlong
double, respectively.

FLT_MIN_10_EXP
This is the minimum negative integer such that 10 raised to this power minus 1
can be represented as a normalized floating point number of typefloat. This
is supposed to be-37or even less.

DBL_MIN_10_EXP
LDBL_MIN_10_EXP
These are similar toFLT_MIN_10_EXP, but for the data typesdoubleandlong
double, respectively.

FLT_MAX_EXP
This is the largest possible exponent value for typefloat. More precisely, this
is the maximum positive integer such that valueFLT_RADIXraised to this power
minus 1 can be represented as a floating point number of typefloat.


Appendix A: C Language Facilities in the Library 963

### DBL_MAX_EXP

### LDBL_MAX_EXP

```
These are similar toFLT_MAX_EXP, but for the data types doubleandlong
double, respectively.
```
FLT_MAX_10_EXP
This is the maximum positive integer such that 10 raised to this power minus 1
can be represented as a normalized floating point number of typefloat. This
is supposed to be at least 37.

DBL_MAX_10_EXP
LDBL_MAX_10_EXP
These are similar toFLT_MAX_10_EXP, but for the data typesdoubleandlong
double, respectively.

FLT_MAX

```
The value of this macro is the maximum number representable in typefloat.
It is supposed to be at least1E+37. The value has typefloat.
The smallest representable number is- FLT_MAX.
```
DBL_MAX
LDBL_MAX

```
These are similar toFLT_MAX, but for the data typesdoubleandlong double,
respectively. The type of the macro¡¯s value is the same as the type it describes.
```
FLT_MIN

```
The value of this macro is the minimum normalized positive floating point
number that is representable in typefloat. It is supposed to be no more than
1E-37.
```
DBL_MIN
LDBL_MIN

```
These are similar toFLT_MIN, but for the data typesdoubleandlong double,
respectively. The type of the macro¡¯s value is the same as the type it describes.
```
FLT_EPSILON
This is the difference between 1 and the smallest floating point number of type
floatthat is greater than 1. It¡¯s supposed to be no greater than1E-5.

DBL_EPSILON
LDBL_EPSILON
These are similar toFLT_EPSILON, but for the data types doubleandlong
double, respectively. The type of the macro¡¯s value is the same as the type it
describes. The values are not supposed to be greater than1E-9.

A.5.3.3 IEEE Floating Point

Here is an example showing how the floating type measurements come out for the most
common floating point representation, specified by theIEEE Standard for Binary Floating
Point Arithmetic (ANSI/IEEE Std 754-1985). Nearly all computers designed since the
1980s use this format.


Appendix A: C Language Facilities in the Library 964

The IEEE single-precision float representation uses a base of 2. There is a sign bit, a
mantissa with 23 bits plus one hidden bit (so the total precision is 24 base-2 digits), and an
8-bit exponent that can represent values in the range -125 to 128, inclusive.

So, for an implementation that uses this representation for thefloatdata type, appro-
priate values for the corresponding parameters are:
FLT_RADIX 2
FLT_MANT_DIG 24
FLT_DIG 6
FLT_MIN_EXP -125
FLT_MIN_10_EXP -37
FLT_MAX_EXP 128
FLT_MAX_10_EXP +38
FLT_MIN 1.17549435E-38F
FLT_MAX 3.40282347E+38F
FLT_EPSILON 1.19209290E-07F
Here are the values for thedoubledata type:
DBL_MANT_DIG 53
DBL_DIG 15
DBL_MIN_EXP -1021
DBL_MIN_10_EXP -307
DBL_MAX_EXP 1024
DBL_MAX_10_EXP 308
DBL_MAX 1.7976931348623157E+308
DBL_MIN 2.2250738585072014E-308
DBL_EPSILON 2.2204460492503131E-016

A.5.4 Structure Field Offset Measurement

You can useoffsetofto measure the location within a structure type of a particular
structure member.

size_t offsetof (type,member) [Macro]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
This expands to an integer constant expression that is the offset of the structure
member namedmemberin the structure typetype. For example,offsetof (struct
s, elem)is the offset, in bytes, of the memberelemin astruct s.
This macro won¡¯t work ifmemberis a bit field; you get an error from the C compiler
in that case.


### 965

## B Summary of Library Facilities..........................

This appendix is a complete list of the facilities declared within the header files supplied
with the GNU C Library. Each entry also lists the standard or other source from which
each facility is derived, and tells you where in the manual you can find more information
about how to use it.

ACCOUNTING
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

AF_FILE
sys/socket.h(GNU):Section 16.3.1 [Address Formats], page 457.

AF_INET
sys/socket.h(BSD):Section 16.3.1 [Address Formats], page 457.

AF_INET6
sys/socket.h(IPv6 Basic API):Section 16.3.1 [Address Formats], page 457.

AF_LOCAL
sys/socket.h(POSIX):Section 16.3.1 [Address Formats], page 457.

AF_UNIX
sys/socket.h(BSD):Section 16.3.1 [Address Formats], page 457.
sys/socket.h(Unix98):Section 16.3.1 [Address Formats], page 457.

AF_UNSPEC
sys/socket.h(BSD):Section 16.3.1 [Address Formats], page 457.

tcflag_t ALTWERASE
termios.h(BSD):Section 17.4.7 [Local Modes], page 512.

int ARGP_ERR_UNKNOWN
argp.h(GNU):Section 25.3.5 [Argp Parser Functions], page 772.

ARGP_HELP_BUG_ADDR
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_DOC
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_EXIT_ERR
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_EXIT_OK
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_LONG
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_LONG_ONLY
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_POST_DOC
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_PRE_DOC
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_SEE
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_SHORT_USAGE
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.


Appendix B: Summary of Library Facilities 966

ARGP_HELP_STD_ERR
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_STD_HELP
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_STD_USAGE
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_HELP_USAGE
argp.h(GNU):Section 25.3.10 [Flags for theargp_helpFunction], page 780.

ARGP_IN_ORDER
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

ARGP_KEY_ARG
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_ARGS
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_END
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_ERROR
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_FINI
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_HELP_ARGS_DOC
argp.h(GNU):Section 25.3.8.1 [Special Keys for Argp Help Filter Functions], page 780.

ARGP_KEY_HELP_DUP_ARGS_NOTE
argp.h(GNU):Section 25.3.8.1 [Special Keys for Argp Help Filter Functions], page 780.

ARGP_KEY_HELP_EXTRA
argp.h(GNU):Section 25.3.8.1 [Special Keys for Argp Help Filter Functions], page 780.

ARGP_KEY_HELP_HEADER
argp.h(GNU):Section 25.3.8.1 [Special Keys for Argp Help Filter Functions], page 780.

ARGP_KEY_HELP_POST_DOC
argp.h(GNU):Section 25.3.8.1 [Special Keys for Argp Help Filter Functions], page 780.

ARGP_KEY_HELP_PRE_DOC
argp.h(GNU):Section 25.3.8.1 [Special Keys for Argp Help Filter Functions], page 780.

ARGP_KEY_INIT
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_NO_ARGS
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_KEY_SUCCESS
argp.h(GNU):Section 25.3.5.1 [Special Keys for Argp Parser Functions], page 773.

ARGP_LONG_ONLY
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

ARGP_NO_ARGS
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

ARGP_NO_ERRS
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

ARGP_NO_EXIT
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.


Appendix B: Summary of Library Facilities 967

ARGP_NO_HELP
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

ARGP_PARSE_ARGV0
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

ARGP_SILENT
argp.h(GNU):Section 25.3.7 [Flags forargp_parse], page 778.

int ARG_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

int BC_BASE_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

int BC_DIM_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

int BC_SCALE_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

int BC_STRING_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

BOOT_TIME
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

tcflag_t BRKINT
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

int BUFSIZ
stdio.h(ISO):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

tcflag_t CCTS_OFLOW
termios.h(BSD):Section 17.4.6 [Control Modes], page 511.

int CHAR_BIT
limits.h(C90):Section A.5.1 [Width of an Integer Type], page 957.

CHAR_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

CHAR_MIN
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

CHAR_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

int CHILD_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

tcflag_t CIGNORE
termios.h(BSD):Section 17.4.6 [Control Modes], page 511.

int CLK_TCK
time.h(POSIX.1):Section 21.4.2 [Processor Time Inquiry], page 650.

tcflag_t CLOCAL
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

int CLOCKS_PER_SEC
time.h(ISO):Section 21.4.1 [CPU Time Inquiry], page 649.

clockid_t CLOCK_MONOTONIC
time.h(POSIX.1):Section 21.5.1 [Getting the Time], page 651.


Appendix B: Summary of Library Facilities 968

clockid_t CLOCK_REALTIME
time.h(POSIX.1):Section 21.5.1 [Getting the Time], page 651.

int COLL_WEIGHTS_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

void CPU_CLR (intcpu, cpu_set_t *set)
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

int CPU_ISSET (intcpu, const cpu_set_t *set)
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

void CPU_SET (intcpu, cpu_set_t *set)
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

int CPU_SETSIZE
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

void CPU_ZERO (cpu_set_t *set)
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

tcflag_t CREAD
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t CRTS_IFLOW
termios.h(BSD):Section 17.4.6 [Control Modes], page 511.

tcflag_t CS5
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t CS6
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t CS7
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t CS8
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t CSIZE
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t CSTOPB
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

DBL_DIG
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_EPSILON
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_MANT_DIG
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_MAX
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_MAX_10_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_MAX_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_MIN
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DBL_MIN_10_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.


Appendix B: Summary of Library Facilities 969

DBL_MIN_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

DEAD_PROCESS
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

DIR
dirent.h(POSIX.1):Section 14.2.2 [Opening a Directory Stream], page 406.

mode_t DTTOIF (intdtype)
dirent.h(BSD):Section 14.2.1 [Format of a Directory Entry], page 404.

int E2BIG
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EACCES
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EADDRINUSE
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EADDRNOTAVAIL
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EADV
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EAFNOSUPPORT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EAGAIN
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EALREADY
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EAUTH
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EBACKGROUND
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int EBADE
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EBADF
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EBADFD
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EBADMSG
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int EBADR
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EBADRPC
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EBADRQC
errno.h(Linux???):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 970

int EBADSLT
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EBFONT
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EBUSY
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ECANCELED
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ECHILD
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

tcflag_t ECHO
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t ECHOCTL
termios.h(BSD):Section 17.4.7 [Local Modes], page 512.

tcflag_t ECHOE
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t ECHOK
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t ECHOKE
termios.h(BSD):Section 17.4.7 [Local Modes], page 512.

tcflag_t ECHONL
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t ECHOPRT
termios.h(BSD):Section 17.4.7 [Local Modes], page 512.

int ECHRNG
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ECOMM
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ECONNABORTED
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ECONNREFUSED
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ECONNRESET
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ED
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int EDEADLK
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EDEADLOCK
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EDESTADDRREQ
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EDIED
errno.h(GNU):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 971

int EDOM
errno.h(ISO):Section 2.2 [Error Codes], page 24.

int EDOTDOT
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EDQUOT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EEXIST
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EFAULT
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EFBIG
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EFTYPE
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EGRATUITOUS
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int EGREGIOUS
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int EHOSTDOWN
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EHOSTUNREACH
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EHWPOISON
errno.h(Linux):Section 2.2 [Error Codes], page 24.

int EIDRM
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int EIEIO
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int EILSEQ
errno.h(ISO):Section 2.2 [Error Codes], page 24.

int EINPROGRESS
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EINTR
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EINVAL
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EIO
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EISCONN
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EISDIR
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 972

int EISNAM
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EKEYEXPIRED
errno.h(Linux):Section 2.2 [Error Codes], page 24.

int EKEYREJECTED
errno.h(Linux):Section 2.2 [Error Codes], page 24.

int EKEYREVOKED
errno.h(Linux):Section 2.2 [Error Codes], page 24.

int EL2HLT
errno.h(Obsolete):Section 2.2 [Error Codes], page 24.

int EL2NSYNC
errno.h(Obsolete):Section 2.2 [Error Codes], page 24.

int EL3HLT
errno.h(Obsolete):Section 2.2 [Error Codes], page 24.

int EL3RST
errno.h(Obsolete):Section 2.2 [Error Codes], page 24.

int ELIBACC
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ELIBBAD
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ELIBEXEC
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ELIBMAX
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ELIBSCN
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ELNRNG
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ELOOP
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EMEDIUMTYPE
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EMFILE
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EMLINK
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

EMPTY
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

int EMSGSIZE
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EMULTIHOP
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 973

int ENAMETOOLONG
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENAVAIL
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENEEDAUTH
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENETDOWN
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENETRESET
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENETUNREACH
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENFILE
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOANO
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENOBUFS
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENOCSI
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENODATA
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int ENODEV
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOENT
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOEXEC
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOKEY
errno.h(Linux):Section 2.2 [Error Codes], page 24.

int ENOLCK
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOLINK
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int ENOMEDIUM
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENOMEM
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOMSG
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int ENONET
errno.h(Linux???):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 974

int ENOPKG
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENOPROTOOPT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENOSPC
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOSR
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int ENOSTR
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int ENOSYS
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOTBLK
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENOTCONN
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENOTDIR
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOTEMPTY
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOTNAM
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENOTRECOVERABLE
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int ENOTSOCK
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ENOTSUP
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOTTY
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ENOTUNIQ
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ENXIO
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EOF
stdio.h(ISO):Section 12.15 [End-Of-File and Errors], page 320.

int EOPNOTSUPP
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EOVERFLOW
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int EOWNERDEAD
errno.h(GNU):Section 2.2 [Error Codes], page 24.

int EPERM
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 975

int EPFNOSUPPORT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EPIPE
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EPROCLIM
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EPROCUNAVAIL
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EPROGMISMATCH
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EPROGUNAVAIL
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EPROTO
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int EPROTONOSUPPORT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EPROTOTYPE
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EQUIV_CLASS_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

int ERANGE
errno.h(ISO):Section 2.2 [Error Codes], page 24.

int EREMCHG
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EREMOTE
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EREMOTEIO
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ERESTART
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ERFKILL
errno.h(Linux):Section 2.2 [Error Codes], page 24.

int EROFS
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ERPCMISMATCH
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ESHUTDOWN
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ESOCKTNOSUPPORT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ESPIPE
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int ESRCH
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.


Appendix B: Summary of Library Facilities 976

int ESRMNT
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ESTALE
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ESTRPIPE
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int ETIME
errno.h(XOPEN):Section 2.2 [Error Codes], page 24.

int ETIMEDOUT
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ETOOMANYREFS
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int ETXTBSY
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EUCLEAN
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EUNATCH
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EUSERS
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EWOULDBLOCK
errno.h(BSD):Section 2.2 [Error Codes], page 24.

int EXDEV
errno.h(POSIX.1):Section 2.2 [Error Codes], page 24.

int EXFULL
errno.h(Linux???):Section 2.2 [Error Codes], page 24.

int EXIT_FAILURE
stdlib.h(ISO):Section 25.7.2 [Exit Status], page 799.

int EXIT_SUCCESS
stdlib.h(ISO):Section 25.7.2 [Exit Status], page 799.

int EXPR_NEST_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

int FD_CLOEXEC
fcntl.h(POSIX.1):Section 13.14 [File Descriptor Flags], page 386.

void FD_CLR (intfiledes, fd_set *set)
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.

int FD_ISSET (intfiledes, const fd_set *set)
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.

void FD_SET (intfiledes, fd_set *set)
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.

int FD_SETSIZE
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.

void FD_ZERO (fd_set *set)
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.


Appendix B: Summary of Library Facilities 977

FE_DIVBYZERO
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

FE_DOWNWARD
fenv.h(ISO):Section 20.6 [Rounding Modes], page 613.

FE_INEXACT
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

FE_INVALID
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

FE_OVERFLOW
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int FE_SNANS_ALWAYS_SIGNAL
fenv.h(ISO):Section 20.5.2 [Infinity and NaN], page 609.

FE_TONEAREST
fenv.h(ISO):Section 20.6 [Rounding Modes], page 613.

FE_TOWARDZERO
fenv.h(ISO):Section 20.6 [Rounding Modes], page 613.

FE_UNDERFLOW
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

FE_UPWARD
fenv.h(ISO):Section 20.6 [Rounding Modes], page 613.

FILE
stdio.h(ISO):Section 12.1 [Streams], page 266.

int FILENAME_MAX
stdio.h(ISO):Section 32.6 [Limits on File System Capacity], page 903.

FLT_DIG
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_EPSILON
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MANT_DIG
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MAX
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MAX_10_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MAX_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MIN
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MIN_10_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_MIN_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

FLT_RADIX
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.


Appendix B: Summary of Library Facilities 978

FLT_ROUNDS
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

tcflag_t FLUSHO
termios.h(BSD):Section 17.4.7 [Local Modes], page 512.

FNM_CASEFOLD
fnmatch.h(GNU):Section 10.1 [Wildcard Matching], page 239.

FNM_EXTMATCH
fnmatch.h(GNU):Section 10.1 [Wildcard Matching], page 239.

FNM_FILE_NAME
fnmatch.h(GNU):Section 10.1 [Wildcard Matching], page 239.

FNM_LEADING_DIR
fnmatch.h(GNU):Section 10.1 [Wildcard Matching], page 239.

FNM_NOESCAPE
fnmatch.h(POSIX.2):Section 10.1 [Wildcard Matching], page 239.

FNM_PATHNAME
fnmatch.h(POSIX.2):Section 10.1 [Wildcard Matching], page 239.

FNM_PERIOD
fnmatch.h(POSIX.2):Section 10.1 [Wildcard Matching], page 239.

int FOPEN_MAX
stdio.h(ISO):Section 12.3 [Opening Streams], page 267.

FPE_DECOVF_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_FLTDIV_FAULT
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_FLTDIV_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_FLTOVF_FAULT
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_FLTOVF_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_FLTUND_FAULT
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_FLTUND_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_INTDIV_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_INTOVF_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

FPE_SUBRNG_TRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

int FP_ILOGB0
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

int FP_ILOGBNAN
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

FP_INFINITE
math.h(C99):Section 20.4 [Floating-Point Number Classification Functions], page 605.


Appendix B: Summary of Library Facilities 979

FP_INT_DOWNWARD
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

FP_INT_TONEAREST
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

FP_INT_TONEARESTFROMZERO
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

FP_INT_TOWARDZERO
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

FP_INT_UPWARD
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long int FP_LLOGB0
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

long int FP_LLOGBNAN
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

FP_NAN
math.h(C99):Section 20.4 [Floating-Point Number Classification Functions], page 605.

FP_NORMAL
math.h(C99):Section 20.4 [Floating-Point Number Classification Functions], page 605.

FP_SUBNORMAL
math.h(C99):Section 20.4 [Floating-Point Number Classification Functions], page 605.

FP_ZERO
math.h(C99):Section 20.4 [Floating-Point Number Classification Functions], page 605.

struct FTW
ftw.h(XPG4.2):Section 14.3 [Working with Directory Trees], page 414.

int F_DUPFD
fcntl.h(POSIX.1):Section 13.13 [Duplicating Descriptors], page 384.

int F_GETFD
fcntl.h(POSIX.1):Section 13.14 [File Descriptor Flags], page 386.

int F_GETFL
fcntl.h(POSIX.1):Section 13.15.4 [Getting and Setting File Status Flags], page 392.

int F_GETLK
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

int F_GETOWN
fcntl.h(BSD):Section 13.19 [Interrupt-Driven Input], page 400.

int F_OFD_SETLK
fcntl.h(POSIX.1):Section 13.17 [Open File Description Locks], page 396.

int F_OFD_SETLKW
fcntl.h(POSIX.1):Section 13.17 [Open File Description Locks], page 396.

int F_OK
unistd.h(POSIX.1):Section 14.9.8 [Testing Permission to Access a File], page 438.

F_RDLCK
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

int F_SETFD
fcntl.h(POSIX.1):Section 13.14 [File Descriptor Flags], page 386.


Appendix B: Summary of Library Facilities 980

int F_SETFL
fcntl.h(POSIX.1):Section 13.15.4 [Getting and Setting File Status Flags], page 392.

int F_SETLK
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

int F_SETLKW
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

int F_SETOWN
fcntl.h(BSD):Section 13.19 [Interrupt-Driven Input], page 400.

F_UNLCK
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

F_WRLCK
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

GLOB_ABORTED
glob.h(POSIX.2):Section 10.2.1 [Callingglob], page 240.

GLOB_ALTDIRFUNC
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

GLOB_APPEND
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_BRACE
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

GLOB_DOOFFS
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_ERR
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_MAGCHAR
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

GLOB_MARK
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_NOCHECK
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_NOESCAPE
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_NOMAGIC
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

GLOB_NOMATCH
glob.h(POSIX.2):Section 10.2.1 [Callingglob], page 240.

GLOB_NOSORT
glob.h(POSIX.2):Section 10.2.2 [Flags for Globbing], page 245.

GLOB_NOSPACE
glob.h(POSIX.2):Section 10.2.1 [Callingglob], page 240.

GLOB_ONLYDIR
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

GLOB_PERIOD
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.


Appendix B: Summary of Library Facilities 981

GLOB_TILDE
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

GLOB_TILDE_CHECK
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

HOST_NOT_FOUND
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

double HUGE_VAL
math.h(ISO):Section 20.5.4 [Error Reporting by Mathematical Functions], page 612.

float HUGE_VALF
math.h(ISO):Section 20.5.4 [Error Reporting by Mathematical Functions], page 612.

long double HUGE_VALL
math.h(ISO):Section 20.5.4 [Error Reporting by Mathematical Functions], page 612.

_FloatN HUGE_VAL_FN
math.h(TS 18661-3:2015): Section 20.5.4 [Error Reporting by Mathematical Functions],
page 612.

_FloatNx HUGE_VAL_FNx
math.h(TS 18661-3:2015): Section 20.5.4 [Error Reporting by Mathematical Functions],
page 612.

tcflag_t HUPCL
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

const float complex I
complex.h(C99):Section 20.9 [Complex Numbers], page 633.

tcflag_t ICANON
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t ICRNL
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t IEXTEN
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

size_t IFNAMSIZ
net/if.h(???):Section 16.4 [Interface Naming], page 460.

int IFTODT (mode_tmode)
dirent.h(BSD):Section 14.2.1 [Format of a Directory Entry], page 404.

tcflag_t IGNBRK
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t IGNCR
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t IGNPAR
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t IMAXBEL
termios.h(BSD):Section 17.4.4 [Input Modes], page 508.

uint32_t INADDR_ANY
netinet/in.h(BSD):Section 16.6.2.2 [Host Address Data Type], page 467.

uint32_t INADDR_BROADCAST
netinet/in.h(BSD):Section 16.6.2.2 [Host Address Data Type], page 467.

uint32_t INADDR_LOOPBACK
netinet/in.h(BSD):Section 16.6.2.2 [Host Address Data Type], page 467.


Appendix B: Summary of Library Facilities 982

uint32_t INADDR_NONE
netinet/in.h(BSD):Section 16.6.2.2 [Host Address Data Type], page 467.

float INFINITY
math.h(ISO):Section 20.5.2 [Infinity and NaN], page 609.

INIT_PROCESS
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

tcflag_t INLCR
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t INPCK
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

INTPTR_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

INT_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

INT_MIN
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

INT_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

int IPPORT_RESERVED
netinet/in.h(BSD):Section 16.6.3 [Internet Ports], page 473.

int IPPORT_USERRESERVED
netinet/in.h(BSD):Section 16.6.3 [Internet Ports], page 473.

tcflag_t ISIG
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t ISTRIP
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

ITIMER_PROF
sys/time.h(BSD):Section 21.6 [Setting an Alarm], page 679.

ITIMER_REAL
sys/time.h(BSD):Section 21.6 [Setting an Alarm], page 679.

ITIMER_VIRTUAL
sys/time.h(BSD):Section 21.6 [Setting an Alarm], page 679.

tcflag_t IXANY
termios.h(BSD):Section 17.4.4 [Input Modes], page 508.

tcflag_t IXOFF
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t IXON
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

LANG
locale.h(ISO):Section 7.3 [Locale Categories], page 184.

LC_ALL
locale.h(ISO):Section 7.3 [Locale Categories], page 184.

LC_COLLATE
locale.h(ISO):Section 7.3 [Locale Categories], page 184.


Appendix B: Summary of Library Facilities 983

LC_CTYPE
locale.h(ISO):Section 7.3 [Locale Categories], page 184.

LC_MESSAGES
locale.h(XOPEN):Section 7.3 [Locale Categories], page 184.

LC_MONETARY
locale.h(ISO):Section 7.3 [Locale Categories], page 184.

LC_NUMERIC
locale.h(ISO):Section 7.3 [Locale Categories], page 184.

LC_TIME
locale.h(ISO):Section 7.3 [Locale Categories], page 184.

LDBL_DIG
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_EPSILON
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MANT_DIG
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MAX
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MAX_10_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MAX_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MIN
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MIN_10_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

LDBL_MIN_EXP
float.h(C90):Section A.5.3.2 [Floating Point Parameters], page 961.

int LINE_MAX
limits.h(POSIX.2):Section 32.10 [Utility Program Capacity Limits], page 908.

int LINK_MAX
limits.hoptional(POSIX.1):Section 32.6 [Limits on File System Capacity], page 903.

LLONG_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

LLONG_MIN
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

LLONG_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

LOGIN_PROCESS
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

LONG_LONG_MAX
limits.h(GNU):Section A.5.2 [Range of an Integer Type], page 958.

LONG_LONG_MIN
limits.h(GNU):Section A.5.2 [Range of an Integer Type], page 958.


Appendix B: Summary of Library Facilities 984

LONG_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

LONG_MIN
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

LONG_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

L_INCR
sys/file.h(BSD):Section 12.18 [File Positioning], page 323.

L_SET
sys/file.h(BSD):Section 12.18 [File Positioning], page 323.

L_XTND
sys/file.h(BSD):Section 12.18 [File Positioning], page 323.

int L_ctermid
stdio.h(POSIX.1):Section 28.6.1 [Identifying the Controlling Terminal], page 831.

int L_cuserid
stdio.h(POSIX.1):Section 30.11 [Identifying Who Logged In], page 855.

int L_tmpnam
stdio.h(ISO):Section 14.11 [Temporary Files], page 446.

MADV_HUGEPAGE
sys/mman.h(Linux):Section 13.8 [Memory-mapped I/O], page 360.

MAP_HUGETLB
sys/mman.h(Linux):Section 13.8 [Memory-mapped I/O], page 360.

int MAXNAMLEN
dirent.h(BSD):Section 32.6 [Limits on File System Capacity], page 903.

int MAXSYMLINKS
sys/param.h(BSD):Section 14.5 [Symbolic Links], page 419.

int MAX_CANON
limits.h(POSIX.1):Section 32.6 [Limits on File System Capacity], page 903.

int MAX_INPUT
limits.h(POSIX.1):Section 32.6 [Limits on File System Capacity], page 903.

int MB_CUR_MAX
stdlib.h(ISO):Section 6.3.1 [Selecting the conversion and its properties], page 144.

int MB_LEN_MAX
limits.h(ISO):Section 6.3.1 [Selecting the conversion and its properties], page 144.

tcflag_t MDMBUF
termios.h(BSD):Section 17.4.6 [Control Modes], page 511.

MFD_ALLOW_SEALING
sys/mman.h(Linux):Section 13.8 [Memory-mapped I/O], page 360.

MFD_CLOEXEC
sys/mman.h(Linux):Section 13.8 [Memory-mapped I/O], page 360.

MFD_HUGETLB
sys/mman.h(Linux):Section 13.8 [Memory-mapped I/O], page 360.

MLOCK_ONFAULT
sys/mman.h(Linux):Section 3.5.3 [Functions To Lock And Unlock Pages], page 83.


Appendix B: Summary of Library Facilities 985

int MSG_DONTROUTE
sys/socket.h(BSD):Section 16.9.5.3 [Socket Data Options], page 487.

int MSG_OOB
sys/socket.h(BSD):Section 16.9.5.3 [Socket Data Options], page 487.

int MSG_PEEK
sys/socket.h(BSD):Section 16.9.5.3 [Socket Data Options], page 487.

int NAME_MAX
limits.h(POSIX.1):Section 32.6 [Limits on File System Capacity], page 903.

float NAN
math.h(GNU):Section 20.5.2 [Infinity and NaN], page 609.

int NCCS
termios.h(POSIX.1):Section 17.4.1 [Terminal Mode Data Types], page 505.

NEW_TIME
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

int NGROUPS_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

tcflag_t NOFLSH
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

tcflag_t NOKERNINFO
termios.hoptional(BSD):Section 17.4.7 [Local Modes], page 512.

NO_ADDRESS
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

NO_RECOVERY
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

int NSIG
signal.h(BSD):Section 24.2 [Standard Signals], page 716.

void * NULL
stddef.h(ISO):Section A.3 [Null Pointer Constant], page 955.

OLD_TIME
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

ONCE_FLAG_INIT
threads.h(C11):Section 35.1.3 [Call Once], page 923.

tcflag_t ONLCR
termios.h(POSIX.1):Section 17.4.5 [Output Modes], page 510.

tcflag_t ONOEOT
termios.hoptional(BSD):Section 17.4.5 [Output Modes], page 510.

int OPEN_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

tcflag_t OPOST
termios.h(POSIX.1):Section 17.4.5 [Output Modes], page 510.

OPTION_ALIAS
argp.h(GNU):Section 25.3.4.1 [Flags for Argp Options], page 771.


Appendix B: Summary of Library Facilities 986

OPTION_ARG_OPTIONAL
argp.h(GNU):Section 25.3.4.1 [Flags for Argp Options], page 771.

OPTION_DOC
argp.h(GNU):Section 25.3.4.1 [Flags for Argp Options], page 771.

OPTION_HIDDEN
argp.h(GNU):Section 25.3.4.1 [Flags for Argp Options], page 771.

OPTION_NO_USAGE
argp.h(GNU):Section 25.3.4.1 [Flags for Argp Options], page 771.

tcflag_t OXTABS
termios.hoptional(BSD):Section 17.4.5 [Output Modes], page 510.

int O_ACCMODE
fcntl.h(POSIX.1):Section 13.15.1 [File Access Modes], page 387.

int O_APPEND
fcntl.h(POSIX.1):Section 13.15.3 [I/O Operating Modes], page 391.

int O_ASYNC
fcntl.h(BSD):Section 13.15.3 [I/O Operating Modes], page 391.

int O_CREAT
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.

int O_DIRECTORY
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.

int O_EXCL
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.

int O_EXEC
fcntl.hoptional(GNU):Section 13.15.1 [File Access Modes], page 387.

int O_EXLOCK
fcntl.hoptional(BSD):Section 13.15.2 [Open-time Flags], page 388.

int O_FSYNC
fcntl.h(BSD):Section 13.15.3 [I/O Operating Modes], page 391.

int O_IGNORE_CTTY
fcntl.hoptional(GNU):Section 13.15.2 [Open-time Flags], page 388.

int O_NDELAY
fcntl.h(BSD):Section 13.15.3 [I/O Operating Modes], page 391.

int O_NOATIME
fcntl.h(GNU):Section 13.15.3 [I/O Operating Modes], page 391.

int O_NOCTTY
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.

int O_NOFOLLOW
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.

int O_NOLINK
fcntl.hoptional(GNU):Section 13.15.2 [Open-time Flags], page 388.

int O_NONBLOCK
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.
fcntl.h(POSIX.1):Section 13.15.3 [I/O Operating Modes], page 391.

int O_NOTRANS
fcntl.hoptional(GNU):Section 13.15.2 [Open-time Flags], page 388.


Appendix B: Summary of Library Facilities 987

int O_PATH
fcntl.h(Linux):Section 13.15.1 [File Access Modes], page 387.

int O_RDONLY
fcntl.h(POSIX.1):Section 13.15.1 [File Access Modes], page 387.

int O_RDWR
fcntl.h(POSIX.1):Section 13.15.1 [File Access Modes], page 387.

int O_READ
fcntl.hoptional(GNU):Section 13.15.1 [File Access Modes], page 387.

int O_SHLOCK
fcntl.hoptional(BSD):Section 13.15.2 [Open-time Flags], page 388.

int O_SYNC
fcntl.h(BSD):Section 13.15.3 [I/O Operating Modes], page 391.

int O_TMPFILE
fcntl.h(GNU):Section 13.15.2 [Open-time Flags], page 388.

int O_TRUNC
fcntl.h(POSIX.1):Section 13.15.2 [Open-time Flags], page 388.

int O_WRITE
fcntl.hoptional(GNU):Section 13.15.1 [File Access Modes], page 387.

int O_WRONLY
fcntl.h(POSIX.1):Section 13.15.1 [File Access Modes], page 387.

tcflag_t PARENB
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

tcflag_t PARMRK
termios.h(POSIX.1):Section 17.4.4 [Input Modes], page 508.

tcflag_t PARODD
termios.h(POSIX.1):Section 17.4.6 [Control Modes], page 511.

int PATH_MAX
limits.h(POSIX.1):Section 32.6 [Limits on File System Capacity], page 903.

PA_CHAR
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_DOUBLE
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_FLAG_LONG
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_FLAG_LONG_DOUBLE
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_FLAG_LONG_LONG
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

int PA_FLAG_MASK
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_FLAG_PTR
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_FLAG_SHORT
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.


Appendix B: Summary of Library Facilities 988

PA_FLOAT
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_INT
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_LAST
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_POINTER
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

PA_STRING
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

tcflag_t PENDIN
termios.h(BSD):Section 17.4.7 [Local Modes], page 512.

int PF_FILE
sys/socket.h(GNU):Section 16.5.2 [Details of Local Namespace], page 461.

int PF_INET
sys/socket.h(BSD):Section 16.6 [The Internet Namespace], page 463.

int PF_INET6
sys/socket.h(X/Open):Section 16.6 [The Internet Namespace], page 463.

int PF_LOCAL
sys/socket.h(POSIX):Section 16.5.2 [Details of Local Namespace], page 461.

int PF_UNIX
sys/socket.h(BSD):Section 16.5.2 [Details of Local Namespace], page 461.

int PIPE_BUF
limits.h(POSIX.1):Section 32.6 [Limits on File System Capacity], page 903.

PKEY_DISABLE_ACCESS
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

PKEY_DISABLE_WRITE
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

POSIX_REC_INCR_XFER_SIZE
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

POSIX_REC_MAX_XFER_SIZE
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

POSIX_REC_MIN_XFER_SIZE
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

POSIX_REC_XFER_ALIGN
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

PRIO_MAX
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

PRIO_MIN
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

PRIO_PGRP
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

PRIO_PROCESS
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.


Appendix B: Summary of Library Facilities 989

PRIO_USER
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

PROT_EXEC
sys/mman.h(POSIX):Section 3.4 [Memory Protection], page 77.

PROT_NONE
sys/mman.h(POSIX):Section 3.4 [Memory Protection], page 77.

PROT_READ
sys/mman.h(POSIX):Section 3.4 [Memory Protection], page 77.

PROT_WRITE
sys/mman.h(POSIX):Section 3.4 [Memory Protection], page 77.

PTRDIFF_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

char * P_tmpdir
stdio.h(SVID):Section 14.11 [Temporary Files], page 446.

int RAND_MAX
stdlib.h(ISO):Section 19.8.1 [ISO C Random Number Functions], page 592.

REG_BADBR
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_BADPAT
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_BADRPT
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_EBRACE
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_EBRACK
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_ECOLLATE
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_ECTYPE
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_EESCAPE
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_EPAREN
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_ERANGE
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_ESPACE
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.
regex.h(POSIX.2): Section 10.3.3 [Matching a Compiled POSIX Regular Expression],
page 251.

REG_ESUBREG
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

REG_EXTENDED
regex.h(POSIX.2):Section 10.3.2 [Flags for POSIX Regular Expressions], page 250.


Appendix B: Summary of Library Facilities 990

REG_ICASE
regex.h(POSIX.2):Section 10.3.2 [Flags for POSIX Regular Expressions], page 250.

REG_NEWLINE
regex.h(POSIX.2):Section 10.3.2 [Flags for POSIX Regular Expressions], page 250.

REG_NOMATCH
regex.h(POSIX.2): Section 10.3.3 [Matching a Compiled POSIX Regular Expression],
page 251.

REG_NOSUB
regex.h(POSIX.2):Section 10.3.2 [Flags for POSIX Regular Expressions], page 250.

REG_NOTBOL
regex.h(POSIX.2): Section 10.3.3 [Matching a Compiled POSIX Regular Expression],
page 251.

REG_NOTEOL
regex.h(POSIX.2): Section 10.3.3 [Matching a Compiled POSIX Regular Expression],
page 251.

int RE_DUP_MAX
limits.h(POSIX.2):Section 32.1 [General Capacity Limits], page 890.

RLIMIT_AS
sys/resource.h(Unix98):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_CORE
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_CPU
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_DATA
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_FSIZE
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_MEMLOCK
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_NOFILE
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_NPROC
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_RSS
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIMIT_STACK
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

rlim_t RLIM_INFINITY
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RLIM_NLIMITS
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

RUN_LVL
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

RUSAGE_CHILDREN
sys/resource.h(BSD):Section 22.1 [Resource Usage], page 684.


Appendix B: Summary of Library Facilities 991

RUSAGE_SELF
sys/resource.h(BSD):Section 22.1 [Resource Usage], page 684.

int R_OK
unistd.h(POSIX.1):Section 14.9.8 [Testing Permission to Access a File], page 438.

int SA_NOCLDSTOP
signal.h(POSIX.1):Section 24.3.5 [Flags forsigaction], page 730.

int SA_ONSTACK
signal.h(BSD):Section 24.3.5 [Flags forsigaction], page 730.

int SA_RESTART
signal.h(BSD):Section 24.3.5 [Flags forsigaction], page 730.

SCHAR_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

SCHAR_MIN
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

SCHAR_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

int SEEK_CUR
stdio.h(ISO):Section 12.18 [File Positioning], page 323.

int SEEK_END
stdio.h(ISO):Section 12.18 [File Positioning], page 323.

int SEEK_SET
stdio.h(ISO):Section 12.18 [File Positioning], page 323.

SHRT_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

SHRT_MIN
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

SHRT_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

int SIGABRT
signal.h(ISO):Section 24.2.1 [Program Error Signals], page 716.

int SIGALRM
signal.h(POSIX.1):Section 24.2.3 [Alarm Signals], page 720.

int SIGBUS
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

int SIGCHLD
signal.h(POSIX.1):Section 24.2.5 [Job Control Signals], page 721.

int SIGCLD
signal.h(SVID):Section 24.2.5 [Job Control Signals], page 721.

int SIGCONT
signal.h(POSIX.1):Section 24.2.5 [Job Control Signals], page 721.

int SIGEMT
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

int SIGFPE
signal.h(ISO):Section 24.2.1 [Program Error Signals], page 716.


Appendix B: Summary of Library Facilities 992

int SIGHUP
signal.h(POSIX.1):Section 24.2.2 [Termination Signals], page 719.

int SIGILL
signal.h(ISO):Section 24.2.1 [Program Error Signals], page 716.

int SIGINFO
signal.h(BSD):Section 24.2.7 [Miscellaneous Signals], page 723.

int SIGINT
signal.h(ISO):Section 24.2.2 [Termination Signals], page 719.

int SIGIO
signal.h(BSD):Section 24.2.4 [Asynchronous I/O Signals], page 720.

int SIGIOT
signal.h(Unix):Section 24.2.1 [Program Error Signals], page 716.

int SIGKILL
signal.h(POSIX.1):Section 24.2.2 [Termination Signals], page 719.

int SIGLOST
signal.h(GNU):Section 24.2.6 [Operation Error Signals], page 722.

int SIGPIPE
signal.h(POSIX.1):Section 24.2.6 [Operation Error Signals], page 722.

int SIGPOLL
signal.h(SVID):Section 24.2.4 [Asynchronous I/O Signals], page 720.

int SIGPROF
signal.h(BSD):Section 24.2.3 [Alarm Signals], page 720.

int SIGQUIT
signal.h(POSIX.1):Section 24.2.2 [Termination Signals], page 719.

int SIGSEGV
signal.h(ISO):Section 24.2.1 [Program Error Signals], page 716.

int SIGSTOP
signal.h(POSIX.1):Section 24.2.5 [Job Control Signals], page 721.

int SIGSYS
signal.h(Unix):Section 24.2.1 [Program Error Signals], page 716.

int SIGTERM
signal.h(ISO):Section 24.2.2 [Termination Signals], page 719.

int SIGTRAP
signal.h(BSD):Section 24.2.1 [Program Error Signals], page 716.

int SIGTSTP
signal.h(POSIX.1):Section 24.2.5 [Job Control Signals], page 721.

int SIGTTIN
signal.h(POSIX.1):Section 24.2.5 [Job Control Signals], page 721.

int SIGTTOU
signal.h(POSIX.1):Section 24.2.5 [Job Control Signals], page 721.

int SIGURG
signal.h(BSD):Section 24.2.4 [Asynchronous I/O Signals], page 720.


Appendix B: Summary of Library Facilities 993

int SIGUSR1
signal.h(POSIX.1):Section 24.2.7 [Miscellaneous Signals], page 723.

int SIGUSR2
signal.h(POSIX.1):Section 24.2.7 [Miscellaneous Signals], page 723.

int SIGVTALRM
signal.h(BSD):Section 24.2.3 [Alarm Signals], page 720.

int SIGWINCH
signal.h(BSD):Section 24.2.7 [Miscellaneous Signals], page 723.

int SIGXCPU
signal.h(BSD):Section 24.2.6 [Operation Error Signals], page 722.

int SIGXFSZ
signal.h(BSD):Section 24.2.6 [Operation Error Signals], page 722.

SIG_ATOMIC_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

SIG_BLOCK
signal.h(POSIX.1):Section 24.7.3 [Process Signal Mask], page 748.

sighandler_t SIG_ERR
signal.h(ISO):Section 24.3.1 [Basic Signal Handling], page 725.

SIG_SETMASK
signal.h(POSIX.1):Section 24.7.3 [Process Signal Mask], page 748.

SIG_UNBLOCK
signal.h(POSIX.1):Section 24.7.3 [Process Signal Mask], page 748.

SIZE_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

double SNAN
math.h(TS 18661-1:2014):Section 20.5.2 [Infinity and NaN], page 609.

float SNANF
math.h(TS 18661-1:2014):Section 20.5.2 [Infinity and NaN], page 609.

_FloatN SNANFN
math.h(TS 18661-3:2015):Section 20.5.2 [Infinity and NaN], page 609.

_FloatNx SNANFNx
math.h(TS 18661-3:2015):Section 20.5.2 [Infinity and NaN], page 609.

long double SNANL
math.h(TS 18661-1:2014):Section 20.5.2 [Infinity and NaN], page 609.

int SOCK_DGRAM
sys/socket.h(BSD):Section 16.2 [Communication Styles], page 456.

int SOCK_RAW
sys/socket.h(BSD):Section 16.2 [Communication Styles], page 456.

int SOCK_STREAM
sys/socket.h(BSD):Section 16.2 [Communication Styles], page 456.

int SOL_SOCKET
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_BROADCAST
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.


Appendix B: Summary of Library Facilities 994

SO_DEBUG
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_DONTROUTE
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_ERROR
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_KEEPALIVE
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_LINGER
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_OOBINLINE
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_RCVBUF
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_REUSEADDR
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_SNDBUF
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

SO_STYLE
sys/socket.h(GNU):Section 16.12.2 [Socket-Level Options], page 499.

SO_TYPE
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

ssize_t SSIZE_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

STDERR_FILENO
unistd.h(POSIX.1):Section 13.4 [Descriptors and Streams], page 352.

STDIN_FILENO
unistd.h(POSIX.1):Section 13.4 [Descriptors and Streams], page 352.

STDOUT_FILENO
unistd.h(POSIX.1):Section 13.4 [Descriptors and Streams], page 352.

int STREAM_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

int SUN_LEN (struct sockaddr_un * ptr)
sys/un.h(BSD):Section 16.5.2 [Details of Local Namespace], page 461.

SYMLINK_MAX
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

S_IEXEC
sys/stat.h(BSD):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IFBLK
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

S_IFCHR
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

S_IFDIR
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.


Appendix B: Summary of Library Facilities 995

S_IFIFO
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

S_IFLNK
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

int S_IFMT
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

S_IFREG
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

S_IFSOCK
sys/stat.h(BSD):Section 14.9.3 [Testing the Type of a File], page 431.

S_IREAD
sys/stat.h(BSD):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IRGRP
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IROTH
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IRUSR
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IRWXG
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IRWXO
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IRWXU
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

int S_ISBLK (mode_tm)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

int S_ISCHR (mode_tm)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

int S_ISDIR (mode_tm)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

int S_ISFIFO (mode_tm)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

S_ISGID
sys/stat.h(POSIX):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

int S_ISLNK (mode_tm)
sys/stat.h(GNU):Section 14.9.3 [Testing the Type of a File], page 431.

int S_ISREG (mode_tm)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

int S_ISSOCK (mode_tm)
sys/stat.h(GNU):Section 14.9.3 [Testing the Type of a File], page 431.

S_ISUID
sys/stat.h(POSIX):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_ISVTX
sys/stat.h(BSD):Section 14.9.5 [The Mode Bits for Access Permission], page 434.


Appendix B: Summary of Library Facilities 996

S_IWGRP
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IWOTH
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IWRITE
sys/stat.h(BSD):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IWUSR
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IXGRP
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IXOTH
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

S_IXUSR
sys/stat.h(POSIX.1):Section 14.9.5 [The Mode Bits for Access Permission], page 434.

int S_TYPEISMQ (struct stat *s)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

int S_TYPEISSEM (struct stat *s)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

int S_TYPEISSHM (struct stat *s)
sys/stat.h(POSIX):Section 14.9.3 [Testing the Type of a File], page 431.

TCSADRAIN
termios.h(POSIX.1):Section 17.4.2 [Terminal Mode Functions], page 506.

TCSAFLUSH
termios.h(POSIX.1):Section 17.4.2 [Terminal Mode Functions], page 506.

TCSANOW
termios.h(POSIX.1):Section 17.4.2 [Terminal Mode Functions], page 506.

TCSASOFT
termios.h(BSD):Section 17.4.2 [Terminal Mode Functions], page 506.

TEMP_FAILURE_RETRY (expression)
unistd.h(GNU):Section 24.5 [Primitives Interrupted by Signals], page 741.

int TMP_MAX
stdio.h(ISO):Section 14.11 [Temporary Files], page 446.

tcflag_t TOSTOP
termios.h(POSIX.1):Section 17.4.7 [Local Modes], page 512.

TRY_AGAIN
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

TSS_DTOR_ITERATIONS
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

int TZNAME_MAX
limits.h(POSIX.1):Section 32.1 [General Capacity Limits], page 890.

UCHAR_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

UCHAR_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.


Appendix B: Summary of Library Facilities 997

UINTPTR_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

UINT_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

UINT_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

ULLONG_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

ULLONG_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

ULONG_LONG_MAX
limits.h(GNU):Section A.5.2 [Range of an Integer Type], page 958.

ULONG_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

ULONG_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

USER_PROCESS
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

USHRT_MAX
limits.h(ISO):Section A.5.2 [Range of an Integer Type], page 958.

USHRT_WIDTH
limits.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

int VDISCARD
termios.h(BSD):Section 17.4.9.4 [Other Special Characters], page 520.

int VDSUSP
termios.h(BSD):Section 17.4.9.2 [Characters that Cause Signals], page 518.

int VEOF
termios.h(POSIX.1):Section 17.4.9.1 [Characters for Input Editing], page 517.

int VEOL
termios.h(POSIX.1):Section 17.4.9.1 [Characters for Input Editing], page 517.

int VEOL2
termios.h(BSD):Section 17.4.9.1 [Characters for Input Editing], page 517.

int VERASE
termios.h(POSIX.1):Section 17.4.9.1 [Characters for Input Editing], page 517.

int VINTR
termios.h(POSIX.1):Section 17.4.9.2 [Characters that Cause Signals], page 518.

int VKILL
termios.h(POSIX.1):Section 17.4.9.1 [Characters for Input Editing], page 517.

int VLNEXT
termios.h(BSD):Section 17.4.9.4 [Other Special Characters], page 520.

int VMIN
termios.h(POSIX.1):Section 17.4.10 [Noncanonical Input], page 521.


Appendix B: Summary of Library Facilities 998

int VQUIT
termios.h(POSIX.1):Section 17.4.9.2 [Characters that Cause Signals], page 518.

int VREPRINT
termios.h(BSD):Section 17.4.9.1 [Characters for Input Editing], page 517.

int VSTART
termios.h(POSIX.1):Section 17.4.9.3 [Special Characters for Flow Control], page 519.

int VSTATUS
termios.h(BSD):Section 17.4.9.4 [Other Special Characters], page 520.

int VSTOP
termios.h(POSIX.1):Section 17.4.9.3 [Special Characters for Flow Control], page 519.

int VSUSP
termios.h(POSIX.1):Section 17.4.9.2 [Characters that Cause Signals], page 518.

int VTIME
termios.h(POSIX.1):Section 17.4.10 [Noncanonical Input], page 521.

int VWERASE
termios.h(BSD):Section 17.4.9.1 [Characters for Input Editing], page 517.

WCHAR_MAX
limits.h(GNU):Section A.5.2 [Range of an Integer Type], page 958.

wint_t WCHAR_MAX
wchar.h(ISO):Section 6.1 [Introduction to Extended Characters], page 140.

wint_t WCHAR_MIN
wchar.h(ISO):Section 6.1 [Introduction to Extended Characters], page 140.

WCHAR_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

int WCOREDUMP (intstatus)
sys/wait.h(BSD):Section 26.7 [Process Completion Status], page 812.

int WEOF
wchar.h(ISO):Section 12.15 [End-Of-File and Errors], page 320.

wint_t WEOF
wchar.h(ISO):Section 6.1 [Introduction to Extended Characters], page 140.

int WEXITSTATUS (intstatus)
sys/wait.h(POSIX.1):Section 26.7 [Process Completion Status], page 812.

int WIFEXITED (intstatus)
sys/wait.h(POSIX.1):Section 26.7 [Process Completion Status], page 812.

int WIFSIGNALED (intstatus)
sys/wait.h(POSIX.1):Section 26.7 [Process Completion Status], page 812.

int WIFSTOPPED (intstatus)
sys/wait.h(POSIX.1):Section 26.7 [Process Completion Status], page 812.

WINT_WIDTH
stdint.h(ISO):Section A.5.1 [Width of an Integer Type], page 957.

WRDE_APPEND
wordexp.h(POSIX.2):Section 10.4.3 [Flags for Word Expansion], page 256.

WRDE_BADCHAR
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.


Appendix B: Summary of Library Facilities 999

WRDE_BADVAL
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

WRDE_CMDSUB
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

WRDE_DOOFFS
wordexp.h(POSIX.2):Section 10.4.3 [Flags for Word Expansion], page 256.

WRDE_NOCMD
wordexp.h(POSIX.2):Section 10.4.3 [Flags for Word Expansion], page 256.

WRDE_NOSPACE
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

WRDE_REUSE
wordexp.h(POSIX.2):Section 10.4.3 [Flags for Word Expansion], page 256.

WRDE_SHOWERR
wordexp.h(POSIX.2):Section 10.4.3 [Flags for Word Expansion], page 256.

WRDE_SYNTAX
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

WRDE_UNDEF
wordexp.h(POSIX.2):Section 10.4.3 [Flags for Word Expansion], page 256.

int WSTOPSIG (intstatus)
sys/wait.h(POSIX.1):Section 26.7 [Process Completion Status], page 812.

int WTERMSIG (intstatus)
sys/wait.h(POSIX.1):Section 26.7 [Process Completion Status], page 812.

int W_OK
unistd.h(POSIX.1):Section 14.9.8 [Testing Permission to Access a File], page 438.

int X_OK
unistd.h(POSIX.1):Section 14.9.8 [Testing Permission to Access a File], page 438.

_ATFILE_SOURCE
no header(GNU):Section 1.3.4 [Feature Test Macros], page 15.

_CS_LFS64_CFLAGS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS64_LDFLAGS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS64_LIBS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS64_LINTFLAGS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS_CFLAGS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS_LDFLAGS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS_LIBS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_LFS_LINTFLAGS
unistd.h(Unix98):Section 32.12 [String-Valued Parameters], page 909.

_CS_PATH
unistd.h(POSIX.2):Section 32.12 [String-Valued Parameters], page 909.


Appendix B: Summary of Library Facilities 1000

const float complex _Complex_I
complex.h(C99):Section 20.9 [Complex Numbers], page 633.

_DEFAULT_SOURCE
no header(GNU):Section 1.3.4 [Feature Test Macros], page 15.

void _Exit (intstatus)
stdlib.h(ISO):Section 25.7.5 [Termination Internals], page 801.

_FILE_OFFSET_BITS
no header(X/Open):Section 1.3.4 [Feature Test Macros], page 15.

_FORTIFY_SOURCE
no header(GNU):Section 1.3.4 [Feature Test Macros], page 15.

_GNU_SOURCE
no header(GNU):Section 1.3.4 [Feature Test Macros], page 15.

int _IOFBF
stdio.h(ISO):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

int _IOLBF
stdio.h(ISO):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

int _IONBF
stdio.h(ISO):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

_ISOC11_SOURCE
no header(C11):Section 1.3.4 [Feature Test Macros], page 15.

_ISOC2X_SOURCE
no header(C2X):Section 1.3.4 [Feature Test Macros], page 15.

_ISOC99_SOURCE
no header(GNU):Section 1.3.4 [Feature Test Macros], page 15.

_LARGEFILE64_SOURCE
no header(X/Open):Section 1.3.4 [Feature Test Macros], page 15.

_LARGEFILE_SOURCE
no header(X/Open):Section 1.3.4 [Feature Test Macros], page 15.

_PC_ASYNC_IO
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_CHOWN_RESTRICTED
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_FILESIZEBITS
unistd.h(LFS):Section 32.9 [Usingpathconf], page 906.

_PC_LINK_MAX
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_MAX_CANON
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_MAX_INPUT
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_NAME_MAX
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_NO_TRUNC
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_PATH_MAX
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.


Appendix B: Summary of Library Facilities 1001

_PC_PIPE_BUF
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_PRIO_IO
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_REC_INCR_XFER_SIZE
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_REC_MAX_XFER_SIZE
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_REC_MIN_XFER_SIZE
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_REC_XFER_ALIGN
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_SYNC_IO
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_PC_VDISABLE
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

_POSIX2_BC_BASE_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

_POSIX2_BC_DIM_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

_POSIX2_BC_SCALE_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

_POSIX2_BC_STRING_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

_POSIX2_COLL_WEIGHTS_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

int _POSIX2_C_DEV
unistd.h(POSIX.2):Section 32.2 [Overall System Options], page 891.

long int _POSIX2_C_VERSION
unistd.h(POSIX.2):Section 32.3 [Which Version of POSIX is Supported], page 892.

_POSIX2_EQUIV_CLASS_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

_POSIX2_EXPR_NEST_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

int _POSIX2_FORT_DEV
unistd.h(POSIX.2):Section 32.2 [Overall System Options], page 891.

int _POSIX2_FORT_RUN
unistd.h(POSIX.2):Section 32.2 [Overall System Options], page 891.

_POSIX2_LINE_MAX
limits.h(POSIX.2):Section 32.11 [Minimum Values for Utility Limits], page 909.

int _POSIX2_LOCALEDEF
unistd.h(POSIX.2):Section 32.2 [Overall System Options], page 891.

_POSIX2_RE_DUP_MAX
limits.h(POSIX.2):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

int _POSIX2_SW_DEV
unistd.h(POSIX.2):Section 32.2 [Overall System Options], page 891.


Appendix B: Summary of Library Facilities 1002

_POSIX_AIO_LISTIO_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

_POSIX_AIO_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

_POSIX_ARG_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

_POSIX_CHILD_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

int _POSIX_CHOWN_RESTRICTED
unistd.h(POSIX.1):Section 32.7 [Optional Features in File Support], page 904.

_POSIX_C_SOURCE
no header(POSIX.2):Section 1.3.4 [Feature Test Macros], page 15.

int _POSIX_JOB_CONTROL
unistd.h(POSIX.1):Section 32.2 [Overall System Options], page 891.

_POSIX_LINK_MAX
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

_POSIX_MAX_CANON
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

_POSIX_MAX_INPUT
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

_POSIX_NAME_MAX
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

_POSIX_NGROUPS_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

int _POSIX_NO_TRUNC
unistd.h(POSIX.1):Section 32.7 [Optional Features in File Support], page 904.

_POSIX_OPEN_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

_POSIX_PATH_MAX
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

_POSIX_PIPE_BUF
limits.h(POSIX.1):Section 32.8 [Minimum Values for File System Limits], page 905.

int _POSIX_SAVED_IDS
unistd.h(POSIX.1):Section 32.2 [Overall System Options], page 891.

_POSIX_SOURCE
no header(POSIX.1):Section 1.3.4 [Feature Test Macros], page 15.

_POSIX_SSIZE_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

_POSIX_STREAM_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

_POSIX_TZNAME_MAX
limits.h(POSIX.1):Section 32.5 [Minimum Values for General Capacity Limits], page 902.

unsigned char _POSIX_VDISABLE
unistd.h(POSIX.1):Section 32.7 [Optional Features in File Support], page 904.

long int _POSIX_VERSION
unistd.h(POSIX.1):Section 32.3 [Which Version of POSIX is Supported], page 892.


Appendix B: Summary of Library Facilities 1003

_REENTRANT
no header(Obsolete):Section 1.3.4 [Feature Test Macros], page 15.

_SC_2_C_DEV
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_2_FORT_DEV
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_2_FORT_RUN
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_2_LOCALEDEF
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_2_SW_DEV
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_2_VERSION
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_AIO_LISTIO_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_AIO_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_AIO_PRIO_DELTA_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_ARG_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_ASYNCHRONOUS_IO
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_ATEXIT_MAX
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_AVPHYS_PAGES
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_BC_BASE_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_BC_DIM_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_BC_SCALE_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_BC_STRING_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_CHARCLASS_NAME_MAX
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_CHAR_BIT
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_CHAR_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_CHAR_MIN
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_CHILD_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.


Appendix B: Summary of Library Facilities 1004

_SC_CLK_TCK
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_COLL_WEIGHTS_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_DELAYTIMER_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_EQUIV_CLASS_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_EXPR_NEST_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_FSYNC
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_GETGR_R_SIZE_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_GETPW_R_SIZE_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_INT_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_INT_MIN
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_JOB_CONTROL
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL1_DCACHE_ASSOC
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL1_DCACHE_LINESIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL1_DCACHE_SIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL1_ICACHE_ASSOC
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL1_ICACHE_LINESIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL1_ICACHE_SIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL2_CACHE_ASSOC
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL2_CACHE_LINESIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL2_CACHE_SIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL3_CACHE_ASSOC
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL3_CACHE_LINESIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL3_CACHE_SIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.


Appendix B: Summary of Library Facilities 1005

_SC_LEVEL4_CACHE_ASSOC
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL4_CACHE_LINESIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LEVEL4_CACHE_SIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LINE_MAX
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LOGIN_NAME_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_LONG_BIT
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MAPPED_FILES
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MB_LEN_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MEMLOCK
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MEMLOCK_RANGE
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MEMORY_PROTECTION
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MESSAGE_PASSING
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MQ_OPEN_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_MQ_PRIO_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NGROUPS_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NL_ARGMAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NL_LANGMAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NL_MSGMAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NL_NMAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NL_SETMAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NL_TEXTMAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NPROCESSORS_CONF
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_NPROCESSORS_ONLN
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.


Appendix B: Summary of Library Facilities 1006

_SC_NZERO
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_OPEN_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PAGESIZE
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PHYS_PAGES
unistd.h(GNU):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_INTERNET
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_INTERNET_DGRAM
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_INTERNET_STREAM
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_OSI
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_OSI_CLTS
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_OSI_COTS
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_OSI_M
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_SOCKET
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PII_XTI
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PRIORITIZED_IO
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_PRIORITY_SCHEDULING
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_REALTIME_SIGNALS
unistdh.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_RTSIG_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SAVED_IDS
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SCHAR_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SCHAR_MIN
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SELECT
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SEMAPHORES
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.


Appendix B: Summary of Library Facilities 1007

_SC_SEM_NSEMS_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SEM_VALUE_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SHARED_MEMORY_OBJECTS
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SHRT_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SHRT_MIN
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SIGQUEUE_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SSIZE_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_STREAM_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_SYNCHRONIZED_IO
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREADS
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_ATTR_STACKADDR
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_ATTR_STACKSIZE
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_DESTRUCTOR_ITERATIONS
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_KEYS_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_PRIORITY_SCHEDULING
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_PRIO_INHERIT
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_PRIO_PROTECT
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_PROCESS_SHARED
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_SAFE_FUNCTIONS
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_STACK_MIN
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_THREAD_THREADS_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_TIMERS
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_TIMER_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.


Appendix B: Summary of Library Facilities 1008

_SC_TTY_NAME_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_TZNAME_MAX
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_T_IOV_MAX
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_UCHAR_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_UINT_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_UIO_MAXIOV
unistd.h(POSIX.1g):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_ULONG_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_USHRT_MAX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_VERSION
unistd.h(POSIX.1):Section 32.4.2 [Constants forsysconfParameters], page 893.
unistd.h(POSIX.2):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_WORD_BIT
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_CRYPT
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_ENH_I18N
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_LEGACY
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_REALTIME
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_REALTIME_THREADS
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_SHM
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_UNIX
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_VERSION
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_XCU_VERSION
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_XPG2
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_XPG3
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_SC_XOPEN_XPG4
unistd.h(X/Open):Section 32.4.2 [Constants forsysconfParameters], page 893.

_THREAD_SAFE
no header(Obsolete):Section 1.3.4 [Feature Test Macros], page 15.


Appendix B: Summary of Library Facilities 1009

_XOPEN_SOURCE
no header(X/Open):Section 1.3.4 [Feature Test Macros], page 15.

_XOPEN_SOURCE_EXTENDED
no header(X/Open):Section 1.3.4 [Feature Test Macros], page 15.

__STDC_WANT_IEC_60559_BFP_EXT__
no header(ISO):Section 1.3.4 [Feature Test Macros], page 15.

__STDC_WANT_IEC_60559_FUNCS_EXT__
no header(ISO):Section 1.3.4 [Feature Test Macros], page 15.

__STDC_WANT_IEC_60559_TYPES_EXT__
no header(ISO):Section 1.3.4 [Feature Test Macros], page 15.

__STDC_WANT_LIB_EXT2__
no header(ISO):Section 1.3.4 [Feature Test Macros], page 15.

size_t __fbufsize (FILE *stream)
stdio_ext.h(GNU):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

int __flbf (FILE *stream)
stdio_ext.h(GNU):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

size_t __fpending (FILE *stream)
stdio_ext.h(GNU):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

void __fpurge (FILE *stream)
stdio_ext.h(GNU):Section 12.20.2 [Flushing Buffers], page 329.

int __freadable (FILE *stream)
stdio_ext.h(GNU):Section 12.3 [Opening Streams], page 267.

int __freading (FILE *stream)
stdio_ext.h(GNU):Section 12.3 [Opening Streams], page 267.

__free_hook
malloc.h(GNU):Section 3.2.3.9 [Memory Allocation Hooks], page 54.

int __fsetlocking (FILE *stream, inttype)
stdio_ext.h(GNU):Section 12.5 [Streams and Threads], page 272.

__ftw64_func_t
ftw.h(GNU):Section 14.3 [Working with Directory Trees], page 414.

__ftw_func_t
ftw.h(GNU):Section 14.3 [Working with Directory Trees], page 414.

int __fwritable (FILE *stream)
stdio_ext.h(GNU):Section 12.3 [Opening Streams], page 267.

int __fwriting (FILE *stream)
stdio_ext.h(GNU):Section 12.3 [Opening Streams], page 267.

void (*__gconv_end_fct) (struct gconv_step *)
gconv.h(GNU):Section 6.5.4 [TheiconvImplementation in the GNU C Library], page 169.

int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *, const char **, const
char *, size_t *, int)
gconv.h(GNU):Section 6.5.4 [TheiconvImplementation in the GNU C Library], page 169.

int (*__gconv_init_fct) (struct __gconv_step *)
gconv.h(GNU):Section 6.5.4 [TheiconvImplementation in the GNU C Library], page 169.

struct __gconv_step
gconv.h(GNU):Section 6.5.4 [TheiconvImplementation in the GNU C Library], page 169.

struct __gconv_step_data
gconv.h(GNU):Section 6.5.4 [TheiconvImplementation in the GNU C Library], page 169.


Appendix B: Summary of Library Facilities 1010

char __libc_single_threaded
sys/single_threaded.h(GNU):Section 35.2.2.4 [Detecting Single-Threaded Execution],
page 931.

__malloc_hook
malloc.h(GNU):Section 3.2.3.9 [Memory Allocation Hooks], page 54.

__memalign_hook
malloc.h(GNU):Section 3.2.3.9 [Memory Allocation Hooks], page 54.

__nftw64_func_t
ftw.h(GNU):Section 14.3 [Working with Directory Trees], page 414.

__nftw_func_t
ftw.h(GNU):Section 14.3 [Working with Directory Trees], page 414.

__realloc_hook
malloc.h(GNU):Section 3.2.3.9 [Memory Allocation Hooks], page 54.

void __va_copy (va_listdest, va_listsrc)
stdarg.h(GNU):Section A.2.2.5 [Argument Access Macros], page 953.

void _exit (intstatus)
unistd.h(POSIX.1):Section 25.7.5 [Termination Internals], page 801.

void _flushlbf (void)
stdio_ext.h(GNU):Section 12.20.2 [Flushing Buffers], page 329.

int _tolower (intc)
ctype.h(SVID):Section 4.2 [Case Conversion], page 89.

int _toupper (intc)
ctype.h(SVID):Section 4.2 [Case Conversion], page 89.

long int a64l (const char *string)
stdlib.h(XPG):Section 5.14 [Encode Binary Data], page 133.

void abort (void)
stdlib.h(ISO):Section 25.7.4 [Aborting a Program], page 801.

int abs (intnumber)
stdlib.h(ISO):Section 20.8.1 [Absolute Value], page 617.

int accept (intsocket, struct sockaddr *addr, socklen_t *length_ptr)
sys/socket.h(BSD):Section 16.9.3 [Accepting Connections], page 484.

int access (const char *filename, inthow)
unistd.h(POSIX.1):Section 14.9.8 [Testing Permission to Access a File], page 438.

double acos (doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

float acosf (floatx)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatN acosfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatNx acosfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

double acosh (doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

float acoshf (floatx)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

_FloatN acoshfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.


Appendix B: Summary of Library Facilities 1011

_FloatNx acoshfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

long double acoshl (long doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

long double acosl (long doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

int addmntent (FILE *stream, const struct mntent *mnt)
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

int adjtime (const struct timeval *delta, struct timeval *olddelta)
sys/time.h(BSD):Section 21.5.2 [Setting and Adjusting the Time], page 653.

int adjtimex (struct timex *timex)
sys/timex.h(GNU):Section 21.5.2 [Setting and Adjusting the Time], page 653.

int aio_cancel (intfildes, struct aiocb *aiocbp)
aio.h(POSIX.1b):Section 13.11.4 [Cancellation of AIO Operations], page 381.

int aio_cancel64 (intfildes, struct aiocb64 *aiocbp)
aio.h(Unix98):Section 13.11.4 [Cancellation of AIO Operations], page 381.

int aio_error (const struct aiocb *aiocbp)
aio.h(POSIX.1b):Section 13.11.2 [Getting the Status of AIO Operations], page 377.

int aio_error64 (const struct aiocb64 *aiocbp)
aio.h(Unix98):Section 13.11.2 [Getting the Status of AIO Operations], page 377.

int aio_fsync (intop, struct aiocb *aiocbp)
aio.h(POSIX.1b):Section 13.11.3 [Getting into a Consistent State], page 379.

int aio_fsync64 (intop, struct aiocb64 *aiocbp)
aio.h(Unix98):Section 13.11.3 [Getting into a Consistent State], page 379.

void aio_init (const struct aioinit *init)
aio.h(GNU):Section 13.11.5 [How to optimize the AIO implementation], page 382.

int aio_read (struct aiocb *aiocbp)
aio.h(POSIX.1b):Section 13.11.1 [Asynchronous Read and Write Operations], page 373.

int aio_read64 (struct aiocb64 *aiocbp)
aio.h(Unix98):Section 13.11.1 [Asynchronous Read and Write Operations], page 373.

ssize_t aio_return (struct aiocb *aiocbp)
aio.h(POSIX.1b):Section 13.11.2 [Getting the Status of AIO Operations], page 377.

ssize_t aio_return64 (struct aiocb64 *aiocbp)
aio.h(Unix98):Section 13.11.2 [Getting the Status of AIO Operations], page 377.

int aio_suspend (const struct aiocb *constlist[], intnent, const struct timespec *timeout)
aio.h(POSIX.1b):Section 13.11.3 [Getting into a Consistent State], page 379.

int aio_suspend64 (const struct aiocb64 *constlist[], intnent, const struct timespec
*timeout)
aio.h(Unix98):Section 13.11.3 [Getting into a Consistent State], page 379.

int aio_write (struct aiocb *aiocbp)
aio.h(POSIX.1b):Section 13.11.1 [Asynchronous Read and Write Operations], page 373.

int aio_write64 (struct aiocb64 *aiocbp)
aio.h(Unix98):Section 13.11.1 [Asynchronous Read and Write Operations], page 373.

struct aiocb
aio.h(POSIX.1b):Section 13.11 [Perform I/O Operations in Parallel], page 371.

struct aiocb64
aio.h(POSIX.1b):Section 13.11 [Perform I/O Operations in Parallel], page 371.


Appendix B: Summary of Library Facilities 1012

struct aioinit
aio.h(GNU):Section 13.11.5 [How to optimize the AIO implementation], page 382.

unsigned int alarm (unsigned intseconds)
unistd.h(POSIX.1):Section 21.6 [Setting an Alarm], page 679.

void * aligned_alloc (size_talignment, size_tsize)
stdlib.h(???):Section 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

void * alloca (size_tsize)
stdlib.h(GNU):Section 3.2.7 [Automatic Storage with Variable Size], page 74.
stdlib.h(BSD):Section 3.2.7 [Automatic Storage with Variable Size], page 74.

int alphasort (const struct dirent **a, const struct dirent **b)
dirent.h(BSD):Section 14.2.6 [Scanning the Content of a Directory], page 411.
dirent.h(SVID):Section 14.2.6 [Scanning the Content of a Directory], page 411.

int alphasort64 (const struct dirent64 **a, const struct dirent **b)
dirent.h(GNU):Section 14.2.6 [Scanning the Content of a Directory], page 411.

struct argp
argp.h(GNU):Section 25.3.3 [Specifying Argp Parsers], page 769.

struct argp_child
argp.h(GNU):Section 25.3.6 [Combining Multiple Argp Parsers], page 778.

error_t argp_err_exit_status
argp.h(GNU):Section 25.3.2 [Argp Global Variables], page 769.

void argp_error (const struct argp_state *state, const char *fmt, ...)
argp.h(GNU):Section 25.3.5.3 [Functions For Use in Argp Parsers], page 776.

void argp_failure (const struct argp_state *state, intstatus, interrnum, const char *fmt, ...)
argp.h(GNU):Section 25.3.5.3 [Functions For Use in Argp Parsers], page 776.

void argp_help (const struct argp *argp, FILE *stream, unsignedflags, char *name)
argp.h(GNU):Section 25.3.9 [Theargp_helpFunction], page 780.

struct argp_option
argp.h(GNU):Section 25.3.4 [Specifying Options in an Argp Parser], page 770.

error_t argp_parse (const struct argp *argp, intargc, char **argv, unsignedflags, int
*arg_index, void *input)
argp.h(GNU):Section 25.3 [Parsing Program Options with Argp], page 768.

const char * argp_program_bug_address
argp.h(GNU):Section 25.3.2 [Argp Global Variables], page 769.

const char * argp_program_version
argp.h(GNU):Section 25.3.2 [Argp Global Variables], page 769.

argp_program_version_hook
argp.h(GNU):Section 25.3.2 [Argp Global Variables], page 769.

struct argp_state
argp.h(GNU):Section 25.3.5.2 [Argp Parsing State], page 775.

void argp_state_help (const struct argp_state *state, FILE *stream, unsignedflags)
argp.h(GNU):Section 25.3.5.3 [Functions For Use in Argp Parsers], page 776.

void argp_usage (const struct argp_state *state)
argp.h(GNU):Section 25.3.5.3 [Functions For Use in Argp Parsers], page 776.

error_t argz_add (char **argz, size_t *argz_len, const char *str)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

error_t argz_add_sep (char **argz, size_t *argz_len, const char *str, intdelim)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.


Appendix B: Summary of Library Facilities 1013

error_t argz_append (char **argz, size_t *argz_len, const char *buf, size_tbuf_len)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

size_t argz_count (const char *argz, size_targz_len)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

error_t argz_create (char *constargv[], char **argz, size_t *argz_len)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

error_t argz_create_sep (const char *string, intsep, char **argz, size_t *argz_len)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

void argz_delete (char **argz, size_t *argz_len, char *entry)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

void argz_extract (const char *argz, size_targz_len, char **argv)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

error_t argz_insert (char **argz, size_t *argz_len, char *before, const char *entry)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

char * argz_next (const char *argz, size_targz_len, const char *entry)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

error_t argz_replace (char **argz, size_t *argz_len, const char *str, const char *with,
unsigned *replace_count)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

void argz_stringify (char *argz, size_tlen, intsep)
argz.h(GNU):Section 5.15.1 [Argz Functions], page 135.

char * asctime (const struct tm *brokentime)
time.h(ISO):Section 21.5.4 [Formatting Calendar Time], page 662.

char * asctime_r (const struct tm *brokentime, char *buffer)
time.h(POSIX.1c):Section 21.5.4 [Formatting Calendar Time], page 662.

double asin (doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

float asinf (floatx)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatN asinfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatNx asinfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

double asinh (doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

float asinhf (floatx)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

_FloatN asinhfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

_FloatNx asinhfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

long double asinhl (long doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

long double asinl (long doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

int asprintf (char **ptr, const char *template, ...)
stdio.h(GNU):Section 12.12.8 [Dynamically Allocating Formatted Output], page 299.


Appendix B: Summary of Library Facilities 1014

void assert (intexpression)
assert.h(ISO):Section A.1 [Explicitly Checking Internal Consistency], page 949.

void assert_perror (interrnum)
assert.h(GNU):Section A.1 [Explicitly Checking Internal Consistency], page 949.

double atan (doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

double atan2 (doubley, doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

float atan2f (floaty, floatx)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatN atan2fN (_FloatN y, _FloatN x)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatNx atan2fNx (_FloatNxy, _FloatNxx)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

long double atan2l (long doubley, long doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

float atanf (floatx)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatN atanfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

_FloatNx atanfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

double atanh (doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

float atanhf (floatx)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

_FloatN atanhfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

_FloatNx atanhfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

long double atanhl (long doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

long double atanl (long doublex)
math.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

int atexit (void (*function) (void))
stdlib.h(ISO):Section 25.7.3 [Cleanups on Exit], page 800.

double atof (const char *string)
stdlib.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

int atoi (const char *string)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

long int atol (const char *string)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

long long int atoll (const char *string)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

int backtrace (void **buffer, intsize)
execinfo.h(GNU):Section 34.1 [Backtraces], page 918.


Appendix B: Summary of Library Facilities 1015

char ** backtrace_symbols (void *const *buffer, intsize)
execinfo.h(GNU):Section 34.1 [Backtraces], page 918.

void backtrace_symbols_fd (void *const *buffer, intsize, intfd)
execinfo.h(GNU):Section 34.1 [Backtraces], page 918.

char * basename (char *path)
libgen.h(XPG):Section 5.10 [Finding Tokens in a String], page 126.

char * basename (const char *filename)
string.h(GNU):Section 5.10 [Finding Tokens in a String], page 126.

int bcmp (const void *a1, const void *a2, size_tsize)
string.h(BSD):Section 5.7 [String/Array Comparison], page 113.

void bcopy (const void *from, void *to, size_tsize)
string.h(BSD):Section 5.4 [Copying Strings and Arrays], page 101.

int bind (intsocket, struct sockaddr *addr, socklen_tlength)
sys/socket.h(BSD):Section 16.3.2 [Setting the Address of a Socket], page 459.

char * bind_textdomain_codeset (const char *domainname, const char *codeset)
libintl.h(GNU):Section 8.2.1.4 [How to specify the output character setgettextuses],
page 221.

char * bindtextdomain (const char *domainname, const char *dirname)
libintl.h(GNU):Section 8.2.1.2 [How to determine which catalog to be used], page 215.

blkcnt64_t
sys/types.h(Unix98):Section 14.9.1 [The meaning of the File Attributes], page 425.

blkcnt_t
sys/types.h(Unix98):Section 14.9.1 [The meaning of the File Attributes], page 425.

int brk (void *addr)
unistd.h(BSD):Section 3.3 [Resizing the Data Segment], page 77.

void * bsearch (const void *key, const void *array, size_tcount, size_tsize, comparison_fn_t
compare)
stdlib.h(ISO):Section 9.2 [Array Search Function], page 228.

wint_t btowc (intc)
wchar.h(ISO):Section 6.3.3 [Converting Single Characters], page 146.

void bzero (void *block, size_tsize)
string.h(BSD):Section 5.4 [Copying Strings and Arrays], page 101.

double cabs (complex doublez)
complex.h(ISO):Section 20.8.1 [Absolute Value], page 617.

float cabsf (complex floatz)
complex.h(ISO):Section 20.8.1 [Absolute Value], page 617.

_FloatN cabsfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 20.8.1 [Absolute Value], page 617.

_FloatNx cabsfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 20.8.1 [Absolute Value], page 617.

long double cabsl (complex long doublez)
complex.h(ISO):Section 20.8.1 [Absolute Value], page 617.

complex double cacos (complex doublez)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex float cacosf (complex floatz)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.


Appendix B: Summary of Library Facilities 1016

complex _FloatN cacosfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex _FloatNx cacosfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex double cacosh (complex doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex float cacoshf (complex floatz)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatN cacoshfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatNx cacoshfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex long double cacoshl (complex long doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex long double cacosl (complex long doublez)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

void call_once (once_flag *flag, void (*func) (void))
threads.h(C11):Section 35.1.3 [Call Once], page 923.

void * calloc (size_tcount, size_teltsize)
malloc.h(ISO):Section 3.2.3.5 [Allocating Cleared Space], page 49.
stdlib.h(ISO):Section 3.2.3.5 [Allocating Cleared Space], page 49.

int canonicalize (double *cx, const double *x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

char * canonicalize_file_name (const char *name)
stdlib.h(GNU):Section 14.5 [Symbolic Links], page 419.

int canonicalizef (float *cx, const float *x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int canonicalizefN (_FloatN*cx, const _FloatN*x)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

int canonicalizefNx (_FloatNx *cx, const _FloatNx *x)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

int canonicalizel (long double *cx, const long double *x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

double carg (complex doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

float cargf (complex floatz)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

_FloatN cargfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

_FloatNx cargfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.


Appendix B: Summary of Library Facilities 1017

long double cargl (complex long doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

complex double casin (complex doublez)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex float casinf (complex floatz)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex _FloatN casinfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex _FloatNx casinfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex double casinh (complex doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex float casinhf (complex floatz)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatN casinhfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatNx casinhfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex long double casinhl (complex long doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex long double casinl (complex long doublez)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex double catan (complex doublez)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex float catanf (complex floatz)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex _FloatN catanfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex _FloatNx catanfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.3 [Inverse Trigonometric Functions], page 542.

complex double catanh (complex doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex float catanhf (complex floatz)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatN catanhfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatNx catanhfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex long double catanhl (complex long doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex long double catanl (complex long doublez)
complex.h(ISO):Section 19.3 [Inverse Trigonometric Functions], page 542.

nl_catd catopen (const char *cat_name, intflag)
nl_types.h(X/Open):Section 8.1.1 [Thecatgetsfunction family], page 203.

double cbrt (doublex)
math.h(BSD):Section 19.4 [Exponentiation and Logarithms], page 544.


Appendix B: Summary of Library Facilities 1018

float cbrtf (floatx)
math.h(BSD):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN cbrtfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx cbrtfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double cbrtl (long doublex)
math.h(BSD):Section 19.4 [Exponentiation and Logarithms], page 544.

cc_t
termios.h(POSIX.1):Section 17.4.1 [Terminal Mode Data Types], page 505.

complex double ccos (complex doublez)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex float ccosf (complex floatz)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex _FloatN ccosfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

complex _FloatNx ccosfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

complex double ccosh (complex doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex float ccoshf (complex floatz)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatN ccoshfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatNx ccoshfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex long double ccoshl (complex long doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex long double ccosl (complex long doublez)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

double ceil (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

float ceilf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN ceilfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx ceilfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double ceill (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

complex double cexp (complex doublez)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex float cexpf (complex floatz)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatN cexpfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.


Appendix B: Summary of Library Facilities 1019

complex _FloatNx cexpfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

complex long double cexpl (complex long doublez)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

speed_t cfgetispeed (const struct termios *termios-p)
termios.h(POSIX.1):Section 17.4.8 [Line Speed], page 515.

speed_t cfgetospeed (const struct termios *termios-p)
termios.h(POSIX.1):Section 17.4.8 [Line Speed], page 515.

void cfmakeraw (struct termios *termios-p)
termios.h(BSD):Section 17.4.10 [Noncanonical Input], page 521.

int cfsetispeed (struct termios *termios-p, speed_tspeed)
termios.h(POSIX.1):Section 17.4.8 [Line Speed], page 515.

int cfsetospeed (struct termios *termios-p, speed_tspeed)
termios.h(POSIX.1):Section 17.4.8 [Line Speed], page 515.

int cfsetspeed (struct termios *termios-p, speed_tspeed)
termios.h(BSD):Section 17.4.8 [Line Speed], page 515.

int chdir (const char *filename)
unistd.h(POSIX.1):Section 14.1 [Working Directory], page 402.

int chmod (const char *filename, mode_tmode)
sys/stat.h(POSIX.1):Section 14.9.7 [Assigning File Permissions], page 436.

int chown (const char *filename, uid_towner, gid_tgroup)
unistd.h(POSIX.1):Section 14.9.4 [File Owner], page 433.

double cimag (complex doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

float cimagf (complex floatz)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

_FloatN cimagfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

_FloatNx cimagfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

long double cimagl (complex long doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

int clearenv (void)
stdlib.h(GNU):Section 25.4.1 [Environment Access], page 793.

void clearerr (FILE *stream)
stdio.h(ISO):Section 12.16 [Recovering from errors], page 322.

void clearerr_unlocked (FILE *stream)
stdio.h(GNU):Section 12.16 [Recovering from errors], page 322.

clock_t clock (void)
time.h(ISO):Section 21.4.1 [CPU Time Inquiry], page 649.

int clock_getres (clockid_tclock, struct timespec *res)
time.h(POSIX.1):Section 21.5.1 [Getting the Time], page 651.


Appendix B: Summary of Library Facilities 1020

int clock_gettime (clockid_tclock, struct timespec *ts)
time.h(POSIX.1):Section 21.5.1 [Getting the Time], page 651.

int clock_settime (clockid_tclock, const struct timespec *ts)
time.h(POSIX):Section 21.5.2 [Setting and Adjusting the Time], page 653.

clock_t
time.h(ISO):Section 21.2 [Time Types], page 647.

clockid_t
time.h(POSIX.1):Section 21.5.1 [Getting the Time], page 651.

complex double clog (complex doublez)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex double clog10 (complex doublez)
complex.h(GNU):Section 19.4 [Exponentiation and Logarithms], page 544.

complex float clog10f (complex floatz)
complex.h(GNU):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatN clog10fN (complex _FloatN z)
complex.h(GNU):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatNx clog10fNx (complex _FloatNxz)
complex.h(GNU):Section 19.4 [Exponentiation and Logarithms], page 544.

complex long double clog10l (complex long doublez)
complex.h(GNU):Section 19.4 [Exponentiation and Logarithms], page 544.

complex float clogf (complex floatz)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatN clogfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatNx clogfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

complex long double clogl (complex long doublez)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

int close (intfiledes)
unistd.h(POSIX.1):Section 13.1 [Opening and Closing Files], page 342.

int closedir (DIR *dirstream)
dirent.h(POSIX.1):Section 14.2.3 [Reading and Closing a Directory Stream], page 407.

void closelog (void)
syslog.h(BSD):Section 18.2.3 [closelog], page 536.

int cnd_broadcast (cnd_t *cond)
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.

void cnd_destroy (cnd_t *cond)
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.

int cnd_init (cnd_t *cond)
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.

int cnd_signal (cnd_t *cond)
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.

cnd_t
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.

int cnd_timedwait (cnd_t *restrictcond, mtx_t *restrictmutex, const struct timespec *restrict
time_point)
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.


Appendix B: Summary of Library Facilities 1021

int cnd_wait (cnd_t *cond, mtx_t *mutex)
threads.h(C11):Section 35.1.5 [Condition Variables], page 926.

size_t confstr (intparameter, char *buf, size_tlen)
unistd.h(POSIX.2):Section 32.12 [String-Valued Parameters], page 909.

complex double conj (complex doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

complex float conjf (complex floatz)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

complex _FloatN conjfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

complex _FloatNx conjfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

complex long double conjl (complex long doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

int connect (intsocket, struct sockaddr *addr, socklen_tlength)
sys/socket.h(BSD):Section 16.9.1 [Making a Connection], page 482.

cookie_close_function_t
stdio.h(GNU):Section 12.21.2.2 [Custom Stream Hook Functions], page 336.

cookie_io_functions_t
stdio.h(GNU):Section 12.21.2.1 [Custom Streams and Cookies], page 335.

cookie_read_function_t
stdio.h(GNU):Section 12.21.2.2 [Custom Stream Hook Functions], page 336.

cookie_seek_function_t
stdio.h(GNU):Section 12.21.2.2 [Custom Stream Hook Functions], page 336.

cookie_write_function_t
stdio.h(GNU):Section 12.21.2.2 [Custom Stream Hook Functions], page 336.

ssize_t copy_file_range (intinputfd, off64_t *inputpos, intoutputfd, off64_t *outputpos,
ssize_tlength, unsigned intflags)
unistd.h(GNU):Section 13.7 [Copying data between two files], page 359.

double copysign (doublex, doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float copysignf (floatx, floaty)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

_FloatN copysignfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

_FloatNx copysignfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

long double copysignl (long doublex, long doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

double cos (doublex)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.


Appendix B: Summary of Library Facilities 1022

float cosf (floatx)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

_FloatN cosfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

_FloatNx cosfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

double cosh (doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

float coshf (floatx)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

_FloatN coshfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

_FloatNx coshfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

long double coshl (long doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

long double cosl (long doublex)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex double cpow (complex doublebase, complex doublepower)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex float cpowf (complex floatbase, complex floatpower)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatN cpowfN (complex _FloatN base, complex _FloatN power)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatNx cpowfNx (complex _FloatNxbase, complex _FloatNxpower)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

complex long double cpowl (complex long doublebase, complex long doublepower)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex double cproj (complex doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

complex float cprojf (complex floatz)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

complex _FloatN cprojfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

complex _FloatNx cprojfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

complex long double cprojl (complex long doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

cpu_set_t
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

double creal (complex doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.


Appendix B: Summary of Library Facilities 1023

float crealf (complex floatz)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

_FloatN crealfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

_FloatNx crealfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 20.10 [Projections, Conjugates, and Decomposing of
Complex Numbers], page 634.

long double creall (complex long doublez)
complex.h(ISO):Section 20.10 [Projections, Conjugates, and Decomposing of Complex Num-
bers], page 634.

int creat (const char *filename, mode_tmode)
fcntl.h(POSIX.1):Section 13.1 [Opening and Closing Files], page 342.

int creat64 (const char *filename, mode_tmode)
fcntl.h(Unix98):Section 13.1 [Opening and Closing Files], page 342.

char * crypt (const char *phrase, const char *salt)
unistd.h(X/Open):Section 33.1 [Passphrase Storage], page 912.
crypt.h(GNU):Section 33.1 [Passphrase Storage], page 912.

char * crypt_r (const char *phrase, const char *salt, struct crypt_data *data)
crypt.h(GNU):Section 33.1 [Passphrase Storage], page 912.

complex double csin (complex doublez)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex float csinf (complex floatz)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex _FloatN csinfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

complex _FloatNx csinfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

complex double csinh (complex doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex float csinhf (complex floatz)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatN csinhfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatNx csinhfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex long double csinhl (complex long doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex long double csinl (complex long doublez)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex double csqrt (complex doublez)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex float csqrtf (complex floatz)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex _FloatN csqrtfN (_FloatN z)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.


Appendix B: Summary of Library Facilities 1024

complex _FloatNx csqrtfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

complex long double csqrtl (complex long doublez)
complex.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

complex double ctan (complex doublez)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex float ctanf (complex floatz)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

complex _FloatN ctanfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

complex _FloatNx ctanfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

complex double ctanh (complex doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex float ctanhf (complex floatz)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatN ctanhfN (complex _FloatN z)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex _FloatNx ctanhfNx (complex _FloatNxz)
complex.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

complex long double ctanhl (complex long doublez)
complex.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

complex long double ctanl (complex long doublez)
complex.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

char * ctermid (char *string)
stdio.h(POSIX.1):Section 28.6.1 [Identifying the Controlling Terminal], page 831.

char * ctime (const time_t *time)
time.h(ISO):Section 21.5.4 [Formatting Calendar Time], page 662.

char * ctime_r (const time_t *time, char *buffer)
time.h(POSIX.1c):Section 21.5.4 [Formatting Calendar Time], page 662.

char * cuserid (char *string)
stdio.h(POSIX.1):Section 30.11 [Identifying Who Logged In], page 855.

double daddl (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

int daylight
time.h(SVID):Section 21.5.7 [Functions and Variables for Time Zones], page 678.

char * dcgettext (const char *domainname, const char *msgid, intcategory)
libintl.h(GNU):Section 8.2.1.1 [What has to be done to translate a message?], page 213.

char * dcngettext (const char *domain, const char *msgid1, const char *msgid2, unsigned long int
n, intcategory)
libintl.h(GNU):Section 8.2.1.3 [Additional functions for more complicated situations],
page 217.

double ddivl (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

dev_t
sys/types.h(POSIX.1):Section 14.9.1 [The meaning of the File Attributes], page 425.


Appendix B: Summary of Library Facilities 1025

char * dgettext (const char *domainname, const char *msgid)
libintl.h(GNU):Section 8.2.1.1 [What has to be done to translate a message?], page 213.

double difftime (time_tend, time_tbegin)
time.h(ISO):Section 21.3 [Calculating Elapsed Time], page 648.

struct dirent
dirent.h(POSIX.1):Section 14.2.1 [Format of a Directory Entry], page 404.

int dirfd (DIR *dirstream)
dirent.h(GNU):Section 14.2.2 [Opening a Directory Stream], page 406.

char * dirname (char *path)
libgen.h(XPG):Section 5.10 [Finding Tokens in a String], page 126.

div_t div (intnumerator, intdenominator)
stdlib.h(ISO):Section 20.2 [Integer Division], page 602.

div_t
stdlib.h(ISO):Section 20.2 [Integer Division], page 602.

double dmull (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

char * dngettext (const char *domain, const char *msgid1, const char *msgid2, unsigned long int
n)
libintl.h(GNU):Section 8.2.1.3 [Additional functions for more complicated situations],
page 217.

double drand48 (void)
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int drand48_r (struct drand48_data *buffer, double *result)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

double drem (doublenumerator, doubledenominator)
math.h(BSD):Section 20.8.4 [Remainder Functions], page 624.

float dremf (floatnumerator, floatdenominator)
math.h(BSD):Section 20.8.4 [Remainder Functions], page 624.

long double dreml (long doublenumerator, long doubledenominator)
math.h(BSD):Section 20.8.4 [Remainder Functions], page 624.

double dsubl (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

int dup (intold)
unistd.h(POSIX.1):Section 13.13 [Duplicating Descriptors], page 384.

int dup2 (intold, intnew)
unistd.h(POSIX.1):Section 13.13 [Duplicating Descriptors], page 384.

char * ecvt (doublevalue, intndigit, int *decpt, int *neg)
stdlib.h (SVID): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.
stdlib.h(Unix98): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

int ecvt_r (doublevalue, intndigit, int *decpt, int *neg, char *buf, size_tlen)
stdlib.h (GNU): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

void endfsent (void)
fstab.h(BSD):Section 31.3.1.1 [Thefstabfile], page 879.


Appendix B: Summary of Library Facilities 1026

void endgrent (void)
grp.h(SVID):Section 30.14.3 [Scanning the List of All Groups], page 869.
grp.h(BSD):Section 30.14.3 [Scanning the List of All Groups], page 869.

void endhostent (void)
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

int endmntent (FILE *stream)
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

void endnetent (void)
netdb.h(BSD):Section 16.13 [Networks Database], page 501.

void endnetgrent (void)
netdb.h(BSD):Section 30.16.2 [Looking up one Netgroup], page 872.

void endprotoent (void)
netdb.h(BSD):Section 16.6.6 [Protocols Database], page 477.

void endpwent (void)
pwd.h(SVID):Section 30.13.3 [Scanning the List of All Users], page 866.
pwd.h(BSD):Section 30.13.3 [Scanning the List of All Users], page 866.

void endservent (void)
netdb.h(BSD):Section 16.6.4 [The Services Database], page 474.

void endutent (void)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

void endutxent (void)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

char ** environ
unistd.h(POSIX.1):Section 25.4.1 [Environment Access], page 793.

error_t envz_add (char **envz, size_t *envz_len, const char *name, const char *value)
envz.h(GNU):Section 5.15.2 [Envz Functions], page 138.

char * envz_entry (const char *envz, size_tenvz_len, const char *name)
envz.h(GNU):Section 5.15.2 [Envz Functions], page 138.

char * envz_get (const char *envz, size_tenvz_len, const char *name)
envz.h(GNU):Section 5.15.2 [Envz Functions], page 138.

error_t envz_merge (char **envz, size_t *envz_len, const char *envz2, size_tenvz2_len, int
override)
envz.h(GNU):Section 5.15.2 [Envz Functions], page 138.

void envz_remove (char **envz, size_t *envz_len, const char *name)
envz.h(GNU):Section 5.15.2 [Envz Functions], page 138.

void envz_strip (char **envz, size_t *envz_len)
envz.h(GNU):Section 5.15.2 [Envz Functions], page 138.

double erand48 (unsigned short intxsubi[3])
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int erand48_r (unsigned short intxsubi[3], struct drand48_data *buffer, double *result)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

double erf (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

double erfc (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float erfcf (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.


Appendix B: Summary of Library Facilities 1027

_FloatN erfcfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

_FloatNx erfcfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

long double erfcl (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float erff (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN erffN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

_FloatNx erffNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

long double erfl (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

void err (intstatus, const char *format, ...)
err.h(BSD):Section 2.3 [Error Messages], page 36.

volatile int errno
errno.h(ISO):Section 2.1 [Checking for Errors], page 23.

void error (intstatus, interrnum, const char *format, ...)
error.h(GNU):Section 2.3 [Error Messages], page 36.

void error_at_line (intstatus, interrnum, const char *fname, unsigned intlineno, const char
*format, ...)
error.h(GNU):Section 2.3 [Error Messages], page 36.

unsigned int error_message_count
error.h(GNU):Section 2.3 [Error Messages], page 36.

int error_one_per_line
error.h(GNU):Section 2.3 [Error Messages], page 36.

void (*error_print_progname) (void)
error.h(GNU):Section 2.3 [Error Messages], page 36.

void errx (intstatus, const char *format, ...)
err.h(BSD):Section 2.3 [Error Messages], page 36.

int execl (const char *filename, const char *arg0, ...)
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

int execle (const char *filename, const char *arg0, ..., char *constenv[])
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

int execlp (const char *filename, const char *arg0, ...)
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

int execv (const char *filename, char *constargv[])
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

int execve (const char *filename, char *constargv[], char *constenv[])
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

int execvp (const char *filename, char *constargv[])
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

void exit (intstatus)
stdlib.h(ISO):Section 25.7.1 [Normal Termination], page 799.

struct exit_status
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.


Appendix B: Summary of Library Facilities 1028

double exp (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

double exp10 (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float exp10f (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN exp10fN (_FloatN x)
math.h(TS 18661-4:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx exp10fNx (_FloatNxx)
math.h(TS 18661-4:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double exp10l (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

double exp2 (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float exp2f (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN exp2fN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx exp2fNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double exp2l (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float expf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN expfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx expfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double expl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

void explicit_bzero (void *block, size_tlen)
string.h(BSD):Section 5.11 [Erasing Sensitive Data], page 131.

double expm1 (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float expm1f (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN expm1fN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx expm1fNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double expm1l (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatM fMaddfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatM fMaddfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.


Appendix B: Summary of Library Facilities 1029

_FloatM fMdivfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatM fMdivfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatM fMmulfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatM fMmulfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatM fMsubfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatM fMsubfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxaddfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxaddfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxdivfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxdivfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxmulfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxmulfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxsubfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatMx fMxsubfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

double fabs (doublenumber)
math.h(ISO):Section 20.8.1 [Absolute Value], page 617.

float fabsf (floatnumber)
math.h(ISO):Section 20.8.1 [Absolute Value], page 617.

_FloatN fabsfN (_FloatN number)
math.h(TS 18661-3:2015):Section 20.8.1 [Absolute Value], page 617.

_FloatNx fabsfNx (_FloatNxnumber)
math.h(TS 18661-3:2015):Section 20.8.1 [Absolute Value], page 617.

long double fabsl (long doublenumber)
math.h(ISO):Section 20.8.1 [Absolute Value], page 617.

float fadd (doublex, doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float faddl (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

int fchdir (intfiledes)
unistd.h(XPG):Section 14.1 [Working Directory], page 402.

int fchmod (intfiledes, mode_tmode)
sys/stat.h(BSD):Section 14.9.7 [Assigning File Permissions], page 436.


Appendix B: Summary of Library Facilities 1030

int fchown (intfiledes, uid_towner, gid_tgroup)
unistd.h(BSD):Section 14.9.4 [File Owner], page 433.

int fclose (FILE *stream)
stdio.h(ISO):Section 12.4 [Closing Streams], page 271.

int fcloseall (void)
stdio.h(GNU):Section 12.4 [Closing Streams], page 271.

int fcntl (intfiledes, intcommand, ...)
fcntl.h(POSIX.1):Section 13.12 [Control Operations on Files], page 383.

char * fcvt (doublevalue, intndigit, int *decpt, int *neg)
stdlib.h (SVID): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.
stdlib.h(Unix98): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

int fcvt_r (doublevalue, intndigit, int *decpt, int *neg, char *buf, size_tlen)
stdlib.h (SVID): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.
stdlib.h(Unix98): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

fd_set
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.

int fdatasync (intfildes)
unistd.h(POSIX):Section 13.10 [Synchronizing I/O operations], page 369.

double fdim (doublex, doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fdimf (floatx, floaty)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatN fdimfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatNx fdimfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

long double fdiml (long doublex, long doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fdiv (doublex, doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fdivl (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

FILE * fdopen (intfiledes, const char *opentype)
stdio.h(POSIX.1):Section 13.4 [Descriptors and Streams], page 352.

DIR * fdopendir (intfd)
dirent.h(GNU):Section 14.2.2 [Opening a Directory Stream], page 406.

int feclearexcept (intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int fedisableexcept (intexcepts)
fenv.h(GNU):Section 20.7 [Floating-Point Control Functions], page 615.

int feenableexcept (intexcepts)
fenv.h(GNU):Section 20.7 [Floating-Point Control Functions], page 615.


Appendix B: Summary of Library Facilities 1031

int fegetenv (fenv_t *envp)
fenv.h(ISO):Section 20.7 [Floating-Point Control Functions], page 615.

int fegetexcept (void)
fenv.h(GNU):Section 20.7 [Floating-Point Control Functions], page 615.

int fegetexceptflag (fexcept_t *flagp, intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int fegetmode (femode_t *modep)
fenv.h(ISO):Section 20.7 [Floating-Point Control Functions], page 615.

int fegetround (void)
fenv.h(ISO):Section 20.6 [Rounding Modes], page 613.

int feholdexcept (fenv_t *envp)
fenv.h(ISO):Section 20.7 [Floating-Point Control Functions], page 615.

int feof (FILE *stream)
stdio.h(ISO):Section 12.15 [End-Of-File and Errors], page 320.

int feof_unlocked (FILE *stream)
stdio.h(GNU):Section 12.15 [End-Of-File and Errors], page 320.

int feraiseexcept (intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int ferror (FILE *stream)
stdio.h(ISO):Section 12.15 [End-Of-File and Errors], page 320.

int ferror_unlocked (FILE *stream)
stdio.h(GNU):Section 12.15 [End-Of-File and Errors], page 320.

int fesetenv (const fenv_t *envp)
fenv.h(ISO):Section 20.7 [Floating-Point Control Functions], page 615.

int fesetexcept (intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int fesetexceptflag (const fexcept_t *flagp, intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int fesetmode (const femode_t *modep)
fenv.h(ISO):Section 20.7 [Floating-Point Control Functions], page 615.

int fesetround (intround)
fenv.h(ISO):Section 20.6 [Rounding Modes], page 613.

int fetestexcept (intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int fetestexceptflag (const fexcept_t *flagp, intexcepts)
fenv.h(ISO):Section 20.5.3 [Examining the FPU status word], page 610.

int feupdateenv (const fenv_t *envp)
fenv.h(ISO):Section 20.7 [Floating-Point Control Functions], page 615.

int fexecve (intfd, char *constargv[], char *constenv[])
unistd.h(POSIX.1):Section 26.5 [Executing a File], page 806.

int fflush (FILE *stream)
stdio.h(ISO):Section 12.20.2 [Flushing Buffers], page 329.

int fflush_unlocked (FILE *stream)
stdio.h(POSIX):Section 12.20.2 [Flushing Buffers], page 329.

int fgetc (FILE *stream)
stdio.h(ISO):Section 12.8 [Character Input], page 280.


Appendix B: Summary of Library Facilities 1032

int fgetc_unlocked (FILE *stream)
stdio.h(POSIX):Section 12.8 [Character Input], page 280.

struct group * fgetgrent (FILE *stream)
grp.h(SVID):Section 30.14.3 [Scanning the List of All Groups], page 869.

int fgetgrent_r (FILE *stream, struct group *result_buf, char *buffer, size_tbuflen, struct
group **result)
grp.h(GNU):Section 30.14.3 [Scanning the List of All Groups], page 869.

int fgetpos (FILE *stream, fpos_t *position)
stdio.h(ISO):Section 12.19 [Portable File-Position Functions], page 326.

int fgetpos64 (FILE *stream, fpos64_t *position)
stdio.h(Unix98):Section 12.19 [Portable File-Position Functions], page 326.

struct passwd * fgetpwent (FILE *stream)
pwd.h(SVID):Section 30.13.3 [Scanning the List of All Users], page 866.

int fgetpwent_r (FILE *stream, struct passwd *result_buf, char *buffer, size_tbuflen, struct
passwd **result)
pwd.h(GNU):Section 30.13.3 [Scanning the List of All Users], page 866.

char * fgets (char *s, intcount, FILE *stream)
stdio.h(ISO):Section 12.9 [Line-Oriented Input], page 283.

char * fgets_unlocked (char *s, intcount, FILE *stream)
stdio.h(GNU):Section 12.9 [Line-Oriented Input], page 283.

wint_t fgetwc (FILE *stream)
wchar.h(ISO):Section 12.8 [Character Input], page 280.

wint_t fgetwc_unlocked (FILE *stream)
wchar.h(GNU):Section 12.8 [Character Input], page 280.

wchar_t * fgetws (wchar_t *ws, intcount, FILE *stream)
wchar.h(ISO):Section 12.9 [Line-Oriented Input], page 283.

wchar_t * fgetws_unlocked (wchar_t *ws, intcount, FILE *stream)
wchar.h(GNU):Section 12.9 [Line-Oriented Input], page 283.

int fileno (FILE *stream)
stdio.h(POSIX.1):Section 13.4 [Descriptors and Streams], page 352.

int fileno_unlocked (FILE *stream)
stdio.h(GNU):Section 13.4 [Descriptors and Streams], page 352.

int finite (doublex)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int finitef (floatx)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int finitel (long doublex)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

struct flock
fcntl.h(POSIX.1):Section 13.16 [File Locks], page 393.

void flockfile (FILE *stream)
stdio.h(POSIX):Section 12.5 [Streams and Threads], page 272.

double floor (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

float floorf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.


Appendix B: Summary of Library Facilities 1033

_FloatN floorfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx floorfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double floorl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

double fma (doublex, doubley, doublez)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fmaf (floatx, floaty, floatz)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatN fmafN (_FloatN x, _FloatN y, _FloatN z)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatNx fmafNx (_FloatNxx, _FloatNxy, _FloatNxz)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

long double fmal (long doublex, long doubley, long doublez)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

double fmax (doublex, doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fmaxf (floatx, floaty)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatN fmaxfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatNx fmaxfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

long double fmaxl (long doublex, long doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

double fmaxmag (doublex, doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fmaxmagf (floatx, floaty)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatN fmaxmagfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatNx fmaxmagfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

long double fmaxmagl (long doublex, long doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

FILE * fmemopen (void *buf, size_tsize, const char *opentype)
stdio.h(GNU):Section 12.21.1 [String Streams], page 333.

double fmin (doublex, doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fminf (floatx, floaty)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatN fminfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatNx fminfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.


Appendix B: Summary of Library Facilities 1034

long double fminl (long doublex, long doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

double fminmag (doublex, doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fminmagf (floatx, floaty)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatN fminmagfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

_FloatNx fminmagfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

long double fminmagl (long doublex, long doubley)
math.h(ISO):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

double fmod (doublenumerator, doubledenominator)
math.h(ISO):Section 20.8.4 [Remainder Functions], page 624.

float fmodf (floatnumerator, floatdenominator)
math.h(ISO):Section 20.8.4 [Remainder Functions], page 624.

_FloatN fmodfN (_FloatN numerator, _FloatN denominator)
math.h(TS 18661-3:2015):Section 20.8.4 [Remainder Functions], page 624.

_FloatNx fmodfNx (_FloatNxnumerator, _FloatNxdenominator)
math.h(TS 18661-3:2015):Section 20.8.4 [Remainder Functions], page 624.

long double fmodl (long doublenumerator, long doubledenominator)
math.h(ISO):Section 20.8.4 [Remainder Functions], page 624.

int fmtmsg (long intclassification, const char *label, intseverity, const char *text, const
char *action, const char *tag)
fmtmsg.h(XPG):Section 12.22.1 [Printing Formatted Messages], page 337.

float fmul (doublex, doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fmull (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

int fnmatch (const char *pattern, const char *string, intflags)
fnmatch.h(POSIX.2):Section 10.1 [Wildcard Matching], page 239.

FILE * fopen (const char *filename, const char *opentype)
stdio.h(ISO):Section 12.3 [Opening Streams], page 267.

FILE * fopen64 (const char *filename, const char *opentype)
stdio.h(Unix98):Section 12.3 [Opening Streams], page 267.

FILE * fopencookie (void *cookie, const char *opentype, cookie_io_functions_tio-functions)
stdio.h(GNU):Section 12.21.2.1 [Custom Streams and Cookies], page 335.

pid_t fork (void)
unistd.h(POSIX.1):Section 26.4 [Creating a Process], page 805.

int forkpty (int *amaster, char *name, const struct termios *termp, const struct winsize *winp)
pty.h(BSD):Section 17.9.2 [Opening a Pseudo-Terminal Pair], page 530.

long int fpathconf (intfiledes, intparameter)
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

int fpclassify (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

fpos64_t
stdio.h(Unix98):Section 12.19 [Portable File-Position Functions], page 326.


Appendix B: Summary of Library Facilities 1035

fpos_t
stdio.h(ISO):Section 12.19 [Portable File-Position Functions], page 326.

int fprintf (FILE *stream, const char *template, ...)
stdio.h(ISO):Section 12.12.7 [Formatted Output Functions], page 296.

int fputc (intc, FILE *stream)
stdio.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

int fputc_unlocked (intc, FILE *stream)
stdio.h(POSIX):Section 12.7 [Simple Output by Characters or Lines], page 277.

int fputs (const char *s, FILE *stream)
stdio.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

int fputs_unlocked (const char *s, FILE *stream)
stdio.h(GNU):Section 12.7 [Simple Output by Characters or Lines], page 277.

wint_t fputwc (wchar_twc, FILE *stream)
wchar.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

wint_t fputwc_unlocked (wchar_twc, FILE *stream)
wchar.h(POSIX):Section 12.7 [Simple Output by Characters or Lines], page 277.

int fputws (const wchar_t *ws, FILE *stream)
wchar.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

int fputws_unlocked (const wchar_t *ws, FILE *stream)
wchar.h(GNU):Section 12.7 [Simple Output by Characters or Lines], page 277.

size_t fread (void *data, size_tsize, size_tcount, FILE *stream)
stdio.h(ISO):Section 12.11 [Block Input/Output], page 287.

size_t fread_unlocked (void *data, size_tsize, size_tcount, FILE *stream)
stdio.h(GNU):Section 12.11 [Block Input/Output], page 287.

void free (void *ptr)
malloc.h(ISO):Section 3.2.3.3 [Freeing Memory Allocated withmalloc], page 47.
stdlib.h(ISO):Section 3.2.3.3 [Freeing Memory Allocated withmalloc], page 47.

FILE * freopen (const char *filename, const char *opentype, FILE *stream)
stdio.h(ISO):Section 12.3 [Opening Streams], page 267.

FILE * freopen64 (const char *filename, const char *opentype, FILE *stream)
stdio.h(Unix98):Section 12.3 [Opening Streams], page 267.

double frexp (doublevalue, int *exponent)
math.h(ISO):Section 20.8.2 [Normalization Functions], page 618.

float frexpf (floatvalue, int *exponent)
math.h(ISO):Section 20.8.2 [Normalization Functions], page 618.

_FloatN frexpfN (_FloatN value, int *exponent)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

_FloatNx frexpfNx (_FloatNxvalue, int *exponent)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

long double frexpl (long doublevalue, int *exponent)
math.h(ISO):Section 20.8.2 [Normalization Functions], page 618.

intmax_t fromfp (doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpf (floatx, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpfN (_FloatN x, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.


Appendix B: Summary of Library Facilities 1036

intmax_t fromfpfNx (_FloatNxx, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpl (long doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpx (doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpxf (floatx, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpxfN (_FloatN x, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpxfNx (_FloatNxx, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

intmax_t fromfpxl (long doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

int fscanf (FILE *stream, const char *template, ...)
stdio.h(ISO):Section 12.14.8 [Formatted Input Functions], page 318.

int fseek (FILE *stream, long intoffset, intwhence)
stdio.h(ISO):Section 12.18 [File Positioning], page 323.

int fseeko (FILE *stream, off_toffset, intwhence)
stdio.h(Unix98):Section 12.18 [File Positioning], page 323.

int fseeko64 (FILE *stream, off64_toffset, intwhence)
stdio.h(Unix98):Section 12.18 [File Positioning], page 323.

int fsetpos (FILE *stream, const fpos_t *position)
stdio.h(ISO):Section 12.19 [Portable File-Position Functions], page 326.

int fsetpos64 (FILE *stream, const fpos64_t *position)
stdio.h(Unix98):Section 12.19 [Portable File-Position Functions], page 326.

struct fstab
fstab.h(BSD):Section 31.3.1.1 [Thefstabfile], page 879.

int fstat (intfiledes, struct stat *buf)
sys/stat.h(POSIX.1):Section 14.9.2 [Reading the Attributes of a File], page 429.

int fstat64 (intfiledes, struct stat64 *buf)
sys/stat.h(Unix98):Section 14.9.2 [Reading the Attributes of a File], page 429.

float fsub (doublex, doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

float fsubl (long doublex, long doubley)
math.h(TS 18661-1:2014):Section 20.8.7 [Miscellaneous FP arithmetic functions], page 630.

int fsync (intfildes)
unistd.h(POSIX):Section 13.10 [Synchronizing I/O operations], page 369.

long int ftell (FILE *stream)
stdio.h(ISO):Section 12.18 [File Positioning], page 323.

off_t ftello (FILE *stream)
stdio.h(Unix98):Section 12.18 [File Positioning], page 323.

off64_t ftello64 (FILE *stream)
stdio.h(Unix98):Section 12.18 [File Positioning], page 323.

int ftruncate (intfd, off_tlength)
unistd.h(POSIX):Section 14.9.10 [File Size], page 442.


Appendix B: Summary of Library Facilities 1037

int ftruncate64 (intid, off64_tlength)
unistd.h(Unix98):Section 14.9.10 [File Size], page 442.

int ftrylockfile (FILE *stream)
stdio.h(POSIX):Section 12.5 [Streams and Threads], page 272.

int ftw (const char *filename, __ftw_func_tfunc, intdescriptors)
ftw.h(SVID):Section 14.3 [Working with Directory Trees], page 414.

int ftw64 (const char *filename, __ftw64_func_tfunc, intdescriptors)
ftw.h(Unix98):Section 14.3 [Working with Directory Trees], page 414.

void funlockfile (FILE *stream)
stdio.h(POSIX):Section 12.5 [Streams and Threads], page 272.

int futimes (intfd, const struct timevaltvp[2])
sys/time.h(BSD):Section 14.9.9 [File Times], page 439.

int fwide (FILE *stream, intmode)
wchar.h(ISO):Section 12.6 [Streams in Internationalized Applications], page 275.

int fwprintf (FILE *stream, const wchar_t *template, ...)
wchar.h(ISO):Section 12.12.7 [Formatted Output Functions], page 296.

size_t fwrite (const void *data, size_tsize, size_tcount, FILE *stream)
stdio.h(ISO):Section 12.11 [Block Input/Output], page 287.

size_t fwrite_unlocked (const void *data, size_tsize, size_tcount, FILE *stream)
stdio.h(GNU):Section 12.11 [Block Input/Output], page 287.

int fwscanf (FILE *stream, const wchar_t *template, ...)
wchar.h(ISO):Section 12.14.8 [Formatted Input Functions], page 318.

double gamma (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float gammaf (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

long double gammal (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

char * gcvt (doublevalue, intndigit, char *buf)
stdlib.h (SVID): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.
stdlib.h(Unix98): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

long int get_avphys_pages (void)
sys/sysinfo.h(GNU):Section 22.4.2 [How to get information about the memory subsys-
tem?], page 702.

char * get_current_dir_name (void)
unistd.h(GNU):Section 14.1 [Working Directory], page 402.

int get_nprocs (void)
sys/sysinfo.h(GNU):Section 22.5 [Learn about the processors available], page 704.

int get_nprocs_conf (void)
sys/sysinfo.h(GNU):Section 22.5 [Learn about the processors available], page 704.

long int get_phys_pages (void)
sys/sysinfo.h(GNU):Section 22.4.2 [How to get information about the memory subsys-
tem?], page 702.

unsigned long int getauxval (unsigned long inttype)
sys/auxv.h(???):Section 25.5 [Auxiliary Vector], page 796.


Appendix B: Summary of Library Facilities 1038

int getc (FILE *stream)
stdio.h(ISO):Section 12.8 [Character Input], page 280.

int getc_unlocked (FILE *stream)
stdio.h(POSIX):Section 12.8 [Character Input], page 280.

int getchar (void)
stdio.h(ISO):Section 12.8 [Character Input], page 280.

int getchar_unlocked (void)
stdio.h(POSIX):Section 12.8 [Character Input], page 280.

int getcontext (ucontext_t *ucp)
ucontext.h(SVID):Section 23.4 [Complete Context Control], page 708.

int getcpu (unsigned int *cpu, unsigned int *node)
<sched.h>(Linux):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

char * getcwd (char *buffer, size_tsize)
unistd.h(POSIX.1):Section 14.1 [Working Directory], page 402.

struct tm * getdate (const char *string)
time.h(Unix98): Section 21.5.5.2 [A More User-friendly Way to Parse Times and Dates],
page 673.

getdate_err
time.h(Unix98): Section 21.5.5.2 [A More User-friendly Way to Parse Times and Dates],
page 673.

int getdate_r (const char *string, struct tm *tp)
time.h(GNU):Section 21.5.5.2 [A More User-friendly Way to Parse Times and Dates],
page 673.

ssize_t getdelim (char **lineptr, size_t *n, intdelimiter, FILE *stream)
stdio.h(GNU):Section 12.9 [Line-Oriented Input], page 283.

ssize_t getdents64 (intfd, void *buffer, size_tlength)
dirent.h(Linux):Section 14.2.8 [Low-level Directory Access], page 413.

int getdomainnname (char *name, size_tlength)
unistd.h(???):Section 31.1 [Host Identification], page 875.

gid_t getegid (void)
unistd.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

int getentropy (void *buffer, size_tlength)
sys/random.h(GNU):Section 33.2 [Generating Unpredictable Bytes], page 916.

char * getenv (const char *name)
stdlib.h(ISO):Section 25.4.1 [Environment Access], page 793.

uid_t geteuid (void)
unistd.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

struct fstab * getfsent (void)
fstab.h(BSD):Section 31.3.1.1 [Thefstabfile], page 879.

struct fstab * getfsfile (const char *name)
fstab.h(BSD):Section 31.3.1.1 [Thefstabfile], page 879.

struct fstab * getfsspec (const char *name)
fstab.h(BSD):Section 31.3.1.1 [Thefstabfile], page 879.

gid_t getgid (void)
unistd.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

struct group * getgrent (void)
grp.h(SVID):Section 30.14.3 [Scanning the List of All Groups], page 869.
grp.h(BSD):Section 30.14.3 [Scanning the List of All Groups], page 869.


Appendix B: Summary of Library Facilities 1039

int getgrent_r (struct group *result_buf, char *buffer, size_tbuflen, struct group **result)
grp.h(GNU):Section 30.14.3 [Scanning the List of All Groups], page 869.

struct group * getgrgid (gid_tgid)
grp.h(POSIX.1):Section 30.14.2 [Looking Up One Group], page 868.

int getgrgid_r (gid_tgid, struct group *result_buf, char *buffer, size_tbuflen, struct group
**result)
grp.h(POSIX.1c):Section 30.14.2 [Looking Up One Group], page 868.

struct group * getgrnam (const char *name)
grp.h(SVID):Section 30.14.2 [Looking Up One Group], page 868.
grp.h(BSD):Section 30.14.2 [Looking Up One Group], page 868.

int getgrnam_r (const char *name, struct group *result_buf, char *buffer, size_tbuflen, struct
group **result)
grp.h(POSIX.1c):Section 30.14.2 [Looking Up One Group], page 868.

int getgrouplist (const char *user, gid_tgroup, gid_t *groups, int *ngroups)
grp.h(BSD):Section 30.7 [Setting the Group IDs], page 849.

int getgroups (intcount, gid_t *groups)
unistd.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

struct hostent * gethostbyaddr (const void *addr, socklen_tlength, intformat)
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

int gethostbyaddr_r (const void *addr, socklen_tlength, intformat, struct hostent *restrict
result_buf, char *restrictbuf, size_tbuflen, struct hostent **restrictresult, int *restrict
h_errnop)
netdb.h(GNU):Section 16.6.2.4 [Host Names], page 469.

struct hostent * gethostbyname (const char *name)
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

struct hostent * gethostbyname2 (const char *name, intaf)
netdb.h(IPv6 Basic API):Section 16.6.2.4 [Host Names], page 469.

int gethostbyname2_r (const char *name, intaf, struct hostent *restrictresult_buf, char
*restrictbuf, size_tbuflen, struct hostent **restrictresult, int *restricth_errnop)
netdb.h(GNU):Section 16.6.2.4 [Host Names], page 469.

int gethostbyname_r (const char *restrictname, struct hostent *restrictresult_buf, char
*restrictbuf, size_tbuflen, struct hostent **restrictresult, int *restricth_errnop)
netdb.h(GNU):Section 16.6.2.4 [Host Names], page 469.

struct hostent * gethostent (void)
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

long int gethostid (void)
unistd.h(BSD):Section 31.1 [Host Identification], page 875.

int gethostname (char *name, size_tsize)
unistd.h(BSD):Section 31.1 [Host Identification], page 875.

int getitimer (intwhich, struct itimerval *old)
sys/time.h(BSD):Section 21.6 [Setting an Alarm], page 679.

ssize_t getline (char **lineptr, size_t *n, FILE *stream)
stdio.h(GNU):Section 12.9 [Line-Oriented Input], page 283.

int getloadavg (doubleloadavg[], intnelem)
stdlib.h(BSD):Section 22.5 [Learn about the processors available], page 704.

char * getlogin (void)
unistd.h(POSIX.1):Section 30.11 [Identifying Who Logged In], page 855.


Appendix B: Summary of Library Facilities 1040

struct mntent * getmntent (FILE *stream)
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

struct mntent * getmntent_r (FILE *stream, struct mntent *result, char *buffer, intbufsize)
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

struct netent * getnetbyaddr (uint32_tnet, inttype)
netdb.h(BSD):Section 16.13 [Networks Database], page 501.

struct netent * getnetbyname (const char *name)
netdb.h(BSD):Section 16.13 [Networks Database], page 501.

struct netent * getnetent (void)
netdb.h(BSD):Section 16.13 [Networks Database], page 501.

int getnetgrent (char **hostp, char **userp, char **domainp)
netdb.h(BSD):Section 30.16.2 [Looking up one Netgroup], page 872.

int getnetgrent_r (char **hostp, char **userp, char **domainp, char *buffer, size_tbuflen)
netdb.h(GNU):Section 30.16.2 [Looking up one Netgroup], page 872.

int getopt (intargc, char *const *argv, const char *options)
unistd.h(POSIX.2):Section 25.2.1 [Using thegetoptfunction], page 761.

int getopt_long (intargc, char *const *argv, const char *shortopts, const struct option
*longopts, int *indexptr)
getopt.h(GNU):Section 25.2.3 [Parsing Long Options withgetopt_long], page 764.

int getopt_long_only (intargc, char *const *argv, const char *shortopts, const struct option
*longopts, int *indexptr)
getopt.h(GNU):Section 25.2.3 [Parsing Long Options withgetopt_long], page 764.

int getpagesize (void)
unistd.h(BSD):Section 22.4.2 [How to get information about the memory subsystem?],
page 702.

char * getpass (const char *prompt)
unistd.h(BSD):Section 17.8 [Reading Passphrases], page 526.

double getpayload (const double *x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float getpayloadf (const float *x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

_FloatN getpayloadfN (const _FloatN*x)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

_FloatNx getpayloadfNx (const _FloatNx *x)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

long double getpayloadl (const long double *x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int getpeername (intsocket, struct sockaddr *addr, socklen_t *length-ptr)
sys/socket.h(BSD):Section 16.9.4 [Who is Connected to Me?], page 485.

int getpgid (pid_tpid)
unistd.h(POSIX.1):Section 28.6.2 [Process Group Functions], page 831.

pid_t getpgrp (void)
unistd.h(POSIX.1):Section 28.6.2 [Process Group Functions], page 831.

pid_t getpid (void)
unistd.h(POSIX.1):Section 26.3 [Process Identification], page 804.


Appendix B: Summary of Library Facilities 1041

pid_t getppid (void)
unistd.h(POSIX.1):Section 26.3 [Process Identification], page 804.

int getpriority (intclass, intid)
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.
sys/resource.h(POSIX):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

struct protoent * getprotobyname (const char *name)
netdb.h(BSD):Section 16.6.6 [Protocols Database], page 477.

struct protoent * getprotobynumber (intprotocol)
netdb.h(BSD):Section 16.6.6 [Protocols Database], page 477.

struct protoent * getprotoent (void)
netdb.h(BSD):Section 16.6.6 [Protocols Database], page 477.

int getpt (void)
stdlib.h(GNU):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.

struct passwd * getpwent (void)
pwd.h(POSIX.1):Section 30.13.3 [Scanning the List of All Users], page 866.

int getpwent_r (struct passwd *result_buf, char *buffer, size_tbuflen, struct passwd **result)
pwd.h(GNU):Section 30.13.3 [Scanning the List of All Users], page 866.

struct passwd * getpwnam (const char *name)
pwd.h(POSIX.1):Section 30.13.2 [Looking Up One User], page 865.

int getpwnam_r (const char *name, struct passwd *result_buf, char *buffer, size_tbuflen,
struct passwd **result)
pwd.h(POSIX.1c):Section 30.13.2 [Looking Up One User], page 865.

struct passwd * getpwuid (uid_tuid)
pwd.h(POSIX.1):Section 30.13.2 [Looking Up One User], page 865.

int getpwuid_r (uid_tuid, struct passwd *result_buf, char *buffer, size_tbuflen, struct
passwd **result)
pwd.h(POSIX.1c):Section 30.13.2 [Looking Up One User], page 865.

ssize_t getrandom (void *buffer, size_tlength, unsigned intflags)
sys/random.h(GNU):Section 33.2 [Generating Unpredictable Bytes], page 916.

int getrlimit (intresource, struct rlimit *rlp)
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

int getrlimit64 (intresource, struct rlimit64 *rlp)
sys/resource.h(Unix98):Section 22.2 [Limiting Resource Usage], page 685.

int getrusage (intprocesses, struct rusage *rusage)
sys/resource.h(BSD):Section 22.1 [Resource Usage], page 684.

char * gets (char *s)
stdio.h(ISO):Section 12.9 [Line-Oriented Input], page 283.

struct servent * getservbyname (const char *name, const char *proto)
netdb.h(BSD):Section 16.6.4 [The Services Database], page 474.

struct servent * getservbyport (intport, const char *proto)
netdb.h(BSD):Section 16.6.4 [The Services Database], page 474.

struct servent * getservent (void)
netdb.h(BSD):Section 16.6.4 [The Services Database], page 474.

pid_t getsid (pid_tpid)
unistd.h(SVID):Section 28.6.2 [Process Group Functions], page 831.

int getsockname (intsocket, struct sockaddr *addr, socklen_t *length-ptr)
sys/socket.h(BSD):Section 16.3.3 [Reading the Address of a Socket], page 459.


Appendix B: Summary of Library Facilities 1042

int getsockopt (intsocket, intlevel, intoptname, void *optval, socklen_t *optlen-ptr)
sys/socket.h(BSD):Section 16.12.1 [Socket Option Functions], page 499.

int getsubopt (char **optionp, char *const *tokens, char **valuep)
stdlib.h(???):Section 25.3.12.1 [Parsing of Suboptions], page 790.

char * gettext (const char *msgid)
libintl.h(GNU):Section 8.2.1.1 [What has to be done to translate a message?], page 213.

pid_t gettid (void)
unistd.h(Linux):Section 26.3 [Process Identification], page 804.

int gettimeofday (struct timeval *tp, void *tzp)
sys/time.h(BSD):Section 21.5.1 [Getting the Time], page 651.

uid_t getuid (void)
unistd.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

mode_t getumask (void)
sys/stat.h(GNU):Section 14.9.7 [Assigning File Permissions], page 436.

struct utmp * getutent (void)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

int getutent_r (struct utmp *buffer, struct utmp **result)
utmp.h(GNU):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

struct utmp * getutid (const struct utmp *id)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

int getutid_r (const struct utmp *id, struct utmp *buffer, struct utmp **result)
utmp.h(GNU):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

struct utmp * getutline (const struct utmp *line)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

int getutline_r (const struct utmp *line, struct utmp *buffer, struct utmp **result)
utmp.h(GNU):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

int getutmp (const struct utmpx *utmpx, struct utmp *utmp)
utmp.h(GNU):Section 30.12.2 [XPG User Accounting Database Functions], page 861.
utmpx.h(GNU):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

int getutmpx (const struct utmp *utmp, struct utmpx *utmpx)
utmp.h(GNU):Section 30.12.2 [XPG User Accounting Database Functions], page 861.
utmpx.h(GNU):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

struct utmpx * getutxent (void)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

struct utmpx * getutxid (const struct utmpx *id)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

struct utmpx * getutxline (const struct utmpx *line)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

int getw (FILE *stream)
stdio.h(SVID):Section 12.8 [Character Input], page 280.

wint_t getwc (FILE *stream)
wchar.h(ISO):Section 12.8 [Character Input], page 280.

wint_t getwc_unlocked (FILE *stream)
wchar.h(GNU):Section 12.8 [Character Input], page 280.

wint_t getwchar (void)
wchar.h(ISO):Section 12.8 [Character Input], page 280.


Appendix B: Summary of Library Facilities 1043

wint_t getwchar_unlocked (void)
wchar.h(GNU):Section 12.8 [Character Input], page 280.

char * getwd (char *buffer)
unistd.h(BSD):Section 14.1 [Working Directory], page 402.

gid_t
sys/types.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

int glob (const char *pattern, intflags, int (*errfunc) (const char *filename, interror-code),
glob_t *vector-ptr)
glob.h(POSIX.2):Section 10.2.1 [Callingglob], page 240.

int glob64 (const char *pattern, intflags, int (*errfunc) (const char *filename, int
error-code), glob64_t *vector-ptr)
glob.h(GNU):Section 10.2.1 [Callingglob], page 240.

glob64_t
glob.h(GNU):Section 10.2.1 [Callingglob], page 240.

glob_t
glob.h(POSIX.2):Section 10.2.1 [Callingglob], page 240.

void globfree (glob_t *pglob)
glob.h(POSIX.2):Section 10.2.3 [More Flags for Globbing], page 246.

void globfree64 (glob64_t *pglob)
glob.h(GNU):Section 10.2.3 [More Flags for Globbing], page 246.

struct tm * gmtime (const time_t *time)
time.h(ISO):Section 21.5.3 [Broken-down Time], page 659.

struct tm * gmtime_r (const time_t *time, struct tm *resultp)
time.h(POSIX.1c):Section 21.5.3 [Broken-down Time], page 659.

int grantpt (intfiledes)
stdlib.h(SVID):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.
stdlib.h(XPG4.2):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.

struct group
grp.h(POSIX.1):Section 30.14.1 [The Data Structure for a Group], page 868.

int gsignal (intsignum)
signal.h(SVID):Section 24.6.1 [Signaling Yourself], page 742.

int gtty (intfiledes, struct sgttyb *attributes)
sgtty.h(BSD):Section 17.5 [BSD Terminal Modes], page 522.

char * hasmntopt (const struct mntent *mnt, const char *opt)
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

int hcreate (size_tnel)
search.h(SVID):Section 9.5 [Thehsearchfunction.], page 232.

int hcreate_r (size_tnel, struct hsearch_data *htab)
search.h(GNU):Section 9.5 [Thehsearchfunction.], page 232.

void hdestroy (void)
search.h(SVID):Section 9.5 [Thehsearchfunction.], page 232.

void hdestroy_r (struct hsearch_data *htab)
search.h(GNU):Section 9.5 [Thehsearchfunction.], page 232.

struct hostent
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

ENTRY * hsearch (ENTRYitem, ACTIONaction)
search.h(SVID):Section 9.5 [Thehsearchfunction.], page 232.


Appendix B: Summary of Library Facilities 1044

int hsearch_r (ENTRYitem, ACTIONaction, ENTRY **retval, struct hsearch_data *htab)
search.h(GNU):Section 9.5 [Thehsearchfunction.], page 232.

uint32_t htonl (uint32_thostlong)
netinet/in.h(BSD):Section 16.6.5 [Byte Order Conversion], page 476.

uint16_t htons (uint16_thostshort)
netinet/in.h(BSD):Section 16.6.5 [Byte Order Conversion], page 476.

double hypot (doublex, doubley)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float hypotf (floatx, floaty)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN hypotfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx hypotfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double hypotl (long doublex, long doubley)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

size_t iconv (iconv_tcd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t
*outbytesleft)
iconv.h(XPG2):Section 6.5.1 [Generic Character Set Conversion Interface], page 162.

int iconv_close (iconv_tcd)
iconv.h(XPG2):Section 6.5.1 [Generic Character Set Conversion Interface], page 162.

iconv_t iconv_open (const char *tocode, const char *fromcode)
iconv.h(XPG2):Section 6.5.1 [Generic Character Set Conversion Interface], page 162.

iconv_t
iconv.h(XPG2):Section 6.5.1 [Generic Character Set Conversion Interface], page 162.

void if_freenameindex (struct if_nameindex *ptr)
net/if.h(IPv6 basic API):Section 16.4 [Interface Naming], page 460.

char * if_indextoname (unsigned intifindex, char *ifname)
net/if.h(IPv6 basic API):Section 16.4 [Interface Naming], page 460.

struct if_nameindex
net/if.h(IPv6 basic API):Section 16.4 [Interface Naming], page 460.

struct if_nameindex * if_nameindex (void)
net/if.h(IPv6 basic API):Section 16.4 [Interface Naming], page 460.

unsigned int if_nametoindex (const char *ifname)
net/if.h(IPv6 basic API):Section 16.4 [Interface Naming], page 460.

int ilogb (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

int ilogbf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

int ilogbfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

int ilogbfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

int ilogbl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

intmax_t imaxabs (intmax_tnumber)
inttypes.h(ISO):Section 20.8.1 [Absolute Value], page 617.


Appendix B: Summary of Library Facilities 1045

imaxdiv_t imaxdiv (intmax_tnumerator, intmax_tdenominator)
inttypes.h(ISO):Section 20.2 [Integer Division], page 602.

imaxdiv_t
inttypes.h(ISO):Section 20.2 [Integer Division], page 602.

struct in6_addr
netinet/in.h(IPv6 basic API):Section 16.6.2.2 [Host Address Data Type], page 467.

struct in6_addr in6addr_any
netinet/in.h(IPv6 basic API):Section 16.6.2.2 [Host Address Data Type], page 467.

struct in6_addr in6addr_loopback
netinet/in.h(IPv6 basic API):Section 16.6.2.2 [Host Address Data Type], page 467.

struct in_addr
netinet/in.h(BSD):Section 16.6.2.2 [Host Address Data Type], page 467.

char * index (const char *string, intc)
string.h(BSD):Section 5.9 [Search Functions], page 121.

uint32_t inet_addr (const char *name)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

int inet_aton (const char *name, struct in_addr *addr)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

uint32_t inet_lnaof (struct in_addraddr)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

struct in_addr inet_makeaddr (uint32_tnet, uint32_tlocal)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

uint32_t inet_netof (struct in_addraddr)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

uint32_t inet_network (const char *name)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

char * inet_ntoa (struct in_addraddr)
arpa/inet.h(BSD):Section 16.6.2.3 [Host Address Functions], page 468.

const char * inet_ntop (intaf, const void *cp, char *buf, socklen_tlen)
arpa/inet.h(IPv6 basic API):Section 16.6.2.3 [Host Address Functions], page 468.

int inet_pton (intaf, const char *cp, void *buf)
arpa/inet.h(IPv6 basic API):Section 16.6.2.3 [Host Address Functions], page 468.

int initgroups (const char *user, gid_tgroup)
grp.h(BSD):Section 30.7 [Setting the Group IDs], page 849.

char * initstate (unsigned intseed, char *state, size_tsize)
stdlib.h(BSD):Section 19.8.2 [BSD Random Number Functions], page 592.

int initstate_r (unsigned intseed, char *restrictstatebuf, size_tstatelen, struct
random_data *restrictbuf)
stdlib.h(GNU):Section 19.8.2 [BSD Random Number Functions], page 592.

int innetgr (const char *netgroup, const char *host, const char *user, const char *domain)
netdb.h(BSD):Section 30.16.3 [Testing for Netgroup Membership], page 874.

ino64_t
sys/types.h(Unix98):Section 14.9.1 [The meaning of the File Attributes], page 425.

ino_t
sys/types.h(POSIX.1):Section 14.9.1 [The meaning of the File Attributes], page 425.


Appendix B: Summary of Library Facilities 1046

int ioctl (intfiledes, intcommand, ...)
sys/ioctl.h(BSD):Section 13.20 [Generic I/O Control operations], page 401.

struct iovec
sys/uio.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

int isalnum (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int isalpha (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int isascii (intc)
ctype.h(SVID):Section 4.1 [Classification of Characters], page 87.
ctype.h(BSD):Section 4.1 [Classification of Characters], page 87.

int isatty (intfiledes)
unistd.h(POSIX.1):Section 17.1 [Identifying Terminals], page 503.

int isblank (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int iscanonical (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int iscntrl (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int isdigit (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int iseqsig (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int isfinite (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isgraph (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int isgreater (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int isgreaterequal (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int isinf (doublex)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isinff (floatx)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isinfl (long doublex)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isless (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int islessequal (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int islessgreater (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int islower (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int isnan (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.


Appendix B: Summary of Library Facilities 1047

int isnan (doublex)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isnanf (floatx)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isnanl (long doublex)
math.h(BSD):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isnormal (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isprint (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int ispunct (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int issignaling (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isspace (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int issubnormal (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

int isunordered (real-floating x,real-floating y)
math.h(ISO):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int isupper (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int iswalnum (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswalpha (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswblank (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswcntrl (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswctype (wint_twc, wctype_tdesc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswdigit (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswgraph (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswlower (wint_twc)
ctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswprint (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswpunct (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswspace (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int iswupper (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.


Appendix B: Summary of Library Facilities 1048

int iswxdigit (wint_twc)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

int isxdigit (intc)
ctype.h(ISO):Section 4.1 [Classification of Characters], page 87.

int iszero (float-type x)
math.h(ISO):Section 20.4 [Floating-Point Number Classification Functions], page 605.

struct itimerval
sys/time.h(BSD):Section 21.6 [Setting an Alarm], page 679.

double j0 (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float j0f (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN j0fN (_FloatN x)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx j0fNx (_FloatNxx)
math.h(GNU):Section 19.6 [Special Functions], page 553.

long double j0l (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

double j1 (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float j1f (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN j1fN (_FloatN x)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx j1fNx (_FloatNxx)
math.h(GNU):Section 19.6 [Special Functions], page 553.

long double j1l (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

jmp_buf
setjmp.h(ISO):Section 23.2 [Details of Non-Local Exits], page 706.

double jn (intn, doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float jnf (intn, floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN jnfN (intn, _FloatN x)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx jnfNx (intn, _FloatNxx)
math.h(GNU):Section 19.6 [Special Functions], page 553.

long double jnl (intn, long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

long int jrand48 (unsigned short intxsubi[3])
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int jrand48_r (unsigned short intxsubi[3], struct drand48_data *buffer, long int *result)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

int kill (pid_tpid, intsignum)
signal.h(POSIX.1):Section 24.6.2 [Signaling Another Process], page 743.


Appendix B: Summary of Library Facilities 1049

int killpg (intpgid, intsignum)
signal.h(BSD):Section 24.6.2 [Signaling Another Process], page 743.

char * l64a (long intn)
stdlib.h(XPG):Section 5.14 [Encode Binary Data], page 133.

long int labs (long intnumber)
stdlib.h(ISO):Section 20.8.1 [Absolute Value], page 617.

void lcong48 (unsigned short intparam[7])
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int lcong48_r (unsigned short intparam[7], struct drand48_data *buffer)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

struct lconv
locale.h(ISO):Section 7.7.1 [localeconv: It is portable but... ], page 189.

double ldexp (doublevalue, intexponent)
math.h(ISO):Section 20.8.2 [Normalization Functions], page 618.

float ldexpf (floatvalue, intexponent)
math.h(ISO):Section 20.8.2 [Normalization Functions], page 618.

_FloatN ldexpfN (_FloatN value, intexponent)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

_FloatNx ldexpfNx (_FloatNxvalue, intexponent)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

long double ldexpl (long doublevalue, intexponent)
math.h(ISO):Section 20.8.2 [Normalization Functions], page 618.

ldiv_t ldiv (long intnumerator, long intdenominator)
stdlib.h(ISO):Section 20.2 [Integer Division], page 602.

ldiv_t
stdlib.h(ISO):Section 20.2 [Integer Division], page 602.

void * lfind (const void *key, const void *base, size_t *nmemb, size_tsize, comparison_fn_t
compar)
search.h(SVID):Section 9.2 [Array Search Function], page 228.

double lgamma (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

double lgamma_r (doublex, int *signp)
math.h(XPG):Section 19.6 [Special Functions], page 553.

float lgammaf (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN lgammafN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

_FloatN lgammafN_r (_FloatN x, int *signp)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx lgammafNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

_FloatNx lgammafNx_r (_FloatNxx, int *signp)
math.h(GNU):Section 19.6 [Special Functions], page 553.

float lgammaf_r (floatx, int *signp)
math.h(XPG):Section 19.6 [Special Functions], page 553.

long double lgammal (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.


Appendix B: Summary of Library Facilities 1050

long double lgammal_r (long doublex, int *signp)
math.h(XPG):Section 19.6 [Special Functions], page 553.

struct linger
sys/socket.h(BSD):Section 16.12.2 [Socket-Level Options], page 499.

int link (const char *oldname, const char *newname)
unistd.h(POSIX.1):Section 14.4 [Hard Links], page 418.

int linkat (int oldfd, const char *oldname, int newfd, const char *newname, int flags)
unistd.h(POSIX.1):Section 14.4 [Hard Links], page 418.

int lio_listio (intmode, struct aiocb *constlist[], intnent, struct sigevent *sig)
aio.h(POSIX.1b):Section 13.11.1 [Asynchronous Read and Write Operations], page 373.

int lio_listio64 (intmode, struct aiocb64 *constlist[], intnent, struct sigevent *sig)
aio.h(Unix98):Section 13.11.1 [Asynchronous Read and Write Operations], page 373.

int listen (intsocket, intn)
sys/socket.h(BSD):Section 16.9.2 [Listening for Connections], page 483.

long long int llabs (long long intnumber)
stdlib.h(ISO):Section 20.8.1 [Absolute Value], page 617.

lldiv_t lldiv (long long intnumerator, long long intdenominator)
stdlib.h(ISO):Section 20.2 [Integer Division], page 602.

lldiv_t
stdlib.h(ISO):Section 20.2 [Integer Division], page 602.

long int llogb (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

long int llogbf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

long int llogbfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long int llogbfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long int llogbl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

long long int llrint (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long long int llrintf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long long int llrintfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long long int llrintfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long long int llrintl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long long int llround (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long long int llroundf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long long int llroundfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.


Appendix B: Summary of Library Facilities 1051

long long int llroundfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long long int llroundl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

struct lconv * localeconv (void)
locale.h(ISO):Section 7.7.1 [localeconv: It is portable but... ], page 189.

struct tm * localtime (const time_t *time)
time.h(ISO):Section 21.5.3 [Broken-down Time], page 659.

struct tm * localtime_r (const time_t *time, struct tm *resultp)
time.h(POSIX.1c):Section 21.5.3 [Broken-down Time], page 659.

double log (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

double log10 (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float log10f (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN log10fN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx log10fNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double log10l (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

double log1p (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float log1pf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN log1pfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx log1pfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double log1pl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

double log2 (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float log2f (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN log2fN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx log2fNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double log2l (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

double logb (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float logbf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.


Appendix B: Summary of Library Facilities 1052

_FloatN logbfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx logbfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double logbl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float logf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN logfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx logfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

void login (const struct utmp *entry)
utmp.h(BSD):Section 30.12.3 [Logging In and Out], page 863.

int login_tty (intfiledes)
utmp.h(BSD):Section 30.12.3 [Logging In and Out], page 863.

long double logl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

int logout (const char *ut_line)
utmp.h(BSD):Section 30.12.3 [Logging In and Out], page 863.

void logwtmp (const char *ut_line, const char *ut_name, const char *ut_host)
utmp.h(BSD):Section 30.12.3 [Logging In and Out], page 863.

void longjmp (jmp_bufstate, intvalue)
setjmp.h(ISO):Section 23.2 [Details of Non-Local Exits], page 706.

long int lrand48 (void)
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int lrand48_r (struct drand48_data *buffer, long int *result)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

long int lrint (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long int lrintf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long int lrintfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long int lrintfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long int lrintl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long int lround (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long int lroundf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

long int lroundfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long int lroundfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.


Appendix B: Summary of Library Facilities 1053

long int lroundl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

void * lsearch (const void *key, void *base, size_t *nmemb, size_tsize, comparison_fn_tcompar)
search.h(SVID):Section 9.2 [Array Search Function], page 228.

off_t lseek (intfiledes, off_toffset, intwhence)
unistd.h(POSIX.1):Section 13.3 [Setting the File Position of a Descriptor], page 350.

off64_t lseek64 (intfiledes, off64_toffset, intwhence)
unistd.h(Unix98):Section 13.3 [Setting the File Position of a Descriptor], page 350.

int lstat (const char *filename, struct stat *buf)
sys/stat.h(BSD):Section 14.9.2 [Reading the Attributes of a File], page 429.

int lstat64 (const char *filename, struct stat64 *buf)
sys/stat.h(Unix98):Section 14.9.2 [Reading the Attributes of a File], page 429.

int lutimes (const char *filename, const struct timevaltvp[2])
sys/time.h(BSD):Section 14.9.9 [File Times], page 439.

int madvise (void *addr, size_tlength, intadvice)
sys/mman.h(POSIX):Section 13.8 [Memory-mapped I/O], page 360.

void makecontext (ucontext_t *ucp, void (*func) (void), intargc, ...)
ucontext.h(SVID):Section 23.4 [Complete Context Control], page 708.

struct mallinfo2
malloc.h(GNU):Section 3.2.3.10 [Statistics for Memory Allocation withmalloc], page 56.

struct mallinfo2 mallinfo2 (void)
malloc.h(SVID):Section 3.2.3.10 [Statistics for Memory Allocation withmalloc], page 56.

void * malloc (size_tsize)
malloc.h(ISO):Section 3.2.3.1 [Basic Memory Allocation], page 45.
stdlib.h(ISO):Section 3.2.3.1 [Basic Memory Allocation], page 45.

int mblen (const char *string, size_tsize)
stdlib.h(ISO):Section 6.4.1 [Non-reentrant Conversion of Single Characters], page 158.

size_t mbrlen (const char *restricts, size_tn, mbstate_t *ps)
wchar.h(ISO):Section 6.3.3 [Converting Single Characters], page 146.

size_t mbrtowc (wchar_t *restrictpwc, const char *restricts, size_tn, mbstate_t *restrictps)
wchar.h(ISO):Section 6.3.3 [Converting Single Characters], page 146.

int mbsinit (const mbstate_t *ps)
wchar.h(ISO):Section 6.3.2 [Representing the state of the conversion], page 145.

size_t mbsnrtowcs (wchar_t *restrictdst, const char **restrictsrc, size_tnmc, size_tlen,
mbstate_t *restrictps)
wchar.h(GNU):Section 6.3.4 [Converting Multibyte and Wide Character Strings], page 153.

size_t mbsrtowcs (wchar_t *restrictdst, const char **restrictsrc, size_tlen, mbstate_t
*restrictps)
wchar.h(ISO):Section 6.3.4 [Converting Multibyte and Wide Character Strings], page 153.

mbstate_t
wchar.h(ISO):Section 6.3.2 [Representing the state of the conversion], page 145.

size_t mbstowcs (wchar_t *wstring, const char *string, size_tsize)
stdlib.h(ISO):Section 6.4.2 [Non-reentrant Conversion of Strings], page 159.

int mbtowc (wchar_t *restrictresult, const char *restrictstring, size_tsize)
stdlib.h(ISO):Section 6.4.1 [Non-reentrant Conversion of Single Characters], page 158.

int mcheck (void (*abortfn) (enum mcheck_statusstatus))
mcheck.h(GNU):Section 3.2.3.8 [Heap Consistency Checking], page 52.


Appendix B: Summary of Library Facilities 1054

void * memalign (size_tboundary, size_tsize)
malloc.h(BSD):Section 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

void * memccpy (void *restrictto, const void *restrictfrom, intc, size_tsize)
string.h(SVID):Section 5.4 [Copying Strings and Arrays], page 101.

void * memchr (const void *block, intc, size_tsize)
string.h(ISO):Section 5.9 [Search Functions], page 121.

int memcmp (const void *a1, const void *a2, size_tsize)
string.h(ISO):Section 5.7 [String/Array Comparison], page 113.

void * memcpy (void *restrictto, const void *restrictfrom, size_tsize)
string.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

int memfd_create (const char *name, unsigned intflags)
sys/mman.h(Linux):Section 13.8 [Memory-mapped I/O], page 360.

void * memfrob (void *mem, size_tlength)
string.h(GNU):Section 5.13 [Obfuscating Data], page 132.

void * memmem (const void *haystack, size_thaystack-len,
const void *needle, size_tneedle-len)
string.h(GNU):Section 5.9 [Search Functions], page 121.

void * memmove (void *to, const void *from, size_tsize)
string.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

void * mempcpy (void *restrictto, const void *restrictfrom, size_tsize)
string.h(GNU):Section 5.4 [Copying Strings and Arrays], page 101.

void * memrchr (const void *block, intc, size_tsize)
string.h(GNU):Section 5.9 [Search Functions], page 121.

void * memset (void *block, intc, size_tsize)
string.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

int mkdir (const char *filename, mode_tmode)
sys/stat.h(POSIX.1):Section 14.8 [Creating Directories], page 424.

char * mkdtemp (char *template)
stdlib.h(BSD):Section 14.11 [Temporary Files], page 446.

int mkfifo (const char *filename, mode_tmode)
sys/stat.h(POSIX.1):Section 15.3 [FIFO Special Files], page 453.

int mknod (const char *filename, mode_tmode, dev_tdev)
sys/stat.h(BSD):Section 14.10 [Making Special Files], page 445.

int mkstemp (char *template)
stdlib.h(BSD):Section 14.11 [Temporary Files], page 446.

char * mktemp (char *template)
stdlib.h(Unix):Section 14.11 [Temporary Files], page 446.

time_t mktime (struct tm *brokentime)
time.h(ISO):Section 21.5.3 [Broken-down Time], page 659.

int mlock (const void *addr, size_tlen)
sys/mman.h(POSIX.1b):Section 3.5.3 [Functions To Lock And Unlock Pages], page 83.

int mlock2 (const void *addr, size_tlen, unsigned intflags)
sys/mman.h(Linux):Section 3.5.3 [Functions To Lock And Unlock Pages], page 83.

int mlockall (intflags)
sys/mman.h(POSIX.1b):Section 3.5.3 [Functions To Lock And Unlock Pages], page 83.

void * mmap (void *address, size_tlength, intprotect, intflags, intfiledes, off_toffset)
sys/mman.h(POSIX):Section 13.8 [Memory-mapped I/O], page 360.


Appendix B: Summary of Library Facilities 1055

void * mmap64 (void *address, size_tlength, intprotect, intflags, intfiledes, off64_t
offset)
sys/mman.h(LFS):Section 13.8 [Memory-mapped I/O], page 360.

struct mntent
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

mode_t
sys/types.h(POSIX.1):Section 14.9.1 [The meaning of the File Attributes], page 425.

double modf (doublevalue, double *integer-part)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

float modff (floatvalue, float *integer-part)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN modffN (_FloatN value, _FloatN*integer-part)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx modffNx (_FloatNxvalue, _FloatNx *integer-part)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double modfl (long doublevalue, long double *integer-part)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

int mount (const char *special_file, const char *dir, const char *fstype, unsigned long int
options, const void *data)
sys/mount.h(SVID):Section 31.3.2 [Mount, Unmount, Remount], page 885.
sys/mount.h(BSD):Section 31.3.2 [Mount, Unmount, Remount], page 885.

int mprotect (void *address, size_tlength, intprotection)
sys/mman.h(POSIX):Section 3.4 [Memory Protection], page 77.

long int mrand48 (void)
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int mrand48_r (struct drand48_data *buffer, long int *result)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

void * mremap (void *address, size_tlength, size_tnew_length, intflag)
sys/mman.h(GNU):Section 13.8 [Memory-mapped I/O], page 360.

int msync (void *address, size_tlength, intflags)
sys/mman.h(POSIX):Section 13.8 [Memory-mapped I/O], page 360.

void mtrace (void)
mcheck.h(GNU):Section 3.2.4.1 [How to install the tracing functionality], page 59.

void mtx_destroy (mtx_t *mutex)
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

int mtx_init (mtx_t *mutex, inttype)
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

int mtx_lock (mtx_t *mutex)
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

mtx_plain
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

mtx_recursive
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

mtx_t
threads.h(C11):Section 35.1.4 [Mutexes], page 923.


Appendix B: Summary of Library Facilities 1056

mtx_timed
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

int mtx_timedlock (mtx_t *restrictmutex, const struct timespec *restricttime_point)
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

int mtx_trylock (mtx_t *mutex)
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

int mtx_unlock (mtx_t *mutex)
threads.h(C11):Section 35.1.4 [Mutexes], page 923.

int munlock (const void *addr, size_tlen)
sys/mman.h(POSIX.1b):Section 3.5.3 [Functions To Lock And Unlock Pages], page 83.

int munlockall (void)
sys/mman.h(POSIX.1b):Section 3.5.3 [Functions To Lock And Unlock Pages], page 83.

int munmap (void *addr, size_tlength)
sys/mman.h(POSIX):Section 13.8 [Memory-mapped I/O], page 360.

void muntrace (void)
mcheck.h(GNU):Section 3.2.4.1 [How to install the tracing functionality], page 59.

double nan (const char *tagp)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float nanf (const char *tagp)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

_FloatN nanfN (const char *tagp)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

_FloatNx nanfNx (const char *tagp)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

long double nanl (const char *tagp)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int nanosleep (const struct timespec *requested_time, struct timespec *remaining)
time.h(POSIX.1):Section 21.7 [Sleeping], page 682.

double nearbyint (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

float nearbyintf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN nearbyintfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx nearbyintfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double nearbyintl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

struct netent
netdb.h(BSD):Section 16.13 [Networks Database], page 501.

double nextafter (doublex, doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float nextafterf (floatx, floaty)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.


Appendix B: Summary of Library Facilities 1057

_FloatN nextafterfN (_FloatN x, _FloatN y)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

_FloatNx nextafterfNx (_FloatNxx, _FloatNxy)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

long double nextafterl (long doublex, long doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

double nextdown (doublex)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float nextdownf (floatx)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

_FloatN nextdownfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

_FloatNx nextdownfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

long double nextdownl (long doublex)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

double nexttoward (doublex, long doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float nexttowardf (floatx, long doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

long double nexttowardl (long doublex, long doubley)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

double nextup (doublex)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

float nextupf (floatx)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

_FloatN nextupfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

_FloatNx nextupfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

long double nextupl (long doublex)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int nftw (const char *filename, __nftw_func_tfunc, intdescriptors, intflag)
ftw.h(XPG4.2):Section 14.3 [Working with Directory Trees], page 414.

int nftw64 (const char *filename, __nftw64_func_tfunc, intdescriptors, intflag)
ftw.h(Unix98):Section 14.3 [Working with Directory Trees], page 414.

char * ngettext (const char *msgid1, const char *msgid2, unsigned long intn)
libintl.h(GNU):Section 8.2.1.3 [Additional functions for more complicated situations],
page 217.

int nice (intincrement)
unistd.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.


Appendix B: Summary of Library Facilities 1058

char * nl_langinfo (nl_itemitem)
langinfo.h(XOPEN):Section 7.7.2 [Pinpoint Access to Locale Data], page 192.

nlink_t
sys/types.h(POSIX.1):Section 14.9.1 [The meaning of the File Attributes], page 425.

long int nrand48 (unsigned short intxsubi[3])
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int nrand48_r (unsigned short intxsubi[3], struct drand48_data *buffer, long int *result)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

uint32_t ntohl (uint32_tnetlong)
netinet/in.h(BSD):Section 16.6.5 [Byte Order Conversion], page 476.

uint16_t ntohs (uint16_tnetshort)
netinet/in.h(BSD):Section 16.6.5 [Byte Order Conversion], page 476.

int ntp_adjtime (struct timex *tptr)
sys/timex.h(GNU):Section 21.5.2 [Setting and Adjusting the Time], page 653.

int ntp_gettime (struct ntptimeval *tptr)
sys/timex.h(GNU):Section 21.5.2 [Setting and Adjusting the Time], page 653.

struct obstack
obstack.h(GNU):Section 3.2.6.1 [Creating Obstacks], page 64.

void obstack_1grow (struct obstack *obstack-ptr, charc)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.

void obstack_1grow_fast (struct obstack *obstack-ptr, charc)
obstack.h(GNU):Section 3.2.6.7 [Extra Fast Growing Objects], page 69.

int obstack_alignment_mask (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.9 [Alignment of Data in Obstacks], page 72.

void * obstack_alloc (struct obstack *obstack-ptr, intsize)
obstack.h(GNU):Section 3.2.6.3 [Allocation in an Obstack], page 65.

obstack_alloc_failed_handler
obstack.h(GNU):Section 3.2.6.2 [Preparing for Using Obstacks], page 64.

void * obstack_base (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.8 [Status of an Obstack], page 71.

void obstack_blank (struct obstack *obstack-ptr, intsize)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.

void obstack_blank_fast (struct obstack *obstack-ptr, intsize)
obstack.h(GNU):Section 3.2.6.7 [Extra Fast Growing Objects], page 69.

int obstack_chunk_size (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.10 [Obstack Chunks], page 72.

void * obstack_copy (struct obstack *obstack-ptr, void *address, intsize)
obstack.h(GNU):Section 3.2.6.3 [Allocation in an Obstack], page 65.

void * obstack_copy0 (struct obstack *obstack-ptr, void *address, intsize)
obstack.h(GNU):Section 3.2.6.3 [Allocation in an Obstack], page 65.

void * obstack_finish (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.

void obstack_free (struct obstack *obstack-ptr, void *object)
obstack.h(GNU):Section 3.2.6.4 [Freeing Objects in an Obstack], page 66.

void obstack_grow (struct obstack *obstack-ptr, void *data, intsize)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.


Appendix B: Summary of Library Facilities 1059

void obstack_grow0 (struct obstack *obstack-ptr, void *data, intsize)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.

int obstack_init (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.2 [Preparing for Using Obstacks], page 64.

void obstack_int_grow (struct obstack *obstack-ptr, intdata)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.

void obstack_int_grow_fast (struct obstack *obstack-ptr, intdata)
obstack.h(GNU):Section 3.2.6.7 [Extra Fast Growing Objects], page 69.

void * obstack_next_free (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.8 [Status of an Obstack], page 71.

int obstack_object_size (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.
obstack.h(GNU):Section 3.2.6.8 [Status of an Obstack], page 71.

int obstack_printf (struct obstack *obstack, const char *template, ...)
stdio.h(GNU):Section 12.12.8 [Dynamically Allocating Formatted Output], page 299.

void obstack_ptr_grow (struct obstack *obstack-ptr, void *data)
obstack.h(GNU):Section 3.2.6.6 [Growing Objects], page 67.

void obstack_ptr_grow_fast (struct obstack *obstack-ptr, void *data)
obstack.h(GNU):Section 3.2.6.7 [Extra Fast Growing Objects], page 69.

int obstack_room (struct obstack *obstack-ptr)
obstack.h(GNU):Section 3.2.6.7 [Extra Fast Growing Objects], page 69.

int obstack_vprintf (struct obstack *obstack, const char *template, va_listap)
stdio.h(GNU):Section 12.12.9 [Variable Arguments Output Functions], page 299.

off64_t
sys/types.h(Unix98):Section 13.3 [Setting the File Position of a Descriptor], page 350.

off_t
sys/types.h(POSIX.1):Section 13.3 [Setting the File Position of a Descriptor], page 350.

size_t offsetof (type,member)
stddef.h(ISO):Section A.5.4 [Structure Field Offset Measurement], page 964.

int on_exit (void (*function)(intstatus, void *arg), void *arg)
stdlib.h(SunOS):Section 25.7.3 [Cleanups on Exit], page 800.

once_flag
threads.h(C11):Section 35.1.3 [Call Once], page 923.

int open (const char *filename, intflags[, mode_tmode])
fcntl.h(POSIX.1):Section 13.1 [Opening and Closing Files], page 342.

int open64 (const char *filename, intflags[, mode_tmode])
fcntl.h(Unix98):Section 13.1 [Opening and Closing Files], page 342.

FILE * open_memstream (char **ptr, size_t *sizeloc)
stdio.h(GNU):Section 12.21.1 [String Streams], page 333.

DIR * opendir (const char *dirname)
dirent.h(POSIX.1):Section 14.2.2 [Opening a Directory Stream], page 406.

void openlog (const char *ident, intoption, intfacility)
syslog.h(BSD):Section 18.2.1 [openlog], page 532.

int openpty (int *amaster, int *aslave, char *name, const struct termios *termp, const struct
winsize *winp)
pty.h(BSD):Section 17.9.2 [Opening a Pseudo-Terminal Pair], page 530.


Appendix B: Summary of Library Facilities 1060

char * optarg
unistd.h(POSIX.2):Section 25.2.1 [Using thegetoptfunction], page 761.

int opterr
unistd.h(POSIX.2):Section 25.2.1 [Using thegetoptfunction], page 761.

int optind
unistd.h(POSIX.2):Section 25.2.1 [Using thegetoptfunction], page 761.

struct option
getopt.h(GNU):Section 25.2.3 [Parsing Long Options withgetopt_long], page 764.

int optopt
unistd.h(POSIX.2):Section 25.2.1 [Using thegetoptfunction], page 761.

size_t parse_printf_format (const char *template, size_tn, int *argtypes)
printf.h(GNU):Section 12.12.10 [Parsing a Template String], page 302.

struct passwd
pwd.h(POSIX.1):Section 30.13.1 [The Data Structure that Describes a User], page 864.

long int pathconf (const char *filename, intparameter)
unistd.h(POSIX.1):Section 32.9 [Usingpathconf], page 906.

int pause (void)
unistd.h(POSIX.1):Section 24.8.1 [Usingpause], page 753.

int pclose (FILE *stream)
stdio.h(POSIX.2):Section 15.2 [Pipe to a Subprocess], page 452.
stdio.h(SVID):Section 15.2 [Pipe to a Subprocess], page 452.
stdio.h(BSD):Section 15.2 [Pipe to a Subprocess], page 452.

void perror (const char *message)
stdio.h(ISO):Section 2.3 [Error Messages], page 36.

pid_t
sys/types.h(POSIX.1):Section 26.3 [Process Identification], page 804.

int pipe (intfiledes[2])
unistd.h(POSIX.1):Section 15.1 [Creating a Pipe], page 450.

int pkey_alloc (unsigned intflags, unsigned intrestrictions)
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

int pkey_free (intkey)
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

int pkey_get (intkey)
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

int pkey_mprotect (void *address, size_tlength, intprotection, intkey)
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

int pkey_set (intkey, unsigned intrights)
sys/mman.h(Linux):Section 3.4 [Memory Protection], page 77.

FILE * popen (const char *command, const char *mode)
stdio.h(POSIX.2):Section 15.2 [Pipe to a Subprocess], page 452.
stdio.h(SVID):Section 15.2 [Pipe to a Subprocess], page 452.
stdio.h(BSD):Section 15.2 [Pipe to a Subprocess], page 452.

int posix_memalign (void **memptr, size_talignment, size_tsize)
stdlib.h(POSIX):Section 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

double pow (doublebase, doublepower)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.


Appendix B: Summary of Library Facilities 1061

float powf (floatbase, floatpower)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN powfN (_FloatN base, _FloatN power)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx powfNx (_FloatNxbase, _FloatNxpower)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

long double powl (long doublebase, long doublepower)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

ssize_t pread (intfiledes, void *buffer, size_tsize, off_toffset)
unistd.h(Unix98):Section 13.2 [Input and Output Primitives], page 345.

ssize_t pread64 (intfiledes, void *buffer, size_tsize, off64_toffset)
unistd.h(Unix98):Section 13.2 [Input and Output Primitives], page 345.

ssize_t preadv (intfd, const struct iovec *iov, intiovcnt, off_toffset)
sys/uio.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

ssize_t preadv2 (intfd, const struct iovec *iov, intiovcnt, off_toffset, intflags)
sys/uio.h(GNU):Section 13.6 [Fast Scatter-Gather I/O], page 355.

ssize_t preadv64 (intfd, const struct iovec *iov, intiovcnt, off64_toffset)
unistd.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

ssize_t preadv64v2 (intfd, const struct iovec *iov, intiovcnt, off64_toffset, intflags)
unistd.h(GNU):Section 13.6 [Fast Scatter-Gather I/O], page 355.

int printf (const char *template, ...)
stdio.h(ISO):Section 12.12.7 [Formatted Output Functions], page 296.

printf_arginfo_function
printf.h(GNU):Section 12.13.3 [Defining the Output Handler], page 307.

printf_function
printf.h(GNU):Section 12.13.3 [Defining the Output Handler], page 307.

struct printf_info
printf.h(GNU):Section 12.13.2 [Conversion Specifier Options], page 306.

int printf_size (FILE *fp, const struct printf_info *info, const void *const *args)
printf.h(GNU):Section 12.13.5 [PredefinedprintfHandlers], page 309.

int printf_size_info (const struct printf_info *info, size_tn, int *argtypes)
printf.h(GNU):Section 12.13.5 [PredefinedprintfHandlers], page 309.

char * program_invocation_name
errno.h(GNU):Section 2.3 [Error Messages], page 36.

char * program_invocation_short_name
errno.h(GNU):Section 2.3 [Error Messages], page 36.

struct protoent
netdb.h(BSD):Section 16.6.6 [Protocols Database], page 477.

void psignal (intsignum, const char *message)
signal.h(BSD):Section 24.2.8 [Signal Messages], page 724.

int pthread_attr_getsigmask_np (const pthread_attr_t *attr, sigset_t *sigmask)
pthread.h(GNU):Section 35.2.2.2 [Controlling the Initial Signal Mask of a New Thread],
page 929.

int pthread_attr_setsigmask_np (pthread_attr_t *attr, const sigset_t *sigmask)
pthread.h(GNU):Section 35.2.2.2 [Controlling the Initial Signal Mask of a New Thread],
page 929.


Appendix B: Summary of Library Facilities 1062

int pthread_getattr_default_np (pthread_attr_t *attr)
pthread.h(GNU):Section 35.2.2.1 [Setting Process-wide defaults for thread attributes],
page 929.

void *pthread_getspecific (pthread_key_tkey)
pthread.h(POSIX):Section 35.2.1 [Thread-specific Data], page 928.

int pthread_key_create (pthread_key_t *key, void (*destructor)(void*))
pthread.h(POSIX):Section 35.2.1 [Thread-specific Data], page 928.

int pthread_key_delete (pthread_key_tkey)
pthread.h(POSIX):Section 35.2.1 [Thread-specific Data], page 928.

int pthread_setattr_default_np (pthread_attr_t *attr)
pthread.h(GNU):Section 35.2.2.1 [Setting Process-wide defaults for thread attributes],
page 929.

int pthread_setspecific (pthread_key_tkey, const void *value)
pthread.h(POSIX):Section 35.2.1 [Thread-specific Data], page 928.

ptrdiff_t
stddef.h(ISO):Section A.4 [Important Data Types], page 956.

char * ptsname (intfiledes)
stdlib.h(SVID):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.
stdlib.h(XPG4.2):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.

int ptsname_r (intfiledes, char *buf, size_tlen)
stdlib.h(GNU):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.

int putc (intc, FILE *stream)
stdio.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

int putc_unlocked (intc, FILE *stream)
stdio.h(POSIX):Section 12.7 [Simple Output by Characters or Lines], page 277.

int putchar (intc)
stdio.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

int putchar_unlocked (intc)
stdio.h(POSIX):Section 12.7 [Simple Output by Characters or Lines], page 277.

int putenv (char *string)
stdlib.h(SVID):Section 25.4.1 [Environment Access], page 793.

int putpwent (const struct passwd *p, FILE *stream)
pwd.h(SVID):Section 30.13.4 [Writing a User Entry], page 867.

int puts (const char *s)
stdio.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

struct utmp * pututline (const struct utmp *utmp)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

struct utmpx * pututxline (const struct utmpx *utmp)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

int putw (intw, FILE *stream)
stdio.h(SVID):Section 12.7 [Simple Output by Characters or Lines], page 277.

wint_t putwc (wchar_twc, FILE *stream)
wchar.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.

wint_t putwc_unlocked (wchar_twc, FILE *stream)
wchar.h(GNU):Section 12.7 [Simple Output by Characters or Lines], page 277.

wint_t putwchar (wchar_twc)
wchar.h(ISO):Section 12.7 [Simple Output by Characters or Lines], page 277.


Appendix B: Summary of Library Facilities 1063

wint_t putwchar_unlocked (wchar_twc)
wchar.h(GNU):Section 12.7 [Simple Output by Characters or Lines], page 277.

ssize_t pwrite (intfiledes, const void *buffer, size_tsize, off_toffset)
unistd.h(Unix98):Section 13.2 [Input and Output Primitives], page 345.

ssize_t pwrite64 (intfiledes, const void *buffer, size_tsize, off64_toffset)
unistd.h(Unix98):Section 13.2 [Input and Output Primitives], page 345.

ssize_t pwritev (intfd, const struct iovec *iov, intiovcnt, off_toffset)
sys/uio.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

ssize_t pwritev2 (intfd, const struct iovec *iov, intiovcnt, off_toffset, intflags)
sys/uio.h(GNU):Section 13.6 [Fast Scatter-Gather I/O], page 355.

ssize_t pwritev64 (intfd, const struct iovec *iov, intiovcnt, off64_toffset)
unistd.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

ssize_t pwritev64v2 (intfd, const struct iovec *iov, intiovcnt, off64_toffset, intflags)
unistd.h(GNU):Section 13.6 [Fast Scatter-Gather I/O], page 355.

char * qecvt (long doublevalue, intndigit, int *decpt, int *neg)
stdlib.h (GNU): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

int qecvt_r (long doublevalue, intndigit, int *decpt, int *neg, char *buf, size_tlen)
stdlib.h (GNU): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

char * qfcvt (long doublevalue, intndigit, int *decpt, int *neg)
stdlib.h (GNU): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

int qfcvt_r (long doublevalue, intndigit, int *decpt, int *neg, char *buf, size_tlen)
stdlib.h (GNU): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

char * qgcvt (long doublevalue, intndigit, char *buf)
stdlib.h (GNU): Section 20.13 [Old-fashioned System V number-to-string functions],
page 643.

void qsort (void *array, size_tcount, size_tsize, comparison_fn_tcompare)
stdlib.h(ISO):Section 9.3 [Array Sort Function], page 229.

int raise (intsignum)
signal.h(ISO):Section 24.6.1 [Signaling Yourself], page 742.

int rand (void)
stdlib.h(ISO):Section 19.8.1 [ISO C Random Number Functions], page 592.

int rand_r (unsigned int *seed)
stdlib.h(POSIX.1):Section 19.8.1 [ISO C Random Number Functions], page 592.

long int random (void)
stdlib.h(BSD):Section 19.8.2 [BSD Random Number Functions], page 592.

struct random_data
stdlib.h(GNU):Section 19.8.2 [BSD Random Number Functions], page 592.

int random_r (struct random_data *restrictbuf, int32_t *restrictresult)
stdlib.h(GNU):Section 19.8.2 [BSD Random Number Functions], page 592.

void * rawmemchr (const void *block, intc)
string.h(GNU):Section 5.9 [Search Functions], page 121.

ssize_t read (intfiledes, void *buffer, size_tsize)
unistd.h(POSIX.1):Section 13.2 [Input and Output Primitives], page 345.


Appendix B: Summary of Library Facilities 1064

struct dirent * readdir (DIR *dirstream)
dirent.h(POSIX.1):Section 14.2.3 [Reading and Closing a Directory Stream], page 407.

struct dirent64 * readdir64 (DIR *dirstream)
dirent.h(LFS):Section 14.2.3 [Reading and Closing a Directory Stream], page 407.

int readdir64_r (DIR *dirstream, struct dirent64 *entry, struct dirent64 **result)
dirent.h(LFS):Section 14.2.3 [Reading and Closing a Directory Stream], page 407.

int readdir_r (DIR *dirstream, struct dirent *entry, struct dirent **result)
dirent.h(GNU):Section 14.2.3 [Reading and Closing a Directory Stream], page 407.

ssize_t readlink (const char *filename, char *buffer, size_tsize)
unistd.h(BSD):Section 14.5 [Symbolic Links], page 419.

ssize_t readv (intfiledes, const struct iovec *vector, intcount)
sys/uio.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

void * realloc (void *ptr, size_tnewsize)
malloc.h(ISO):Section 3.2.3.4 [Changing the Size of a Block], page 48.
stdlib.h(ISO):Section 3.2.3.4 [Changing the Size of a Block], page 48.

void * reallocarray (void *ptr, size_tnmemb, size_tsize)
malloc.h(BSD):Section 3.2.3.4 [Changing the Size of a Block], page 48.
stdlib.h(BSD):Section 3.2.3.4 [Changing the Size of a Block], page 48.

char * realpath (const char *restrictname, char *restrictresolved)
stdlib.h(XPG):Section 14.5 [Symbolic Links], page 419.

ssize_t recv (intsocket, void *buffer, size_tsize, intflags)
sys/socket.h(BSD):Section 16.9.5.2 [Receiving Data], page 487.

ssize_t recvfrom (intsocket, void *buffer, size_tsize, intflags, struct sockaddr *addr,
socklen_t *length-ptr)
sys/socket.h(BSD):Section 16.10.2 [Receiving Datagrams], page 494.

int regcomp (regex_t *restrictcompiled, const char *restrictpattern, intcflags)
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

size_t regerror (interrcode, const regex_t *restrictcompiled, char *restrictbuffer, size_t
length)
regex.h(POSIX.2):Section 10.3.6 [POSIX Regexp Matching Cleanup], page 253.

regex_t
regex.h(POSIX.2):Section 10.3.1 [POSIX Regular Expression Compilation], page 249.

int regexec (const regex_t *restrictcompiled, const char *restrictstring, size_tnmatch,
regmatch_tmatchptr[restrict], inteflags)
regex.h(POSIX.2): Section 10.3.3 [Matching a Compiled POSIX Regular Expression],
page 251.

void regfree (regex_t *compiled)
regex.h(POSIX.2):Section 10.3.6 [POSIX Regexp Matching Cleanup], page 253.

int register_printf_function (intspec, printf_functionhandler-function,
printf_arginfo_functionarginfo-function)
printf.h(GNU):Section 12.13.1 [Registering New Conversions], page 305.

regmatch_t
regex.h(POSIX.2):Section 10.3.4 [Match Results with Subexpressions], page 252.

regoff_t
regex.h(POSIX.2):Section 10.3.4 [Match Results with Subexpressions], page 252.

double remainder (doublenumerator, doubledenominator)
math.h(ISO):Section 20.8.4 [Remainder Functions], page 624.


Appendix B: Summary of Library Facilities 1065

float remainderf (floatnumerator, floatdenominator)
math.h(ISO):Section 20.8.4 [Remainder Functions], page 624.

_FloatN remainderfN (_FloatN numerator, _FloatN denominator)
math.h(TS 18661-3:2015):Section 20.8.4 [Remainder Functions], page 624.

_FloatNx remainderfNx (_FloatNxnumerator, _FloatNxdenominator)
math.h(TS 18661-3:2015):Section 20.8.4 [Remainder Functions], page 624.

long double remainderl (long doublenumerator, long doubledenominator)
math.h(ISO):Section 20.8.4 [Remainder Functions], page 624.

int remove (const char *filename)
stdio.h(ISO):Section 14.6 [Deleting Files], page 422.

int rename (const char *oldname, const char *newname)
stdio.h(ISO):Section 14.7 [Renaming Files], page 423.

void rewind (FILE *stream)
stdio.h(ISO):Section 12.18 [File Positioning], page 323.

void rewinddir (DIR *dirstream)
dirent.h(POSIX.1):Section 14.2.5 [Random Access in a Directory Stream], page 410.

char * rindex (const char *string, intc)
string.h(BSD):Section 5.9 [Search Functions], page 121.

double rint (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

float rintf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN rintfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx rintfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double rintl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

struct rlimit
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

struct rlimit64
sys/resource.h(Unix98):Section 22.2 [Limiting Resource Usage], page 685.

int rmdir (const char *filename)
unistd.h(POSIX.1):Section 14.6 [Deleting Files], page 422.

double round (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

double roundeven (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

float roundevenf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN roundevenfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx roundevenfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double roundevenl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.


Appendix B: Summary of Library Facilities 1066

float roundf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN roundfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx roundfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double roundl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

int rpmatch (const char *response)
stdlib.h(GNU):Section 7.9 [Yes-or-No Questions], page 201.

struct rusage
sys/resource.h(BSD):Section 22.1 [Resource Usage], page 684.

void *sbrk (ptrdiff_tdelta)
unistd.h(BSD):Section 3.3 [Resizing the Data Segment], page 77.

double scalb (doublevalue, doubleexponent)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

float scalbf (floatvalue, floatexponent)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

long double scalbl (long doublevalue, long doubleexponent)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

double scalbln (doublex, long intn)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

float scalblnf (floatx, long intn)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

_FloatN scalblnfN (_FloatN x, long intn)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

_FloatNx scalblnfNx (_FloatNxx, long intn)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

long double scalblnl (long doublex, long intn)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

double scalbn (doublex, intn)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

float scalbnf (floatx, intn)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

_FloatN scalbnfN (_FloatN x, intn)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

_FloatNx scalbnfNx (_FloatNxx, intn)
math.h(TS 18661-3:2015):Section 20.8.2 [Normalization Functions], page 618.

long double scalbnl (long doublex, intn)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

int scandir (const char *dir, struct dirent ***namelist, int (*selector) (const struct dirent
*), int (*cmp) (const struct dirent **, const struct dirent **))
dirent.h(BSD):Section 14.2.6 [Scanning the Content of a Directory], page 411.
dirent.h(SVID):Section 14.2.6 [Scanning the Content of a Directory], page 411.

int scandir64 (const char *dir, struct dirent64 ***namelist, int (*selector) (const struct
dirent64 *), int (*cmp) (const struct dirent64 **, const struct dirent64 **))
dirent.h(GNU):Section 14.2.6 [Scanning the Content of a Directory], page 411.


Appendix B: Summary of Library Facilities 1067

int scanf (const char *template, ...)
stdio.h(ISO):Section 12.14.8 [Formatted Input Functions], page 318.

int sched_get_priority_max (intpolicy)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_get_priority_min (intpolicy)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_getaffinity (pid_tpid, size_tcpusetsize, cpu_set_t *cpuset)
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

int sched_getparam (pid_tpid, struct sched_param *param)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_getscheduler (pid_tpid)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

struct sched_param
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_rr_get_interval (pid_tpid, struct timespec *interval)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_setaffinity (pid_tpid, size_tcpusetsize, const cpu_set_t *cpuset)
sched.h(GNU):Section 22.3.5 [Limiting execution to certain CPUs], page 699.

int sched_setparam (pid_tpid, const struct sched_param *param)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_setscheduler (pid_tpid, intpolicy, const struct sched_param *param)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

int sched_yield (void)
sched.h(POSIX):Section 22.3.3 [Basic Scheduling Functions], page 692.

char * secure_getenv (const char *name)
stdlib.h(GNU):Section 25.4.1 [Environment Access], page 793.

unsigned short int * seed48 (unsigned short intseed16v[3])
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int seed48_r (unsigned short intseed16v[3], struct drand48_data *buffer)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

void seekdir (DIR *dirstream, long intpos)
dirent.h(BSD):Section 14.2.5 [Random Access in a Directory Stream], page 410.

int select (intnfds, fd_set *read-fds, fd_set *write-fds, fd_set *except-fds, struct timeval
*timeout)
sys/types.h(BSD):Section 13.9 [Waiting for Input or Output], page 366.

ssize_t send (intsocket, const void *buffer, size_tsize, intflags)
sys/socket.h(BSD):Section 16.9.5.1 [Sending Data], page 486.

ssize_t sendto (intsocket, const void *buffer, size_tsize, intflags, struct sockaddr *addr,
socklen_tlength)
sys/socket.h(BSD):Section 16.10.1 [Sending Datagrams], page 494.

struct servent
netdb.h(BSD):Section 16.6.4 [The Services Database], page 474.

void setbuf (FILE *stream, char *buf)
stdio.h(ISO):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

void setbuffer (FILE *stream, char *buf, size_tsize)
stdio.h(BSD):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.


Appendix B: Summary of Library Facilities 1068

int setcontext (const ucontext_t *ucp)
ucontext.h(SVID):Section 23.4 [Complete Context Control], page 708.

int setdomainname (const char *name, size_tlength)
unistd.h(???):Section 31.1 [Host Identification], page 875.

int setegid (gid_tnewgid)
unistd.h(POSIX.1):Section 30.7 [Setting the Group IDs], page 849.

int setenv (const char *name, const char *value, intreplace)
stdlib.h(BSD):Section 25.4.1 [Environment Access], page 793.

int seteuid (uid_tneweuid)
unistd.h(POSIX.1):Section 30.6 [Setting the User ID], page 848.

int setfsent (void)
fstab.h(BSD):Section 31.3.1.1 [Thefstabfile], page 879.

int setgid (gid_tnewgid)
unistd.h(POSIX.1):Section 30.7 [Setting the Group IDs], page 849.

void setgrent (void)
grp.h(SVID):Section 30.14.3 [Scanning the List of All Groups], page 869.
grp.h(BSD):Section 30.14.3 [Scanning the List of All Groups], page 869.

int setgroups (size_tcount, const gid_t *groups)
grp.h(BSD):Section 30.7 [Setting the Group IDs], page 849.

void sethostent (intstayopen)
netdb.h(BSD):Section 16.6.2.4 [Host Names], page 469.

int sethostid (long intid)
unistd.h(BSD):Section 31.1 [Host Identification], page 875.

int sethostname (const char *name, size_tlength)
unistd.h(BSD):Section 31.1 [Host Identification], page 875.

int setitimer (intwhich, const struct itimerval *new, struct itimerval *old)
sys/time.h(BSD):Section 21.6 [Setting an Alarm], page 679.

int setjmp (jmp_bufstate)
setjmp.h(ISO):Section 23.2 [Details of Non-Local Exits], page 706.

void setlinebuf (FILE *stream)
stdio.h(BSD):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

char * setlocale (intcategory, const char *locale)
locale.h(ISO):Section 7.4 [How Programs Set the Locale], page 185.

int setlogmask (intmask)
syslog.h(BSD):Section 18.2.4 [setlogmask], page 537.

FILE * setmntent (const char *file, const char *mode)
mntent.h(BSD):Section 31.3.1.2 [Themtabfile], page 882.

void setnetent (intstayopen)
netdb.h(BSD):Section 16.13 [Networks Database], page 501.

int setnetgrent (const char *netgroup)
netdb.h(BSD):Section 30.16.2 [Looking up one Netgroup], page 872.

int setpayload (double *x, doublepayload)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int setpayloadf (float *x, floatpayload)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.


Appendix B: Summary of Library Facilities 1069

int setpayloadfN (_FloatN*x, _FloatN payload)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

int setpayloadfNx (_FloatNx *x, _FloatNxpayload)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

int setpayloadl (long double *x, long doublepayload)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int setpayloadsig (double *x, doublepayload)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int setpayloadsigf (float *x, floatpayload)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int setpayloadsigfN (_FloatN*x, _FloatN payload)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

int setpayloadsigfNx (_FloatNx *x, _FloatNxpayload)
math.h(TS 18661-3:2015):Section 20.8.5 [Setting and modifying single bits of FP values],
page 625.

int setpayloadsigl (long double *x, long doublepayload)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

int setpgid (pid_tpid, pid_tpgid)
unistd.h(POSIX.1):Section 28.6.2 [Process Group Functions], page 831.

int setpgrp (pid_tpid, pid_tpgid)
unistd.h(BSD):Section 28.6.2 [Process Group Functions], page 831.

int setpriority (intclass, intid, intniceval)
sys/resource.h(BSD):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.
sys/resource.h(POSIX):Section 22.3.4.2 [Functions For Traditional Scheduling], page 697.

void setprotoent (intstayopen)
netdb.h(BSD):Section 16.6.6 [Protocols Database], page 477.

void setpwent (void)
pwd.h(SVID):Section 30.13.3 [Scanning the List of All Users], page 866.
pwd.h(BSD):Section 30.13.3 [Scanning the List of All Users], page 866.

int setregid (gid_trgid, gid_tegid)
unistd.h(BSD):Section 30.7 [Setting the Group IDs], page 849.

int setreuid (uid_truid, uid_teuid)
unistd.h(BSD):Section 30.6 [Setting the User ID], page 848.

int setrlimit (intresource, const struct rlimit *rlp)
sys/resource.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

int setrlimit64 (intresource, const struct rlimit64 *rlp)
sys/resource.h(Unix98):Section 22.2 [Limiting Resource Usage], page 685.

void setservent (intstayopen)
netdb.h(BSD):Section 16.6.4 [The Services Database], page 474.

pid_t setsid (void)
unistd.h(POSIX.1):Section 28.6.2 [Process Group Functions], page 831.

int setsockopt (intsocket, intlevel, intoptname, const void *optval, socklen_toptlen)
sys/socket.h(BSD):Section 16.12.1 [Socket Option Functions], page 499.

char * setstate (char *state)
stdlib.h(BSD):Section 19.8.2 [BSD Random Number Functions], page 592.


Appendix B: Summary of Library Facilities 1070

int setstate_r (char *restrictstatebuf, struct random_data *restrictbuf)
stdlib.h(GNU):Section 19.8.2 [BSD Random Number Functions], page 592.

int settimeofday (const struct timeval *tp, const void *tzp)
sys/time.h(BSD):Section 21.5.2 [Setting and Adjusting the Time], page 653.

int setuid (uid_tnewuid)
unistd.h(POSIX.1):Section 30.6 [Setting the User ID], page 848.

void setutent (void)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

void setutxent (void)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

int setvbuf (FILE *stream, char *buf, intmode, size_tsize)
stdio.h(ISO):Section 12.20.3 [Controlling Which Kind of Buffering], page 330.

struct sgttyb
termios.h(BSD):Section 17.5 [BSD Terminal Modes], page 522.

int shm_open (const char *name, intoflag, mode_tmode)
sys/mman.h(POSIX):Section 13.8 [Memory-mapped I/O], page 360.

int shutdown (intsocket, inthow)
sys/socket.h(BSD):Section 16.8.2 [Closing a Socket], page 480.

sig_atomic_t
signal.h(ISO):Section 24.4.7.2 [Atomic Types], page 740.

const char * sigabbrev_np (intsignum)
string.h(GNU):Section 24.2.8 [Signal Messages], page 724.

int sigaction (intsignum, const struct sigaction *restrictaction, struct sigaction *restrict
old-action)
signal.h(POSIX.1):Section 24.3.2 [Advanced Signal Handling], page 727.

struct sigaction
signal.h(POSIX.1):Section 24.3.2 [Advanced Signal Handling], page 727.

int sigaddset (sigset_t *set, intsignum)
signal.h(POSIX.1):Section 24.7.2 [Signal Sets], page 747.

int sigaltstack (const stack_t *restrictstack, stack_t *restrictoldstack)
signal.h(XPG):Section 24.9 [Using a Separate Signal Stack], page 755.

int sigblock (intmask)
signal.h(BSD):Section 24.10 [BSD Signal Handling], page 757.

int sigdelset (sigset_t *set, intsignum)
signal.h(POSIX.1):Section 24.7.2 [Signal Sets], page 747.

const char * sigdescr_np (intsignum)
string.h(GNU):Section 24.2.8 [Signal Messages], page 724.

int sigemptyset (sigset_t *set)
signal.h(POSIX.1):Section 24.7.2 [Signal Sets], page 747.

int sigfillset (sigset_t *set)
signal.h(POSIX.1):Section 24.7.2 [Signal Sets], page 747.

sighandler_t
signal.h(GNU):Section 24.3.1 [Basic Signal Handling], page 725.

int siginterrupt (intsignum, intfailflag)
signal.h(XPG):Section 24.10 [BSD Signal Handling], page 757.

int sigismember (const sigset_t *set, intsignum)
signal.h(POSIX.1):Section 24.7.2 [Signal Sets], page 747.


Appendix B: Summary of Library Facilities 1071

sigjmp_buf
setjmp.h(POSIX.1):Section 23.3 [Non-Local Exits and Signals], page 707.

void siglongjmp (sigjmp_bufstate, intvalue)
setjmp.h(POSIX.1):Section 23.3 [Non-Local Exits and Signals], page 707.

int sigmask (intsignum)
signal.h(BSD):Section 24.10 [BSD Signal Handling], page 757.

sighandler_t signal (intsignum, sighandler_taction)
signal.h(ISO):Section 24.3.1 [Basic Signal Handling], page 725.

int signbit (float-type x)
math.h(ISO):Section 20.8.5 [Setting and modifying single bits of FP values], page 625.

double significand (doublex)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

float significandf (floatx)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

long double significandl (long doublex)
math.h(BSD):Section 20.8.2 [Normalization Functions], page 618.

int sigpause (intmask)
signal.h(BSD):Section 24.10 [BSD Signal Handling], page 757.

int sigpending (sigset_t *set)
signal.h(POSIX.1):Section 24.7.6 [Checking for Pending Signals], page 751.

int sigprocmask (inthow, const sigset_t *restrictset, sigset_t *restrictoldset)
signal.h(POSIX.1):Section 24.7.3 [Process Signal Mask], page 748.

sigset_t
signal.h(POSIX.1):Section 24.7.2 [Signal Sets], page 747.

int sigsetjmp (sigjmp_bufstate, intsavesigs)
setjmp.h(POSIX.1):Section 23.3 [Non-Local Exits and Signals], page 707.

int sigsetmask (intmask)
signal.h(BSD):Section 24.10 [BSD Signal Handling], page 757.

int sigstack (struct sigstack *stack, struct sigstack *oldstack)
signal.h(BSD):Section 24.9 [Using a Separate Signal Stack], page 755.

struct sigstack
signal.h(BSD):Section 24.9 [Using a Separate Signal Stack], page 755.

int sigsuspend (const sigset_t *set)
signal.h(POSIX.1):Section 24.8.3 [Usingsigsuspend], page 754.

double sin (doublex)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

void sincos (doublex, double *sinx, double *cosx)
math.h(GNU):Section 19.2 [Trigonometric Functions], page 540.

void sincosf (floatx, float *sinx, float *cosx)
math.h(GNU):Section 19.2 [Trigonometric Functions], page 540.

_FloatN sincosfN (_FloatN x, _FloatN*sinx, _FloatN*cosx)
math.h(GNU):Section 19.2 [Trigonometric Functions], page 540.

_FloatNx sincosfNx (_FloatNxx, _FloatNx *sinx, _FloatNx *cosx)
math.h(GNU):Section 19.2 [Trigonometric Functions], page 540.

void sincosl (long doublex, long double *sinx, long double *cosx)
math.h(GNU):Section 19.2 [Trigonometric Functions], page 540.


Appendix B: Summary of Library Facilities 1072

float sinf (floatx)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

_FloatN sinfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

_FloatNx sinfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

double sinh (doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

float sinhf (floatx)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

_FloatN sinhfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

_FloatNx sinhfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

long double sinhl (long doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

long double sinl (long doublex)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

size_t
stddef.h(ISO):Section A.4 [Important Data Types], page 956.

unsigned int sleep (unsigned intseconds)
unistd.h(POSIX.1):Section 21.7 [Sleeping], page 682.

int snprintf (char *s, size_tsize, const char *template, ...)
stdio.h(GNU):Section 12.12.7 [Formatted Output Functions], page 296.

struct sockaddr
sys/socket.h(BSD):Section 16.3.1 [Address Formats], page 457.

struct sockaddr_in
netinet/in.h(BSD):Section 16.6.1 [Internet Socket Address Formats], page 464.

struct sockaddr_un
sys/un.h(BSD):Section 16.5.2 [Details of Local Namespace], page 461.

int socket (intnamespace, intstyle, intprotocol)
sys/socket.h(BSD):Section 16.8.1 [Creating a Socket], page 480.

int socketpair (intnamespace, intstyle, intprotocol, intfiledes[2])
sys/socket.h(BSD):Section 16.8.3 [Socket Pairs], page 481.

speed_t
termios.h(POSIX.1):Section 17.4.8 [Line Speed], page 515.

int sprintf (char *s, const char *template, ...)
stdio.h(ISO):Section 12.12.7 [Formatted Output Functions], page 296.

double sqrt (doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

float sqrtf (floatx)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatN sqrtfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.

_FloatNx sqrtfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.4 [Exponentiation and Logarithms], page 544.


Appendix B: Summary of Library Facilities 1073

long double sqrtl (long doublex)
math.h(ISO):Section 19.4 [Exponentiation and Logarithms], page 544.

void srand (unsigned intseed)
stdlib.h(ISO):Section 19.8.1 [ISO C Random Number Functions], page 592.

void srand48 (long intseedval)
stdlib.h(SVID):Section 19.8.3 [SVID Random Number Function], page 594.

int srand48_r (long intseedval, struct drand48_data *buffer)
stdlib.h(GNU):Section 19.8.3 [SVID Random Number Function], page 594.

void srandom (unsigned intseed)
stdlib.h(BSD):Section 19.8.2 [BSD Random Number Functions], page 592.

int srandom_r (unsigned intseed, struct random_data *buf)
stdlib.h(GNU):Section 19.8.2 [BSD Random Number Functions], page 592.

int sscanf (const char *s, const char *template, ...)
stdio.h(ISO):Section 12.14.8 [Formatted Input Functions], page 318.

sighandler_t ssignal (intsignum, sighandler_taction)
signal.h(SVID):Section 24.3.1 [Basic Signal Handling], page 725.

ssize_t
unistd.h(POSIX.1):Section 13.2 [Input and Output Primitives], page 345.

stack_t
signal.h(XPG):Section 24.9 [Using a Separate Signal Stack], page 755.

int stat (const char *filename, struct stat *buf)
sys/stat.h(POSIX.1):Section 14.9.2 [Reading the Attributes of a File], page 429.

struct stat
sys/stat.h(POSIX.1):Section 14.9.1 [The meaning of the File Attributes], page 425.

int stat64 (const char *filename, struct stat64 *buf)
sys/stat.h(Unix98):Section 14.9.2 [Reading the Attributes of a File], page 429.

struct stat64
sys/stat.h(LFS):Section 14.9.1 [The meaning of the File Attributes], page 425.

FILE * stderr
stdio.h(ISO):Section 12.2 [Standard Streams], page 266.

FILE * stdin
stdio.h(ISO):Section 12.2 [Standard Streams], page 266.

FILE * stdout
stdio.h(ISO):Section 12.2 [Standard Streams], page 266.

int stime (const time_t *newtime)
time.h(SVID):Section 21.5.2 [Setting and Adjusting the Time], page 653.
time.h(XPG):Section 21.5.2 [Setting and Adjusting the Time], page 653.

char * stpcpy (char *restrictto, const char *restrictfrom)
string.h(Unknown origin):Section 5.4 [Copying Strings and Arrays], page 101.

char * stpncpy (char *restrictto, const char *restrictfrom, size_tsize)
string.h(GNU):Section 5.6 [Truncating Strings while Copying], page 109.

int strcasecmp (const char *s1, const char *s2)
string.h(BSD):Section 5.7 [String/Array Comparison], page 113.

char * strcasestr (const char *haystack, const char *needle)
string.h(GNU):Section 5.9 [Search Functions], page 121.


Appendix B: Summary of Library Facilities 1074

char * strcat (char *restrictto, const char *restrictfrom)
string.h(ISO):Section 5.5 [Concatenating Strings], page 106.

char * strchr (const char *string, intc)
string.h(ISO):Section 5.9 [Search Functions], page 121.

char * strchrnul (const char *string, intc)
string.h(GNU):Section 5.9 [Search Functions], page 121.

int strcmp (const char *s1, const char *s2)
string.h(ISO):Section 5.7 [String/Array Comparison], page 113.

int strcoll (const char *s1, const char *s2)
string.h(ISO):Section 5.8 [Collation Functions], page 117.

char * strcpy (char *restrictto, const char *restrictfrom)
string.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

size_t strcspn (const char *string, const char *stopset)
string.h(ISO):Section 5.9 [Search Functions], page 121.

char * strdup (const char *s)
string.h(SVID):Section 5.4 [Copying Strings and Arrays], page 101.

char * strdupa (const char *s)
string.h(GNU):Section 5.4 [Copying Strings and Arrays], page 101.

char * strerror (interrnum)
string.h(ISO):Section 2.3 [Error Messages], page 36.

char * strerror_r (interrnum, char *buf, size_tn)
string.h(GNU):Section 2.3 [Error Messages], page 36.

const char * strerrordesc_np (interrnum)
string.h(GNU):Section 2.3 [Error Messages], page 36.

const char * strerrorname_np (interrnum)
string.h(GNU):Section 2.3 [Error Messages], page 36.

int strfromd (char *restrictstring, size_tsize, const char *restrictformat, doublevalue)
stdlib.h(ISO/IEC TS 18661-1):Section 20.12 [Printing of Floats], page 642.

int strfromf (char *restrictstring, size_tsize, const char *restrictformat, floatvalue)
stdlib.h(ISO/IEC TS 18661-1):Section 20.12 [Printing of Floats], page 642.

int strfromfN (char *restrictstring, size_tsize, const char *restrictformat, _FloatN value)
stdlib.h(ISO/IEC TS 18661-3):Section 20.12 [Printing of Floats], page 642.

int strfromfNx (char *restrictstring, size_tsize, const char *restrictformat, _FloatNx
value)
stdlib.h(ISO/IEC TS 18661-3):Section 20.12 [Printing of Floats], page 642.

int strfroml (char *restrictstring, size_tsize, const char *restrictformat, long double
value)
stdlib.h(ISO/IEC TS 18661-1):Section 20.12 [Printing of Floats], page 642.

char * strfry (char *string)
string.h(GNU):Section 5.12 [Shuffling Bytes], page 132.

size_t strftime (char *s, size_tsize, const char *template, const struct tm *brokentime)
time.h(ISO):Section 21.5.4 [Formatting Calendar Time], page 662.

size_t strlen (const char *s)
string.h(ISO):Section 5.3 [String Length], page 99.

int strncasecmp (const char *s1, const char *s2, size_tn)
string.h(BSD):Section 5.7 [String/Array Comparison], page 113.


Appendix B: Summary of Library Facilities 1075

char * strncat (char *restrictto, const char *restrictfrom, size_tsize)
string.h(ISO):Section 5.6 [Truncating Strings while Copying], page 109.

int strncmp (const char *s1, const char *s2, size_tsize)
string.h(ISO):Section 5.7 [String/Array Comparison], page 113.

char * strncpy (char *restrictto, const char *restrictfrom, size_tsize)
string.h(C90):Section 5.6 [Truncating Strings while Copying], page 109.

char * strndup (const char *s, size_tsize)
string.h(GNU):Section 5.6 [Truncating Strings while Copying], page 109.

char * strndupa (const char *s, size_tsize)
string.h(GNU):Section 5.6 [Truncating Strings while Copying], page 109.

size_t strnlen (const char *s, size_tmaxlen)
string.h(GNU):Section 5.3 [String Length], page 99.

char * strpbrk (const char *string, const char *stopset)
string.h(ISO):Section 5.9 [Search Functions], page 121.

char * strptime (const char *s, const char *fmt, struct tm *tp)
time.h(XPG4):Section 21.5.5.1 [Interpret string according to given format], page 668.

char * strrchr (const char *string, intc)
string.h(ISO):Section 5.9 [Search Functions], page 121.

char * strsep (char **string_ptr, const char *delimiter)
string.h(BSD):Section 5.10 [Finding Tokens in a String], page 126.

char * strsignal (intsignum)
string.h(GNU):Section 24.2.8 [Signal Messages], page 724.

size_t strspn (const char *string, const char *skipset)
string.h(ISO):Section 5.9 [Search Functions], page 121.

char * strstr (const char *haystack, const char *needle)
string.h(ISO):Section 5.9 [Search Functions], page 121.

double strtod (const char *restrictstring, char **restricttailptr)
stdlib.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

float strtof (const char *string, char **tailptr)
stdlib.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

_FloatN strtofN (const char *string, char **tailptr)
stdlib.h(ISO/IEC TS 18661-3):Section 20.11.2 [Parsing of Floats], page 640.

_FloatNx strtofNx (const char *string, char **tailptr)
stdlib.h(ISO/IEC TS 18661-3):Section 20.11.2 [Parsing of Floats], page 640.

intmax_t strtoimax (const char *restrictstring, char **restricttailptr, intbase)
inttypes.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

char * strtok (char *restrictnewstring, const char *restrictdelimiters)
string.h(ISO):Section 5.10 [Finding Tokens in a String], page 126.

char * strtok_r (char *newstring, const char *delimiters, char **save_ptr)
string.h(POSIX):Section 5.10 [Finding Tokens in a String], page 126.

long int strtol (const char *restrictstring, char **restricttailptr, intbase)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

long double strtold (const char *string, char **tailptr)
stdlib.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

long long int strtoll (const char *restrictstring, char **restricttailptr, intbase)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.


Appendix B: Summary of Library Facilities 1076

long long int strtoq (const char *restrictstring, char **restricttailptr, intbase)
stdlib.h(BSD):Section 20.11.1 [Parsing of Integers], page 635.

unsigned long int strtoul (const char *restrictstring, char **restricttailptr, intbase)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

unsigned long long int strtoull (const char *restrictstring, char **restricttailptr, intbase)
stdlib.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

uintmax_t strtoumax (const char *restrictstring, char **restricttailptr, intbase)
inttypes.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

unsigned long long int strtouq (const char *restrictstring, char **restricttailptr, intbase)
stdlib.h(BSD):Section 20.11.1 [Parsing of Integers], page 635.

int strverscmp (const char *s1, const char *s2)
string.h(GNU):Section 5.7 [String/Array Comparison], page 113.

size_t strxfrm (char *restrictto, const char *restrictfrom, size_tsize)
string.h(ISO):Section 5.8 [Collation Functions], page 117.

int stty (intfiledes, const struct sgttyb *attributes)
sgtty.h(BSD):Section 17.5 [BSD Terminal Modes], page 522.

int swapcontext (ucontext_t *restrictoucp, const ucontext_t *restrictucp)
ucontext.h(SVID):Section 23.4 [Complete Context Control], page 708.

int swprintf (wchar_t *ws, size_tsize, const wchar_t *template, ...)
wchar.h(GNU):Section 12.12.7 [Formatted Output Functions], page 296.

int swscanf (const wchar_t *ws, const wchar_t *template, ...)
wchar.h(ISO):Section 12.14.8 [Formatted Input Functions], page 318.

int symlink (const char *oldname, const char *newname)
unistd.h(BSD):Section 14.5 [Symbolic Links], page 419.

void sync (void)
unistd.h(X/Open):Section 13.10 [Synchronizing I/O operations], page 369.

long int syscall (long intsysno, ...)
unistd.h(???):Section 25.6 [System Calls], page 797.

long int sysconf (intparameter)
unistd.h(POSIX.1):Section 32.4.1 [Definition ofsysconf], page 893.

void syslog (intfacility_priority, const char *format, ...)
syslog.h(BSD):Section 18.2.2 [syslog, vsyslog], page 534.

int system (const char *command)
stdlib.h(ISO):Section 26.1 [Running a Command], page 803.

sighandler_t sysv_signal (intsignum, sighandler_taction)
signal.h(GNU):Section 24.3.1 [Basic Signal Handling], page 725.

double tan (doublex)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

float tanf (floatx)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

_FloatN tanfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

_FloatNx tanfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.2 [Trigonometric Functions], page 540.

double tanh (doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.


Appendix B: Summary of Library Facilities 1077

float tanhf (floatx)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

_FloatN tanhfN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

_FloatNx tanhfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.5 [Hyperbolic Functions], page 550.

long double tanhl (long doublex)
math.h(ISO):Section 19.5 [Hyperbolic Functions], page 550.

long double tanl (long doublex)
math.h(ISO):Section 19.2 [Trigonometric Functions], page 540.

int tcdrain (intfiledes)
termios.h(POSIX.1):Section 17.6 [Line Control Functions], page 523.

tcflag_t
termios.h(POSIX.1):Section 17.4.1 [Terminal Mode Data Types], page 505.

int tcflow (intfiledes, intaction)
termios.h(POSIX.1):Section 17.6 [Line Control Functions], page 523.

int tcflush (intfiledes, intqueue)
termios.h(POSIX.1):Section 17.6 [Line Control Functions], page 523.

int tcgetattr (intfiledes, struct termios *termios-p)
termios.h(POSIX.1):Section 17.4.2 [Terminal Mode Functions], page 506.

pid_t tcgetpgrp (intfiledes)
unistd.h(POSIX.1):Section 28.6.3 [Functions for Controlling Terminal Access], page 833.

pid_t tcgetsid (intfildes)
termios.h(Unix98):Section 28.6.3 [Functions for Controlling Terminal Access], page 833.

int tcsendbreak (intfiledes, intduration)
termios.h(POSIX.1):Section 17.6 [Line Control Functions], page 523.

int tcsetattr (intfiledes, intwhen, const struct termios *termios-p)
termios.h(POSIX.1):Section 17.4.2 [Terminal Mode Functions], page 506.

int tcsetpgrp (intfiledes, pid_tpgid)
unistd.h(POSIX.1):Section 28.6.3 [Functions for Controlling Terminal Access], page 833.

void * tdelete (const void *key, void **rootp, comparison_fn_tcompar)
search.h(SVID):Section 9.6 [Thetsearchfunction.], page 235.

void tdestroy (void *vroot, __free_fn_tfreefct)
search.h(GNU):Section 9.6 [Thetsearchfunction.], page 235.

long int telldir (DIR *dirstream)
dirent.h(BSD):Section 14.2.5 [Random Access in a Directory Stream], page 410.

char * tempnam (const char *dir, const char *prefix)
stdio.h(SVID):Section 14.11 [Temporary Files], page 446.

struct termios
termios.h(POSIX.1):Section 17.4.1 [Terminal Mode Data Types], page 505.

char * textdomain (const char *domainname)
libintl.h(GNU):Section 8.2.1.2 [How to determine which catalog to be used], page 215.

void * tfind (const void *key, void *const *rootp, comparison_fn_tcompar)
search.h(SVID):Section 9.6 [Thetsearchfunction.], page 235.

double tgamma (doublex)
math.h(XPG):Section 19.6 [Special Functions], page 553.
math.h(ISO):Section 19.6 [Special Functions], page 553.


Appendix B: Summary of Library Facilities 1078

float tgammaf (floatx)
math.h(XPG):Section 19.6 [Special Functions], page 553.
math.h(ISO):Section 19.6 [Special Functions], page 553.

_FloatN tgammafN (_FloatN x)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

_FloatNx tgammafNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 19.6 [Special Functions], page 553.

long double tgammal (long doublex)
math.h(XPG):Section 19.6 [Special Functions], page 553.
math.h(ISO):Section 19.6 [Special Functions], page 553.

int tgkill (pid_tpid, pid_ttid, intsignum)
signal.h(Linux):Section 24.6.2 [Signaling Another Process], page 743.

thrd_busy
threads.h(C11):Section 35.1.1 [Return Values], page 921.

int thrd_create (thrd_t *thr, thrd_start_tfunc, void *arg)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thrd_t thrd_current (void)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

int thrd_detach (thrd_tthr)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

int thrd_equal (thrd_tlhs, thrd_trhs)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thrd_error
threads.h(C11):Section 35.1.1 [Return Values], page 921.

_Noreturn void thrd_exit (intres)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

int thrd_join (thrd_tthr, int *res)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thrd_nomem
threads.h(C11):Section 35.1.1 [Return Values], page 921.

int thrd_sleep (const struct timespec *time_point, struct timespec *remaining)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thrd_start_t
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thrd_success
threads.h(C11):Section 35.1.1 [Return Values], page 921.

thrd_t
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thrd_timedout
threads.h(C11):Section 35.1.1 [Return Values], page 921.

void thrd_yield (void)
threads.h(C11):Section 35.1.2 [Creation and Control], page 921.

thread_local
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

time_t time (time_t *result)
time.h(ISO):Section 21.5.1 [Getting the Time], page 651.


Appendix B: Summary of Library Facilities 1079

time_t
time.h(ISO):Section 21.2 [Time Types], page 647.

time_t timegm (struct tm *brokentime)
time.h(???):Section 21.5.3 [Broken-down Time], page 659.

time_t timelocal (struct tm *brokentime)
time.h(???):Section 21.5.3 [Broken-down Time], page 659.

clock_t times (struct tms *buffer)
sys/times.h(POSIX.1):Section 21.4.2 [Processor Time Inquiry], page 650.

struct timespec
time.h(POSIX.1):Section 21.2 [Time Types], page 647.

struct timeval
sys/time.h(BSD):Section 21.2 [Time Types], page 647.

long int timezone
time.h(SVID):Section 21.5.7 [Functions and Variables for Time Zones], page 678.

struct tm
time.h(ISO):Section 21.2 [Time Types], page 647.
time.h(ISO):Section 21.5.3 [Broken-down Time], page 659.

FILE * tmpfile (void)
stdio.h(ISO):Section 14.11 [Temporary Files], page 446.

FILE * tmpfile64 (void)
stdio.h(Unix98):Section 14.11 [Temporary Files], page 446.

char * tmpnam (char *result)
stdio.h(ISO):Section 14.11 [Temporary Files], page 446.

char * tmpnam_r (char *result)
stdio.h(GNU):Section 14.11 [Temporary Files], page 446.

struct tms
sys/times.h(POSIX.1):Section 21.4.2 [Processor Time Inquiry], page 650.

int toascii (intc)
ctype.h(SVID):Section 4.2 [Case Conversion], page 89.
ctype.h(BSD):Section 4.2 [Case Conversion], page 89.

int tolower (intc)
ctype.h(ISO):Section 4.2 [Case Conversion], page 89.

int totalorder (const double *x, const double *y)
math.h(TS 18661-1:2014):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalorderf (const float *x, const float *y)
math.h(TS 18661-1:2014):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalorderfN (const _FloatN*x, const _FloatN*y)
math.h(TS 18661-3:2015):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalorderfNx (const _FloatNx *x, const _FloatNx *y)
math.h(TS 18661-3:2015):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalorderl (const long double *x, const long double *y)
math.h(TS 18661-1:2014):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalordermag (const double *x, const double *y)
math.h(TS 18661-1:2014):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalordermagf (const float *x, const float *y)
math.h(TS 18661-1:2014):Section 20.8.6 [Floating-Point Comparison Functions], page 628.


Appendix B: Summary of Library Facilities 1080

int totalordermagfN (const _FloatN*x, const _FloatN*y)
math.h(TS 18661-3:2015):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalordermagfNx (const _FloatNx *x, const _FloatNx *y)
math.h(TS 18661-3:2015):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int totalordermagl (const long double *x, const long double *y)
math.h(TS 18661-1:2014):Section 20.8.6 [Floating-Point Comparison Functions], page 628.

int toupper (intc)
ctype.h(ISO):Section 4.2 [Case Conversion], page 89.

wint_t towctrans (wint_twc, wctrans_tdesc)
wctype.h(ISO):Section 4.5 [Mapping of wide characters.], page 95.

wint_t towlower (wint_twc)
wctype.h(ISO):Section 4.5 [Mapping of wide characters.], page 95.

wint_t towupper (wint_twc)
wctype.h(ISO):Section 4.5 [Mapping of wide characters.], page 95.

double trunc (doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

int truncate (const char *filename, off_tlength)
unistd.h(X/Open):Section 14.9.10 [File Size], page 442.

int truncate64 (const char *name, off64_tlength)
unistd.h(Unix98):Section 14.9.10 [File Size], page 442.

float truncf (floatx)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

_FloatN truncfN (_FloatN x)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

_FloatNx truncfNx (_FloatNxx)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

long double truncl (long doublex)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

void * tsearch (const void *key, void **rootp, comparison_fn_tcompar)
search.h(SVID):Section 9.6 [Thetsearchfunction.], page 235.

int tss_create (tss_t *tss_key, tss_dtor_tdestructor)
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

void tss_delete (tss_ttss_key)
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

tss_dtor_t
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

void * tss_get (tss_ttss_key)
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

int tss_set (tss_ttss_key, void *val)
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

tss_t
threads.h(C11):Section 35.1.6 [Thread-local Storage], page 927.

char * ttyname (intfiledes)
unistd.h(POSIX.1):Section 17.1 [Identifying Terminals], page 503.

int ttyname_r (intfiledes, char *buf, size_tlen)
unistd.h(POSIX.1):Section 17.1 [Identifying Terminals], page 503.


Appendix B: Summary of Library Facilities 1081

void twalk (const void *root, __action_fn_taction)
search.h(SVID):Section 9.6 [Thetsearchfunction.], page 235.

void twalk_r (const void *root, void (*action) (const void *key, VISITwhich, void *closure),
void *closure)
search.h(GNU):Section 9.6 [Thetsearchfunction.], page 235.

char * tzname [2]
time.h(POSIX.1):Section 21.5.7 [Functions and Variables for Time Zones], page 678.

void tzset (void)
time.h(POSIX.1):Section 21.5.7 [Functions and Variables for Time Zones], page 678.

ucontext_t
ucontext.h(SVID):Section 23.4 [Complete Context Control], page 708.

uintmax_t ufromfp (doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpf (floatx, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpfN (_FloatN x, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpfNx (_FloatNxx, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpl (long doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpx (doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpxf (floatx, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpxfN (_FloatN x, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpxfNx (_FloatNxx, intround, unsigned intwidth)
math.h(TS 18661-3:2015):Section 20.8.3 [Rounding Functions], page 620.

uintmax_t ufromfpxl (long doublex, intround, unsigned intwidth)
math.h(ISO):Section 20.8.3 [Rounding Functions], page 620.

uid_t
sys/types.h(POSIX.1):Section 30.5 [Reading the Persona of a Process], page 847.

long int ulimit (intcmd, ...)
ulimit.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

mode_t umask (mode_tmask)
sys/stat.h(POSIX.1):Section 14.9.7 [Assigning File Permissions], page 436.

int umount (const char *file)
sys/mount.h(SVID):Section 31.3.2 [Mount, Unmount, Remount], page 885.
sys/mount.h(GNU):Section 31.3.2 [Mount, Unmount, Remount], page 885.

int umount2 (const char *file, intflags)
sys/mount.h(GNU):Section 31.3.2 [Mount, Unmount, Remount], page 885.

int uname (struct utsname *info)
sys/utsname.h(POSIX.1):Section 31.2 [Platform Type Identification], page 877.

int ungetc (intc, FILE *stream)
stdio.h(ISO):Section 12.10.2 [UsingungetcTo Do Unreading], page 286.


Appendix B: Summary of Library Facilities 1082

wint_t ungetwc (wint_twc, FILE *stream)
wchar.h(ISO):Section 12.10.2 [UsingungetcTo Do Unreading], page 286.

int unlink (const char *filename)
unistd.h(POSIX.1):Section 14.6 [Deleting Files], page 422.

int unlockpt (intfiledes)
stdlib.h(SVID):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.
stdlib.h(XPG4.2):Section 17.9.1 [Allocating Pseudo-Terminals], page 528.

int unsetenv (const char *name)
stdlib.h(BSD):Section 25.4.1 [Environment Access], page 793.

void updwtmp (const char *wtmp_file, const struct utmp *utmp)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

struct utimbuf
utime.h(POSIX.1):Section 14.9.9 [File Times], page 439.

int utime (const char *filename, const struct utimbuf *times)
utime.h(POSIX.1):Section 14.9.9 [File Times], page 439.

int utimes (const char *filename, const struct timevaltvp[2])
sys/time.h(BSD):Section 14.9.9 [File Times], page 439.

int utmpname (const char *file)
utmp.h(SVID):Section 30.12.1 [Manipulating the User Accounting Database], page 856.

int utmpxname (const char *file)
utmpx.h(XPG4.2):Section 30.12.2 [XPG User Accounting Database Functions], page 861.

struct utsname
sys/utsname.h(POSIX.1):Section 31.2 [Platform Type Identification], page 877.

typeva_arg (va_listap,type)
stdarg.h(ISO):Section A.2.2.5 [Argument Access Macros], page 953.

void va_copy (va_listdest, va_listsrc)
stdarg.h(C99):Section A.2.2.5 [Argument Access Macros], page 953.

void va_end (va_listap)
stdarg.h(ISO):Section A.2.2.5 [Argument Access Macros], page 953.

va_list
stdarg.h(ISO):Section A.2.2.5 [Argument Access Macros], page 953.

void va_start (va_listap,last-required)
stdarg.h(ISO):Section A.2.2.5 [Argument Access Macros], page 953.

void * valloc (size_tsize)
malloc.h(BSD):Section 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.
stdlib.h(BSD):Section 3.2.3.6 [Allocating Aligned Memory Blocks], page 49.

int vasprintf (char **ptr, const char *template, va_listap)
stdio.h(GNU):Section 12.12.9 [Variable Arguments Output Functions], page 299.

void verr (intstatus, const char *format, va_listap)
err.h(BSD):Section 2.3 [Error Messages], page 36.

void verrx (intstatus, const char *format, va_listap)
err.h(BSD):Section 2.3 [Error Messages], page 36.

int versionsort (const struct dirent **a, const struct dirent **b)
dirent.h(GNU):Section 14.2.6 [Scanning the Content of a Directory], page 411.

int versionsort64 (const struct dirent64 **a, const struct dirent64 **b)
dirent.h(GNU):Section 14.2.6 [Scanning the Content of a Directory], page 411.


Appendix B: Summary of Library Facilities 1083

pid_t vfork (void)
unistd.h(BSD):Section 26.4 [Creating a Process], page 805.

int vfprintf (FILE *stream, const char *template, va_listap)
stdio.h(ISO):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vfscanf (FILE *stream, const char *template, va_listap)
stdio.h(ISO):Section 12.14.9 [Variable Arguments Input Functions], page 319.

int vfwprintf (FILE *stream, const wchar_t *template, va_listap)
wchar.h(ISO):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vfwscanf (FILE *stream, const wchar_t *template, va_listap)
wchar.h(ISO):Section 12.14.9 [Variable Arguments Input Functions], page 319.

int vlimit (intresource, intlimit)
sys/vlimit.h(BSD):Section 22.2 [Limiting Resource Usage], page 685.

int vprintf (const char *template, va_listap)
stdio.h(ISO):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vscanf (const char *template, va_listap)
stdio.h(ISO):Section 12.14.9 [Variable Arguments Input Functions], page 319.

int vsnprintf (char *s, size_tsize, const char *template, va_listap)
stdio.h(GNU):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vsprintf (char *s, const char *template, va_listap)
stdio.h(ISO):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vsscanf (const char *s, const char *template, va_listap)
stdio.h(ISO):Section 12.14.9 [Variable Arguments Input Functions], page 319.

int vswprintf (wchar_t *ws, size_tsize, const wchar_t *template, va_listap)
wchar.h(GNU):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vswscanf (const wchar_t *s, const wchar_t *template, va_listap)
wchar.h(ISO):Section 12.14.9 [Variable Arguments Input Functions], page 319.

void vsyslog (intfacility_priority, const char *format, va_listarglist)
syslog.h(BSD):Section 18.2.2 [syslog, vsyslog], page 534.

void vwarn (const char *format, va_listap)
err.h(BSD):Section 2.3 [Error Messages], page 36.

void vwarnx (const char *format, va_listap)
err.h(BSD):Section 2.3 [Error Messages], page 36.

int vwprintf (const wchar_t *template, va_listap)
wchar.h(ISO):Section 12.12.9 [Variable Arguments Output Functions], page 299.

int vwscanf (const wchar_t *template, va_listap)
wchar.h(ISO):Section 12.14.9 [Variable Arguments Input Functions], page 319.

pid_t wait (int *status-ptr)
sys/wait.h(POSIX.1):Section 26.6 [Process Completion], page 809.

pid_t wait3 (int *status-ptr, intoptions, struct rusage *usage)
sys/wait.h(BSD):Section 26.8 [BSD Process Wait Function], page 813.

pid_t wait4 (pid_tpid, int *status-ptr, intoptions, struct rusage *usage)
sys/wait.h(BSD):Section 26.6 [Process Completion], page 809.

pid_t waitpid (pid_tpid, int *status-ptr, intoptions)
sys/wait.h(POSIX.1):Section 26.6 [Process Completion], page 809.

void warn (const char *format, ...)
err.h(BSD):Section 2.3 [Error Messages], page 36.


Appendix B: Summary of Library Facilities 1084

void warnx (const char *format, ...)
err.h(BSD):Section 2.3 [Error Messages], page 36.

wchar_t
stddef.h(ISO):Section 6.1 [Introduction to Extended Characters], page 140.

wchar_t * wcpcpy (wchar_t *restrictwto, const wchar_t *restrictwfrom)
wchar.h(GNU):Section 5.4 [Copying Strings and Arrays], page 101.

wchar_t * wcpncpy (wchar_t *restrictwto, const wchar_t *restrictwfrom, size_tsize)
wchar.h(GNU):Section 5.6 [Truncating Strings while Copying], page 109.

size_t wcrtomb (char *restricts, wchar_twc, mbstate_t *restrictps)
wchar.h(ISO):Section 6.3.3 [Converting Single Characters], page 146.

int wcscasecmp (const wchar_t *ws1, const wchar_t *ws2)
wchar.h(GNU):Section 5.7 [String/Array Comparison], page 113.

wchar_t * wcscat (wchar_t *restrictwto, const wchar_t *restrictwfrom)
wchar.h(ISO):Section 5.5 [Concatenating Strings], page 106.

wchar_t * wcschr (const wchar_t *wstring, wchar_twc)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.

wchar_t * wcschrnul (const wchar_t *wstring, wchar_twc)
wchar.h(GNU):Section 5.9 [Search Functions], page 121.

int wcscmp (const wchar_t *ws1, const wchar_t *ws2)
wchar.h(ISO):Section 5.7 [String/Array Comparison], page 113.

int wcscoll (const wchar_t *ws1, const wchar_t *ws2)
wchar.h(ISO):Section 5.8 [Collation Functions], page 117.

wchar_t * wcscpy (wchar_t *restrictwto, const wchar_t *restrictwfrom)
wchar.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

size_t wcscspn (const wchar_t *wstring, const wchar_t *stopset)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.

wchar_t * wcsdup (const wchar_t *ws)
wchar.h(GNU):Section 5.4 [Copying Strings and Arrays], page 101.

size_t wcsftime (wchar_t *s, size_tsize, const wchar_t *template, const struct tm *brokentime)
time.h(ISO/Amend1):Section 21.5.4 [Formatting Calendar Time], page 662.

size_t wcslen (const wchar_t *ws)
wchar.h(ISO):Section 5.3 [String Length], page 99.

int wcsncasecmp (const wchar_t *ws1, const wchar_t *s2, size_tn)
wchar.h(GNU):Section 5.7 [String/Array Comparison], page 113.

wchar_t * wcsncat (wchar_t *restrictwto, const wchar_t *restrictwfrom, size_tsize)
wchar.h(ISO):Section 5.6 [Truncating Strings while Copying], page 109.

int wcsncmp (const wchar_t *ws1, const wchar_t *ws2, size_tsize)
wchar.h(ISO):Section 5.7 [String/Array Comparison], page 113.

wchar_t * wcsncpy (wchar_t *restrictwto, const wchar_t *restrictwfrom, size_tsize)
wchar.h(ISO):Section 5.6 [Truncating Strings while Copying], page 109.

size_t wcsnlen (const wchar_t *ws, size_tmaxlen)
wchar.h(GNU):Section 5.3 [String Length], page 99.

size_t wcsnrtombs (char *restrictdst, const wchar_t **restrictsrc, size_tnwc, size_tlen,
mbstate_t *restrictps)
wchar.h(GNU):Section 6.3.4 [Converting Multibyte and Wide Character Strings], page 153.

wchar_t * wcspbrk (const wchar_t *wstring, const wchar_t *stopset)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.


Appendix B: Summary of Library Facilities 1085

wchar_t * wcsrchr (const wchar_t *wstring, wchar_twc)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.

size_t wcsrtombs (char *restrictdst, const wchar_t **restrictsrc, size_tlen, mbstate_t
*restrictps)
wchar.h(ISO):Section 6.3.4 [Converting Multibyte and Wide Character Strings], page 153.

size_t wcsspn (const wchar_t *wstring, const wchar_t *skipset)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.

wchar_t * wcsstr (const wchar_t *haystack, const wchar_t *needle)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.

double wcstod (const wchar_t *restrictstring, wchar_t **restricttailptr)
wchar.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

float wcstof (const wchar_t *string, wchar_t **tailptr)
wchar.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

_FloatN wcstofN (const wchar_t *string, wchar_t **tailptr)
wchar.h(GNU):Section 20.11.2 [Parsing of Floats], page 640.

_FloatNx wcstofNx (const wchar_t *string, wchar_t **tailptr)
wchar.h(GNU):Section 20.11.2 [Parsing of Floats], page 640.

intmax_t wcstoimax (const wchar_t *restrictstring, wchar_t **restricttailptr, intbase)
wchar.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

wchar_t * wcstok (wchar_t *newstring, const wchar_t *delimiters, wchar_t **save_ptr)
wchar.h(ISO):Section 5.10 [Finding Tokens in a String], page 126.

long int wcstol (const wchar_t *restrictstring, wchar_t **restricttailptr, intbase)
wchar.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

long double wcstold (const wchar_t *string, wchar_t **tailptr)
wchar.h(ISO):Section 20.11.2 [Parsing of Floats], page 640.

long long int wcstoll (const wchar_t *restrictstring, wchar_t **restricttailptr, intbase)
wchar.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

size_t wcstombs (char *string, const wchar_t *wstring, size_tsize)
stdlib.h(ISO):Section 6.4.2 [Non-reentrant Conversion of Strings], page 159.

long long int wcstoq (const wchar_t *restrictstring, wchar_t **restricttailptr, intbase)
wchar.h(GNU):Section 20.11.1 [Parsing of Integers], page 635.

unsigned long int wcstoul (const wchar_t *restrictstring, wchar_t **restricttailptr, int
base)
wchar.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

unsigned long long int wcstoull (const wchar_t *restrictstring, wchar_t **restricttailptr,
intbase)
wchar.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

uintmax_t wcstoumax (const wchar_t *restrictstring, wchar_t **restricttailptr, intbase)
wchar.h(ISO):Section 20.11.1 [Parsing of Integers], page 635.

unsigned long long int wcstouq (const wchar_t *restrictstring, wchar_t **restricttailptr, int
base)
wchar.h(GNU):Section 20.11.1 [Parsing of Integers], page 635.

wchar_t * wcswcs (const wchar_t *haystack, const wchar_t *needle)
wchar.h(XPG):Section 5.9 [Search Functions], page 121.

size_t wcsxfrm (wchar_t *restrictwto, const wchar_t *wfrom, size_tsize)
wchar.h(ISO):Section 5.8 [Collation Functions], page 117.

int wctob (wint_tc)
wchar.h(ISO):Section 6.3.3 [Converting Single Characters], page 146.


Appendix B: Summary of Library Facilities 1086

int wctomb (char *string, wchar_twchar)
stdlib.h(ISO):Section 6.4.1 [Non-reentrant Conversion of Single Characters], page 158.

wctrans_t wctrans (const char *property)
wctype.h(ISO):Section 4.5 [Mapping of wide characters.], page 95.

wctrans_t
wctype.h(ISO):Section 4.5 [Mapping of wide characters.], page 95.

wctype_t wctype (const char *property)
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

wctype_t
wctype.h(ISO):Section 4.3 [Character class determination for wide characters], page 90.

wint_t
wchar.h(ISO):Section 6.1 [Introduction to Extended Characters], page 140.

wchar_t * wmemchr (const wchar_t *block, wchar_twc, size_tsize)
wchar.h(ISO):Section 5.9 [Search Functions], page 121.

int wmemcmp (const wchar_t *a1, const wchar_t *a2, size_tsize)
wchar.h(ISO):Section 5.7 [String/Array Comparison], page 113.

wchar_t * wmemcpy (wchar_t *restrictwto, const wchar_t *restrictwfrom, size_tsize)
wchar.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

wchar_t * wmemmove (wchar_t *wto, const wchar_t *wfrom, size_tsize)
wchar.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

wchar_t * wmempcpy (wchar_t *restrictwto, const wchar_t *restrictwfrom, size_tsize)
wchar.h(GNU):Section 5.4 [Copying Strings and Arrays], page 101.

wchar_t * wmemset (wchar_t *block, wchar_twc, size_tsize)
wchar.h(ISO):Section 5.4 [Copying Strings and Arrays], page 101.

int wordexp (const char *words, wordexp_t *word-vector-ptr, intflags)
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

wordexp_t
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

void wordfree (wordexp_t *word-vector-ptr)
wordexp.h(POSIX.2):Section 10.4.2 [Callingwordexp], page 255.

int wprintf (const wchar_t *template, ...)
wchar.h(ISO):Section 12.12.7 [Formatted Output Functions], page 296.

ssize_t write (intfiledes, const void *buffer, size_tsize)
unistd.h(POSIX.1):Section 13.2 [Input and Output Primitives], page 345.

ssize_t writev (intfiledes, const struct iovec *vector, intcount)
sys/uio.h(BSD):Section 13.6 [Fast Scatter-Gather I/O], page 355.

int wscanf (const wchar_t *template, ...)
wchar.h(ISO):Section 12.14.8 [Formatted Input Functions], page 318.

double y0 (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float y0f (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN y0fN (_FloatN x)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx y0fNx (_FloatNxx)
math.h(GNU):Section 19.6 [Special Functions], page 553.


Appendix B: Summary of Library Facilities 1087

long double y0l (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

double y1 (doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float y1f (floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN y1fN (_FloatN x)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx y1fNx (_FloatNxx)
math.h(GNU):Section 19.6 [Special Functions], page 553.

long double y1l (long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

double yn (intn, doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.

float ynf (intn, floatx)
math.h(SVID):Section 19.6 [Special Functions], page 553.

_FloatN ynfN (intn, _FloatN x)
math.h(GNU):Section 19.6 [Special Functions], page 553.

_FloatNx ynfNx (intn, _FloatNxx)
math.h(GNU):Section 19.6 [Special Functions], page 553.

long double ynl (intn, long doublex)
math.h(SVID):Section 19.6 [Special Functions], page 553.


### 1088

## C Installing the GNU C Library.........................

Before you do anything else, you should read the FAQ athttps://sourceware.org/glibc/
wiki/FAQ. It answers common questions and describes problems you may experience with
compilation and installation.

You will need recent versions of several GNU tools: definitely GCC and GNU Make, and
possibly others. SeeSection C.3 [Recommended Tools for Compilation], page 1095, below.

C.1 Configuring and compiling the GNU C Library

The GNU C Library cannot be compiled in the source directory. You must build it in a
separate build directory. For example, if you have unpacked the GNU C Library sources
in/src/gnu/glibc-version, create a directory/src/gnu/glibc-buildto put the object
files in. This allows removing the whole build directory in case an error occurs, which is
the safest way to get a fresh start and should always be done.

From your object directory, run the shell scriptconfigurelocated at the top level of
the source tree. In the scenario above, you¡¯d type
$ ../glibc-version/configureargs...
Please note that even though you¡¯re building in a separate build directory, the compila-
tion may need to create or modify files and directories in the source directory.

configuretakes many options, but the only one that is usually mandatory is ¡®--prefix¡¯.
This option tells configure where you want the GNU C Library installed. This
defaults to/usr/local, but the normal setting to install as the standard system library
is ¡®--prefix=/usr¡¯ for GNU/Linux systems and ¡®--prefix=¡¯ (an empty prefix) for
GNU/Hurd systems.

It may also be useful to pass ¡®CC=compiler¡¯ andCFLAGS=flagsarguments toconfigure.
CCselects the C compiler that will be used, andCFLAGSsets optimization options for the
compiler. Any compiler options required for all compilations, such as options selecting an
ABI or a processor for which to generate code, should be included inCC. Options that
may be overridden by the GNU C Library build system for particular files, such as for
optimization and debugging, should go inCFLAGS. The default value ofCFLAGSis ¡®-g -O2¡¯,
and the GNU C Library cannot be compiled without optimization, so ifCFLAGSis specified
it must enable optimization. For example:
$ ../glibc-version/configure CC="gcc -m32" CFLAGS="-O3"
The following list describes all of the available options forconfigure:

¡®--prefix=directory¡¯
Install machine-independent data files in subdirectories ofdirectory. The
default is to install in/usr/local.

¡®--exec-prefix=directory¡¯
Install the library and other machine-dependent files in subdirectories of
directory. The default is to the ¡®--prefix¡¯ directory if that option is
specified, or/usr/localotherwise.

¡®--with-headers=directory¡¯
Look for kernel header files in directory, not/usr/include. The GNU C
Library needs information from the kernel¡¯s header files describing the interface


Appendix C: Installing the GNU C Library 1089

```
to the kernel. The GNU C Library will normally look in/usr/includefor
them, but if you specify this option, it will look inDIRECTORY instead.
This option is primarily of use on a system where the headers in/usr/include
come from an older version of the GNU C Library. Conflicts can occasionally
happen in this case. You can also use this option if you want to compile the
GNU C Library with a newer set of kernel headers than the ones found in
/usr/include.
```
¡®--enable-kernel=version¡¯
This option is currently only useful on GNU/Linux systems. Theversionpa-
rameter should have the form X.Y.Z and describes the smallest version of the
Linux kernel the generated library is expected to support. The higher thever-
sionnumber is, the less compatibility code is added, and the faster the code
gets.

¡®--with-binutils=directory¡¯
Use the binutils (assembler and linker) indirectory, not the ones the C com-
piler would default to. You can use this option if the default binutils on your
system cannot deal with all the constructs in the GNU C Library. In that
case,configurewill detect the problem and suppress these constructs, so that
the library will still be usable, but functionality may be lost¡ªfor example, you
can¡¯t build a shared libc with old binutils.

¡®--with-nonshared-cflags=cflags¡¯
Use additional compiler flagscflags to build the parts of the library which
are always statically linked into applications and libraries even with shared
linking (that is, the object files contained inlib*_nonshared.alibraries).
The build process will automatically use the appropriate flags, but this
option can be used to set additional flags required for building applications
and libraries, to match local policy. For example, if such a policy requires
that all code linked into applications must be built with source fortification,
¡®--with-nonshared-cflags=-Wp,-D_FORTIFY_SOURCE=2¡¯ will make sure that
the objects inlibc_nonshared.aare compiled with this flag (although this
will not affect the generated code in this particular case and potentially change
debugging information and metadata only).

¡®--disable-shared¡¯
Don¡¯t build shared libraries even if it is possible. Not all systems support shared
libraries; you need ELF support and (currently) the GNU linker.

¡®--enable-static-pie¡¯
Enable static position independent executable (static PIE) support. Static PIE
is similar to static executable, but can be loaded at any address without help
from a dynamic linker. All static programs as well as static tests are built as
static PIE, except for those marked with no-pie. The resulting glibc can be
used with the GCC option, -static-pie, which is available with GCC 8 or above,
to create static PIE. This option also implies that glibc programs and tests are
created as dynamic position independent executables (PIE) by default.


Appendix C: Installing the GNU C Library 1090

¡®--enable-cet¡¯
¡®--enable-cet=permissive¡¯
Enable Intel Control-flow Enforcement Technology (CET) support. When the
GNU C Library is built with--enable-cetor--enable-cet=permissive, the
resulting library is protected with indirect branch tracking (IBT) and shadow
stack (SHSTK). When CET is enabled, the GNU C Library is compatible
with all existing executables and shared libraries. This feature is currently
supported on i386, x8664 and x32 with GCC 8 and binutils 2.29 or later. Note
that when CET is enabled, the GNU C Library requires CPUs capable of multi-
byte NOPs, like x86-64 processors as well as Intel Pentium Pro or newer. With
--enable-cet, it is an error to dlopen a non CET enabled shared library in
CET enabled application. With--enable-cet=permissive, CET is disabled
when dlopening a non CET enabled shared library in CET enabled application.
NOTE:--enable-cethas been tested for i686, x8664 and x32 on non-CET
processors. --enable-cethas been tested for i686, x8664 and x32 on CET
processors.

¡®--enable-memory-tagging¡¯
Enable memory tagging support if the architecture supports it. When the
GNU C Library is built with this option then the resulting library will be able
to control the use of tagged memory when hardware support is present by use
of the tunable ¡®glibc.mem.tagging¡¯. This includes the generation of tagged
memory when using themallocAPIs.
At present only AArch64 platforms with MTE provide this functionality, al-
though the library will still operate (without memory tagging) on older versions
of the architecture.
The default is to disable support for memory tagging.

¡®--disable-profile¡¯
Don¡¯t build libraries with profiling information. You may want to use this
option if you don¡¯t plan to do profiling.

¡®--enable-static-nss¡¯
Compile static versions of the NSS (Name Service Switch) libraries. This is
not recommended because it defeats the purpose of NSS; a program linked
statically with the NSS libraries cannot be dynamically reconfigured to use a
different name database.

¡®--enable-hardcoded-path-in-tests¡¯
By default, dynamic tests are linked to run with the installed C library. This
option hardcodes the newly built C library path in dynamic tests so that they
can be invoked directly.

¡®--disable-timezone-tools¡¯
By default, timezone related utilities (zic,zdump, andtzselect) are installed
with the GNU C Library. If you are building these independently (e.g. by using
the ¡®tzcode¡¯ package), then this option will allow disabling the install of these.


Appendix C: Installing the GNU C Library 1091

```
Note that you need to make sure the external tools are kept in sync with the
versions that the GNU C Library expects as the data formats may change over
time. Consult thetimezonesubdirectory for more details.
```
¡®--enable-stack-protector¡¯
¡®--enable-stack-protector=strong¡¯
¡®--enable-stack-protector=all¡¯
Compile the C library and all other parts of the glibc package (including the
threading and math libraries, NSS modules, and transliteration modules) us-
ing the GCC-fstack-protector,-fstack-protector-strongor-fstack-
protector-alloptions to detect stack overruns. Only the dynamic linker and
a small number of routines called directly from assembler are excluded from
this protection.

¡®--enable-bind-now¡¯
Disable lazy binding for installed shared objects and programs. This provides
additional security hardening because it enables full RELRO and a read-only
global offset table (GOT), at the cost of slightly increased program load times.

¡®--enable-pt_chown¡¯
The filept_chownis a helper binary forgrantpt(seeSection 17.9.1 [Allocating
Pseudo-Terminals], page 528) that is installed setuid root to fix up pseudo-
terminal ownership on GNU/Hurd. It is not required on GNU/Linux, and the
GNU C Library will not use the installedpt_chownprogram when configured
with--enable-pt_chown.

¡®--disable-werror¡¯
By default, the GNU C Library is built with-Werror. If you wish to build
without this option (for example, if building with a newer version of GCC than
this version of the GNU C Library was tested with, so new warnings cause the
build with-Werrorto fail), you can configure with--disable-werror.

¡®--disable-mathvec¡¯
By default for x8664, the GNU C Library is built with the vector math library.
Use this option to disable the vector math library.

¡®--enable-tunables¡¯
Tunables support allows additional library parameters to be customized at run-
time. This feature is enabled by default. This option can take the following
values:

```
yes This is the default if no option is passed to configure. This enables
tunables and selects the default frontend (currently ¡®valstring¡¯).
```
```
no This option disables tunables.
```
```
valstring
This enables tunables and selects the ¡®valstring¡¯ frontend for tun-
ables. This frontend allows users to specify tunables as a colon-
separated list in a single environment variableGLIBC_TUNABLES.
```

Appendix C: Installing the GNU C Library 1092

¡®--disable-crypt¡¯
Do not install the passphrase-hashing librarylibcrypt or the header file
crypt.h. unistd.hwill still declare the functioncrypt. Using this option
does not change the set of programs that may need to be linked with-lcrypt;
it only means that the GNU C Library will not provide that library.
This option is for hackers and distributions experimenting with independently-
maintained implementations of libcrypt. It may become the default in a future
release.

¡®--disable-experimental-malloc¡¯
By default, a per-thread cache is enabled inmalloc. While this cache can be
disabled on a per-application basis using tunables (set glibc.malloc.tcachecount
to zero), this option can be used to remove it from the build completely.

¡®--build=build-system¡¯
¡®--host=host-system¡¯
These options are for cross-compiling. If you specify both options andbuild-
systemis different fromhost-system,configurewill prepare to cross-compile
the GNU C Library frombuild-systemto be used onhost-system. You¡¯ll prob-
ably need the ¡®--with-headers¡¯ option too, and you may have to override
configure¡¯s selection of the compiler and/or binutils.
If you only specify ¡®--host¡¯,configurewill prepare for a native compile but
use what you specify instead of guessing what your system is. This is most
useful to change the CPU submodel. For example, ifconfigureguesses your
machine asi686-pc-linux-gnubut you want to compile a library for 586es,
give ¡®--host=i586-pc-linux-gnu¡¯ or just ¡®--host=i586-linux¡¯ and add the
appropriate compiler flags (¡®-mcpu=i586¡¯ will do the trick) toCC.
If you specify just ¡®--build¡¯,configurewill get confused.

¡®--with-pkgversion=version¡¯
Specify a description, possibly including a build number or build date, of the
binaries being built, to be included in--versionoutput from programs in-
stalled with the GNU C Library. For example,--with-pkgversion='FooBar
GNU/Linux glibc build 123'. The default value is ¡®GNU libc¡¯.

¡®--with-bugurl=url¡¯
Specify the URL that users should visit if they wish to report a bug, to be
included in--helpoutput from programs installed with the GNU C Library.
The default value refers to the main bug-reporting information for the GNU C
Library.
To build the library and related programs, typemake. This will produce a lot of output,
some of which may look like errors frommakebut aren¡¯t. Look for error messages from
makecontaining ¡®***¡¯. Those indicate that something is seriously wrong.

The compilation process can take a long time, depending on the configuration and the
speed of your machine. Some complex modules may take a very long time to compile, as
much as several minutes on slower machines. Do not panic if the compiler appears to hang.

If you want to run a parallel make, simply pass the ¡®-j¡¯ option with an appropriate
numeric parameter tomake. You need a recent GNUmakeversion, though.


Appendix C: Installing the GNU C Library 1093

To build and run test programs which exercise some of the library facilities, typemake
check. If it does not complete successfully, do not use the built library, and report a bug
after verifying that the problem is not already known. SeeSection C.5 [Reporting Bugs],
page 1098, for instructions on reporting bugs. Note that some of the tests assume they are
not being run byroot. We recommend you compile and test the GNU C Library as an
unprivileged user.

Before reporting bugs make sure there is no problem with your system. The tests
(and later installation) use some pre-existing files of the system such as/etc/passwd,
/etc/nsswitch.confand others. These files must all contain correct and sensible content.

Normally,make checkwill run all the tests before reporting all problems found and exit-
ing with error status if any problems occurred. You can specify ¡®stop-on-test-failure=y¡¯
when runningmake checkto make the test run stop and exit with an error status immedi-
ately when a failure occurs.

To format theGNU C Library Reference Manualfor printing, typemake dvi. You need
a working TEX installation to do this. The distribution builds the on-line formatted version
of the manual, as Info files, as part of the build process. You can build them manually with
make info.

The library has a number of special-purpose configuration parameters which you can
find inMakeconfig. These can be overwritten with the fileconfigparms. To change them,
create aconfigparmsin your build directory and add values as appropriate for your system.
The file is included and parsed bymakeand has to follow the conventions for makefiles.

It is easy to configure the GNU C Library for cross-compilation by setting a few variables
inconfigparms. SetCCto the cross-compiler for the target you configured the library for;
it is important to use this sameCCvalue when runningconfigure, like this: ¡®configure
targetCC=target-gcc¡¯. SetBUILD_CCto the compiler to use for programs run on the
build system as part of compiling the library. You may need to setARto cross-compiling
versions ofarif the native tools are not configured to work with object files for the target
you configured for. When cross-compiling the GNU C Library, it may be tested using ¡®make
check test-wrapper="srcdir/scripts/cross-test-ssh.shhostname"¡¯, wheresrcdiris
the absolute directory name for the main source directory andhostnameis the host name of
a system that can run the newly built binaries of the GNU C Library. The source and build
directories must be visible at the same locations on both the build system andhostname.

In general, when testing the GNU C Library, ¡®test-wrapper¡¯ may be set to the name
and arguments of any program to run newly built binaries. This program must preserve the
arguments to the binary being run, its working directory and the standard input, output and
error file descriptors. If ¡®test-wrapperenv¡¯ will not work to run a program with environ-
ment variables set, then ¡®test-wrapper-env¡¯ must be set to a program that runs a newly
built program with environment variable assignments in effect, those assignments being
specified as ¡®var=value¡¯ before the name of the program to be run. If multiple assignments
to the same variable are specified, the last assignment specified must take precedence. Sim-
ilarly, if ¡®test-wrapperenv -i¡¯ will not work to run a program with an environment com-
pletely empty of variables except those directly assigned, then ¡®test-wrapper-env-only¡¯
must be set; its use has the same syntax as ¡®test-wrapper-env¡¯, the only difference in
its semantics being starting with an empty set of environment variables rather than the
ambient set.


Appendix C: Installing the GNU C Library 1094

C.2 Installing the C Library

To install the library and its header files, and the Info files of the manual, typemake
install. This will build things, if necessary, before installing them; however, you should
still compile everything first. If you are installing the GNU C Library as your primary C
library, we recommend that you shut the system down to single-user mode first, and reboot
afterward. This minimizes the risk of breaking things when the library changes out from
underneath.

¡®make install¡¯ will do the entire job of upgrading from a previous installation of the
GNU C Library version 2.x. There may sometimes be headers left behind from the previous
installation, but those are generally harmless. If you want to avoid leaving headers behind
you can do things in the following order.

You must first build the library (¡®make¡¯), optionally check it (¡®make check¡¯), switch the
include directories and then install (¡®make install¡¯). The steps must be done in this order.
Not moving the directory before install will result in an unusable mixture of header files
from both libraries, but configuring, building, and checking the library requires the ability to
compile and run programs against the old library. The new/usr/include, after switching
the include directories and before installing the library should contain the Linux headers,
but nothing else. If you do this, you will need to restore any headers from libraries other
than the GNU C Library yourself after installing the library.

You can install the GNU C Library somewhere other than where you configured it to
go by setting theDESTDIRGNU standard make variable on the command line for ¡®make
install¡¯. The value of this variable is prepended to all the paths for installation. This
is useful when setting up a chroot environment or preparing a binary distribution. The
directory should be specified with an absolute file name. Installing with theprefixand
exec_prefixGNU standard make variables set is not supported.

The GNU C Library includes a daemon callednscd, which you may or may not want
to run. nscdcaches name service lookups; it can dramatically improve performance with
NIS+, and may help with DNS as well.

One auxiliary program, /usr/libexec/pt_chown, is installed setuid root if the
¡®--enable-pt_chown¡¯ configuration option is used. This program is invoked by the
grantptfunction; it sets the permissions on a pseudoterminal so it can be used by the
calling process. If you are using a Linux kernel with thedevptsfilesystem enabled and
mounted at/dev/pts, you don¡¯t need this program.

After installation you should configure the timezone and install locales for your system.
The time zone configuration ensures that your system time matches the time for your current
timezone. The locales ensure that the display of information on your system matches the
expectations of your language and geographic region.

The GNU C Library is able to use two kinds of localization information sources,
the first is a locale database named locale-archive which is generally installed as
/usr/lib/locale/locale-archive. The locale archive has the benefit of taking up less
space and being very fast to load, but only if you plan to install sixty or more locales.
If you plan to install one or two locales you can instead install individual locales into
their self-named directories e.g./usr/lib/locale/en_US.utf8. For example to install
the German locale using the character set for UTF-8 with namede_DEinto the locale
archive issue the command ¡®localedef -i de_DE -f UTF-8 de_DE¡¯, and to install just the


Appendix C: Installing the GNU C Library 1095

one locale issue the command ¡®localedef --no-archive -i de_DE -f UTF-8 de_DE¡¯. To
configure all locales that are supported by the GNU C Library, you can issue from your
build directory the command ¡®make localedata/install-locales¡¯ to install all locales
into the locale archive or ¡®make localedata/install-locale-files¡¯ to install all locales
as files in the default configured locale installation directory (derived from ¡®--prefix¡¯
or--localedir). To install into an alternative system root use ¡®DESTDIR¡¯ e.g. ¡®make
localedata/install-locale-files DESTDIR=/opt/glibc¡¯, but note that this does not
change the configured prefix.

To configure the locally used timezone, set theTZenvironment variable. The script
tzselecthelps you to select the right value. As an example, for Germany,tzselect
would tell you to use ¡®TZ='Europe/Berlin'¡¯. For a system wide installation (the given
paths are for an installation with ¡®--prefix=/usr¡¯), link the timezone file which is in
/usr/share/zoneinfoto the file/etc/localtime. For Germany, you might execute ¡®ln
-s /usr/share/zoneinfo/Europe/Berlin /etc/localtime¡¯.

C.3 Recommended Tools for Compilation

We recommend installing the following GNU tools before attempting to build the GNU C
Library:

- GNUmake4.0 or newer
    As of relase time, GNUmake4.3 is the newest verified to work to build the GNU C
    Library.
- GCC 6.2 or newer
    GCC 6.2 or higher is required. In general it is recommended to use the newest version
    of the compiler that is known to work for building the GNU C Library, as newer
    compilers usually produce better code. As of release time, GCC 10.2 is the newest
    compiler verified to work to build the GNU C Library.
    For PowerPC 64-bits little-endian (powerpc64le), a GCC version with support for-mno-
    gnu-attribute,-mabi=ieeelongdouble, and-mabi=ibmlondoubleis required. Like-
    wise, the compiler must also support passing-mlong-double-128with the preceding
    options. As of release, this implies GCC 7.4 and newer (excepting GCC 7.5.0, see GCC
    PR94200). These additional features are required for building the GNU C Library with
    support for IEEE long double.
    For ARC architecture builds, GCC 8.3 or higher is needed.
    For s390x architecture builds, GCC 7.1 or higher is needed (See gcc Bug 98269).
    For multi-arch support it is recommended to use a GCC which has been built with
    support for GNU indirect functions. This ensures that correct debugging information
    is generated for functions selected by IFUNC resolvers. This support can either be
    enabled by configuring GCC with ¡®--enable-gnu-indirect-function¡¯, or by enabling
    it by default by setting ¡®default_gnu_indirect_function¡¯ variable for a particular
    architecture in the GCC source filegcc/config.gcc.
    You can use whatever compiler you like to compile programs that use the GNU C
    Library.
    Check the FAQ for any special compiler issues on particular platforms.


Appendix C: Installing the GNU C Library 1096

- GNUbinutils2.25 or later
    You must use GNUbinutils(as and ld) to build the GNU C Library. No other
    assembler or linker has the necessary functionality at the moment. As of release time,
    GNUbinutils2.35.1 is the newest verified to work to build the GNU C Library.
    For PowerPC 64-bits little-endian (powerpc64le), objcopy is required to support
    --update-section. This option requires binutils 2.26 or newer.
    ARC architecture needsbinutils2.32 or higher for TLS related fixes.
- GNUtexinfo4.7 or later
    To correctly translate and install the Texinfo documentation you need this version
    of thetexinfopackage. Earlier versions do not understand all the tags used in the
    document, and the installation mechanism for the info files is not present or works
    differently. As of release time,texinfo6.7 is the newest verified to work to build the
    GNU C Library.
- GNUawk3.1.2, or higher
    awkis used in several places to generate files. Somegawkextensions are used, including
    theasortifunction, which was introduced in version 3.1.2 ofgawk. As of release time,
    gawkversion 5.1 is the newest verified to work to build the GNU C Library.
- GNUbison2.7 or later
    bisonis used to generate theyaccparser code in theintlsubdirectory. As of release
    time,bisonversion 3.7.4 is the newest verified to work to build the GNU C Library.
- Perl 5
    Perl is not required, but if present it is used in some tests and themtraceprogram, to
    build the GNU C Library manual. As of release timeperlversion 5.32.0 is the newest
    verified to work to build the GNU C Library.
- GNUsed3.02 or newer
    Sedis used in several places to generate files. Most scripts work with any version of
    sed. As of release time,sedversion 4.8 is the newest verified to work to build the GNU
    C Library.
- Python 3.4 or later
    Python is required to build the GNU C Library. As of release time, Python 3.8.6 is
    the newest verified to work for building and testing the GNU C Library.
- PExpect 4.0
    The pretty printer tests drive GDB through test programs and compare its output to
    the printers¡¯. PExpect is used to capture the output of GDB, and should be compatible
    with the Python version in your system. As of release time PExpect 4.8 is the newest
    verified to work to test the pretty printers.
- GDB 7.8 or later with support for Python 2.7/3.4 or later
    GDB itself needs to be configured with Python support in order to use the pretty
    printers. Notice that your system having Python available doesn¡¯t imply that GDB
    supports it, nor that your system¡¯s Python and GDB¡¯s have the same version. As
    of release time GNUdebugger10.1 is the newest verified to work to test the pretty
    printers.


Appendix C: Installing the GNU C Library 1097

```
Unless Python, PExpect and GDB with Python support are present, the printer tests
will report themselves asUNSUPPORTED. Notice that some of the printer tests require
the GNU C Library to be compiled with debugging symbols.
```
If you change any of theconfigure.acfiles you will also need

- GNUautoconf2.69 (exactly)

and if you change any of the message translation files you will need

- GNUgettext0.10.36 or later
    As of release time, GNUgettextversion 0.21 is the newest version verified to work to
    build the GNU C Library.

You may also need these packages if you upgrade your source tree using patches, although
we try to avoid this.

C.4 Specific advice for GNU/Linux systems

If you are installing the GNU C Library on GNU/Linux systems, you need to have the
header files from a 3.2 or newer kernel around for reference. (For the ia64 architecture, you
need version 3.2.18 or newer because this is the first version with support for theaccept4
system call.) These headers must be installed using ¡®make headers_install¡¯; the headers
present in the kernel source directory are not suitable for direct use by the GNU C Library.
You do not need to use that kernel, just have its headers installed where the GNU C
Library can access them, referred to here asinstall-directory. The easiest way to do this is
to unpack it in a directory such as/usr/src/linux-version. In that directory, run ¡®make
headers_install INSTALL_HDR_PATH=install-directory¡¯. Finally, configure the GNU
C Library with the option ¡®--with-headers=install-directory/include¡¯. Use the most
recent kernel you can get your hands on. (If you are cross-compiling the GNU C Library,
you need to specify ¡®ARCH=architecture¡¯ in the ¡®make headers_install¡¯ command, where
architectureis the architecture name used by the Linux kernel, such as ¡®x86¡¯ or ¡®powerpc¡¯.)

After installing the GNU C Library, you may need to remove or rename directories such
as/usr/include/linuxand/usr/include/asm, and replace them with copies of directo-
ries such aslinuxandasmfrominstall-directory/include. All directories present in
install-directory/includeshould be copied, except that the GNU C Library provides
its own version of/usr/include/scsi; the files provided by the kernel should be copied
without replacing those provided by the GNU C Library. Thelinux,asmandasm-generic
directories are required to compile programs using the GNU C Library; the other directories
describe interfaces to the kernel but are not required if not compiling programs using those
interfaces. You do not need to copy kernel headers if you did not specify an alternate kernel
header source using ¡®--with-headers¡¯.

The Filesystem Hierarchy Standard for GNU/Linux systems expects some components
of the GNU C Library installation to be in/liband some in/usr/lib. This is handled
automatically if you configure the GNU C Library with ¡®--prefix=/usr¡¯. If you set some
other prefix or allow it to default to/usr/local, then all the components are installed
there.


Appendix C: Installing the GNU C Library 1098

C.5 Reporting Bugs

There are probably bugs in the GNU C Library. There are certainly errors and omissions
in this manual. If you report them, they will get fixed. If you don¡¯t, no one will ever know
about them and they will remain unfixed for all eternity, if not longer.

It is a good idea to verify that the problem has not already been reported. Bugs are doc-
umented in two places: The fileBUGSdescribes a number of well known bugs and the central
GNU C Library bug tracking system has a WWW interface athttps://sourceware.org/
bugzilla/. The WWW interface gives you access to open and closed reports. A closed
report normally includes a patch or a hint on solving the problem.

To report a bug, first you must find it. With any luck, this will be the hard part. Once
you¡¯ve found a bug, make sure it¡¯s really a bug. A good way to do this is to see if the GNU
C Library behaves the same way some other C library does. If so, probably you are wrong
and the libraries are right (but not necessarily). If not, one of the libraries is probably
wrong. It might not be the GNU C Library. Many historical Unix C libraries permit things
that we don¡¯t, such as closing a file twice.

If you think you have found some way in which the GNU C Library does not conform to
the ISO and POSIX standards (seeSection 1.2 [Standards and Portability], page 1), that
is definitely a bug. Report it!

Once you¡¯re sure you¡¯ve found a bug, try to narrow it down to the smallest test case
that reproduces the problem. In the case of a C library, you really only need to narrow it
down to one library function call, if possible. This should not be too difficult.

The final step when you have a simple test case is to report the bug. Do this at
https://www.gnu.org/software/libc/bugs.html.

If you are not sure how a function should behave, and this manual doesn¡¯t tell you, that¡¯s
a bug in the manual. Report that too! If the function¡¯s behavior disagrees with the manual,
then either the library or the manual has a bug, so report the disagreement. If you find any
errors or omissions in this manual, please report them to the bug database. If you refer to
specific sections of the manual, please include the section names for easier identification.


### 1099

## D Library Maintenance................................

D.1 Adding New Functions

The process of building the library is driven by the makefiles, which make heavy use of
special features of GNUmake. The makefiles are very complex, and you probably don¡¯t
want to try to understand them. But what they do is fairly straightforward, and only
requires that you define a few variables in the right places.

The library sources are divided into subdirectories, grouped by topic.
Thestringsubdirectory has all the string-manipulation functions,mathhas all the
mathematical functions, etc.

Each subdirectory contains a simple makefile, calledMakefile, which defines a fewmake
variables and then includes the global makefileRuleswith a line like:
include ../Rules

The basic variables that a subdirectory makefile defines are:

subdir The name of the subdirectory, for examplestdio. This variablemustbe de-
fined.

headers The names of the header files in this section of the library, such asstdio.h.

routines
aux The names of the modules (source files) in this section of the library. These
should be simple names, such as ¡®strlen¡¯ (rather than complete file names, such
asstrlen.c). Useroutinesfor modules that define functions in the library,
andauxfor auxiliary modules containing things like data definitions. But the
values ofroutinesandauxare just concatenated, so there really is no practical
difference.

tests The names of test programs for this section of the library. These should be
simple names, such as ¡®tester¡¯ (rather than complete file names, such as
tester.c). ¡®make tests¡¯ will build and run all the test programs. If a test
program needs input, put the test data in a file calledtest-program.input;
it will be given to the test program on its standard input. If a test program
wants to be run with arguments, put the arguments (all on a single line) in
a file calledtest-program.args. Test programs should exit with zero status
when the test passes, and nonzero status when the test indicates a bug in the
library or error in building.

others The names of ¡°other¡± programs associated with this section of the library.
These are programs which are not tests per se, but are other small programs
included with the library. They are built by ¡®make others¡¯.

install-lib
install-data
install Files to be installed by ¡®make install¡¯. Files listed in ¡®install-lib¡¯ are
installed in the directory specified by ¡®libdir¡¯ inconfigparmsorMakeconfig
(seeAppendix C [Installing the GNU C Library], page 1088). Files listed
in install-data are installed in the directory specified by ¡®datadir¡¯ in


Appendix D: Library Maintenance 1100

```
configparms orMakeconfig. Files listed ininstall are installed in the
directory specified by ¡®bindir¡¯ inconfigparmsorMakeconfig.
```
distribute
Other files from this subdirectory which should be put into a distribution tar
file. You need not list here the makefile itself or the source and header files
listed in the other standard variables. Only definedistributeif there are files
used in an unusual way that should go into the distribution.

generated
Files which are generated byMakefilein this subdirectory. These files will be
removed by ¡®make clean¡¯, and they will never go into a distribution.

extra-objs
Extra object files which are built byMakefilein this subdirectory. This should
be a list of file names likefoo.o; the files will actually be found in what-
ever directory object files are being built in. These files will be removed by
¡®make clean¡¯. This variable is used for secondary object files needed to build
othersortests.

D.1.1 Platform-specific types, macros and functions

It¡¯s sometimes necessary to provide nonstandard, platform-specific features to developers.
The C library is traditionally the lowest library layer, so it makes sense for it to provide these
low-level features. However, including these features in the C library may be a disadvantage
if another package provides them as well as there will be two conflicting versions of them.
Also, the features won¡¯t be available to projects that do not use the GNU C Library but
use other GNU tools, like GCC.

```
The current guidelines are:
```
- If the header file provides features that only make sense on a particular machine ar-
    chitecture and have nothing to do with an operating system, then the features should
    ultimately be provided as GCC built-in functions. Until then, the GNU C Library may
    provide them in the header file. When the GCC built-in functions become available,
    those provided in the header file should be made conditionally available prior to the
    GCC version in which the built-in function was made available.
- If the header file provides features that are specific to an operating system, both GCC
    and the GNU C Library could provide it, but the GNU C Library is preferred as it
    already has a lot of information about the operating system.
- If the header file provides features that are specific to an operating system but used by
    the GNU C Library, then the GNU C Library should provide them.

```
The general solution for providing low-level features is to export them as follows:
```
- A nonstandard, low-level header file that defines macros and inline functions should be
    calledsys/platform/name.h.
- Each header file¡¯s name should include the platform name, to avoid users thinking there
    is anything in common between the different header files for different platforms. For
    example, asys/platform/arch.hname such assys/platform/ppc.his better than
    sys/platform.h.


Appendix D: Library Maintenance 1101

- A platform-specific header file provided by the GNU C Library should coordinate
    with GCC such that compiler built-in versions of the functions and macros are pre-
    ferred if available. This means that user programs will only ever need to include
    sys/platform/arch.h, keeping the same names of types, macros, and functions for
    convenience and portability.
- Each included symbol must have the prefix__arch_, such as__ppc_get_timebase.

The easiest way to provide a header file is to add it to thesysdep_headersvariable.
For example, the combination of Linux-specific header files on PowerPC could be provided
like this:
sysdep_headers += sys/platform/ppc.h
Then ensure that you have added asys/platform/ppc.hheader file in the machine-
specific directory, e.g.,sysdeps/powerpc/sys/platform/ppc.h.

D.2 Symbol handling in the GNU C Library

D.2.1 64-bit time symbol handling in the GNU C Library

With respect to time handling, GNU C Library configurations fall in two classes depending
on the value of__TIMESIZE:

__TIMESIZE == 32
Thesedual-timeconfigurations have both 32-bit and 64-bit time support. 32-
bit time support provides typetime_tand cannot handle dates beyondY2038.
64-bit time support provides type__time64_tand can handle dates beyond
Y2038.
In these configurations, time-related types have two declarations, a 64-bit one,
and a 32-bit one; and time-related functions generally have two definitions: a
64-bit one, and a 32-bit one which is a wrapper around the former. Therefore,
for everytime_t-related symbol, there is a corresponding__time64_t-related
symbol, the name of which is usually the 32-bit symbol¡¯s name with__(a
double underscore) prepended and 64 appended. For instance, the 64-bit-time
counterpart ofclock_gettimeis__clock_gettime64.

__TIMESIZE == 64
Thesesingle-timeconfigurations only have a 64-bittime_tand related func-
tions, which can handle dates beyond 2038-01-19 03:14:07 (akaY2038).
In these configurations, time-related types only have a 64-bit declaration; and
time-related functions only have one 64-bit definition. However, for everytime_
t-related symbol, there is a corresponding__time64_t-related macro, the name
of which is derived as in the dual-time configuration case, and which expands
to the symbol¡¯s name. For instance, the macro__clock_gettime64expands
toclock_gettime.
These macros are purely internal to the GNU C Library and exist only so that
a single definition of the 64-bit time functions can be used on both single-time
and dual-time configurations, and so that glibc code can freely call the 64-bit
functions internally in all configurations.


Appendix D: Library Maintenance 1102

Note: at this point, 64-bit time support in dual-time configurations is work-in-progress,
so for these configurations, the public API only makes the 32-bit time support available.
In a later change, the public API will allow user code to choose the time size for a given
compilation unit.

64-bit variants of time-related types or functions are defined for all configurations and
use 64-bit-time symbol names (for dual-time configurations) or macros (for single-time con-
figurations).

32-bit variants of time-related types or functions are defined only for dual-time configu-
rations.

Here is an example withlocaltime:
Functionlocaltimeis declared intime/time.has
extern struct tm *localtime (const time_t *__timer) __THROW;
libc_hidden_proto (localtime)
For single-time configurations,__localtime64is a macro which evaluates tolocaltime;
for dual-time configurations,__localtime64is a function similar tolocaltimeexcept it
uses Y2038-proof types:
#if __TIMESIZE == 64
# define __localtime64 localtime
#else
extern struct tm *__localtime64 (const __time64_t *__timer) __THROW;
libc_hidden_proto (__localtime64)
#endif
(note: typetime_tis replaced with__time64_tbecausetime_tis not Y2038-proof,
butstruct tmis not replaced because it is already Y2038-proof.)

The 64-bit-time implementation oflocaltimeis written as follows and is compiled for
both dual-time and single-time configuration classes.
struct tm *
__localtime64 (const __time64_t *t)
{
return __tz_convert (*t, 1, &_tmbuf);
}
libc_hidden_def (__localtime64)
The 32-bit-time implementation is a wrapper and is only compiled for dual-time config-
urations:
#if __TIMESIZE != 64

```
struct tm *
localtime (const time_t *t)
{
__time64_t t64 = *t;
return __localtime64 (&t64);
}
libc_hidden_def (localtime)
```
```
#endif
```
D.3 Porting the GNU C Library

The GNU C Library is written to be easily portable to a variety of machines and operating
systems. Machine- and operating system-dependent functions are well separated to make it


Appendix D: Library Maintenance 1103

easy to add implementations for new machines or operating systems. This section describes
the layout of the library source tree and explains the mechanisms used to select machine-
dependent code to use.

All the machine-dependent and operating system-dependent files in the library are in the
subdirectorysysdepsunder the top-level library source directory. This directory contains a
hierarchy of subdirectories (seeSection D.3.1 [Layout of thesysdepsDirectory Hierarchy],
page 1105).

Each subdirectory ofsysdepscontains source files for a particular machine or operating
system, or for a class of machine or operating system (for example, systems by a particular
vendor, or all machines that use IEEE 754 floating-point format). A configuration specifies
an ordered list of these subdirectories. Each subdirectory implicitly appends its parent di-
rectory to the list. For example, specifying the listunix/bsd/vaxis equivalent to specifying
the listunix/bsd/vax unix/bsd unix. A subdirectory can also specify that it implies other
subdirectories which are not directly above it in the directory hierarchy. If the fileImplies
exists in a subdirectory, it lists other subdirectories ofsysdepswhich are appended to the
list, appearing after the subdirectory containing theImpliesfile. Lines in anImpliesfile
that begin with a ¡®#¡¯ character are ignored as comments. For example,unix/bsd/Implies
contains:
# BSD has Internet-related things.
unix/inet

andunix/Impliescontains:
posix

So the final list isunix/bsd/vax unix/bsd unix/inet unix posix.

sysdepshas a ¡°special¡± subdirectory calledgeneric. It is always implicitly appended
to the list of subdirectories, so you needn¡¯t put it in anImpliesfile, and you should not
create any subdirectories under it intended to be new specific categories. genericserves
two purposes. First, the makefiles do not bother to look for a system-dependent version of a
file that¡¯s not ingeneric. This means that any system-dependent source file must have an
analogue ingeneric, even if the routines defined by that file are not implemented on other
platforms. Second, thegenericversion of a system-dependent file is used if the makefiles
do not find a version specific to the system you¡¯re compiling for.

If it is possible to implement the routines in agenericfile in machine-independent C,
using only other machine-independent functions in the C library, then you should do so.
Otherwise, make them stubs. Astubfunction is a function which cannot be implemented
on a particular machine or operating system. Stub functions always return an error, and set
errnotoENOSYS(Function not implemented). SeeChapter 2 [Error Reporting], page 23. If
you define a stub function, you must place the statementstub_warning(function), where
functionis the name of your function, after its definition. This causes the function to be
listed in the installed<gnu/stubs.h>, and makes GNU ld warn when the function is used.

Some rare functions are only useful on specific systems and aren¡¯t defined at all on
others; these do not appear anywhere in the system-independent source code or makefiles
(including thegenericdirectory), only in the system-dependentMakefilein the specific
system¡¯s subdirectory.

If you come across a file that is in one of the main source directories (string,stdio, etc.),
and you want to write a machine- or operating system-dependent version of it, move the


Appendix D: Library Maintenance 1104

file intosysdeps/genericand write your new implementation in the appropriate system-
specific subdirectory. Note that if a file is to be system-dependent, itmust notappear in
one of the main source directories.

```
There are a few special files that may exist in each subdirectory ofsysdeps:
```
Makefile

A makefile for this machine or operating system, or class of machine or oper-
ating system. This file is included by the library makefileMakerules, which is
used by the top-level makefile and the subdirectory makefiles. It can change the
variables set in the including makefile or add new rules. It can use GNUmake
conditional directives based on the variable ¡®subdir¡¯ (see above) to select differ-
ent sets of variables and rules for different sections of the library. It can also set
themakevariable ¡®sysdep-routines¡¯, to specify extra modules to be included
in the library. You should use ¡®sysdep-routines¡¯ rather than adding modules
to ¡®routines¡¯ because the latter is used in determining what to distribute for
each subdirectory of the main source tree.
Each makefile in a subdirectory in the ordered list of subdirectories to be
searched is included in order. Since several system-dependent makefiles may
be included, each should append to ¡®sysdep-routines¡¯ rather than simply set-
ting it:
sysdep-routines := $(sysdep-routines) foo bar
Subdirs

```
This file contains the names of new whole subdirectories under the top-level
library source tree that should be included for this system. These subdirectories
are treated just like the system-independent subdirectories in the library source
tree, such asstdioandmath.
Use this when there are completely new sets of functions and header files that
should go into the library for the system this subdirectory ofsysdepsimple-
ments. For example,sysdeps/unix/inet/Subdirscontainsinet; theinet
directory contains various network-oriented operations which only make sense
to put in the library on systems that support the Internet.
```
configure
This file is a shell script fragment to be run at configuration time. The top-level
configurescript uses the shell.command to read theconfigurefile in each
system-dependent directory chosen, in order. Theconfigurefiles are often
generated fromconfigure.acfiles using Autoconf.
A system-dependentconfigurescript will usually add things to the shell vari-
ables ¡®DEFS¡¯ and ¡®config_vars¡¯; see the top-levelconfigurescript for details.
The script can check for ¡®--with-package¡¯ options that were passed to the top-
levelconfigure. For an option ¡®--with-package=value¡¯configuresets the
shell variable ¡®with_package¡¯ (with any dashes inpackageconverted to under-
scores) tovalue; if the option is just ¡®--with-package¡¯ (no argument), then it
sets ¡®with_package¡¯ to ¡®yes¡¯.

configure.ac
This file is an Autoconf input fragment to be processed into the fileconfigure
in this subdirectory. SeeSection ¡°Introduction¡± inAutoconf: Generating Auto-


Appendix D: Library Maintenance 1105

```
matic Configuration Scripts, for a description of Autoconf. You should write ei-
therconfigureorconfigure.ac, but not both. The first line ofconfigure.ac
should invoke them4macro ¡®GLIBC_PROVIDES¡¯. This macro does severalAC_
PROVIDEcalls for Autoconf macros which are used by the top-levelconfigure
script; without this, those macros might be invoked again unnecessarily by
Autoconf.
```
That is the general system for how system-dependencies are isolated. The next section
explains how to decide what directories insysdepsto use. Section D.3.2 [Porting the
GNU C Library to Unix Systems], page 1107, has some tips on porting the library to Unix
variants.

D.3.1 Layout of thesysdepsDirectory Hierarchy

A GNU configuration name has three parts: the CPU type, the manufacturer¡¯s name, and
the operating system.configureuses these to pick the list of system-dependent directories
to look for. If the ¡®--nfp¡¯ option isnotpassed toconfigure, the directorymachine/fpu
is also used. The operating system often has abase operating system; for example, if
the operating system is ¡®Linux¡¯, the base operating system is ¡®unix/sysv¡¯. The algorithm
used to pick the list of directories is simple: configuremakes a list of the base operating
system, manufacturer, CPU type, and operating system, in that order. It then concatenates
all these together with slashes in between, to produce a directory name; for example, the
configuration ¡®i686-linux-gnu¡¯ results inunix/sysv/linux/i386/i686.configurethen
tries removing each element of the list in turn, sounix/sysv/linuxandunix/sysvare
also tried, among others. Since the precise version number of the operating system is often
not important, and it would be very inconvenient, for example, to have identicalirix6.2
andirix6.3directories,configuretries successively less specific operating system names
by removing trailing suffixes starting with a period.

As an example, here is the complete list of directories that would be tried for the con-
figuration ¡®i686-linux-gnu¡¯:

```
sysdeps/i386/elf
sysdeps/unix/sysv/linux/i386
sysdeps/unix/sysv/linux
sysdeps/gnu
sysdeps/unix/common
sysdeps/unix/mman
sysdeps/unix/inet
sysdeps/unix/sysv/i386/i686
sysdeps/unix/sysv/i386
sysdeps/unix/sysv
sysdeps/unix/i386
sysdeps/unix
sysdeps/posix
sysdeps/i386/i686
sysdeps/i386/i486
sysdeps/libm-i387/i686
sysdeps/i386/fpu
sysdeps/libm-i387
sysdeps/i386
sysdeps/wordsize-32
sysdeps/ieee754
sysdeps/libm-ieee754
```

Appendix D: Library Maintenance 1106

```
sysdeps/generic
```
Different machine architectures are conventionally subdirectories at the top level of the
sysdepsdirectory tree. For example,sysdeps/sparcandsysdeps/m68k. These contain
files specific to those machine architectures, but not specific to any particular operating
system. There might be subdirectories for specializations of those architectures, such as
sysdeps/m68k/68020. Code which is specific to the floating-point coprocessor used with a
particular machine should go insysdeps/machine/fpu.

There are a few directories at the top level of thesysdepshierarchy that are not for
particular machine architectures.

generic As described above (seeSection D.3 [Porting the GNU C Library], page 1102),
this is the subdirectory that every configuration implicitly uses after all others.

ieee754 This directory is for code using the IEEE 754 floating-point format, where the
C typefloatis IEEE 754 single-precision format, anddoubleis IEEE 754
double-precision format. Usually this directory is referred to in theImplies
file in a machine architecture-specific directory, such asm68k/Implies.

libm-ieee754
This directory contains an implementation of a mathematical library usable on
platforms which use IEEE 754 conformant floating-point arithmetic.

libm-i387
This is a special case. Ideally the code should be insysdeps/i386/fpubut for
various reasons it is kept aside.

posix This directory contains implementations of things in the library in terms of
POSIX.1functions. This includes some of thePOSIX.1functions themselves.
Of course,POSIX.1cannot be completely implemented in terms of itself, so a
configuration using justposixcannot be complete.

unix This is the directory for Unix-like things. SeeSection D.3.2 [Porting the GNU
C Library to Unix Systems], page 1107. uniximpliesposix. There are some
special-purpose subdirectories ofunix:

```
unix/common
This directory is for things common to both BSD and System V re-
lease 4. Bothunix/bsdandunix/sysv/sysv4implyunix/common.
```
```
unix/inet
This directory is forsocket and related functions on Unix sys-
tems.unix/inet/Subdirsenables theinettop-level subdirectory.
unix/commonimpliesunix/inet.
```
mach This is the directory for things based on the Mach microkernel from CMU (in-
cluding GNU/Hurd systems). Other basic operating systems (VMS, for exam-
ple) would have their own directories at the top level of thesysdepshierarchy,
parallel tounixandmach.


Appendix D: Library Maintenance 1107

D.3.2 Porting the GNU C Library to Unix Systems

Most Unix systems are fundamentally very similar. There are variations between different
machines, and variations in what facilities are provided by the kernel. But the interface to
the operating system facilities is, for the most part, pretty uniform and simple.

The code for Unix systems is in the directoryunix, at the top level of thesysdeps
hierarchy. This directory contains subdirectories (and subdirectory trees) for various Unix
variants.

The functions which are system calls in most Unix systems are implemented in assembly
code, which is generated automatically from specifications in files namedsyscalls.list.
There are several such files, one insysdeps/unixand others in its subdirectories. Some
special system calls are implemented in files that are named with a suffix of ¡®.S¡¯; for example,
_exit.S. Files ending in ¡®.S¡¯ are run through the C preprocessor before being fed to the
assembler.

These files all use a set of macros that should be defined insysdep.h. Thesysdep.h
file insysdeps/unixpartially defines them; asysdep.hfile in another directory must
finish defining them for the particular machine and operating system variant. See
sysdeps/unix/sysdep.hand the machine-specificsysdep.himplementations to see what
these macros are and what they should do.

The system-specific makefile for theunix directory (sysdeps/unix/Makefile) gives
rules to generate several files from the Unix system you are building the library on (which
is assumed to be the target system you are building the libraryfor). All the generated files
are put in the directory where the object files are kept; they should not affect the source
tree itself. The files generated areioctls.h,errnos.h,sys/param.h, anderrlist.c(for
thestdiosection of the library).


### 1108

## E Platform-specific facilities............................

The GNU C Library can provide machine-specific functionality.

E.1 PowerPC-specific Facilities

Facilities specific to PowerPC that are not specific to a particular operating system are
declared insys/platform/ppc.h.

uint64_t __ppc_get_timebase (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Read the current value of the Time Base Register.
TheTime Base Registeris a 64-bit register that stores a monotonically incremented
value updated at a system-dependent frequency that may be different from the pro-
cessor frequency. More information is available inPower ISA 2.06b - Book II - Section
5.2.
__ppc_get_timebaseuses the processor¡¯s time base facility directly without requiring
assistance from the operating system, so it is very efficient.

uint64_t __ppc_get_timebase_freq(void) [Function]
Preliminary:|MT-Unsafe init|AS-Unsafe corrupt:init|AC-Unsafe corrupt:init|
SeeSection 1.2.2.1 [POSIX Safety Concepts], page 2.
Read the current frequency at which the Time Base Register is updated.
This frequency is not related to the processor clock or the bus clock. It is also possible
that this frequency is not constant. More information is available inPower ISA 2.06b

- Book II - Section 5.2.

The following functions provide hints about the usage of resources that are shared with
other processors. They can be used, for example, if a program waiting on a lock intends to
divert the shared resources to be used by other processors. More information is available
inPower ISA 2.06b - Book II - Section 3.2.

void __ppc_yield (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Provide a hint that performance will probably be improved if shared resources dedi-
cated to the executing processor are released for use by other processors.

void __ppc_mdoio (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Provide a hint that performance will probably be improved if shared resources dedi-
cated to the executing processor are released until all outstanding storage accesses to
caching-inhibited storage have been completed.


Appendix E: Platform-specific facilities 1109

void __ppc_mdoom (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Provide a hint that performance will probably be improved if shared resources dedi-
cated to the executing processor are released until all outstanding storage accesses to
cacheable storage for which the data is not in the cache have been completed.

void __ppc_set_ppr_med (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the Program Priority Register to medium value (default).
TheProgram Priority Register(PPR) is a 64-bit register that controls the program¡¯s
priority. By adjusting the PPR value the programmer may improve system through-
put by causing the system resources to be used more efficiently, especially in con-
tention situations. The three unprivileged states available are covered by the functions
__ppc_set_ppr_med(medium ¨C default),__ppc_set_ppc_low(low) and__ppc_set_
ppc_med_low(medium low). More information available inPower ISA 2.06b - Book
II - Section 3.1.

void __ppc_set_ppr_low (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the Program Priority Register to low value.

void __ppc_set_ppr_med_low (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the Program Priority Register to medium low value.

Power ISA 2.07 extends the priorities that can be set to the Program Priority Register
(PPR). The following functions implement the new priority levels: very low and medium
high.

void __ppc_set_ppr_very_low (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the Program Priority Register to very low value.

void __ppc_set_ppr_med_high (void) [Function]
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Set the Program Priority Register to medium high value. The medium high priority
is privileged and may only be set during certain time intervals by problem-state
programs. If the program priority is medium high when the time interval expires or
if an attempt is made to set the priority to medium high when it is not allowed, the
priority is set to medium.


Appendix E: Platform-specific facilities 1110

E.2 RISC-V-specific Facilities

Cache management facilities specific to RISC-V systems that implement the Linux ABI are
declared insys/cachectl.h.

void __riscv_flush_icache(void *start, void *end, unsigned long [Function]
intflags)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Enforce ordering between stores and instruction cache fetches. The range of addresses
over which ordering is enforced is specified bystartandend. Theflags argument
controls the extent of this ordering, with the default behavior (aflagsvalue of 0)
being to enforce the fence on all threads in the current process. Setting theSYS_
RISCV_FLUSH_ICACHE_LOCALbit allows users to indicate that enforcing ordering on
only the current thread is necessary. All other flag bits are reserved.

E.3 X86-specific Facilities

Facilities specific to X86 that are not specific to a particular operating system are declared
insys/platform/x86.h.

const struct cpuid_feature * __x86_get_cpuid_feature_leaf [Function]
(unsigned intleaf)
Preliminary:|MT-Safe |AS-Safe |AC-Safe |SeeSection 1.2.2.1 [POSIX Safety
Concepts], page 2.
Return a pointer to x86 CPU feature structure used by query macros for x86 CPU
featureleaf.

int HAS_CPU_FEATURE (name) [Macro]
This macro returns a nonzero value (true) if the processor has the featurename.

int CPU_FEATURE_USABLE (name) [Macro]
This macro returns a nonzero value (true) if the processor has the featurenameand
the feature is supported by the operating system.

```
The supported processor features are:
```
- ACPI¨C Thermal Monitor and Software Controlled Clock Facilities.
- ADX¨C ADX instruction extensions.
- APIC¨C APIC On-Chip.
- AES¨C The AES instruction extensions.
- AESKLE¨C AES Key Locker instructions are enabled by OS.
- AMX_BF16¨C Tile computational operations on bfloat16 numbers.
- AMX_INT8¨C Tile computational operations on 8-bit numbers.
- AMX_TILE¨C Tile architecture.
- ARCH_CAPABILITIES¨C IA32ARCHCAPABILITIES MSR.
- AVX¨C The AVX instruction extensions.
- AVX2¨C The AVX2 instruction extensions.


Appendix E: Platform-specific facilities 1111

- AVX_VNNI¨C The AVX-VNNI instruction extensions.
- AVX512_4FMAPS¨C The AVX5124FMAPS instruction extensions.
- AVX512_4VNNIW¨C The AVX5124VNNIW instruction extensions.
- AVX512_BF16¨C The AVX512BF16 instruction extensions.
- AVX512_BITALG¨C The AVX512BITALG instruction extensions.
- AVX512_FP16¨C The AVX512FP16 instruction extensions.
- AVX512_IFMA¨C The AVX512IFMA instruction extensions.
- AVX512_VBMI¨C The AVX512VBMI instruction extensions.
- AVX512_VBMI2¨C The AVX512VBMI2 instruction extensions.
- AVX512_VNNI¨C The AVX512VNNI instruction extensions.
- AVX512_VP2INTERSECT¨C The AVX512VP2INTERSECT instruction extensions.
- AVX512_VPOPCNTDQ¨C The AVX512VPOPCNTDQ instruction extensions.
- AVX512BW¨C The AVX512BW instruction extensions.
- AVX512CD¨C The AVX512CD instruction extensions.
- AVX512ER¨C The AVX512ER instruction extensions.
- AVX512DQ¨C The AVX512DQ instruction extensions.
- AVX512F¨C The AVX512F instruction extensions.
- AVX512PF¨C The AVX512PF instruction extensions.
- AVX512VL¨C The AVX512VL instruction extensions.
- BMI1¨C BMI1 instructions.
- BMI2¨C BMI2 instructions.
- CLDEMOTE¨C CLDEMOTE instruction.
- CLFLUSHOPT¨C CLFLUSHOPT instruction.
- CLFSH¨C CLFLUSH instruction.
- CLWB¨C CLWB instruction.
- CMOV¨C Conditional Move instructions.
- CMPXCHG16B¨C CMPXCHG16B instruction.
- CNXT_ID¨C L1 Context ID.
- CORE_CAPABILITIES¨C IA32CORECAPABILITIES MSR.
- CX8¨C CMPXCHG8B instruction.
- DCA¨C Data prefetch from a memory mapped device.
- DE¨C Debugging Extensions.
- DEPR_FPU_CS_DS¨C Deprecates FPU CS and FPU DS values.
- DS¨C Debug Store.
- DS_CPL¨C CPL Qualified Debug Store.
- DTES64¨C 64-bit DS Area.
- EIST¨C Enhanced Intel SpeedStep technology.
- ENQCMD¨C Enqueue Stores instructions.
- ERMS¨C Enhanced REP MOVSB/STOSB.


Appendix E: Platform-specific facilities 1112

- F16C¨C 16-bit floating-point conversion instructions.
- FMA¨C FMA extensions using YMM state.
- FMA4¨C FMA4 instruction extensions.
- FPU¨C X87 Floating Point Unit On-Chip.
- FSGSBASE¨C RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE instructions.
- FSRCS¨C Fast Short REP CMP and SCA.
- FSRM¨C Fast Short REP MOV.
- FSRS¨C Fast Short REP STO.
- FXSR¨C FXSAVE and FXRSTOR instructions.
- FZLRM¨C Fast Zero-Length REP MOV.
- GFNI¨C GFNI instruction extensions.
- HLE¨C HLE instruction extensions.
- HTT¨C Max APIC IDs reserved field is Valid.
- HRESET¨C History reset.
- HYBRID¨C Hybrid processor.
- IBRS_IBPB¨C Indirect branch restricted speculation (IBRS) and the indirect branch
    predictor barrier (IBPB).
- IBT¨C Intel Indirect Branch Tracking instruction extensions.
- INVARIANT_TSC¨C Invariant TSC.
- INVPCID¨C INVPCID instruction.
- KL¨C AES Key Locker instructions.
- LAM¨C Linear Address Masking.
- L1D_FLUSH¨C IA32FLUSHCMD MSR.
- LAHF64_SAHF64¨C LAHF/SAHF available in 64-bit mode.
- LM¨C Long mode.
- LWP¨C Lightweight profiling.
- LZCNT¨C LZCNT instruction.
- MCA¨C Machine Check Architecture.
- MCE¨C Machine Check Exception.
- MD_CLEAR¨C MDCLEAR.
- MMX¨C Intel MMX Technology.
- MONITOR¨C MONITOR/MWAIT instructions.
- MOVBE¨C MOVBE instruction.
- MOVDIRI¨C MOVDIRI instruction.
- MOVDIR64B¨C MOVDIR64B instruction.
- MPX¨C Intel Memory Protection Extensions.
- MSR¨C Model Specific Registers RDMSR and WRMSR instructions.
- MTRR¨C Memory Type Range Registers.
- NX¨C No-execute page protection.


Appendix E: Platform-specific facilities 1113

- OSPKE¨C OS has set CR4.PKE to enable protection keys.
- OSXSAVE¨C The OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV in-
    structions to access XCR0 and to support processor extended state management using
    XSAVE/XRSTOR.
- PAE¨C Physical Address Extension.
- PAGE1GB¨C 1-GByte page.
- PAT¨C Page Attribute Table.
- PBE¨C Pending Break Enable.
- PCID¨C Process-context identifiers.
- PCLMULQDQ¨C PCLMULQDQ instruction.
- PCONFIG¨C PCONFIG instruction.
- PDCM¨C Perfmon and Debug Capability.
- PGE¨C Page Global Bit.
- PKS¨C Protection keys for supervisor-mode pages.
- PKU¨C Protection keys for user-mode pages.
- POPCNT¨C POPCNT instruction.
- PREFETCHW¨C PREFETCHW instruction.
- PREFETCHWT1¨C PREFETCHWT1 instruction.
- PSE¨C Page Size Extension.
- PSE_36¨C 36-Bit Page Size Extension.
- PSN¨C Processor Serial Number.
- RDPID¨C RDPID instruction.
- RDRAND¨C RDRAND instruction.
- RDSEED¨C RDSEED instruction.
- RDT_A¨C Intel Resource Director Technology (Intel RDT) Allocation capability.
- RDT_M¨C Intel Resource Director Technology (Intel RDT) Monitoring capability.
- RDTSCP¨C RDTSCP instruction.
- RTM¨C RTM instruction extensions.
- SDBG¨C IA32DEBUGINTERFACE MSR for silicon debug.
- SEP¨C SYSENTER and SYSEXIT instructions.
- SERIALIZE¨C SERIALIZE instruction.
- SGX¨C Intel Software Guard Extensions.
- SGX_LC¨C SGX Launch Configuration.
- SHA¨C SHA instruction extensions.
- SHSTK¨C Intel Shadow Stack instruction extensions.
- SMAP¨C Supervisor-Mode Access Prevention.
- SMEP¨C Supervisor-Mode Execution Prevention.
- SMX¨C Safer Mode Extensions.
- SS¨C Self Snoop.


Appendix E: Platform-specific facilities 1114

- SSBD¨C Speculative Store Bypass Disable (SSBD).
- SSE¨C Streaming SIMD Extensions.
- SSE2¨C Streaming SIMD Extensions 2.
- SSE3¨C Streaming SIMD Extensions 3.
- SSE4_1¨C Streaming SIMD Extensions 4.1.
- SSE4_2¨C Streaming SIMD Extensions 4.2.
- SSE4A¨C SSE4A instruction extensions.
- SSSE3¨C Supplemental Streaming SIMD Extensions 3.
- STIBP¨C Single thread indirect branch predictors (STIBP).
- SVM¨C Secure Virtual Machine.
- SYSCALL_SYSRET¨C SYSCALL/SYSRET instructions.
- TBM¨C Trailing bit manipulation instructions.
- TM¨C Thermal Monitor.
- TM2¨C Thermal Monitor 2.
- TRACE¨C Intel Processor Trace.
- TSC¨C Time Stamp Counter. RDTSC instruction.
- TSC_ADJUST¨C IA32TSCADJUST MSR.
- TSC_DEADLINE¨C Local APIC timer supports one-shot operation using a TSC deadline
    value.
- TSXLDTRK¨C TSXLDTRK instructions.
- UINTR¨C User interrupts.
- UMIP¨C User-mode instruction prevention.
- VAES¨C VAES instruction extensions.
- VME¨C Virtual 8086 Mode Enhancements.
- VMX¨C Virtual Machine Extensions.
- VPCLMULQDQ¨C VPCLMULQDQ instruction.
- WAITPKG¨C WAITPKG instruction extensions.
- WBNOINVD¨C WBINVD/WBNOINVD instructions.
- WIDE_KL¨C AES wide Key Locker instructions.
- X2APIC¨C x2APIC.
- XFD¨C Extended Feature Disable (XFD).
- XGETBV_ECX_1¨C XGETBV with ECX = 1.
- XOP¨C XOP instruction extensions.
- XSAVE ¨C The XSAVE/XRSTOR processor extended states feature, the
    XSETBV/XGETBV instructions, and XCR0.
- XSAVEC¨C XSAVEC instruction.
- XSAVEOPT¨C XSAVEOPT instruction.
- XSAVES¨C XSAVES/XRSTORS instructions.
- XTPRUPDCTRL¨C xTPR Update Control.


Appendix E: Platform-specific facilities 1115

```
You could query if a processor supportsAVXwith:
#include <sys/platform/x86.h>
```
```
int
support_avx (void)
{
return HAS_CPU_FEATURE (AVX);
}
and ifAVXis usable with:
#include <sys/platform/x86.h>
```
```
int
usable_avx (void)
{
return CPU_FEATURE_USABLE (AVX);
}
```

### 1116

## F Contributors to the GNU C Library....................

The GNU C Library project would like to thank its many contributors. Without them the
project would not have been nearly as successful as it has been. Any omissions in this list
are accidental. Feel free to file a bug in bugzilla if you have been left out or some of your
contributions are not listed. Please keep this list in alphabetical order.

- Nick Alcock for contributing fixes to allow the GNU C Library to be built with the
    stack smashing protector enabled.
- John David Anglin for various fixes to the hppa port.
- Albert ARIBAUD for Y2038 related fixes.
- Ryan S. Arnold for his improvements for Linux on PowerPC and his direction as FSF
    Project Steward for the GNU C Library.
- Miles Bader for writing theargpargument-parsing package, and theargz/envzinter-
    faces.
- Ralf B ?achle for contributingfpu_control.h,regdef.h,sgidefs.h,sys/asm.h, and
    sys/regdef.hunder thesysdeps/mipsdirectory.
- Jeff Bailey for his maintainership of the HPPA architecture.
- Petr Baudis for bug fixes and testing.
- Anton Blanchard for various fixes.
- Stephen R. van den Berg for contributing a highly-optimizedstrstrfunction.
- Ond¡¦rej B ?ilka for contributing optimized string routines for x64 and various fixes.
- Eric Blake for adding O(n) implementations ofmemmem,strstrandstrcasestr.
- Philip Blundell for the ports to Linux/ARM (arm-ANYTHING-linuxaout) and ARM
    standalone (arm-ANYTHING-none), as well as for parts of the IPv6 support code.
- Per Bothner for the implementation of thelibiolibrary which is used to implement
    stdiofunctions.
- Mark Brown for his direction as part of the GNU C Library steering committee.
- Thomas Bushnell for his contributions to Hurd.
- Rogerio Alves Cardoso for various fixes to PowerPC.
- Paul Clarke for optimized functions on PowerPC.
- Mike Crowe for various fixes.
- Palmer Dabbelt for contributing the port to Linux/RISC-V.
- DJ Delorie for maintenance of Linux/RISC-V, and various fixes.
- Wilco Dijkstra for various fixes.
- Liubov Dmitrieva for optimized string and math functions on x86-64 and x86.
- Ulrich Drepper for his many contributions in almost all parts of the GNU C Library,
    including:
       - writing most of the POSIX Threads Library originally.
       - internationalization support, including thelocaleandlocaledefutilities.
       - Linux i386/ELF support


Appendix F: Contributors to the GNU C Library 1117

- thehsearchanddrand48families of functions, reentrant ¡®..._r¡¯ versions of the
    randomfamily; System V shared memory and IPC support code
- several highly-optimized string functions for ix86 processors
- many math functions
- the character conversion functions (iconv)
- theftwandnftwfunctions
- the floating-point printing function used byprintfand friends and the floating-
    point reading function used byscanf,strtodand friends
- thecatgetssupport and the entire suite of multi-byte and wide-character support
    functions (wctype.h,wchar.h, etc.).
- versioning of objects on the symbol level
- Richard Earnshaw for continued support and fixes to the various ARM machine files.
- Paul Eggert for themktimefunction and for his direction as part of the GNU C Library
steering committee.
- Steve Ellcey for various fixes.
- Mike FABIAN for automating Unicode updates, for updating the locale data for ISO
14651, for updating the library Unicode support, and for various locale updates and
fixes.
- Tulio Magno Quites Machado Filho for adding a new class of installed headers for
low-level platform-specific functionality and one such for PowerPC and various fixes.
- Olaf Flebbe and Ralf B ?achle for contributingsysdeps/mips/fpu_control.h.
- Alistair Francis for Y2038 related fixes.
- Mike Frysinger for his maintaining of the IA64 architecture and for testing and bug
fixing.
- Martin Galvan for contributing gdb pretty printer support to glibc and adding an initial
set of pretty printers for structures in the POSIX Threads library.
- Michael Glad for the passphrase-hashing functioncryptand related functions.
- Wolfram Gloger for contributing the memory allocation functions functionsmalloc,
reallocandfreeand related code.
- Gabriel F. T. Gomes for his improvements for Linux on PowerPC and for implementing
the IEEE 128-bit floating point type for PowerPC.
- Torbj ?orn Granlund for fast implementations of many of the string functions (memcpy,
strlen, etc.).
- Michael J. Haertel for writing the merge sort functionqsortand malloc checking
functions likemcheck.
- Bruno Haible for his improvements to theiconvand locale implementations.
- Mao Han for the C-SKY port.
- Richard Henderson for the port to Linux on Alpha (alpha-anything-linux) and soft-
ware floating-point support.
- David Holsgrove for the port to Linux on MicroBlaze.
- Leonhard Holz for various fixes.


Appendix F: Contributors to the GNU C Library 1118

- Daniel Jacobowitz for various fixes and enhancements.
- Andreas Jaeger for the port to Linux on x86-64 (x86_64-anything-linuxand his work
    on Linux for MIPS (mips-anything-linux), implementing theldconfigprogram,
    providing a test suite for the math library and for his direction as part of the GNU C
    Library steering committee.
- Aurelien Jarno for various fixes.
- Rical Jasan for contributing various fixes in the GNU C Library manual.
- Jakub Jelinek for implementing a number of checking functions, software floating-point
    support and for his direction as part of the GNU C Library steering committee.
- Simon Josefsson for thelibidnadd-on.
- Geoffrey Keating for the port to Linux on PowerPC (powerpc-anything-linux).
- Brendan Kehoe for contributing the port to the MIPS DECStation running Ultrix 4
    (mips-dec-ultrix4) and the port to the DEC Alpha running OSF/1 (alpha-dec-
    osf1).
- Mark Kettenis for implementing theutmpxinterface and a utmp daemon, and for a
    Hesiod NSS module.
- Andi Kleen for implementing pthreads lock elision with TSX.
- Kazumoto Kojima for the port of the Mach and Hurd code to the MIPS architecture
    (mips-anything-gnu) and for his work on the SH architecture.
- Maxim Kuvyrkov for various fixes.
- Andreas Krebbel for his work on Linux for s390 and s390x.
- Thorsten Kukuk for providing an implementation for NIS (YP) and NIS+, securelevel
    0, 1 and 2 and for the implementation for a caching daemon for NSS (nscd).
- Akhilesh Kumar for various fixes to locales.
- Jeff Law for various fixes.
- Doug Lea for contributing the memory allocation functionsmalloc,reallocandfree
    and related code.
- Chris Leonard for various fixes and enhancements to localedata.
- Ilya Leoshkevich for various fixes.
- Dmitry V. Levin for various fixes.
- Stefan Liebler for various fixes.
- Hongjiu Lu for providing the support for a Linux 32-bit runtime environment under
    x86-64 (x32), for porting to Linux on IA64, for improved string functions, a framework
    for testing IFUNC implementations, for implementing Intel Control-Flow Enforcement
    Technology, and many bug fixes.
- Rafa l Lu ?zy ?nski for contributing support for two grammatical forms of month names,
    and for various fixes to locales.
- Luis Machado for optimized functions on PowerPC.
- David J. MacKenzie for his contribution to thegetoptfunction and writing thetar.h
    header.
- Lukasz Majewski for Y2038 related fixes.


Appendix F: Contributors to the GNU C Library 1119

- Greg McGary for adding runtime support for bounds checking.
- Roland McGrath for writing most of the GNU C Library originally, for his work on
    the Hurd port, his direction as part of the GNU C Library steering committee and as
    FSF Project Steward for the GNU C Library, and for many bug fixes and reviewing of
    contributions.
- Allan McRae for various fixes.
- Jason Merrill for the port to the Sequent Symmetry running Dynix version 3
    (i386-sequent-bsd).
- Chris Metcalf for the port to Linux/Tile (tilegx-anything-linux and
    tilepro-anything-linux) and support for the generic Linux kernel syscall interface
    used by several newer ports.
- Jim Meyering for various fixes.
- David Miller for contributing the port to Linux/Sparc (sparc*-anything-linux).
- Alan Modra for his improvements for Linux on PowerPC.
- David Mosberger-Tang for contributing the port to Linux/Alpha (alpha-anything-
    linux).
- Wainer dos Santos Moschetta for various fixes to powerpc.
- Stephen Moshier for implementing some 128-bit long double format math functions.
- Stephen Munroe for his port to Linux on PowerPC64 (powerpc64-anything-linux)
    and for adding optimized implementations for PowerPC.
- Paul E. Murphy for various fixes on PowerPC and for implementing the IEEE 128-bit
    floating point type for PowerPC.
- Joseph S. Myers for numerous bug fixes for the libm functions, for his maintainer-
    ship of the ARM and MIPS architectures and the math component, improving cross-
    compilation and cross-testing of the GNU C Library, expanded coverage of conformtest,
    merging the ports/ subdirectory into the GNU C Library main repository and his di-
    rection as FSF Project Steward for the GNU C Library.
- Marko Myllynen for various fixes.
- Szabolcs Nagy for various fixes.
- Will Newton for contributing some optimized string functions and pointer encryption
    support for ARM and various fixes.
- Carlos O¡¯Donell for his maintainership of the HPPA architecture, for maintaining the
    GNU C Library web pages and wiki, for his direction as FSF Project Steward for the
    GNU C Library and various bug fixes.
- Alexandre Oliva for adding TLS descriptors for LD and GD on x86 and x86-64, for
    the am33 port, for completing the MIPS n64/n32/o32 multilib port, for thread-safety,
    async-signal safety and async-cancellation safety documentation in the manual, for his
    direction as FSF Project Maintainer and for various fixes.
- Paul Pluzhnikov for various fixes.
- Marek Polacek for various fixes.
- Siddhesh Poyarekar for various fixes, an implementation of a framework for performance
    benchmarking of functions and implementing the tunables infrastructure.


Appendix F: Contributors to the GNU C Library 1120

- Tom Quinn for contributing the startup code to support SunOS shared libraries and
    the port to SGI machines running Irix 4 (mips-sgi-irix4).
- Torvald Riegel for the implementation of new algorithms for semaphores,
    pthreadrwlock and condition variables.
- Maciej W. Rozycki for MIPS fixes, support for ABSOLUTE symbols, and various fixes.
- Leonardo Sandoval for various fixes.
- Pravin Satpute for writing sorting rules for some Indian languages.
- Douglas C. Schmidt for writing the quick sort function used as a fallback byqsort.
- Will Schmidt for optimized string functions on PowerPC.
- Andreas Schwab for the port to Linux/m68k (m68k-anything-linux), for his direction
    as part of the GNU C Library steering committee, and for various bug fixes.
- Martin Schwidefsky for porting to Linux on s390 (s390-anything-linux) and s390x
    (s390x-anything-linux).
- Thomas Schwinge for his contribution to Hurd and the SH architecture.
- Martin Sebor for various fixes.
- Andrew Senkevich for contributing vector math function implementations for x86.
- Carlos Eduardo Seo for optimized functions on PowerPC.
- Arjun Shankar for testing and bug fixing.
- Marcus Shawcroft for contributing the AArch64 port.
- TAMUKI Shoichi for various fixes.
- Franz Sirl for various fixes.
- Jes Sorensen for porting to Linux on IA64 (ia64-anything-linux).
- Rajalakshmi Srinivasaraghavan for various fixes and optimizations on PowerPC and
    for implementing the IEEE 128-bit floating point type for PowerPC.
- Richard Stallman for his contribution to thegetoptfunction.
- Alfred M. Szmidt for various fixes.
- Chung-Lin Tang for contributing the Nios II port.
- Ian Lance Taylor for contributing the port to the MIPS DECStation running Ultrix 4
    (mips-dec-ultrix4).
- Samuel Thibault for improving the Hurd port.
- Pino Toscano for various fixes.
- Matt Turner for various fixes to the Alpha port.
- Tim Waugh for the implementation of the POSIX.2wordexpfunction family.
- Ulrich Weigand for various fixes to the PowerPC64 and Arm ports.
- Florian Weimer for his maintainership of the network component, for handling of se-
    curity issues, and for various fixes.
- Zack Weinberg for theexplicit_bzeroimplementation and for various fixes.
- Mark Wielaard for various fixes.
- Eric Youngdale for implementing versioning of objects on the symbol level.


Appendix F: Contributors to the GNU C Library 1121

- Adhemerval Zanella for optimized functions on PowerPC, ISO C threads support and
    various fixes.
- Xuelei Zhang for optimized functions on AArch64.
    Some code in the GNU C Library comes from other projects and might be under a
different license:
- The timezone support code is derived from the public-domain timezone package by
Arthur David Olson and his many contributors.
- Some of the support code for Mach is taken from Mach 3.0 by CMU; the fileif_ppp.h
is also copyright by CMU, but under a different license; see the fileLICENSESfor the
text of the licenses.
- The random number generation functionsrandom,srandom,setstateandinitstate,
which are also the basis for therandandsrandfunctions, were written by Earl T.
Cohen for the University of California at Berkeley and are copyrighted by the Regents
of the University of California. They have undergone minor changes to fit into the
GNU C Library and to fit the ISO C standard, but the functional code is Berkeley¡¯s.
- The Internet-related code (most of theinetsubdirectory) and several other miscel-
laneous functions and header files have been included from 4.4 BSD with little or no
modification. The copying permission notice for this code can be found in the file
LICENSESin the source distribution.
- Thegetaddrinfoandgetnameinfofunctions and supporting code were written by
Craig Metz; see the fileLICENSESfor details on their licensing.
- The DNS resolver code is taken directly from BIND 8.2.3-T5B, which includes copy-
righted code from UC Berkeley and from Digital Equipment Corporation. See the file
LICENSESfor the text of the DEC license.
- The code to support Sun RPC is taken verbatim from Sun¡¯srpcsrc-4.0distribution;
see the fileLICENSESfor the text of the license.
- The math functions are taken fromfdlibm-5.1 by Sun Microsystems, as modified
by J.T. Conklin, Ian Lance Taylor, Ulrich Drepper, Andreas Schwab, and Roland
McGrath.
- Many of the IEEE 64-bit double precision math functions (in the
sysdeps/ieee754/dbl-64 subdirectory) come from the IBM Accurate Math-
ematical Library, contributed by IBM.
- Many of the IA64 math functions are taken from a collection of ¡°Highly Optimized
Mathematical Functions for Itanium¡± that Intel makes available under a free license;
see the fileLICENSESfor details.


### 1122

## Appendix G Free Software Needs Free

## Documentation

The biggest deficiency in the free software community today is not in the software¡ªit is the
lack of good free documentation that we can include with the free software. Many of our
most important programs do not come with free reference manuals and free introductory
texts. Documentation is an essential part of any software package; when an important free
software package does not come with a free manual and a free tutorial, that is a major gap.
We have many such gaps today.

Consider Perl, for instance. The tutorial manuals that people normally use are non-free.
How did this come about? Because the authors of those manuals published them with
restrictive terms¡ªno copying, no modification, source files not available¡ªwhich exclude
them from the free software world.

That wasn¡¯t the first time this sort of thing happened, and it was far from the last.
Many times we have heard a GNU user eagerly describe a manual that he is writing, his
intended contribution to the community, only to learn that he had ruined everything by
signing a publication contract to make it non-free.

Free documentation, like free software, is a matter of freedom, not price. The problem
with the non-free manual is not that publishers charge a price for printed copies¡ªthat in
itself is fine. (The Free Software Foundation sells printed copies of manuals, too.) The
problem is the restrictions on the use of the manual. Free manuals are available in source
code form, and give you permission to copy and modify. Non-free manuals do not allow
this.

The criteria of freedom for a free manual are roughly the same as for free software.
Redistribution (including the normal kinds of commercial redistribution) must be permitted,
so that the manual can accompany every copy of the program, both on-line and on paper.

Permission for modification of the technical content is crucial too. When people mod-
ify the software, adding or changing features, if they are conscientious they will change
the manual too¡ªso they can provide accurate and clear documentation for the modified
program. A manual that leaves you no choice but to write a new manual to document a
changed version of the program is not really available to our community.

Some kinds of limits on the way modification is handled are acceptable. For example,
requirements to preserve the original author¡¯s copyright notice, the distribution terms, or
the list of authors, are ok. It is also no problem to require modified versions to include
notice that they were modified. Even entire sections that may not be deleted or changed
are acceptable, as long as they deal with nontechnical topics (like this one). These kinds of
restrictions are acceptable because they don¡¯t obstruct the community¡¯s normal use of the
manual.

However, it must be possible to modify all thetechnicalcontent of the manual, and then
distribute the result in all the usual media, through all the usual channels. Otherwise, the
restrictions obstruct the use of the manual, it is not free, and we need another manual to
replace it.

Please spread the word about this issue. Our community continues to lose manuals
to proprietary publishing. If we spread the word that free software needs free reference
manuals and free tutorials, perhaps the next person who wants to contribute by writing


Appendix G: Free Software Needs Free Documentation 1123

documentation will realize, before it is too late, that only free manuals contribute to the
free software community.

If you are writing documentation, please insist on publishing it under the GNU Free
Documentation License or another free documentation license. Remember that this deci-
sion requires your approval¡ªyou don¡¯t have to let the publisher decide. Some commercial
publishers will use a free license if you insist, but they will not propose the option; it is up
to you to raise the issue and say firmly that this is what you want. If the publisher you
are dealing with refuses, please try other publishers. If you¡¯re not sure whether a proposed
license is free, write tolicensing@gnu.org.

You can encourage commercial publishers to sell more free, copylefted manuals and
tutorials by buying them, and particularly by buying copies from the publishers that paid
for their writing or for major improvements. Meanwhile, try to avoid buying non-free
documentation at all. Check the distribution terms of a manual before you buy it, and
insist that whoever seeks your business must respect your freedom. Check the history of
the book, and try reward the publishers that have paid or pay the authors to work on it.

The Free Software Foundation maintains a list of free documentation published by other
publishers, athttps://www.fsf.org/doc/other-free-books.html.


### 1124

## Appendix H GNU Lesser General Public License

```
Version 2.1, February 1999
Copyright?c 1991, 1999 Free Software Foundation, Inc.
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
```
```
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
```
```
[This is the first released version of the Lesser GPL. It also counts
as the successor of the GNU Library Public License, version 2, hence the
version number 2.1.]
```
Preamble

The licenses for most software are designed to take away your freedom to share and change
it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom
to share and change free software¡ªto make sure the software is free for all its users.

This license, the Lesser General Public License, applies to some specially designated
software¡ªtypically libraries¡ªof the Free Software Foundation and other authors who decide
to use it. You can use it too, but we suggest you first think carefully about whether this
license or the ordinary General Public License is the better strategy to use in any particular
case, based on the explanations below.

When we speak of free software, we are referring to freedom of use, not price. Our
General Public Licenses are designed to make sure that you have the freedom to distribute
copies of free software (and charge for this service if you wish); that you receive source code
or can get it if you want it; that you can change the software and use pieces of it in new
free programs; and that you are informed that you can do these things.

To protect your rights, we need to make restrictions that forbid distributors to deny you
these rights or to ask you to surrender these rights. These restrictions translate to certain
responsibilities for you if you distribute copies of the library or if you modify it.

For example, if you distribute copies of the library, whether gratis or for a fee, you must
give the recipients all the rights that we gave you. You must make sure that they, too,
receive or can get the source code. If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them with the library after
making changes to the library and recompiling it. And you must show them these terms so
they know their rights.

We protect your rights with a two-step method: (1) we copyright the library, and (2) we
offer you this license, which gives you legal permission to copy, distribute and/or modify
the library.

To protect each distributor, we want to make it very clear that there is no warranty for
the free library. Also, if the library is modified by someone else and passed on, the recipients
should know that what they have is not the original version, so that the original author¡¯s
reputation will not be affected by problems that might be introduced by others.

Finally, software patents pose a constant threat to the existence of any free program.
We wish to make sure that a company cannot effectively restrict the users of a free program


Appendix H: GNU Lesser General Public License 1125

by obtaining a restrictive license from a patent holder. Therefore, we insist that any patent
license obtained for a version of the library must be consistent with the full freedom of use
specified in this license.

Most GNU software, including some libraries, is covered by the ordinary GNU General
Public License. This license, the GNU Lesser General Public License, applies to certain
designated libraries, and is quite different from the ordinary General Public License. We
use this license for certain libraries in order to permit linking those libraries into non-free
programs.

When a program is linked with a library, whether statically or using a shared library,
the combination of the two is legally speaking a combined work, a derivative of the original
library. The ordinary General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom. The Lesser General Public License permits
more lax criteria for linking other code with the library.

We call this license theLesserGeneral Public License because it doesLessto protect the
user¡¯s freedom than the ordinary General Public License. It also provides other free software
developers Less of an advantage over competing non-free programs. These disadvantages
are the reason we use the ordinary General Public License for many libraries. However, the
Lesser license provides advantages in certain special circumstances.

For example, on rare occasions, there may be a special need to encourage the widest
possible use of a certain library, so that it becomes a de-facto standard. To achieve this,
non-free programs must be allowed to use the library. A more frequent case is that a free
library does the same job as widely used non-free libraries. In this case, there is little to
gain by limiting the free library to free software only, so we use the Lesser General Public
License.

In other cases, permission to use a particular library in non-free programs enables a
greater number of people to use a large body of free software. For example, permission to
use the GNU C Library in non-free programs enables many more people to use the whole
GNU operating system, as well as its variant, the GNU/Linux operating system.

Although the Lesser General Public License is Less protective of the users¡¯ freedom, it
does ensure that the user of a program that is linked with the Library has the freedom and
the wherewithal to run that program using a modified version of the Library.

The precise terms and conditions for copying, distribution and modification follow. Pay
close attention to the difference between a ¡°work based on the library¡± and a ¡°work that
uses the library¡±. The former contains code derived from the library, whereas the latter
must be combined with the library in order to run.

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION

AND MODIFICATION

0. This License Agreement applies to any software library or other program which contains
    a notice placed by the copyright holder or other authorized party saying it may be
    distributed under the terms of this Lesser General Public License (also called ¡°this
    License¡±). Each licensee is addressed as ¡°you¡±.
    A ¡°library¡± means a collection of software functions and/or data prepared so as to be
    conveniently linked with application programs (which use some of those functions and
    data) to form executables.


Appendix H: GNU Lesser General Public License 1126

```
The ¡°Library¡±, below, refers to any such software library or work which has been
distributed under these terms. A ¡°work based on the Library¡± means either the Library
or any derivative work under copyright law: that is to say, a work containing the
Library or a portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language. (Hereinafter, translation is included without
limitation in the term ¡°modification¡±.)
¡°Source code¡± for a work means the preferred form of the work for making modifications
to it. For a library, complete source code means all the source code for all modules it
contains, plus any associated interface definition files, plus the scripts used to control
compilation and installation of the library.
Activities other than copying, distribution and modification are not covered by this
License; they are outside its scope. The act of running a program using the Library is
not restricted, and output from such a program is covered only if its contents constitute
a work based on the Library (independent of the use of the Library in a tool for writing
it). Whether that is true depends on what the Library does and what the program
that uses the Library does.
```
1. You may copy and distribute verbatim copies of the Library¡¯s complete source code
    as you receive it, in any medium, provided that you conspicuously and appropriately
    publish on each copy an appropriate copyright notice and disclaimer of warranty; keep
    intact all the notices that refer to this License and to the absence of any warranty; and
    distribute a copy of this License along with the Library.
    You may charge a fee for the physical act of transferring a copy, and you may at your
    option offer warranty protection in exchange for a fee.
2. You may modify your copy or copies of the Library or any portion of it, thus forming a
    work based on the Library, and copy and distribute such modifications or work under
    the terms of Section 1 above, provided that you also meet all of these conditions:
       a. The modified work must itself be a software library.
b. You must cause the files modified to carry prominent notices stating that you
changed the files and the date of any change.
       c. You must cause the whole of the work to be licensed at no charge to all third
          parties under the terms of this License.
d. If a facility in the modified Library refers to a function or a table of data to
be supplied by an application program that uses the facility, other than as an
argument passed when the facility is invoked, then you must make a good faith
effort to ensure that, in the event an application does not supply such function or
table, the facility still operates, and performs whatever part of its purpose remains
meaningful.
(For example, a function in a library to compute square roots has a purpose that
is entirely well-defined independent of the application. Therefore, Subsection 2d
requires that any application-supplied function or table used by this function must
be optional: if the application does not supply it, the square root function must
still compute square roots.)
    These requirements apply to the modified work as a whole. If identifiable sections of
    that work are not derived from the Library, and can be reasonably considered indepen-
    dent and separate works in themselves, then this License, and its terms, do not apply


Appendix H: GNU Lesser General Public License 1127

```
to those sections when you distribute them as separate works. But when you distribute
the same sections as part of a whole which is a work based on the Library, the distri-
bution of the whole must be on the terms of this License, whose permissions for other
licensees extend to the entire whole, and thus to each and every part regardless of who
wrote it.
Thus, it is not the intent of this section to claim rights or contest your rights to
work written entirely by you; rather, the intent is to exercise the right to control the
distribution of derivative or collective works based on the Library.
In addition, mere aggregation of another work not based on the Library with the
Library (or with a work based on the Library) on a volume of a storage or distribution
medium does not bring the other work under the scope of this License.
```
3. You may opt to apply the terms of the ordinary GNU General Public License instead
    of this License to a given copy of the Library. To do this, you must alter all the notices
    that refer to this License, so that they refer to the ordinary GNU General Public
    License, version 2, instead of to this License. (If a newer version than version 2 of the
    ordinary GNU General Public License has appeared, then you can specify that version
    instead if you wish.) Do not make any other change in these notices.
    Once this change is made in a given copy, it is irreversible for that copy, so the ordinary
    GNU General Public License applies to all subsequent copies and derivative works made
    from that copy.
    This option is useful when you wish to copy part of the code of the Library into a
    program that is not a library.
4. You may copy and distribute the Library (or a portion or derivative of it, under Section
    2) in object code or executable form under the terms of Sections 1 and 2 above provided
    that you accompany it with the complete corresponding machine-readable source code,
    which must be distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange.
    If distribution of object code is made by offering access to copy from a designated place,
    then offering equivalent access to copy the source code from the same place satisfies the
    requirement to distribute the source code, even though third parties are not compelled
    to copy the source along with the object code.
5. A program that contains no derivative of any portion of the Library, but is designed
    to work with the Library by being compiled or linked with it, is called a ¡°work that
    uses the Library¡±. Such a work, in isolation, is not a derivative work of the Library,
    and therefore falls outside the scope of this License.
    However, linking a ¡°work that uses the Library¡± with the Library creates an executable
    that is a derivative of the Library (because it contains portions of the Library), rather
    than a ¡°work that uses the library¡±. The executable is therefore covered by this License.
    Section 6 states terms for distribution of such executables.
    When a ¡°work that uses the Library¡± uses material from a header file that is part of
    the Library, the object code for the work may be a derivative work of the Library even
    though the source code is not. Whether this is true is especially significant if the work
    can be linked without the Library, or if the work is itself a library. The threshold for
    this to be true is not precisely defined by law.


Appendix H: GNU Lesser General Public License 1128

```
If such an object file uses only numerical parameters, data structure layouts and ac-
cessors, and small macros and small inline functions (ten lines or less in length), then
the use of the object file is unrestricted, regardless of whether it is legally a derivative
work. (Executables containing this object code plus portions of the Library will still
fall under Section 6.)
Otherwise, if the work is a derivative of the Library, you may distribute the object code
for the work under the terms of Section 6. Any executables containing that work also
fall under Section 6, whether or not they are linked directly with the Library itself.
```
6. As an exception to the Sections above, you may also combine or link a ¡°work that
    uses the Library¡± with the Library to produce a work containing portions of the Li-
    brary, and distribute that work under terms of your choice, provided that the terms
    permit modification of the work for the customer¡¯s own use and reverse engineering for
    debugging such modifications.
    You must give prominent notice with each copy of the work that the Library is used
    in it and that the Library and its use are covered by this License. You must supply
    a copy of this License. If the work during execution displays copyright notices, you
    must include the copyright notice for the Library among them, as well as a reference
    directing the user to the copy of this License. Also, you must do one of these things:
       a. Accompany the work with the complete corresponding machine-readable source
          code for the Library including whatever changes were used in the work (which must
          be distributed under Sections 1 and 2 above); and, if the work is an executable
          linked with the Library, with the complete machine-readable ¡°work that uses the
          Library¡±, as object code and/or source code, so that the user can modify the
          Library and then relink to produce a modified executable containing the modified
          Library. (It is understood that the user who changes the contents of definitions
          files in the Library will not necessarily be able to recompile the application to use
          the modified definitions.)
b. Use a suitable shared library mechanism for linking with the Library. A suitable
mechanism is one that (1) uses at run time a copy of the library already present
on the user¡¯s computer system, rather than copying library functions into the
executable, and (2) will operate properly with a modified version of the library, if
the user installs one, as long as the modified version is interface-compatible with
the version that the work was made with.
       c. Accompany the work with a written offer, valid for at least three years, to give the
          same user the materials specified in Subsection 6a, above, for a charge no more
          than the cost of performing this distribution.
d. If distribution of the work is made by offering access to copy from a designated
place, offer equivalent access to copy the above specified materials from the same
place.
       e. Verify that the user has already received a copy of these materials or that you have
          already sent this user a copy.
    For an executable, the required form of the ¡°work that uses the Library¡± must include
    any data and utility programs needed for reproducing the executable from it. However,
    as a special exception, the materials to be distributed need not include anything that
    is normally distributed (in either source or binary form) with the major components


Appendix H: GNU Lesser General Public License 1129

```
(compiler, kernel, and so on) of the operating system on which the executable runs,
unless that component itself accompanies the executable.
It may happen that this requirement contradicts the license restrictions of other pro-
prietary libraries that do not normally accompany the operating system. Such a con-
tradiction means you cannot use both them and the Library together in an executable
that you distribute.
```
7. You may place library facilities that are a work based on the Library side-by-side in
    a single library together with other library facilities not covered by this License, and
    distribute such a combined library, provided that the separate distribution of the work
    based on the Library and of the other library facilities is otherwise permitted, and
    provided that you do these two things:
       a. Accompany the combined library with a copy of the same work based on the
          Library, uncombined with any other library facilities. This must be distributed
          under the terms of the Sections above.
b. Give prominent notice with the combined library of the fact that part of it is a work
based on the Library, and explaining where to find the accompanying uncombined
form of the same work.
8. You may not copy, modify, sublicense, link with, or distribute the Library except
    as expressly provided under this License. Any attempt otherwise to copy, modify,
    sublicense, link with, or distribute the Library is void, and will automatically terminate
    your rights under this License. However, parties who have received copies, or rights,
    from you under this License will not have their licenses terminated so long as such
    parties remain in full compliance.
9. You are not required to accept this License, since you have not signed it. However,
    nothing else grants you permission to modify or distribute the Library or its derivative
    works. These actions are prohibited by law if you do not accept this License. Therefore,
    by modifying or distributing the Library (or any work based on the Library), you
    indicate your acceptance of this License to do so, and all its terms and conditions for
    copying, distributing or modifying the Library or works based on it.
10. Each time you redistribute the Library (or any work based on the Library), the recipient
automatically receives a license from the original licensor to copy, distribute, link with
or modify the Library subject to these terms and conditions. You may not impose any
further restrictions on the recipients¡¯ exercise of the rights granted herein. You are not
responsible for enforcing compliance by third parties with this License.
11. If, as a consequence of a court judgment or allegation of patent infringement or for any
other reason (not limited to patent issues), conditions are imposed on you (whether by
court order, agreement or otherwise) that contradict the conditions of this License, they
do not excuse you from the conditions of this License. If you cannot distribute so as
to satisfy simultaneously your obligations under this License and any other pertinent
obligations, then as a consequence you may not distribute the Library at all. For
example, if a patent license would not permit royalty-free redistribution of the Library
by all those who receive copies directly or indirectly through you, then the only way
you could satisfy both it and this License would be to refrain entirely from distribution
of the Library.


Appendix H: GNU Lesser General Public License 1130

```
If any portion of this section is held invalid or unenforceable under any particular
circumstance, the balance of the section is intended to apply, and the section as a
whole is intended to apply in other circumstances.
It is not the purpose of this section to induce you to infringe any patents or other
property right claims or to contest validity of any such claims; this section has the
sole purpose of protecting the integrity of the free software distribution system which
is implemented by public license practices. Many people have made generous contri-
butions to the wide range of software distributed through that system in reliance on
consistent application of that system; it is up to the author/donor to decide if he or
she is willing to distribute software through any other system and a licensee cannot
impose that choice.
This section is intended to make thoroughly clear what is believed to be a consequence
of the rest of this License.
```
12. If the distribution and/or use of the Library is restricted in certain countries either
    by patents or by copyrighted interfaces, the original copyright holder who places the
    Library under this License may add an explicit geographical distribution limitation
    excluding those countries, so that distribution is permitted only in or among countries
    not thus excluded. In such case, this License incorporates the limitation as if written
    in the body of this License.
13. The Free Software Foundation may publish revised and/or new versions of the Lesser
    General Public License from time to time. Such new versions will be similar in spirit
    to the present version, but may differ in detail to address new problems or concerns.
    Each version is given a distinguishing version number. If the Library specifies a version
    number of this License which applies to it and ¡°any later version¡±, you have the option of
    following the terms and conditions either of that version or of any later version published
    by the Free Software Foundation. If the Library does not specify a license version
    number, you may choose any version ever published by the Free Software Foundation.
14. If you wish to incorporate parts of the Library into other free programs whose distribu-
    tion conditions are incompatible with these, write to the author to ask for permission.
    For software which is copyrighted by the Free Software Foundation, write to the Free
    Software Foundation; we sometimes make exceptions for this. Our decision will be
    guided by the two goals of preserving the free status of all derivatives of our free soft-
    ware and of promoting the sharing and reuse of software generally.
       NO WARRANTY
15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
    WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLI-
    CABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPY-
    RIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY ¡°AS IS¡±
    WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
    CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
    RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH
    YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST
    OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN


Appendix H: GNU Lesser General Public License 1131

### WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO

### MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED

### ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,

### SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF

### THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT

### LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR

### LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE

### LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH

### HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF

### SUCH DAMAGES.

END OF TERMS AND CONDITIONS


Appendix H: GNU Lesser General Public License 1132

How to Apply These Terms to Your New Libraries

If you develop a new library, and you want it to be of the greatest possible use to the public,
we recommend making it free software that everyone can redistribute and change. You can
do so by permitting redistribution under these terms (or, alternatively, under the terms of
the ordinary General Public License).

To apply these terms, attach the following notices to the library. It is safest to attach
them to the start of each source file to most effectively convey the exclusion of warranty;
and each file should have at least the ¡°copyright¡± line and a pointer to where the full notice
is found.
one line to give the library's name and an idea of what it does.
Copyright (C)year name of author

```
This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at
your option) any later version.
```
```
This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
```
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
USA.
Also add information on how to contact you by electronic and paper mail.
You should also get your employer (if you work as a programmer) or your school, if any,
to sign a ¡°copyright disclaimer¡± for the library, if necessary. Here is a sample; alter the
names:
Yoyodyne, Inc., hereby disclaims all copyright interest in the library
`Frob' (a library for tweaking knobs) written by James Random Hacker.

```
signature of Ty Coon, 1 April 1990
Ty Coon, President of Vice
That¡¯s all there is to it!
```

### 1133

## Appendix I GNU Free Documentation License

```
Version 1.3, 3 November 2008
Copyright?c 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
https://fsf.org/
```
```
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
```
0. PREAMBLE
    The purpose of this License is to make a manual, textbook, or other functional and
    useful documentfreein the sense of freedom: to assure everyone the effective freedom
    to copy and redistribute it, with or without modifying it, either commercially or non-
    commercially. Secondarily, this License preserves for the author and publisher a way
    to get credit for their work, while not being considered responsible for modifications
    made by others.
    This License is a kind of ¡°copyleft¡±, which means that derivative works of the document
    must themselves be free in the same sense. It complements the GNU General Public
    License, which is a copyleft license designed for free software.
    We have designed this License in order to use it for manuals for free software, because
    free software needs free documentation: a free program should come with manuals
    providing the same freedoms that the software does. But this License is not limited to
    software manuals; it can be used for any textual work, regardless of subject matter or
    whether it is published as a printed book. We recommend this License principally for
    works whose purpose is instruction or reference.
1. APPLICABILITY AND DEFINITIONS
    This License applies to any manual or other work, in any medium, that contains a
    notice placed by the copyright holder saying it can be distributed under the terms
    of this License. Such a notice grants a world-wide, royalty-free license, unlimited in
    duration, to use that work under the conditions stated herein. The ¡°Document¡±,
    below, refers to any such manual or work. Any member of the public is a licensee, and
    is addressed as ¡°you¡±. You accept the license if you copy, modify or distribute the work
    in a way requiring permission under copyright law.
    A ¡°Modified Version¡± of the Document means any work containing the Document or
    a portion of it, either copied verbatim, or with modifications and/or translated into
    another language.
    A ¡°Secondary Section¡± is a named appendix or a front-matter section of the Document
    that deals exclusively with the relationship of the publishers or authors of the Document
    to the Document¡¯s overall subject (or to related matters) and contains nothing that
    could fall directly within that overall subject. (Thus, if the Document is in part a
    textbook of mathematics, a Secondary Section may not explain any mathematics.) The
    relationship could be a matter of historical connection with the subject or with related
    matters, or of legal, commercial, philosophical, ethical or political position regarding
    them.
    The ¡°Invariant Sections¡± are certain Secondary Sections whose titles are designated, as
    being those of Invariant Sections, in the notice that says that the Document is released


Appendix I: GNU Free Documentation License 1134

```
under this License. If a section does not fit the above definition of Secondary then it is
not allowed to be designated as Invariant. The Document may contain zero Invariant
Sections. If the Document does not identify any Invariant Sections then there are none.
The ¡°Cover Texts¡± are certain short passages of text that are listed, as Front-Cover
Texts or Back-Cover Texts, in the notice that says that the Document is released under
this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may
be at most 25 words.
A ¡°Transparent¡± copy of the Document means a machine-readable copy, represented
in a format whose specification is available to the general public, that is suitable for
revising the document straightforwardly with generic text editors or (for images com-
posed of pixels) generic paint programs or (for drawings) some widely available drawing
editor, and that is suitable for input to text formatters or for automatic translation to
a variety of formats suitable for input to text formatters. A copy made in an otherwise
Transparent file format whose markup, or absence of markup, has been arranged to
thwart or discourage subsequent modification by readers is not Transparent. An image
format is not Transparent if used for any substantial amount of text. A copy that is
not ¡°Transparent¡± is called ¡°Opaque¡±.
Examples of suitable formats for Transparent copies include plain ASCII without
markup, Texinfo input format, LaTEX input format, SGML or XML using a publicly
available DTD, and standard-conforming simple HTML, PostScript or PDF designed
for human modification. Examples of transparent image formats include PNG, XCF
and JPG. Opaque formats include proprietary formats that can be read and edited
only by proprietary word processors, SGML or XML for which the DTD and/or pro-
cessing tools are not generally available, and the machine-generated HTML, PostScript
or PDF produced by some word processors for output purposes only.
The ¡°Title Page¡± means, for a printed book, the title page itself, plus such following
pages as are needed to hold, legibly, the material this License requires to appear in the
title page. For works in formats which do not have any title page as such, ¡°Title Page¡±
means the text near the most prominent appearance of the work¡¯s title, preceding the
beginning of the body of the text.
The ¡°publisher¡± means any person or entity that distributes copies of the Document
to the public.
A section ¡°Entitled XYZ¡± means a named subunit of the Document whose title either
is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in
another language. (Here XYZ stands for a specific section name mentioned below, such
as ¡°Acknowledgements¡±, ¡°Dedications¡±, ¡°Endorsements¡±, or ¡°History¡±.) To ¡°Preserve
the Title¡± of such a section when you modify the Document means that it remains a
section ¡°Entitled XYZ¡± according to this definition.
The Document may include Warranty Disclaimers next to the notice which states that
this License applies to the Document. These Warranty Disclaimers are considered to
be included by reference in this License, but only as regards disclaiming warranties:
any other implication that these Warranty Disclaimers may have is void and has no
effect on the meaning of this License.
```
2. VERBATIM COPYING


Appendix I: GNU Free Documentation License 1135

```
You may copy and distribute the Document in any medium, either commercially or
noncommercially, provided that this License, the copyright notices, and the license
notice saying this License applies to the Document are reproduced in all copies, and
that you add no other conditions whatsoever to those of this License. You may not use
technical measures to obstruct or control the reading or further copying of the copies
you make or distribute. However, you may accept compensation in exchange for copies.
If you distribute a large enough number of copies you must also follow the conditions
in section 3.
You may also lend copies, under the same conditions stated above, and you may publicly
display copies.
```
3. COPYING IN QUANTITY
    If you publish printed copies (or copies in media that commonly have printed covers) of
    the Document, numbering more than 100, and the Document¡¯s license notice requires
    Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all
    these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
    the back cover. Both covers must also clearly and legibly identify you as the publisher
    of these copies. The front cover must present the full title with all words of the title
    equally prominent and visible. You may add other material on the covers in addition.
    Copying with changes limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim copying in other
    respects.
    If the required texts for either cover are too voluminous to fit legibly, you should put
    the first ones listed (as many as fit reasonably) on the actual cover, and continue the
    rest onto adjacent pages.
    If you publish or distribute Opaque copies of the Document numbering more than 100,
    you must either include a machine-readable Transparent copy along with each Opaque
    copy, or state in or with each Opaque copy a computer-network location from which
    the general network-using public has access to download using public-standard network
    protocols a complete Transparent copy of the Document, free of added material. If
    you use the latter option, you must take reasonably prudent steps, when you begin
    distribution of Opaque copies in quantity, to ensure that this Transparent copy will
    remain thus accessible at the stated location until at least one year after the last time
    you distribute an Opaque copy (directly or through your agents or retailers) of that
    edition to the public.
    It is requested, but not required, that you contact the authors of the Document well
    before redistributing any large number of copies, to give them a chance to provide you
    with an updated version of the Document.
4. MODIFICATIONS
    You may copy and distribute a Modified Version of the Document under the conditions
    of sections 2 and 3 above, provided that you release the Modified Version under precisely
    this License, with the Modified Version filling the role of the Document, thus licensing
    distribution and modification of the Modified Version to whoever possesses a copy of
    it. In addition, you must do these things in the Modified Version:
       A. Use in the Title Page (and on the covers, if any) a title distinct from that of the
          Document, and from those of previous versions (which should, if there were any,


Appendix I: GNU Free Documentation License 1136

```
be listed in the History section of the Document). You may use the same title as
a previous version if the original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities responsible for
authorship of the modifications in the Modified Version, together with at least five
of the principal authors of the Document (all of its principal authors, if it has fewer
than five), unless they release you from this requirement.
C. State on the Title page the name of the publisher of the Modified Version, as the
publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modifications adjacent to the other
copyright notices.
F. Include, immediately after the copyright notices, a license notice giving the public
permission to use the Modified Version under the terms of this License, in the form
shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections and required Cover
Texts given in the Document¡¯s license notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled ¡°History¡±, Preserve its Title, and add to it an item
stating at least the title, year, new authors, and publisher of the Modified Version
as given on the Title Page. If there is no section Entitled ¡°History¡± in the Docu-
ment, create one stating the title, year, authors, and publisher of the Document
as given on its Title Page, then add an item describing the Modified Version as
stated in the previous sentence.
J. Preserve the network location, if any, given in the Document for public access to
a Transparent copy of the Document, and likewise the network locations given in
the Document for previous versions it was based on. These may be placed in the
¡°History¡± section. You may omit a network location for a work that was published
at least four years before the Document itself, or if the original publisher of the
version it refers to gives permission.
K. For any section Entitled ¡°Acknowledgements¡± or ¡°Dedications¡±, Preserve the Title
of the section, and preserve in the section all the substance and tone of each of the
contributor acknowledgements and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document, unaltered in their text and
in their titles. Section numbers or the equivalent are not considered part of the
section titles.
M. Delete any section Entitled ¡°Endorsements¡±. Such a section may not be included
in the Modified Version.
N. Do not retitle any existing section to be Entitled ¡°Endorsements¡± or to conflict in
title with any Invariant Section.
O. Preserve any Warranty Disclaimers.
If the Modified Version includes new front-matter sections or appendices that qualify
as Secondary Sections and contain no material copied from the Document, you may at
your option designate some or all of these sections as invariant. To do this, add their
```

Appendix I: GNU Free Documentation License 1137

```
titles to the list of Invariant Sections in the Modified Version¡¯s license notice. These
titles must be distinct from any other section titles.
You may add a section Entitled ¡°Endorsements¡±, provided it contains nothing but
endorsements of your Modified Version by various parties¡ªfor example, statements of
peer review or that the text has been approved by an organization as the authoritative
definition of a standard.
You may add a passage of up to five words as a Front-Cover Text, and a passage of up
to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified
Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be
added by (or through arrangements made by) any one entity. If the Document already
includes a cover text for the same cover, previously added by you or by arrangement
made by the same entity you are acting on behalf of, you may not add another; but
you may replace the old one, on explicit permission from the previous publisher that
added the old one.
The author(s) and publisher(s) of the Document do not by this License give permission
to use their names for publicity for or to assert or imply endorsement of any Modified
Version.
```
5. COMBINING DOCUMENTS
    You may combine the Document with other documents released under this License,
    under the terms defined in section 4 above for modified versions, provided that you
    include in the combination all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your combined work in its license
    notice, and that you preserve all their Warranty Disclaimers.
    The combined work need only contain one copy of this License, and multiple identical
    Invariant Sections may be replaced with a single copy. If there are multiple Invariant
    Sections with the same name but different contents, make the title of each such section
    unique by adding at the end of it, in parentheses, the name of the original author or
    publisher of that section if known, or else a unique number. Make the same adjustment
    to the section titles in the list of Invariant Sections in the license notice of the combined
    work.
    In the combination, you must combine any sections Entitled ¡°History¡± in the vari-
    ous original documents, forming one section Entitled ¡°History¡±; likewise combine any
    sections Entitled ¡°Acknowledgements¡±, and any sections Entitled ¡°Dedications¡±. You
    must delete all sections Entitled ¡°Endorsements.¡±
6. COLLECTIONS OF DOCUMENTS
    You may make a collection consisting of the Document and other documents released
    under this License, and replace the individual copies of this License in the various
    documents with a single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of the documents in all
    other respects.
    You may extract a single document from such a collection, and distribute it individu-
    ally under this License, provided you insert a copy of this License into the extracted
    document, and follow this License in all other respects regarding verbatim copying of
    that document.


Appendix I: GNU Free Documentation License 1138

### 7. AGGREGATION WITH INDEPENDENT WORKS

```
A compilation of the Document or its derivatives with other separate and independent
documents or works, in or on a volume of a storage or distribution medium, is called
an ¡°aggregate¡± if the copyright resulting from the compilation is not used to limit the
legal rights of the compilation¡¯s users beyond what the individual works permit. When
the Document is included in an aggregate, this License does not apply to the other
works in the aggregate which are not themselves derivative works of the Document.
If the Cover Text requirement of section 3 is applicable to these copies of the Document,
then if the Document is less than one half of the entire aggregate, the Document¡¯s Cover
Texts may be placed on covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form. Otherwise they
must appear on printed covers that bracket the whole aggregate.
```
8. TRANSLATION
    Translation is considered a kind of modification, so you may distribute translations
    of the Document under the terms of section 4. Replacing Invariant Sections with
    translations requires special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition to the original versions
    of these Invariant Sections. You may include a translation of this License, and all the
    license notices in the Document, and any Warranty Disclaimers, provided that you
    also include the original English version of this License and the original versions of
    those notices and disclaimers. In case of a disagreement between the translation and
    the original version of this License or a notice or disclaimer, the original version will
    prevail.
    If a section in the Document is Entitled ¡°Acknowledgements¡±, ¡°Dedications¡±, or ¡°His-
    tory¡±, the requirement (section 4) to Preserve its Title (section 1) will typically require
    changing the actual title.
9. TERMINATION
    You may not copy, modify, sublicense, or distribute the Document except as expressly
    provided under this License. Any attempt otherwise to copy, modify, sublicense, or
    distribute it is void, and will automatically terminate your rights under this License.
    However, if you cease all violation of this License, then your license from a particular
    copyright holder is reinstated (a) provisionally, unless and until the copyright holder
    explicitly and finally terminates your license, and (b) permanently, if the copyright
    holder fails to notify you of the violation by some reasonable means prior to 60 days
    after the cessation.
    Moreover, your license from a particular copyright holder is reinstated permanently if
    the copyright holder notifies you of the violation by some reasonable means, this is the
    first time you have received notice of violation of this License (for any work) from that
    copyright holder, and you cure the violation prior to 30 days after your receipt of the
    notice.
    Termination of your rights under this section does not terminate the licenses of parties
    who have received copies or rights from you under this License. If your rights have
    been terminated and not permanently reinstated, receipt of a copy of some or all of the
    same material does not give you any rights to use it.


Appendix I: GNU Free Documentation License 1139

### 10. FUTURE REVISIONS OF THIS LICENSE

```
The Free Software Foundation may publish new, revised versions of the GNU Free
Documentation License from time to time. Such new versions will be similar in spirit
to the present version, but may differ in detail to address new problems or concerns.
Seehttps://www.gnu.org/licenses/.
Each version of the License is given a distinguishing version number. If the Document
specifies that a particular numbered version of this License ¡°or any later version¡±
applies to it, you have the option of following the terms and conditions either of that
specified version or of any later version that has been published (not as a draft) by
the Free Software Foundation. If the Document does not specify a version number of
this License, you may choose any version ever published (not as a draft) by the Free
Software Foundation. If the Document specifies that a proxy can decide which future
versions of this License can be used, that proxy¡¯s public statement of acceptance of a
version permanently authorizes you to choose that version for the Document.
```
11. RELICENSING

```
¡°Massive Multiauthor Collaboration Site¡± (or ¡°MMC Site¡±) means any World Wide
Web server that publishes copyrightable works and also provides prominent facilities
for anybody to edit those works. A public wiki that anybody can edit is an example of
such a server. A ¡°Massive Multiauthor Collaboration¡± (or ¡°MMC¡±) contained in the
site means any set of copyrightable works thus published on the MMC site.
¡°CC-BY-SA¡± means the Creative Commons Attribution-Share Alike 3.0 license pub-
lished by Creative Commons Corporation, a not-for-profit corporation with a principal
place of business in San Francisco, California, as well as future copyleft versions of that
license published by that same organization.
¡°Incorporate¡± means to publish or republish a Document, in whole or in part, as part
of another Document.
An MMC is ¡°eligible for relicensing¡± if it is licensed under this License, and if all works
that were first published under this License somewhere other than this MMC, and
subsequently incorporated in whole or in part into the MMC, (1) had no cover texts
or invariant sections, and (2) were thus incorporated prior to November 1, 2008.
The operator of an MMC Site may republish an MMC contained in the site under
CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is
eligible for relicensing.
```

Appendix I: GNU Free Documentation License 1140

ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of the License in the
document and put the following copyright and license notices just after the title page:
Copyright (C) year your name.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts. A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the
¡°with... Texts.¡± line with this:
with the Invariant Sections beinglist their titles, with
the Front-Cover Texts beinglist, and with the Back-Cover Texts
beinglist.
If you have Invariant Sections without Cover Texts, or some other combination of the
three, merge those two alternatives to suit the situation.

If your document contains nontrivial examples of program code, we recommend releasing
these examples in parallel under your choice of free software license, such as the GNU
General Public License, to permit their use in free software.


### 1141

## Concept Index.........................................

!
!posix.......................................... 10

.
.lib section in a.out corrupted.................. 35

/
/condition..................................... 11
/etc/hostname................................ 876
/etc/nsswitch.conf.......................... 836

:
:identifier...................................... 11

?
?.............................................. 32

_POSIX_OPTION_ORDERenvironment variable... 796
_POSIX_SAVED_IDS............................ 846

4
4.nBSD Unix.................................. 11

A
abort signal................................... 718
aborting a program........................... 801
absolute file name............................. 264
absolute priority.............................. 690
absolute value functions....................... 617
AC-Safe........................................ 3
AC-Unsafe...................................... 3
accepting connections......................... 484
access permission for a file.................... 436
access, testing for............................. 438
Accessing a corrupted shared library........... 35
accessing directories.......................... 404
Address already in use......................... 29
Address family not supported by protocol...... 29
address of socket.............................. 457
address space............................ 702 , 759
Advertise error................................. 34
alarm signal.................................. 720
alarms, setting................................ 679
aliases........................................ 835
alignment (in obstacks)........................ 72
alignment (withmalloc)....................... 49

```
allocadisadvantages.......................... 76
allocafunction................................ 74
allocating file storage......................... 444
allocating pseudo-terminals................... 528
allocation (obstacks)........................... 65
allocation debugging........................... 59
allocation hooks, formalloc.................... 54
allocation of memory withmalloc.............. 45
allocation size of string......................... 98
allocation statistics............................ 56
alphabetic character........................ 87 , 91
alphanumeric character..................... 88 , 91
alternativemallocimplementations............ 62
append-access files............................ 263
argc (program argument count)............... 759
argp (program argument parser).............. 768
argp parser functions......................... 772
ARGPHELPFMT environment variable..... 789
Argument list too long......................... 25
argument parsing with argp................... 768
argument promotion.......................... 953
argument vectors, null-byte separated......... 135
arguments (variadic functions)................ 952
arguments, how many......................... 952
arguments, to program........................ 759
argv (program argument vector).............. 759
argz vectors (string vectors)................... 135
arithmetic expansion.......................... 254
array comparison functions.................... 113
array copy functions.......................... 101
array search function......................... 228
array sort function............................ 229
AS-Safe......................................... 3
AS-Unsafe...................................... 3
ASCII character............................... 89
assertions..................................... 949
Async-Cancel-Safe.............................. 3
Async-Cancel-Unsafe............................ 3
Async-Signal-Safe............................... 3
Async-Signal-Unsafe............................ 3
Attempting to link in too many
shared libraries.............................. 35
attributes of a file............................. 425
Authentication error........................... 31
automatic freeing.............................. 74
automatic memory allocation................... 44
automatic storage class........................ 44
automatic storage with variable size............ 74
auxiliary vector............................... 796
```

Concept Index 1142

B
background job............................... 818
background job, launching.................... 826
backtrace..................................... 918
backtracefd.................................. 918
backtracesymbols............................ 918
Bad address................................... 25
Bad file descriptor............................. 25
Bad font file format............................ 34
Bad message................................... 32
base (of floating point number)................ 960
baud rate..................................... 515
Berkeley Unix................................. 11
Bessel functions............................... 553
bias (of floating point number exponent)...... 960
big-endian.................................... 476
binary I/O to a stream....................... 287
binary search function (for arrays)............ 228
binary stream................................. 322
binding a socket address...................... 457
blank character............................. 88 , 94
Block device required.......................... 25
block I/O to a stream......................... 287
blocked signals................................ 715
blocked signals, checking for.................. 751
blocking signals............................... 746
blocking signals, in a handler.................. 750
bootstrapping, and services................... 838
break condition, detecting..................... 509
break condition, generating................... 523
breaking a string into tokens.................. 126
Broken pipe................................... 27
broken pipe signal............................ 723
broken-down time........................ 646 , 659
BSD Unix..................................... 11
buffering of streams........................... 328
buffering, controlling.......................... 330
bugs, reporting.............................. 1098
bus error..................................... 718
butterfly...................................... 632
byte order conversion, for socket.............. 476
byte stream................................... 455

C

C threads..................................... 921
C++streams.................................. 275
calendar time................................. 646
calendar time and broken-down time.......... 659
calendar time, simple......................... 646
calendar, Gregorian........................... 646
call once...................................... 923
calling variadic functions...................... 953
Can not access a needed shared library......... 35
Cannot allocate memory....................... 25
Cannot assign requested address............... 29
Cannot exec a shared library directly........... 35

```
Cannot send after transport
endpoint shutdown.......................... 30
canonical input processing.................... 504
capacity limits, POSIX....................... 890
carrier detect................................. 511
case conversion of characters................... 89
catching signals............................... 715
categories for locales.......................... 184
change working directory...................... 402
changing the locale........................... 185
changing the size of a block (malloc)........... 48
changing the size of a block (obstacks)......... 67
Channel number out of range.................. 33
channels...................................... 353
character case conversion....................... 89
character predicates............................ 87
character testing............................... 87
checking for pending signals................... 751
child process........................ 651 , 803 , 804
child process signal........................... 721
chunks......................................... 72
classes, floating-point......................... 605
classification of characters...................... 87
cleaning up a stream.......................... 354
clearing terminal input queue................. 524
client......................................... 482
clock ticks............................... 647 , 649
clock, disciplining............................. 654
clock, high accuracy.......................... 654
close-on-exec (file descriptor flag)............. 386
closing a file descriptor........................ 342
closing a socket............................... 480
closing a stream.............................. 271
collating strings............................... 117
combining locales............................. 184
command argument syntax.................... 760
command arguments, parsing................. 760
command line arguments...................... 759
command substitution........................ 254
Communication error on send.................. 34
communication style (of a socket)............. 455
comparing strings and arrays.................. 113
Comparison Function......................... 228
compiling.................................... 1088
complex exponentiation functions............. 548
complex logarithm functions.................. 548
complex numbers............................. 633
complex trigonometric functions.............. 541
Computer bought the farm..................... 32
concatenating strings..................... 101 , 106
condition variables............................ 926
Conditionally Safe Features..................... 5
condvar....................................... 926
configuring.................................. 1088
conjugate complex numbers................... 634
connecting a socket........................... 482
connection.................................... 482
Connection refused............................. 30
```

Concept Index 1143

Connection reset by peer....................... 29
Connection timed out.......................... 30
consistency checking.......................... 949
consistency checking, of heap................... 52
const........................................... 7
constants................................. 43 , 539
continue signal................................ 721
control character........................... 89 , 92
control operations on files..................... 383
controlling process............................ 818
controlling terminal........................... 817
controlling terminal, access to................. 818
controlling terminal, determining.............. 831
controlling terminal, setting................... 390
conversion specifications (printf)............. 288
conversion specifications (scanf).............. 311
converting byte order......................... 476
converting case of characters................... 89
converting file descriptor to stream............ 352
converting floats to integers................... 620
converting group ID to group name........... 868
converting group name to group ID........... 868
converting host address to name.............. 469
converting host name to address.............. 469
converting network name to network number.. 501
converting network number to network name.. 501
converting port number to service name....... 474
converting service name to port number....... 474
converting string to collation order............ 118
converting strings to numbers................. 635
converting user ID to user name............... 865
converting user name to user ID............... 865
cookie, for custom stream..................... 335
copy-on-write page fault....................... 83
copying files.................................. 359
copying strings and arrays.................... 101
corrupt......................................... 4
cpu priority................................... 689
CPU time........................... 646 , 649 , 650
create on open (file status flag)................ 389
creating a directory........................... 424
creating a FIFO special file................... 453
creating a pipe................................ 450
creating a pipe to a subprocess................ 452
creating a process............................. 804
creating a socket.............................. 480
creating a socket pair......................... 481
creating special files........................... 445
CRNG........................................ 916
cryptographic random number generator...... 916
CSPRNG..................................... 916
cube root function............................ 548
currency symbols............................. 190
current limit.................................. 685
current working directory..................... 402
custom streams............................... 335
customizingmalloc............................ 62
customizingprintf........................... 305

```
cwd............................................ 10
```
```
D
data loss on sockets........................... 455
datacachesize tunables...................... 946
databases..................................... 835
datagram socket.............................. 493
datagrams, transmitting...................... 494
date.......................................... 646
Daylight Saving Time......................... 659
decimal digit character......................... 88
decimal-point separator....................... 189
declaration (compared to definition)............ 12
declaring variadic functions................... 953
decompose complex numbers.................. 634
default action (for a signal)................... 715
default action for a signal..................... 725
default argument promotions.................. 953
default value, and NSS........................ 839
defining newprintfconversions.............. 305
definition (compared to declaration)............ 12
delayed suspend character..................... 519
deleting a directory........................... 423
deleting a file................................. 422
delivery of signals............................. 715
descriptors and streams....................... 353
Destination address required................... 29
deterministic random bit generator............ 916
Device not a stream............................ 33
Device or resource busy........................ 25
digit character............................. 88 , 92
directories, accessing.......................... 404
directories, creating........................... 424
directories, deleting........................... 423
directory..................................... 263
directory entry................................ 263
directory hierarchy............................ 414
Directory not empty........................... 30
directory stream.............................. 404
disadvantages ofalloca........................ 76
DISCARD character.......................... 520
Disk quota exceeded........................... 30
division by zero............................... 607
dlopen.......................................... 5
DNS.......................................... 875
DNS server unavailable....................... 837
domain (of socket)............................ 455
domain error.................................. 612
domain name................................. 875
Domain Name System........................ 875
dot notation, for Internet addresses........... 466
DRBG........................................ 916
DSUSP character............................. 519
duplicating file descriptors.................... 384
dynamic linking tunables...................... 943
dynamic memory allocation.................... 44
```

Concept Index 1144

E

EBCDIC..................................... 142
echo of terminal input........................ 513
effective group ID............................. 845
effective user ID.............................. 845
efficiency and obstacks......................... 69
efficiency of chunks............................ 72
EINTR, and restarting
interrupted primitives...................... 741
elapsed time.................................. 646
elision tunables............................... 944
end of file, on a stream........................ 320
end-of-file, on a file descriptor................. 345
env............................................. 9
environment.................................. 792
environment access........................... 793
environment representation................... 793
environment variable.......................... 792
environment vectors, null-byte separated...... 135
envz vectors (environment vectors)............ 135
EOF character................................ 517
EOL character................................ 517
EOL2 character............................... 517
epoch.................................... 646 , 647
ERASE character............................. 517
errno......................................... 798
error codes..................................... 23
error messages, in argp........................ 777
error reporting................................. 23
errors, mathematical.......................... 612
establishing a handler......................... 725
ethers........................................ 835
EUC......................................... 142
EUC-JP...................................... 170
exception................................ 607 , 717
Exchange full.................................. 34
exclusive lock................................. 393
Exec format error.............................. 25
execfunctions................................ 806
execing a program............................. 43
executable..................................... 43
executing a file............................... 806
exit status.................................... 799
exit status value.............................. 798
exiting a program.............................. 43
expansion of shell words...................... 254
exponent (of floating point number)........... 960
exponentiation functions...................... 544
extendingprintf............................. 305
extracting file descriptor from stream......... 352

```
F
fcntlfunction................................ 383
fd............................................... 9
FDL, GNU Free Documentation License..... 1133
feature test macros............................. 15
field splitting................................. 254
FIFO special file.............................. 450
file access permission.......................... 436
file access time................................ 439
file allocation................................. 444
file attribute modification time................ 439
file attributes................................. 425
file copy...................................... 359
file creation mask............................. 436
file descriptor flags............................ 386
File descriptor in bad state..................... 34
file descriptor sets, forselect................. 367
file descriptors, standard...................... 353
File exists..................................... 25
file fragmentation............................. 444
File locking deadlock error..................... 34
file locks...................................... 393
file modification time......................... 439
file name..................................... 263
file name component.......................... 263
file name errors............................... 264
file name resolution........................... 264
File name too long............................. 30
file name translation flags..................... 388
file names, multiple........................... 418
file owner..................................... 433
file permission bits............................ 434
file pointer.................................... 266
file position................................... 262
file positioning on a file descriptor............. 350
file positioning on a stream................... 323
file status flags................................ 387
File too large.................................. 26
files, accessing................................. 43
files, sparse................................... 444
filtering i/o through subprocess............... 452
flag character (printf)........................ 290
flag character (scanf)......................... 312
flags forsigaction........................... 730
flags, file name translation.................... 388
flags, open-time action........................ 389
floating point................................. 604
floating point, IEEE.......................... 963
floating type measurements................... 959
floating-point classes.......................... 605
floating-point exception....................... 717
flow control, terminal......................... 525
flow label..................................... 465
flushing a stream............................. 329
flushing terminal output queue................ 524
foreground job................................ 818
foreground job, launching..................... 825
forking a process.............................. 804
```

Concept Index 1145

format string, forprintf...................... 288
format string, forscanf....................... 311
formatted input from a stream................ 311
formatted messages........................... 337
formatted output to a stream................. 288
FP arithmetic................................ 625
FQDN........................................ 875
fragmentation of files......................... 444
frame, real memory............................ 42
free documentation.......................... 1122
freeing (obstacks).............................. 66
freeing memory................................ 43
freeing memory allocated withmalloc.......... 47
fully buffered stream.......................... 328
Function not implemented..................... 31
function prototypes (variadic)................. 951

G
gamma function.............................. 553
gcvtr........................................ 645
gencat........................................ 208
generation of signals.......................... 714
generic i/o control operations................. 401
globbing...................................... 240
gnu allocator................................... 45
graphic character........................... 89 , 92
Gratuitous error............................... 32
Gregorian calendar........................... 646
group......................................... 835
group database............................... 868
group ID..................................... 845
group name................................... 845
group owner of a file.......................... 433
grouping of digits............................. 189
growing objects (in obstacks)................... 67
gshadow...................................... 835

H
handling multiple signals...................... 735
hangup signal................................. 720
hard limit.................................... 686
hard link..................................... 418
hardware capability tunables.................. 946
hashing, passphrase........................... 912
header files.................................... 12
heap............................................ 5
heap consistency checking...................... 52
heap, dynamic allocation from................. 45
heap, freeing memory from..................... 47
hexadecimal digit character................. 88 , 94
hidden bit (of floating point
number mantissa).......................... 960
hierarchy, directory........................... 414
high-priority data............................. 491
holes in files.................................. 350
home directory............................... 795

```
HOMEenvironment variable.................... 795
hook functions (of custom streams)........... 336
host address, Internet......................... 465
Host is down................................... 30
host name.................................... 875
hostid........................................... 9
hostname..................................... 875
hosts......................................... 835
hosts database................................ 469
how many arguments......................... 952
hwcap tunables............................... 946
hwcaps tunables.............................. 946
hyperbolic functions...................... 550 , 551
```
```
I
i18n............................................ 5
iconv........................................... 5
Identifier removed.............................. 32
identifying terminals.......................... 503
IEEE 754..................................... 604
IEEE floating point........................... 604
IEEE floating point representation............ 963
IEEE Std 1003.1................................ 2
IEEE Std 1003.2................................ 2
ignore action for a signal...................... 725
illegal instruction............................. 718
Illegal seek..................................... 26
impossible events............................. 949
Inappropriate file type or format............... 31
Inappropriate ioctl for device................... 26
Inappropriate operation for
background process.......................... 32
independent channels......................... 354
inexact exception............................. 607
infinity....................................... 609
init............................................. 6
initgroups.................................... 835
initial signal actions.......................... 731
inode number................................. 428
input available signal......................... 721
input conversions, forscanf................... 312
input from multiple files...................... 366
Input/output error............................. 24
installation tools............................. 1095
installing.................................... 1094
integer........................................ 601
integer division functions...................... 602
integer type range............................ 958
integer type width............................ 957
interactive signals, from terminal.............. 514
interactive stop signal......................... 722
internal representation........................ 140
internationalization........................... 183
Internet host address......................... 465
Internet namespace, for sockets............... 463
interposingmalloc............................. 62
interprocess communication, with FIFO....... 453
```

Concept Index 1146

interprocess communication, with pipes....... 450
interprocess communication, with signals...... 745
interprocess communication, with sockets...... 455
interrupt character............................ 518
interrupt signal............................... 719
interrupt-driven input......................... 400
Interrupted system call......................... 24
Interrupted system call should be restarted..... 33
interrupting primitives........................ 741
interval....................................... 646
interval timer, setting......................... 679
INTR character............................... 518
Invalid argument............................... 26
Invalid cross-device link........................ 25
invalid exception.............................. 607
Invalid exchange............................... 34
Invalid or incomplete multibyte or
wide character............................... 32
Invalid request code............................ 34
Invalid request descriptor...................... 34
Invalid slot.................................... 34
inverse complex hyperbolic functions.......... 552
inverse complex trigonometric functions....... 543
inverse hyperbolic functions................... 551
inverse trigonometric functions................ 542
invocation of program......................... 759
IOCTLs...................................... 401
ipc........................................... 815
IPv6 flow label............................... 465
IPv6 scope ID................................ 465
IPv6 traffic class.............................. 465
Is a directory.................................. 26
Is a named type file............................ 35
ISO 10646.................................... 140
ISO 2022..................................... 142
ISO 6937..................................... 143
ISO C.......................................... 2
ISO C threads................................ 921
ISO-2022-JP.................................. 170
ISO/IEC 9945-1................................ 2
ISO/IEC 9945-2................................ 2

J

job........................................... 817
job control.................................... 817
job control functions.......................... 831
job control signals............................ 721
job control, enabling.......................... 821

```
K
Kermit the frog............................... 232
kernel call.................................... 797
kernel header files........................... 1097
Key has been revoked.......................... 35
Key has expired................................ 35
Key was rejected by service.................... 35
kill signal..................................... 720
KILL character............................... 518
killing a process.............................. 743
Korn Shell.................................... 240
```
```
L
LANG environment variable.............. 205 , 796
launching jobs................................ 822
LCALL environment variable............ 205 , 796
LC_COLLATEenvironment variable............. 796
LC_CTYPEenvironment variable................ 796
LCMESSAGES environment variable.... 205 , 796
LC_MONETARYenvironment variable............ 796
LC_NUMERICenvironment variable............. 796
LC_TIMEenvironment variable................. 796
LD_PRELOADandmalloc........................ 62
leap second................................... 659
leap seconds.................................. 646
length of string................................ 98
Level 2 halted................................. 34
Level 2 not synchronized....................... 33
Level 3 halted................................. 33
Level 3 reset................................... 33
level, for socket options....................... 499
library.......................................... 1
limit.......................................... 685
limits on resource usage....................... 685
limits, file name length........................ 904
limits, floating types.......................... 959
limits, integer types........................... 958
limits, link count of files...................... 903
limits, number of open files................... 890
limits, number of processes.................... 890
limits, number of supplementary group IDs.... 890
limits, pipe buffer size........................ 904
limits, POSIX................................ 890
limits, program argument size................. 890
limits, terminal input queue................... 903
limits, time zone name length................. 890
line buffered stream........................... 328
line speed..................................... 515
lines (in a text file)........................... 323
link........................................... 263
Link has been severed.......................... 32
Link number out of range...................... 33
link, hard..................................... 418
link, soft...................................... 419
link, symbolic................................. 419
linked channels............................... 354
listening (sockets)............................. 483
```

Concept Index 1147

literals......................................... 43
little-endian.................................. 476
LNEXT character............................. 520
load average.................................. 704
local namespace, for sockets................... 461
local network address number................. 465
local time..................................... 646
locale........................................... 9
locale categories.............................. 184
locale, changing............................... 185
locales........................................ 183
lock............................................. 4
locking pages.................................. 82
logarithm functions........................... 544
login name.................................... 845
login name, determining...................... 855
LOGNAMEenvironment variable................. 795
long jumps................................... 705
long-named options........................... 760
longjmp....................................... 75
loss of data on sockets........................ 455
lost resource signal............................ 723
lower-case character........................ 87 , 92

M
Machine is not on the network................. 34
macros......................................... 67
mainfunction................................. 759
malloc debugger............................... 59
mallocfunction................................ 45
mallocreplacement............................ 62
malloc tunables............................... 941
mantissa (of floating point number)........... 960
matching failure, inscanf..................... 311
math errors................................... 556
mathematical constants....................... 539
maximum..................................... 630
maximum field width (scanf)................. 312
maximum limit............................... 686
maximum possible integer..................... 602
measurements of floating types................ 959
mem........................................... 10
memory allocation............................. 42
memory allocation tunables................... 941
memory lock................................... 82
memory mapped file........................... 43
memory mapped I/O.......................... 43
memory page................................. 702
Memory page has hardware error............... 35
memory protection............................. 77
memory protection key......................... 79
memory related tunables...................... 947
merging of signals............................. 735
Message too long.............................. 28
MIN termios slot............................. 521
minimum..................................... 630
minimum field width (printf)................ 290

```
minimum possible integer..................... 602
mixing descriptors and streams................ 353
modem disconnect............................ 511
modem status lines........................... 511
monetary value formatting.................... 189
monotonic time............................... 652
MPK.......................................... 79
MT-Safe........................................ 3
MT-Unsafe..................................... 3
multi-threaded application.................... 272
multibyte character....................... 97 , 142
multibyte string............................ 97 , 98
Multihop attempted........................... 32
multiple names for one file.................... 418
multiplexing input............................ 366
multiply-add.................................. 630
mutex........................................ 923
mutex tunables............................... 945
mutual exclusion.............................. 923
```
```
N
Name not unique on network................... 34
name of running program...................... 37
name of socket................................ 457
Name Service Switch.......................... 835
name space.................................... 14
names of signals.............................. 716
namespace (of socket)......................... 455
NaN..................................... 609 , 626
Need authenticator............................. 31
netgroup...................................... 835
Netgroup..................................... 872
network byte order............................ 476
Network dropped connection on reset........... 29
Network is down............................... 29
Network is unreachable........................ 29
network number.............................. 465
network protocol.............................. 455
networks...................................... 835
networks database............................ 501
nisplus, and booting.......................... 838
nisplus, and completeness..................... 838
NIS........................................... 875
NIS domain name........................ 875 , 876
NLSPATH environment variable.......... 204 , 796
No anode...................................... 34
No buffer space available....................... 29
No child processes............................. 25
No CSI structure available..................... 33
No data available.............................. 32
No locks available.............................. 31
No medium found.............................. 35
No message of desired type..................... 32
No route to host............................... 30
No space left on device......................... 26
No such device................................. 26
No such device or address...................... 24
```

Concept Index 1148

No such file or directory........................ 24
No such process................................ 24
No XENIX semaphores available............... 35
non-blocking open............................ 389
non-local exit, from signal handler............ 733
non-local exits................................ 705
nontemporalthreshold tunables.............. 946
noncanonical input processing................. 505
normalization functions (floating-point)....... 618
normalized floating point number............. 960
Not a directory................................ 26
not a number................................. 609
Not a XENIX named type file.................. 35
Not supported................................. 31
nsswitch.conf............................... 836
NSS........................................ 5 , 835
null byte....................................... 97
null pointer constant.......................... 955
null wide character............................. 97
number of arguments passed.................. 952
number syntax, parsing....................... 635
numeric value formatting..................... 189
Numerical argument out of domain............. 27
Numerical result out of range.................. 27

O
Object is remote............................... 31
obstack status................................. 71
obstacks....................................... 63
one-way hashing.............................. 912
open-time action flags......................... 389
opening a file................................. 261
opening a file descriptor....................... 342
opening a pipe................................ 450
opening a pseudo-terminal pair................ 530
opening a socket.............................. 480
opening a socket pair......................... 481
opening a stream............................. 267
Operation already in progress.................. 28
Operation canceled............................ 33
Operation not permitted....................... 24
Operation not possible due to RF-kill.......... 35
Operation not supported....................... 28
Operation now in progress..................... 28
Operation would block......................... 27
Optimization................................. 599
optimizing NSS............................... 839
option parsing with argp...................... 768
optional arguments........................... 950
optional POSIX features...................... 891
orientation, stream....................... 268 , 275
orphaned process group....................... 819
Other Safety Remarks........................... 9
Out of streams resources....................... 33
out-of-band data.............................. 491
output conversions, forprintf................ 290
output possible signal......................... 721

```
overflow exception............................ 607
Owner died.................................... 33
owner of a file................................ 433
```
```
P
Package not installed........................... 34
packet........................................ 455
page boundary................................. 49
page fault...................................... 42
page fault, copy-on-write....................... 83
page frame..................................... 42
page protection................................ 77
page, memory................................ 702
page, virtual memory.......................... 42
paging..................................... 42 , 82
parameter promotion........................... 99
parent directory.............................. 264
parent process........................... 803 , 804
parity checking............................... 508
parsing a template string..................... 302
parsing numbers (in formatted input)......... 635
parsing program arguments................... 760
parsing tokens from a string................... 126
passphrase hashing........................... 912
passwd....................................... 835
password database............................ 864
PATHenvironment variable.................... 795
pausefunction................................ 753
peeking at input.............................. 285
pending signals............................... 715
pending signals, checking for.................. 751
period of time................................ 646
Permission denied.............................. 25
permission to access a file..................... 436
persona....................................... 845
physical address.............................. 702
physical memory.............................. 702
pi (trigonometric constant).................... 540
pipe.......................................... 450
pipe signal.................................... 723
pipe to a subprocess.......................... 452
plugin.......................................... 5
port number.................................. 473
positioning a file descriptor................... 350
positioning a stream.......................... 323
positive difference............................. 630
POSIX......................................... 2
POSIX capacity limits........................ 890
POSIX optional features...................... 891
POSIX Safety Concepts......................... 2
POSIX.1........................................ 2
POSIX.2........................................ 2
power functions............................... 544
precision (of floating point number)........... 960
precision (printf)............................ 290
predicates on arrays.......................... 113
predicates on characters........................ 87
```

Concept Index 1149

predicates on strings.......................... 113
preemptingmalloc............................. 62
preemptive scheduling........................ 690
Preliminary..................................... 3
primitives, interrupting....................... 741
printing character.......................... 89 , 93
priority of a process........................... 689
priority, absolute.............................. 690
process.................................. 759 , 803
process completion............................ 809
process group functions....................... 831
process group ID.............................. 822
process group leader.......................... 822
process groups................................ 817
process ID.................................... 804
process image................................. 804
process priority............................... 689
process signal mask........................... 748
process termination........................... 798
processor time........................... 646 , 650
profiling alarm signal......................... 720
profiling timer................................ 680
program...................................... 759
program argument syntax..................... 760
program arguments........................... 759
program arguments, parsing................... 760
program error signals......................... 716
program name................................. 37
program startup.............................. 759
program termination.......................... 798
program termination signals.................. 719
programming your own streams............... 335
project complex numbers..................... 634
protection flags................................ 77
protection key................................. 79
protocol (of socket)........................... 455
Protocol driver not attached................... 33
Protocol error.................................. 33
protocol family............................... 455
Protocol family not supported.................. 28
Protocol not available.......................... 28
Protocol not supported........................ 28
Protocol wrong type for socket................. 28
protocols..................................... 835
protocols database............................ 477
prototypes for variadic functions.............. 951
pseudo-random numbers...................... 591
pseudo-random numbers, cryptographic....... 916
pseudo-terminals.............................. 527
pthread mutex tunables....................... 945
pthreads...................................... 928
publickey..................................... 835
punctuation character...................... 88 , 93
pushing input back........................... 285

```
Q
quick sort function (for arrays)................ 229
quit signal.................................... 719
QUIT character............................... 519
quote removal................................ 254
```
```
R
race............................................. 6
race conditions, relating to job control........ 823
race conditions, relating to signals............. 734
radix (of floating point number)............... 960
raising signals................................ 742
random numbers.............................. 591
random numbers, cryptographic............... 916
random-access files............................ 262
randomness source............................ 916
range error................................... 612
range of integer type.......................... 958
read lock..................................... 393
Read-only file system.......................... 27
reading from a directory...................... 404
reading from a file descriptor.................. 345
reading from a socket......................... 485
reading from a stream, by blocks.............. 287
reading from a stream, by characters.......... 280
reading from a stream, formatted............. 311
ready to run.................................. 690
real group ID................................. 845
real user ID................................... 845
real-time timer................................ 679
realtime CPU scheduling...................... 690
realtime processing............................. 82
realtime scheduling........................... 691
receiving datagrams........................... 494
record locking................................ 393
redirecting input and output.................. 384
reentrant functions............................ 738
reentrant NSS functions....................... 839
relative file name............................. 264
Remote address changed....................... 34
Remote I/O error.............................. 35
removal of quotes............................. 254
removing a file................................ 422
removing macros that shadow functions........ 13
renaming a file................................ 423
replacingmalloc............................... 62
reporting bugs............................... 1098
reporting errors................................ 23
REPRINT character.......................... 518
Required key not available..................... 35
reserved names................................ 14
Resource deadlock avoided..................... 25
resource limits................................ 685
Resource temporarily unavailable............... 27
restarting interrupted primitives.............. 741
restrictions on signal handler functions........ 737
RFS specific error.............................. 34
```

Concept Index 1150

root directory................................. 264
Rot13........................................ 132
rpc........................................... 835
RPC bad procedure for program............... 31
RPC program not available.................... 31
RPC program version wrong................... 31
RPC struct is bad............................. 31
RPC version wrong............................ 31
rtld tunables.................................. 943
runnable process.............................. 690
running a command........................... 803

S
saved set-group-ID............................ 846
saved set-user-ID............................. 846
scanning the group list........................ 869
scanning the user list......................... 866
scatter-gather................................. 355
scheduling, traditional........................ 696
scope ID...................................... 465
search function (for arrays)................... 228
search functions (for strings).................. 121
seconds, leap................................. 646
seed (for random numbers).................... 591
seeking on a file descriptor.................... 350
seeking on a stream........................... 323
segmentation violation........................ 718
sending a datagram........................... 494
sending signals................................ 742
sequential-access files......................... 262
server........................................ 482
services....................................... 835
services database............................. 474
session........................................ 817
session leader................................. 817
setting an alarm.............................. 679
setuidprograms............................. 846
setuid programs and file access................ 438
severity class............................. 338 , 339
sgettext.................................. 222 , 223
shadow....................................... 835
shadowing functions with macros............... 13
shared lock................................... 393
shared memory............................... 702
sharedcachesize tunables.................... 946
shell.......................................... 817
shift state.................................... 145
ShiftJIS..................................... 142
shrinking objects............................... 69
shutting down a socket........................ 480
sig.............................................. 8
sigactionflags............................... 730
sigactionfunction........................... 727
SIGCHLD, handling of.......................... 827
sigintr.......................................... 9
sign (of floating point number)................ 960
signal.................................... 607 , 714

```
signal action.................................. 715
signal actions................................. 725
signal flags................................... 730
signalfunction............................... 725
signal handler function........................ 731
signal mask................................... 748
signal messages............................... 724
signal names.................................. 716
signal number................................ 716
signal set..................................... 747
signals, generating............................ 742
signedness.................................... 601
significand (of floating point number)......... 960
SIGTTIN, from background job................ 818
SIGTTOU, from background job................ 818
simple calendar time.......................... 646
simple time................................... 646
single-byte string.............................. 98
single-call functions........................... 923
size of string................................... 98
SJIS.......................................... 142
socket........................................ 455
socket address (name) binding................ 457
socket domain................................ 455
socket namespace............................. 455
Socket operation on non-socket................. 28
socket option level............................ 499
socket options................................ 499
socket pair.................................... 481
socket protocol............................... 455
socket shutdown.............................. 480
Socket type not supported..................... 28
socket, client actions.......................... 482
socket, closing................................ 480
socket, connecting............................ 482
socket, creating............................... 480
socket, initiating a connection................. 482
sockets, accepting connections................. 484
sockets, listening.............................. 483
sockets, server actions......................... 483
soft limit..................................... 685
soft link...................................... 419
Software caused connection abort.............. 29
sort function (for arrays)...................... 229
sparse files............................... 350 , 444
special files................................... 445
special functions.............................. 553
specified action (for a signal).................. 715
speed of execution............................. 82
square root function.......................... 547
Srmount error................................. 34
stable sorting................................. 230
Stale file handle................................ 30
standard dot notation, for Internet addresses.. 466
standard environment variables............... 795
standard error file descriptor.................. 353
standard error stream......................... 266
standard file descriptors....................... 353
```

Concept Index 1151

standard input file descriptor................. 353
standard input stream........................ 266
standard output file descriptor................ 353
standard output stream....................... 266
standard streams............................. 266
standards....................................... 1
START character............................. 520
startup of program............................ 759
State not recoverable........................... 33
stateful............... 145 , 148 , 154 , 164 , 167 , 178
static memory allocation....................... 44
static storage class............................. 44
status codes................................... 23
status of a file................................ 425
status of obstack............................... 71
STATUS character............................ 520
sticky bit..................................... 435
stop signal.................................... 722
STOP character.............................. 520
stopped job................................... 818
stopped jobs, continuing...................... 829
stopped jobs, detecting....................... 827
storage allocating............................. 444
storage allocation.............................. 42
stream (sockets).............................. 455
stream orientation....................... 268 , 275
stream, for I/O to a string.................... 333
streams and descriptors....................... 353
Streams pipe error............................. 35
streams, and file descriptors................... 352
streams, C++................................. 275
streams, standard............................. 266
string.......................................... 97
string allocation............................... 98
string collation functions...................... 117
string comparison functions................... 113
string concatenation functions............ 101 , 106
string copy functions.......................... 101
string length................................... 98
string literal................................... 97
string search functions........................ 121
string stream................................. 333
string truncation.............................. 109
string vectors, null-byte separated............. 135
string, representation of........................ 97
Structure needs cleaning....................... 35
style of communication (of a socket)........... 455
subprocess.................................... 804
subshell...................................... 821
substitution of variables and commands....... 254
successive signals............................. 735
summer time................................. 659
SunOS......................................... 11
supplementary group IDs..................... 845
SUSP character............................... 519
suspend character............................. 519
SVID.......................................... 11
swap space..................................... 42

```
symbolic link................................. 419
symbolic link, opening........................ 390
synchronizing............................ 369 , 379
syntax error messages, in argp................ 777
syntax, for program arguments................ 760
syntax, for reading numbers................... 635
sysconf.................................. 703 , 704
system call................................... 797
system call number........................... 797
System V Unix................................ 11
```
```
T
task ID....................................... 804
TCP (Internet protocol)...................... 477
template, forprintf.......................... 288
template, forscanf........................... 311
term............................................ 8
TERMenvironment variable.................... 795
terminal flow control.......................... 525
terminal identification........................ 503
terminal input queue.......................... 504
terminal input queue, clearing................. 524
terminal input signal.......................... 722
terminal line control functions................ 523
terminal line speed............................ 515
terminal mode data types..................... 505
terminal mode functions...................... 506
terminal modes, BSD......................... 522
terminal output queue........................ 504
terminal output queue, flushing............... 524
terminal output signal........................ 722
terminated jobs, detecting.................... 827
termination signal............................ 719
testing access permission...................... 438
testing exit status of child process............. 809
Text file busy.................................. 26
text stream................................... 322
thrashing..................................... 702
thread control................................ 921
thread creation............................... 921
thread group.................................. 804
thread ID..................................... 804
thread management........................... 921
thread mutex tunables........................ 945
thread of control.............................. 759
thread-local storage........................... 927
Thread-Safe..................................... 3
Thread-Unsafe.................................. 3
threads.................................. 272 , 921
ticks, clock............................... 647 , 649
tilde expansion............................... 254
time.......................................... 646
time zone..................................... 676
time zone database........................... 677
time, elapsed................................. 646
time, high precision........................... 654
TIME termios slot............................ 521
```

Concept Index 1152

timer........................................... 5
Timer expired................................. 33
timer, profiling................................ 680
timer, real-time............................... 679
timer, virtual................................. 679
timers, setting................................ 679
timespec...................................... 647
timeval....................................... 647
timing error in signal handling................ 753
TMPDIR environment variable............... 448
tokenizing strings............................. 126
Too many levels of symbolic links.............. 30
Too many links................................ 27
Too many open files............................ 26
Too many open files in system................. 26
Too many processes............................ 30
Too many references: cannot splice............. 30
Too many users................................ 30
tools, for installing library................... 1095
traffic class................................... 465
Translator died................................ 32
transmitting datagrams....................... 494
Transport endpoint is already connected........ 29
Transport endpoint is not connected........... 29
tree, directory................................ 414
triangulation.................................. 170
trigonometric functions....................... 540
truncating strings............................. 109
Tunable names............................... 941
Tunable namespaces.......................... 941
tunables...................................... 940
tunables thread mutex........................ 945
tunables, datacachesize..................... 946
tunables, elision.............................. 944
tunables, hwcap............................... 946
tunables, hwcaps.............................. 946
tunables, malloc.............................. 941
tunables, nontemporalthreshold............. 946
tunables, sharedcachesize................... 946
type measurements, floating................... 959
type measurements, integer................... 957
type modifier character (printf).............. 290
type modifier character (scanf)............... 312
typeahead buffer.............................. 504
TZenvironment variable....................... 796

U

UCS-2........................................ 140
UCS-4........................................ 140
ulps.......................................... 556
umask........................................ 436
unbuffered stream............................ 328
unconstrained memory allocation............... 45
undefining macros that shadow functions....... 13
underflow exception........................... 607
Unicode...................................... 140
Unix, Berkeley................................. 11

```
Unix, System V................................ 11
unlinking a file................................ 422
unordered comparison........................ 628
unreading characters.......................... 285
Unsafe Features................................. 4
upper-case character....................... 87 , 93
urgent data signal............................ 721
urgent socket condition....................... 491
usage limits................................... 685
usage messages, in argp....................... 776
user accounting database...................... 856
user database................................. 864
user ID....................................... 845
user ID, determining.......................... 855
user name.................................... 845
user signals................................... 723
usual file name errors......................... 264
UTF-16...................................... 140
UTF-7........................................ 143
UTF-8................................... 140 , 143
```
```
V
vacopy....................................... 107
Value too large for defined data type........... 33
variable number of arguments................. 950
variable substitution.......................... 254
variable-sized arrays........................... 76
variadic function argument access............. 952
variadic function prototypes................... 951
variadic functions............................. 950
variadic functions, calling..................... 953
virtual time alarm signal...................... 720
virtual timer.................................. 679
volatiledeclarations......................... 737
```
```
W
waiting for a signal........................... 753
waiting for completion of child process........ 809
waiting for input or output.................... 366
WERASE character.......................... 518
whitespace character....................... 88 , 93
wide character................................ 140
wide string................................. 97 , 98
width of integer type.......................... 957
wildcard expansion........................... 254
wintt......................................... 99
word expansion............................... 254
working directory............................. 402
write lock..................................... 393
writing to a file descriptor.................... 347
writing to a socket............................ 485
writing to a stream, by blocks................. 287
writing to a stream, by characters............. 277
writing to a stream, formatted................ 288
Wrong medium type........................... 35
```

Concept Index 1153

Y
You really blew it this time.................... 32
YP........................................... 875
YP domain name........................ 875 , 876

```
Z
zero divide.................................... 607
```

### 1154

## Type Index...........................................

__ftw_func_t................................ 414
__ftw64_func_t.............................. 414
__nftw_func_t............................... 415
__nftw64_func_t............................. 415

B

blkcnt_t..................................... 429
blkcnt64_t................................... 429

C

cc_t.......................................... 506
clock_t...................................... 647
clockid_t.................................... 652
cnd_t......................................... 926
comparison_fn_t............................. 228
cookie_close_function_t.................... 336
cookie_io_functions_t...................... 335
cookie_read_function_t..................... 336
cookie_seek_function_t..................... 336
cookie_write_function_t.................... 336
cpu_set_t.................................... 699

D

dev_t......................................... 429
DIR........................................... 406
div_t......................................... 602

E

enum mcheck_status........................... 53

F

fd_set....................................... 367
FILE.......................................... 266
fpos_t....................................... 327
fpos64_t..................................... 327

```
G
gid_t......................................... 847
glibc.cpu.................................... 946
glibc.cpu.cached_memopt.................... 946
glibc.cpu.hwcap_mask....................... 946
glibc.cpu.hwcaps............................ 946
glibc.cpu.name.............................. 946
glibc.cpu.x86_data_cache_size............. 946
glibc.cpu.x86_ibt........................... 947
glibc.cpu.x86_non_temporal_threshold..... 946
glibc.cpu.x86_rep_movsb_threshold........ 947
glibc.cpu.x86_rep_stosb_threshold........ 947
glibc.cpu.x86_shared_cache_size........... 946
glibc.cpu.x86_shstk........................ 947
glibc.elision............................... 944
glibc.elision.enable....................... 944
glibc.elision.skip_lock_after_retries.... 945
glibc.elision.skip_lock_busy.............. 944
glibc.elision.skip_lock_internal_abort... 945
glibc.elision.skip_trylock_
internal_abort............................ 945
glibc.elision.tries........................ 945
glibc.malloc................................ 941
glibc.malloc.arena_max..................... 943
glibc.malloc.arena_test.................... 942
glibc.malloc.check.......................... 941
glibc.malloc.mmap_max...................... 942
glibc.malloc.mmap_threshold............... 942
glibc.malloc.mxfast........................ 943
glibc.malloc.perturb....................... 942
glibc.malloc.tcache_count.................. 943
glibc.malloc.tcache_max.................... 943
glibc.malloc.tcache_unsorted_limit....... 943
glibc.malloc.top_pad....................... 941
glibc.malloc.trim_threshold............... 942
glibc.mem.................................... 947
glibc.mem.tagging........................... 947
glibc.pthread............................... 945
glibc.pthread.mutex_spin_count............ 945
glibc.rtld................................... 943
glibc.rtld.nns.............................. 944
glibc.rtld.optional_static_tls............ 944
glob_t....................................... 241
glob64_t..................................... 243
```
```
I
iconv_t...................................... 163
imaxdiv_t.................................... 604
ino_t......................................... 428
ino64_t...................................... 429
```

Type Index 1155

J
jmp_buf...................................... 706

L
ldiv_t....................................... 603
lldiv_t...................................... 603
longjmp...................................... 939
longjmp_target.............................. 939

M
mbstate_t.................................... 145
memory_arena_new............................ 935
memory_arena_retry.......................... 935
memory_arena_reuse.......................... 935
memory_arena_reuse_free_list.............. 936
memory_arena_reuse_wait.................... 935
memory_calloc_retry........................ 934
memory_heap_free............................ 934
memory_heap_less............................ 934
memory_heap_more............................ 934
memory_heap_new............................. 934
memory_malloc_retry........................ 934
memory_mallopt.............................. 936
memory_mallopt_arena_max................... 937
memory_mallopt_arena_test.................. 936
memory_mallopt_free_dyn_thresholds....... 937
memory_mallopt_mmap_max.................... 936
memory_mallopt_mmap_threshold............. 936
memory_mallopt_mxfast...................... 936
memory_mallopt_perturb..................... 936
memory_mallopt_top_pad..................... 936
memory_mallopt_trim_threshold............. 936
memory_memalign_retry...................... 934
memory_realloc_retry....................... 934
memory_sbrk_less............................ 934
memory_sbrk_more............................ 934
memory_tcache_double_free.................. 937
memory_tunable_tcache_count............... 937
memory_tunable_tcache_max_bytes........... 937
memory_tunable_tcache_unsorted_limit..... 937
mode_t....................................... 428
mtx_t......................................... 924

N
nlink_t...................................... 429

O

off_t......................................... 352
off64_t...................................... 352
once_flag.................................... 923

```
P
pid_t......................................... 805
printf_arginfo_function.................... 308
printf_function............................. 308
ptrdiff_t.................................... 956
```
```
R
regex_t...................................... 249
regmatch_t................................... 252
regoff_t..................................... 252
```
```
S
setjmp....................................... 939
sig_atomic_t................................ 740
sighandler_t................................ 725
sigjmp_buf................................... 707
sigset_t..................................... 747
size_t....................................... 956
slowatan..................................... 938
slowatan_inexact............................ 938
slowatan2.................................... 937
slowatan2_inexact........................... 938
slowcos...................................... 938
slowcos_dx................................... 938
slowsin...................................... 938
slowsin_dx................................... 938
slowtan...................................... 938
speed_t...................................... 516
ssize_t...................................... 345
stack_t...................................... 755
struct __gconv_step......................... 172
struct __gconv_step_data................... 173
struct aiocb................................. 371
struct aiocb64............................... 372
struct aioinit............................... 382
struct argp.................................. 769
struct argp_child........................... 778
struct argp_option.......................... 770
struct argp_state........................... 775
struct crypt_data........................... 914
struct dirent................................ 404
struct ENTRY................................. 233
struct exit_status.......................... 856
struct flock................................. 393
struct fstab................................. 879
struct FTW................................... 415
struct group................................. 868
struct hostent............................... 470
struct if_nameindex......................... 460
struct in_addr............................... 467
struct in6_addr............................. 467
struct iovec................................. 355
struct itimerval............................ 680
struct lconv................................. 189
struct linger................................ 500
struct mallinfo2............................. 56
```

Type Index 1156

struct mntent................................ 882
struct netent................................ 501
struct ntptimeval........................... 654
struct obstack................................ 64
struct option................................ 764
struct passwd................................ 864
struct printf_info.......................... 306
struct protoent............................. 477
struct random_data.......................... 594
struct rlimit................................ 687
struct rlimit64............................. 687
struct rusage................................ 684
struct sched_param.......................... 693
struct servent............................... 474
struct sgttyb................................ 522
struct sigaction............................ 727
struct sigstack............................. 757
struct sockaddr............................. 458
struct sockaddr_in.......................... 464
struct sockaddr_in6......................... 464
struct sockaddr_un.......................... 462
struct stat.................................. 425
struct stat64................................ 427
struct termios............................... 505
struct timespec............................. 647
struct timeval............................... 647
struct timex................................. 655
struct tm................................ 648 , 659
struct tms................................... 650
struct utimbuf............................... 440

```
struct utmp.................................. 856
struct utmpx................................. 861
struct utsname............................... 877
```
```
T
tcflag_t..................................... 506
thrd_start_t................................ 921
thrd_t....................................... 921
time_t....................................... 647
tss_dtor_t................................... 927
tss_t......................................... 927
```
```
U
ucontext_t................................... 708
uid_t......................................... 847
```
```
V
va_list...................................... 953
VISIT......................................... 237
```
```
W
wchar_t...................................... 141
wctrans_t..................................... 95
wctype_t...................................... 90
wint_t....................................... 141
wordexp_t.................................... 255
```

### 1157

## Function and Macro Index...............................

*
*pthread_getspecific....................... 929
*sbrk.......................................... 77
*sem_open.................................... 815

__fbufsize................................... 332
__flbf....................................... 332
__fpending................................... 332
__fpurge..................................... 330
__freadable.................................. 270
__freading................................... 270
__fsetlocking............................... 274
__fwritable.................................. 270
__fwriting................................... 271
__ppc_get_timebase........................ 1108
__ppc_get_timebase_freq................... 1108
__ppc_mdoio................................. 1108
__ppc_mdoom................................. 1109
__ppc_set_ppr_low.......................... 1109
__ppc_set_ppr_med.......................... 1109
__ppc_set_ppr_med_high.................... 1109
__ppc_set_ppr_med_low..................... 1109
__ppc_set_ppr_very_low.................... 1109
__ppc_yield................................. 1108
__riscv_flush_icache...................... 1110
__va_copy.................................... 954
__x86_get_cpuid_feature_leaf............. 1110
_exit......................................... 801
_Exit......................................... 802
_flushlbf.................................... 329
_tolower...................................... 90
_toupper...................................... 90

A
a64l.......................................... 134
abort......................................... 801
abs........................................... 617
accept....................................... 484
access....................................... 439
acos.......................................... 543
acosf......................................... 543
acosfN....................................... 543
acosfNx...................................... 543
acosh......................................... 552
acoshf....................................... 552
acoshfN...................................... 552
acoshfNx..................................... 552
acoshl....................................... 552
acosl......................................... 543
addmntent.................................... 884
addseverity.................................. 339

```
adjtime...................................... 657
adjtimex..................................... 658
aio_cancel................................... 381
aio_cancel64................................ 382
aio_error.................................... 378
aio_error64.................................. 378
aio_fsync.................................... 379
aio_fsync64.................................. 380
aio_init..................................... 383
aio_read..................................... 373
aio_read64................................... 374
aio_return................................... 378
aio_return64................................ 379
aio_suspend.................................. 380
aio_suspend64............................... 381
aio_write.................................... 375
aio_write64.................................. 376
alarm......................................... 681
aligned_alloc................................ 49
alloca......................................... 75
alphasort.................................... 411
alphasort64.................................. 412
argp_error................................... 777
argp_failure................................ 777
argp_help.................................... 780
argp_parse................................... 768
argp_state_help............................. 777
argp_usage................................... 776
argz_add..................................... 136
argz_add_sep................................ 136
argz_append.................................. 136
argz_count................................... 136
argz_create.................................. 135
argz_create_sep............................. 135
argz_delete.................................. 137
argz_extract................................ 136
argz_insert.................................. 137
argz_next.................................... 137
argz_replace................................ 137
argz_stringify.............................. 136
asctime...................................... 662
asctime_r.................................... 662
asin.......................................... 542
asinf......................................... 542
asinfN....................................... 542
asinfNx...................................... 542
asinh......................................... 551
asinhf....................................... 551
asinhfN...................................... 551
asinhfNx..................................... 551
asinhl....................................... 551
asinl......................................... 542
asprintf..................................... 299
assert....................................... 949
assert_perror............................... 950
```

Function and Macro Index 1158

atan.......................................... 543
atan2......................................... 543
atan2f....................................... 543
atan2fN...................................... 543
atan2fNx..................................... 543
atan2l....................................... 543
atanf......................................... 543
atanfN....................................... 543
atanfNx...................................... 543
atanh......................................... 552
atanhf....................................... 552
atanhfN...................................... 552
atanhfNx..................................... 552
atanhl....................................... 552
atanl......................................... 543
atexit....................................... 800
atof.......................................... 642
atoi.......................................... 639
atol.......................................... 639
atoll......................................... 639

B
backtrace.................................... 918
backtrace_symbols........................... 918
backtrace_symbols_fd....................... 919
basename................................ 129 , 130
bcmp.......................................... 117
bcopy......................................... 106
bind.......................................... 459
bind_textdomain_codeset.................... 221
bindtextdomain.............................. 216
brk............................................ 77
bsearch...................................... 229
btowc......................................... 147
bzero......................................... 106

C
cabs.......................................... 618
cabsf......................................... 618
cabsfN....................................... 618
cabsfNx...................................... 618
cabsl......................................... 618
cacos......................................... 544
cacosf....................................... 544
cacosfN...................................... 544
cacosfNx..................................... 544
cacosh....................................... 552
cacoshf...................................... 552
cacoshfN..................................... 552
cacoshfNx.................................... 552
cacoshl...................................... 552
cacosl....................................... 544
call_once.................................... 923
calloc......................................... 49
canonicalize................................ 627
canonicalize_file_name..................... 421

```
canonicalizef............................... 627
canonicalizefN.............................. 627
canonicalizefNx............................. 627
canonicalizel............................... 627
carg.......................................... 634
cargf......................................... 634
cargfN....................................... 634
cargfNx...................................... 635
cargl......................................... 634
casin......................................... 544
casinf....................................... 544
casinfN...................................... 544
casinfNx..................................... 544
casinh....................................... 552
casinhf...................................... 552
casinhfN..................................... 552
casinhfNx.................................... 552
casinhl...................................... 552
casinl....................................... 544
catan......................................... 544
catanf....................................... 544
catanfN...................................... 544
catanfNx..................................... 544
catanh....................................... 552
catanhf...................................... 552
catanhfN..................................... 552
catanhfNx.................................... 552
catanhl...................................... 552
catanl....................................... 544
catclose..................................... 206
catgets...................................... 206
catopen...................................... 203
cbrt.......................................... 548
cbrtf......................................... 548
cbrtfN....................................... 548
cbrtfNx...................................... 548
cbrtl......................................... 548
ccos.......................................... 542
ccosf......................................... 542
ccosfN....................................... 542
ccosfNx...................................... 542
ccosh......................................... 551
ccoshf....................................... 551
ccoshfN...................................... 551
ccoshfNx..................................... 551
ccoshl....................................... 551
ccosl......................................... 542
ceil.......................................... 620
ceilf......................................... 620
ceilfN....................................... 620
ceilfNx...................................... 620
ceill......................................... 620
cexp.......................................... 549
cexpf......................................... 549
cexpfN....................................... 549
cexpfNx...................................... 549
cexpl......................................... 549
cfgetispeed.................................. 515
```

Function and Macro Index 1159

cfgetospeed.................................. 515
cfmakeraw.................................... 522
cfsetispeed.................................. 516
cfsetospeed.................................. 515
cfsetspeed................................... 516
chdir......................................... 403
chmod.................................... 436 , 437
chown......................................... 433
cimag......................................... 634
cimagf....................................... 634
cimagfN...................................... 634
cimagfNx..................................... 634
cimagl....................................... 634
clearenv..................................... 794
clearerr..................................... 322
clearerr_unlocked........................... 322
clock......................................... 650
clock_getres................................ 652
clock_gettime............................... 652
clock_settime............................... 653
clog.......................................... 549
clog10....................................... 549
clog10f...................................... 549
clog10fN..................................... 549
clog10fNx.................................... 549
clog10l...................................... 549
clogf......................................... 549
clogfN....................................... 549
clogfNx...................................... 549
clogl......................................... 549
close......................................... 344
closedir..................................... 409
closelog..................................... 536
cnd_broadcast............................... 926
cnd_destroy.................................. 927
cnd_init..................................... 926
cnd_signal................................... 926
cnd_timedwait............................... 926
cnd_wait..................................... 926
confstr...................................... 909
conj.......................................... 634
conjf......................................... 634
conjfN....................................... 634
conjfNx...................................... 634
conjl......................................... 634
connect...................................... 482
continue..................................... 837
copy_file_range............................. 359
copysign..................................... 625
copysignf.................................... 625
copysignfN................................... 625
copysignfNx.................................. 625
copysignl.................................... 625
cos........................................... 540
cosf.......................................... 540
cosfN......................................... 541
cosfNx....................................... 541
cosh.......................................... 550

```
coshf......................................... 550
coshfN....................................... 550
coshfNx...................................... 550
coshl......................................... 550
cosl.......................................... 540
cpow.......................................... 550
cpowf......................................... 550
cpowfN....................................... 550
cpowfNx...................................... 550
cpowl......................................... 550
cproj......................................... 635
cprojf....................................... 635
cprojfN...................................... 635
cprojfNx..................................... 635
cprojl....................................... 635
CPU_CLR...................................... 700
CPU_FEATURE_USABLE........................ 1110
CPU_ISSET.................................... 700
CPU_SET...................................... 700
CPU_ZERO..................................... 700
creal......................................... 634
crealf....................................... 634
crealfN...................................... 634
crealfNx..................................... 634
creall....................................... 634
creat......................................... 343
creat64...................................... 344
crypt......................................... 912
crypt_r...................................... 914
csin.......................................... 541
csinf......................................... 541
csinfN....................................... 541
csinfNx...................................... 541
csinh......................................... 551
csinhf....................................... 551
csinhfN...................................... 551
csinhfNx..................................... 551
csinhl....................................... 551
csinl......................................... 541
csqrt......................................... 549
csqrtf....................................... 549
csqrtfN...................................... 549
csqrtfNx..................................... 549
csqrtl....................................... 549
ctan.......................................... 542
ctanf......................................... 542
ctanfN....................................... 542
ctanfNx...................................... 542
ctanh......................................... 551
ctanhf....................................... 551
ctanhfN...................................... 551
ctanhfNx..................................... 551
ctanhl....................................... 551
ctanl......................................... 542
ctermid...................................... 831
ctime......................................... 662
ctime_r...................................... 662
cuserid...................................... 855
```

Function and Macro Index 1160

D
daddl......................................... 632
dcgettext.................................... 214
dcngettext................................... 218
ddivl......................................... 633
dgettext..................................... 214
difftime..................................... 648
dirfd......................................... 407
dirname...................................... 130
div........................................... 603
dmull......................................... 632
dngettext.................................... 218
drand48...................................... 595
drand48_r.................................... 597
drem.......................................... 625
dremf......................................... 625
dreml......................................... 625
dsubl......................................... 632
DTTOIF....................................... 405
dup........................................... 384
dup2.......................................... 385

E
ecvt.......................................... 643
ecvt_r....................................... 645
endfsent..................................... 881
endgrent..................................... 871
endhostent................................... 473
endmntent.................................... 884
endnetent.................................... 502
endnetgrent.................................. 874
endprotoent.................................. 478
endpwent..................................... 867
endservent................................... 475
endutent..................................... 858
endutxent.................................... 862
envz_add..................................... 138
envz_entry................................... 138
envz_get..................................... 138
envz_merge................................... 138
envz_remove.................................. 139
envz_strip................................... 139
erand48...................................... 595
erand48_r.................................... 597
erf........................................... 553
erfc.......................................... 553
erfcf......................................... 553
erfcfN....................................... 553
erfcfNx...................................... 553
erfcl......................................... 553
erff.......................................... 553
erffN......................................... 553
erffNx....................................... 553
erfl.......................................... 553
err............................................ 41
error.......................................... 38
error_at_line................................ 39

```
errx........................................... 41
execl......................................... 807
execle....................................... 807
execlp....................................... 808
execv......................................... 807
execve....................................... 807
execvp....................................... 808
exit.......................................... 799
exp........................................... 544
exp10......................................... 545
exp10f....................................... 545
exp10fN...................................... 545
exp10fNx..................................... 545
exp10l....................................... 545
exp2.......................................... 544
exp2f......................................... 544
exp2fN....................................... 545
exp2fNx...................................... 545
exp2l......................................... 544
expf.......................................... 544
expfN......................................... 544
expfNx....................................... 544
expl.......................................... 544
explicit_bzero.............................. 132
expm1......................................... 548
expm1f....................................... 548
expm1fN...................................... 548
expm1fNx..................................... 548
expm1l....................................... 548
```
```
F
fabs.......................................... 618
fabsf......................................... 618
fabsfN....................................... 618
fabsfNx...................................... 618
fabsl......................................... 618
fadd.......................................... 632
faddl......................................... 632
fchdir....................................... 404
fchmod....................................... 438
fchown....................................... 434
fclose....................................... 271
fcloseall.................................... 271
fcntl......................................... 383
fcvt.......................................... 644
fcvt_r....................................... 645
FD_CLR....................................... 367
FD_ISSET..................................... 367
FD_SET....................................... 367
FD_ZERO...................................... 367
fdatasync.................................... 370
fdim.......................................... 631
fdimf......................................... 631
fdimfN....................................... 631
fdimfNx...................................... 631
fdiml......................................... 631
fdiv.......................................... 633
```

Function and Macro Index 1161

fdivl......................................... 633
fdopen....................................... 352
fdopendir.................................... 406
feclearexcept............................... 611
fedisableexcept............................. 617
feenableexcept.............................. 617
fegetenv..................................... 615
fegetexcept.................................. 617
fegetexceptflag............................. 612
fegetmode.................................... 616
fegetround................................... 614
feholdexcept................................ 615
feof.......................................... 321
feof_unlocked............................... 321
feraiseexcept............................... 611
ferror....................................... 321
ferror_unlocked............................. 321
fesetenv..................................... 616
fesetexcept.................................. 611
fesetexceptflag............................. 612
fesetmode.................................... 616
fesetround................................... 614
fetestexcept................................ 611
fetestexceptflag............................ 612
feupdateenv.................................. 616
fexecve...................................... 807
fflush....................................... 329
fflush_unlocked............................. 329
fgetc......................................... 280
fgetc_unlocked.............................. 280
fgetgrent.................................... 869
fgetgrent_r.................................. 870
fgetpos...................................... 327
fgetpos64.................................... 327
fgetpwent.................................... 866
fgetpwent_r.................................. 866
fgets......................................... 284
fgets_unlocked.............................. 284
fgetwc....................................... 280
fgetwc_unlocked............................. 281
fgetws....................................... 284
fgetws_unlocked............................. 285
fileno....................................... 353
fileno_unlocked............................. 353
finite....................................... 607
finitef...................................... 607
finitel...................................... 607
flockfile.................................... 272
floor......................................... 621
floorf....................................... 621
floorfN...................................... 621
floorfNx..................................... 621
floorl....................................... 621
fma........................................... 631
fMaddfN...................................... 632
fMaddfNx..................................... 632
fmaf.......................................... 631
fmafN......................................... 631

```
fmafNx....................................... 632
fmal.......................................... 631
fmax.......................................... 631
fmaxf......................................... 631
fmaxfN....................................... 631
fmaxfNx...................................... 631
fmaxl......................................... 631
fmaxmag...................................... 631
fmaxmagf..................................... 631
fmaxmagfN.................................... 631
fmaxmagfNx................................... 631
fmaxmagl..................................... 631
fMdivfN...................................... 633
fMdivfNx..................................... 633
fmemopen..................................... 333
fmin.......................................... 630
fminf......................................... 630
fminfN....................................... 630
fminfNx...................................... 630
fminl......................................... 630
fminmag...................................... 631
fminmagf..................................... 631
fminmagfN.................................... 631
fminmagfNx................................... 631
fminmagl..................................... 631
fMmulfN...................................... 632
fMmulfNx..................................... 632
fmod.......................................... 624
fmodf......................................... 624
fmodfN....................................... 624
fmodfNx...................................... 624
fmodl......................................... 624
fMsubfN...................................... 632
fMsubfNx..................................... 632
fmtmsg....................................... 337
fmul.......................................... 632
fmull......................................... 632
fMxaddfN..................................... 632
fMxaddfNx.................................... 632
fMxdivfN..................................... 633
fMxdivfNx.................................... 633
fMxmulfN..................................... 633
fMxmulfNx.................................... 633
fMxsubfN..................................... 632
fMxsubfNx.................................... 632
fnmatch...................................... 239
fopen......................................... 267
fopen64...................................... 269
fopencookie.................................. 335
fork.......................................... 805
forkpty...................................... 530
fpathconf.................................... 907
fpclassify................................... 605
fprintf...................................... 297
fputc......................................... 277
fputc_unlocked.............................. 277
fputs......................................... 279
fputs_unlocked.............................. 279
```

Function and Macro Index 1162

fputwc....................................... 277
fputwc_unlocked............................. 277
fputws....................................... 279
fputws_unlocked............................. 279
fread......................................... 287
fread_unlocked.............................. 287
free........................................... 47
freopen...................................... 269
freopen64.................................... 270
frexp......................................... 618
frexpf....................................... 618
frexpfN...................................... 618
frexpfNx..................................... 618
frexpl....................................... 618
fromfp....................................... 623
fromfpf...................................... 623
fromfpfN..................................... 623
fromfpfNx.................................... 623
fromfpl...................................... 623
fromfpx...................................... 623
fromfpxf..................................... 623
fromfpxfN.................................... 623
fromfpxfNx................................... 623
fromfpxl..................................... 623
fscanf....................................... 318
fseek......................................... 324
fseeko....................................... 324
fseeko64..................................... 325
fsetpos...................................... 327
fsetpos64.................................... 328
fstat......................................... 430
fstat64...................................... 430
fsub.......................................... 632
fsubl......................................... 632
fsync......................................... 370
ftell......................................... 323
ftello....................................... 324
ftello64..................................... 324
ftruncate.................................... 443
ftruncate64.................................. 443
ftrylockfile................................ 272
ftw........................................... 415
ftw64......................................... 416
funlockfile.................................. 273
futimes...................................... 441
fwide......................................... 276
fwprintf..................................... 297
fwrite....................................... 287
fwrite_unlocked............................. 288
fwscanf...................................... 319

```
G
gamma......................................... 554
gammaf....................................... 554
gammal....................................... 554
gcvt.......................................... 644
get_avphys_pages............................ 703
get_current_dir_name....................... 403
get_nprocs................................... 704
get_nprocs_conf............................. 704
get_phys_pages.............................. 703
getauxval.................................... 797
getc.......................................... 281
getc_unlocked............................... 281
getchar...................................... 281
getchar_unlocked............................ 282
getcontext................................... 709
getcpu....................................... 701
getcwd....................................... 402
getdate...................................... 674
getdate_r.................................... 675
getdelim..................................... 283
getdents64................................... 413
getdomainnname.............................. 876
getegid...................................... 847
getentropy................................... 916
getenv....................................... 793
geteuid...................................... 847
getfsent..................................... 881
getfsfile.................................... 881
getfsspec.................................... 881
getgid....................................... 847
getgrent..................................... 870
getgrent_r................................... 870
getgrgid..................................... 868
getgrgid_r................................... 869
getgrnam..................................... 869
getgrnam_r................................... 869
getgrouplist................................ 851
getgroups.................................... 847
gethostbyaddr............................... 471
gethostbyaddr_r............................. 473
gethostbyname............................... 470
gethostbyname_r............................. 471
gethostbyname2.............................. 471
gethostbyname2_r............................ 472
gethostent................................... 473
gethostid.................................... 877
gethostname.................................. 875
getitimer.................................... 681
getline...................................... 283
getloadavg................................... 704
getlogin..................................... 855
getmntent.................................... 884
getmntent_r.................................. 884
getnetbyaddr................................ 502
getnetbyname................................ 502
getnetent.................................... 502
getnetgrent.................................. 873
```

Function and Macro Index 1163

getnetgrent_r............................... 873
getopt....................................... 761
getopt_long.................................. 765
getopt_long_only............................ 765
getpagesize.................................. 703
getpass...................................... 526
getpayload................................... 627
getpayloadf.................................. 627
getpayloadfN................................ 627
getpayloadfNx............................... 627
getpayloadl.................................. 627
getpeername.................................. 485
getpgid...................................... 832
getpgrp...................................... 832
getpid....................................... 805
getppid...................................... 805
getpriority.................................. 697
getprotobyname.............................. 477
getprotobynumber............................ 477
getprotoent.................................. 478
getpt......................................... 528
getpwent..................................... 867
getpwent_r................................... 867
getpwnam..................................... 866
getpwnam_r................................... 866
getpwuid..................................... 865
getpwuid_r................................... 865
getrandom.................................... 917
getrlimit.................................... 686
getrlimit64.................................. 686
getrusage.................................... 684
gets.......................................... 285
getservbyname............................... 475
getservbyport............................... 475
getservent................................... 475
getsid....................................... 832
getsockname.................................. 459
getsockopt................................... 499
getsubopt.................................... 790
gettext...................................... 213
gettid....................................... 805
gettimeofday................................ 653
getuid....................................... 847
getumask..................................... 437
getutent..................................... 858
getutent_r................................... 859
getutid...................................... 858
getutid_r.................................... 859
getutline.................................... 858
getutline_r.................................. 860
getutmp...................................... 863
getutmpx..................................... 863
getutxent.................................... 862
getutxid..................................... 862
getutxline................................... 862
getw.......................................... 282
getwc......................................... 281
getwc_unlocked.............................. 281

```
getwchar..................................... 281
getwchar_unlocked........................... 282
getwd......................................... 403
glob.......................................... 244
glob64....................................... 245
globfree..................................... 248
globfree64................................... 248
gmtime....................................... 660
gmtime_r..................................... 661
grantpt................................ 528 , 1091
gsignal...................................... 742
gtty.......................................... 523
```
```
H
HAS_CPU_FEATURE............................ 1110
hasmntopt.................................... 885
hcreate...................................... 233
hcreate_r.................................... 234
hdestroy..................................... 233
hdestroy_r................................... 235
hsearch...................................... 234
hsearch_r.................................... 235
htonl......................................... 476
htons......................................... 476
hypot......................................... 548
hypotf....................................... 548
hypotfN...................................... 548
hypotfNx..................................... 548
hypotl....................................... 548
```
```
I
iconv......................................... 164
iconv_close.................................. 164
iconv_open................................... 163
if_freenameindex............................ 461
if_indextoname.............................. 460
if_nameindex................................ 461
if_nametoindex.............................. 460
IFTODT....................................... 405
ilogb......................................... 546
ilogbf....................................... 546
ilogbfN...................................... 546
ilogbfNx..................................... 546
ilogbl....................................... 546
imaxabs...................................... 617
imaxdiv...................................... 604
index......................................... 126
inet_addr.................................... 468
inet_aton.................................... 468
inet_lnaof................................... 469
inet_makeaddr............................... 469
inet_netof................................... 469
inet_network................................ 468
inet_ntoa.................................... 468
inet_ntop.................................... 469
inet_pton.................................... 469
```

Function and Macro Index 1164

initgroups................................... 850
initstate.................................... 593
initstate_r.................................. 594
innetgr...................................... 874
ioctl......................................... 401
isalnum....................................... 88
isalpha....................................... 87
isascii....................................... 89
isatty....................................... 503
isblank....................................... 88
iscanonical.................................. 605
iscntrl....................................... 89
isdigit....................................... 88
iseqsig...................................... 629
isfinite..................................... 606
isgraph....................................... 89
isgreater.................................... 628
isgreaterequal.............................. 629
isinf......................................... 606
isinff....................................... 606
isinfl....................................... 606
isless....................................... 629
islessequal.................................. 629
islessgreater............................... 629
islower....................................... 87
isnan.................................... 606 , 607
isnanf....................................... 607
isnanl....................................... 607
isnormal..................................... 606
isprint....................................... 89
ispunct....................................... 88
issignaling.................................. 606
isspace....................................... 88
issubnormal.................................. 606
isunordered.................................. 629
isupper....................................... 87
iswalnum...................................... 91
iswalpha...................................... 91
iswblank...................................... 94
iswcntrl...................................... 92
iswctype...................................... 91
iswdigit...................................... 92
iswgraph...................................... 92
iswlower...................................... 92
iswprint...................................... 93
iswpunct...................................... 93
iswspace...................................... 93
iswupper...................................... 93
iswxdigit..................................... 94
isxdigit...................................... 88
iszero....................................... 606

```
J
j0............................................ 554
j0f........................................... 554
j0fN.......................................... 554
j0fNx......................................... 554
j0l........................................... 554
j1............................................ 555
j1f........................................... 555
j1fN.......................................... 555
j1fNx......................................... 555
j1l........................................... 555
jn............................................ 555
jnf........................................... 555
jnfN.......................................... 555
jnfNx......................................... 555
jnl........................................... 555
jrand48...................................... 596
jrand48_r.................................... 598
```
```
K
kill.......................................... 743
killpg....................................... 744
```
```
L
l64a.......................................... 133
labs.......................................... 617
lcong48...................................... 597
lcong48_r.................................... 599
ldexp......................................... 619
ldexpf....................................... 619
ldexpfN...................................... 619
ldexpfNx..................................... 619
ldexpl....................................... 619
ldiv.......................................... 603
lfind......................................... 228
lgamma....................................... 553
lgamma_r..................................... 554
lgammaf...................................... 553
lgammaf_r.................................... 554
lgammafN..................................... 553
lgammafN_r................................... 554
lgammafNx.................................... 553
lgammafNx_r.................................. 554
lgammal...................................... 553
lgammal_r.................................... 554
link.......................................... 418
linkat....................................... 419
lio_listio................................... 376
lio_listio64................................ 377
listen....................................... 483
llabs......................................... 617
lldiv......................................... 603
llogb......................................... 546
llogbf....................................... 546
llogbfN...................................... 546
llogbfNx..................................... 546
```

Function and Macro Index 1165

llogbl....................................... 546
llrint....................................... 622
llrintf...................................... 622
llrintfN..................................... 622
llrintfNx.................................... 622
llrintl...................................... 622
llround...................................... 623
llroundf..................................... 623
llroundfN.................................... 623
llroundfNx................................... 623
llroundl..................................... 623
localeconv................................... 189
localtime.................................... 660
localtime_r.................................. 660
log........................................... 545
log10......................................... 545
log10f....................................... 545
log10fN...................................... 545
log10fNx..................................... 545
log10l....................................... 545
log1p......................................... 548
log1pf....................................... 548
log1pfN...................................... 548
log1pfNx..................................... 548
log1pl....................................... 548
log2.......................................... 545
log2f......................................... 545
log2fN....................................... 545
log2fNx...................................... 545
log2l......................................... 545
logb.......................................... 546
logbf......................................... 546
logbfN....................................... 546
logbfNx...................................... 546
logbl......................................... 546
logf.......................................... 545
logfN......................................... 545
logfNx....................................... 545
login......................................... 863
login_tty.................................... 863
logl.......................................... 545
logout....................................... 864
logwtmp...................................... 864
longjmp...................................... 706
lrand48...................................... 595
lrand48_r.................................... 598
lrint......................................... 622
lrintf....................................... 622
lrintfN...................................... 622
lrintfNx..................................... 622
lrintl....................................... 622
lround....................................... 622
lroundf...................................... 622
lroundfN..................................... 622
lroundfNx.................................... 622
lroundl...................................... 622
lsearch...................................... 229
lseek......................................... 350

```
lseek64...................................... 351
lstat......................................... 430
lstat64...................................... 430
lutimes...................................... 441
```
```
M
madvise...................................... 364
main.......................................... 759
makecontext.................................. 709
mallinfo2..................................... 57
malloc......................................... 46
mallopt....................................... 51
mblen......................................... 159
mbrlen....................................... 150
mbrtowc...................................... 148
mbsinit...................................... 146
mbsnrtowcs................................... 155
mbsrtowcs.................................... 153
mbstowcs..................................... 160
mbtowc....................................... 158
mcheck......................................... 53
memalign...................................... 50
memccpy...................................... 103
memchr....................................... 121
memcmp....................................... 113
memcpy....................................... 101
memfd_create................................ 365
memfrob...................................... 133
memmem....................................... 125
memmove...................................... 103
mempcpy...................................... 102
memrchr...................................... 122
memset....................................... 104
merge......................................... 838
mkdir......................................... 424
mkdtemp...................................... 449
mkfifo....................................... 453
mknod......................................... 445
mkstemp...................................... 448
mktemp....................................... 448
mktime....................................... 661
mlock.......................................... 84
mlock2......................................... 84
mlockall...................................... 85
mmap.......................................... 360
mmap64....................................... 362
modf.......................................... 623
modff......................................... 623
modffN....................................... 623
modffNx...................................... 623
modfl......................................... 623
mount......................................... 885
mprobe......................................... 53
mprotect...................................... 78
mrand48...................................... 596
mrand48_r.................................... 598
mremap....................................... 363
```

Function and Macro Index 1166

msync......................................... 363
mtrace......................................... 59
mtx_destroy.................................. 925
mtx_init..................................... 924
mtx_lock..................................... 924
mtx_timedlock............................... 925
mtx_trylock.................................. 925
mtx_unlock................................... 925
munlock....................................... 85
munlockall.................................... 86
munmap....................................... 362
muntrace...................................... 59

N
nan........................................... 626
nanf.......................................... 626
nanfN......................................... 626
nanfNx....................................... 626
nanl.......................................... 626
nanosleep.................................... 682
nearbyint.................................... 621
nearbyintf................................... 621
nearbyintfN.................................. 621
nearbyintfNx................................ 621
nearbyintl................................... 621
nextafter.................................... 625
nextafterf................................... 625
nextafterfN.................................. 625
nextafterfNx................................ 625
nextafterl................................... 625
nextdown..................................... 626
nextdownf.................................... 626
nextdownfN................................... 626
nextdownfNx.................................. 626
nextdownl.................................... 626
nexttoward................................... 626
nexttowardf.................................. 626
nexttowardl.................................. 626
nextup....................................... 626
nextupf...................................... 626
nextupfN..................................... 626
nextupfNx.................................... 626
nextupl...................................... 626
nftw.......................................... 416
nftw64....................................... 417
ngettext..................................... 218
nice.......................................... 698
nl_langinfo.................................. 193
notfound..................................... 837
nrand48...................................... 595
nrand48_r.................................... 598
ntohl......................................... 476
ntohs......................................... 476
ntp_adjtime.................................. 657
ntp_gettime.................................. 655

```
O
obstack_1grow................................ 68
obstack_1grow_fast........................... 70
obstack_alignment_mask...................... 72
obstack_alloc................................ 65
obstack_base.................................. 71
obstack_blank................................ 68
obstack_blank_fast........................... 70
obstack_chunk_alloc.......................... 64
obstack_chunk_free........................... 64
obstack_chunk_size........................... 73
obstack_copy.................................. 66
obstack_copy0................................ 66
obstack_finish............................... 69
obstack_free.................................. 66
obstack_grow.................................. 68
obstack_grow0................................ 68
obstack_init.................................. 65
obstack_int_grow............................. 69
obstack_int_grow_fast....................... 70
obstack_next_free............................ 71
obstack_object_size...................... 69 , 71
obstack_printf.............................. 299
obstack_ptr_grow............................. 68
obstack_ptr_grow_fast....................... 70
obstack_room.................................. 70
obstack_vprintf............................. 301
offsetof..................................... 964
on_exit...................................... 800
open.......................................... 342
open_memstream.............................. 334
open64....................................... 343
opendir...................................... 406
openlog...................................... 532
openpty...................................... 530
```
```
P
parse_printf_format........................ 302
pathconf..................................... 906
pause......................................... 753
pclose....................................... 452
perror......................................... 36
pipe.......................................... 450
pkey_alloc.................................... 80
pkey_free..................................... 81
pkey_get...................................... 82
pkey_mprotect................................ 81
pkey_set...................................... 81
popen......................................... 452
posix_fallocate............................. 444
posix_fallocate64........................... 445
posix_memalign............................... 50
pow........................................... 547
powf.......................................... 547
powfN......................................... 547
powfNx....................................... 547
powl.......................................... 547
```

Function and Macro Index 1167

pread......................................... 346
pread64...................................... 347
preadv....................................... 356
preadv2...................................... 357
preadv64..................................... 356
preadv64v2................................... 358
printf....................................... 296
printf_size.................................. 310
printf_size_info............................ 310
psignal...................................... 724
pthread_attr_getsigmask_np................ 930
pthread_attr_setsigmask_np................ 929
pthread_clockjoin_np....................... 931
pthread_cond_clockwait..................... 930
pthread_getattr_default_np................ 929
pthread_key_create.......................... 928
pthread_key_delete.......................... 928
pthread_rwlock_clockrdlock................ 931
pthread_rwlock_clockwrlock................ 931
pthread_setattr_default_np................ 929
pthread_setspecific........................ 929
pthread_timedjoin_np....................... 931
pthread_tryjoin_np.......................... 931
ptsname...................................... 529
ptsname_r.................................... 529
putc.......................................... 278
putc_unlocked............................... 278
putchar...................................... 278
putchar_unlocked............................ 278
putenv....................................... 793
putpwent..................................... 867
puts.......................................... 279
pututline.................................... 859
pututxline................................... 863
putw.......................................... 280
putwc......................................... 278
putwc_unlocked.............................. 278
putwchar..................................... 278
putwchar_unlocked........................... 279
pwrite....................................... 349
pwrite64..................................... 349
pwritev...................................... 356
pwritev2..................................... 358
pwritev64.................................... 357
pwritev64v2.................................. 358

Q

qecvt......................................... 644
qecvt_r...................................... 645
qfcvt......................................... 644
qfcvt_r...................................... 645
qgcvt......................................... 645
qsort......................................... 229

```
R
raise......................................... 742
rand.......................................... 592
rand_r....................................... 592
random....................................... 593
random_r..................................... 594
rawmemchr.................................... 122
read.......................................... 345
readdir...................................... 407
readdir_r.................................... 408
readdir64.................................... 409
readdir64_r.................................. 409
readlink..................................... 420
readv......................................... 355
realloc....................................... 48
reallocarray.................................. 48
realpath..................................... 422
recv.......................................... 487
recvfrom..................................... 494
regcomp...................................... 249
regerror..................................... 253
regexec...................................... 251
regfree...................................... 253
register_printf_function................... 305
remainder.................................... 624
remainderf................................... 624
remainderfN.................................. 624
remainderfNx................................ 624
remainderl................................... 624
remove....................................... 423
rename....................................... 423
return....................................... 837
rewind....................................... 325
rewinddir.................................... 410
rindex....................................... 126
rint.......................................... 621
rintf......................................... 621
rintfN....................................... 621
rintfNx...................................... 621
rintl......................................... 621
rmdir......................................... 423
round......................................... 621
roundeven.................................... 622
roundevenf................................... 622
roundevenfN.................................. 622
roundevenfNx................................ 622
roundevenl................................... 622
roundf....................................... 621
roundfN...................................... 621
roundfNx..................................... 622
roundl....................................... 621
rpmatch...................................... 201
```

Function and Macro Index 1168

S
S_ISBLK...................................... 431
S_ISCHR...................................... 431
S_ISDIR...................................... 431
S_ISFIFO..................................... 431
S_ISLNK...................................... 432
S_ISREG...................................... 431
S_ISSOCK..................................... 432
S_TYPEISMQ................................... 432
S_TYPEISSEM.................................. 433
S_TYPEISSHM.................................. 433
scalb......................................... 619
scalbf....................................... 619
scalbl....................................... 619
scalbln...................................... 619
scalblnf..................................... 619
scalblnfN.................................... 619
scalblnfNx................................... 619
scalblnl..................................... 619
scalbn....................................... 619
scalbnf...................................... 619
scalbnfN..................................... 619
scalbnfNx.................................... 619
scalbnl...................................... 619
scandir...................................... 411
scandir64.................................... 412
scanf......................................... 318
sched_get_priority_max..................... 695
sched_get_priority_min..................... 695
sched_getaffinity........................... 700
sched_getparam.............................. 694
sched_getscheduler.......................... 694
sched_rr_get_interval...................... 695
sched_setaffinity........................... 701
sched_setparam.............................. 694
sched_setscheduler.......................... 693
sched_yield.................................. 695
secure_getenv............................... 793
seed48....................................... 596
seed48_r..................................... 599
seekdir...................................... 410
select....................................... 368
sem_clockwait............................... 930
sem_close.................................... 815
sem_destroy.................................. 815
sem_getvalue................................ 816
sem_init..................................... 815
sem_post..................................... 816
sem_timedwait............................... 816
sem_trywait.................................. 816
sem_unlink................................... 815
sem_wait..................................... 816
semctl....................................... 815
semget....................................... 815
semop......................................... 815
semtimedop................................... 815
send.......................................... 486
sendto....................................... 494

```
setbuf....................................... 331
setbuffer.................................... 331
setcontext................................... 710
setdomainname............................... 876
setegid...................................... 849
setenv....................................... 793
seteuid...................................... 848
setfsent..................................... 880
setgid....................................... 849
setgrent..................................... 870
setgroups.................................... 850
sethostent................................... 473
sethostid.................................... 877
sethostname.................................. 876
setitimer.................................... 680
setjmp....................................... 706
setlinebuf................................... 331
setlocale.................................... 185
setlogmask................................... 537
setmntent.................................... 883
setnetent.................................... 502
setnetgrent.................................. 873
setpayload................................... 628
setpayloadf.................................. 628
setpayloadfN................................ 628
setpayloadfNx............................... 628
setpayloadl.................................. 628
setpayloadsig............................... 628
setpayloadsigf.............................. 628
setpayloadsigfN............................. 628
setpayloadsigfNx............................ 628
setpayloadsigl.............................. 628
setpgid...................................... 832
setpgrp...................................... 833
setpriority.................................. 698
setprotoent.................................. 478
setpwent..................................... 867
setregid..................................... 850
setreuid..................................... 849
setrlimit.................................... 686
setrlimit64.................................. 686
setservent................................... 475
setsid....................................... 831
setsockopt................................... 499
setstate..................................... 593
setstate_r................................... 594
settimeofday................................ 658
setuid....................................... 848
setutent..................................... 857
setutxent.................................... 862
setvbuf...................................... 330
shm_open..................................... 365
shm_unlink................................... 365
shutdown..................................... 480
sigabbrev_np................................ 725
sigaction.................................... 728
sigaddset.................................... 747
sigaltstack.................................. 756
```

Function and Macro Index 1169

sigblock..................................... 758
sigdelset.................................... 748
sigdescr_np.................................. 724
sigemptyset.................................. 747
sigfillset................................... 747
siginterrupt................................ 757
sigismember.................................. 748
siglongjmp................................... 708
sigmask...................................... 758
signal....................................... 725
signbit...................................... 625
significand.................................. 620
significandf................................ 620
significandl................................ 620
sigpause..................................... 758
sigpending................................... 751
sigprocmask.................................. 748
sigsetjmp.................................... 708
sigsetmask................................... 758
sigstack..................................... 757
sigsuspend................................... 754
sin........................................... 540
sincos....................................... 541
sincosf...................................... 541
sincosfN..................................... 541
sincosfNx.................................... 541
sincosl...................................... 541
sinf.......................................... 540
sinfN......................................... 540
sinfNx....................................... 540
sinh.......................................... 550
sinhf......................................... 550
sinhfN....................................... 550
sinhfNx...................................... 550
sinhl......................................... 550
sinl.......................................... 540
sleep......................................... 682
snprintf..................................... 298
socket....................................... 480
socketpair................................... 481
sprintf...................................... 297
sqrt.......................................... 547
sqrtf......................................... 547
sqrtfN....................................... 547
sqrtfNx...................................... 547
sqrtl......................................... 547
srand......................................... 592
srand48...................................... 596
srand48_r.................................... 599
srandom...................................... 593
srandom_r.................................... 594
sscanf....................................... 319
ssignal...................................... 727
stat.......................................... 429
stat64....................................... 430
stime......................................... 658
stpcpy....................................... 104
stpncpy...................................... 110

```
strcasecmp................................... 115
strcasestr................................... 124
strcat....................................... 106
strchr....................................... 122
strchrnul.................................... 123
strcmp....................................... 114
strcoll...................................... 118
strcpy....................................... 104
strcspn...................................... 125
strdup....................................... 104
strdupa...................................... 105
strerror...................................... 36
strerror_r.................................... 36
strerrordesc_np.............................. 37
strerrorname_np.............................. 37
strfmon...................................... 198
strfromd..................................... 642
strfromf..................................... 642
strfromfN.................................... 643
strfromfNx................................... 643
strfroml..................................... 642
strfry....................................... 132
strftime..................................... 663
strlen......................................... 99
strncasecmp.................................. 115
strncat...................................... 111
strncmp...................................... 115
strncpy...................................... 109
strndup...................................... 110
strndupa..................................... 110
strnlen...................................... 100
strpbrk...................................... 126
strptime..................................... 668
strrchr...................................... 123
strsep....................................... 129
strsignal.................................... 724
strspn....................................... 125
strstr....................................... 124
strtod....................................... 640
strtof....................................... 641
strtofN...................................... 642
strtofNx..................................... 642
strtoimax.................................... 638
strtok....................................... 126
strtok_r..................................... 128
strtol....................................... 635
strtold...................................... 641
strtoll...................................... 637
strtoq....................................... 637
strtoul...................................... 636
strtoull..................................... 638
strtoumax.................................... 639
strtouq...................................... 638
strverscmp................................... 116
strxfrm...................................... 118
stty.......................................... 523
success...................................... 837
SUN_LEN...................................... 462
```

Function and Macro Index 1170

swapcontext.................................. 710
swprintf..................................... 297
swscanf...................................... 319
symlink...................................... 420
sync.......................................... 370
syscall...................................... 797
sysconf...................................... 893
syslog....................................... 534
system....................................... 803
sysv_signal.................................. 727

T
tan........................................... 541
tanf.......................................... 541
tanfN......................................... 541
tanfNx....................................... 541
tanh.......................................... 550
tanhf......................................... 550
tanhfN....................................... 550
tanhfNx...................................... 550
tanhl......................................... 550
tanl.......................................... 541
tcdrain...................................... 524
tcflow....................................... 525
tcflush...................................... 524
tcgetattr.................................... 506
tcgetpgrp.................................... 833
tcgetsid..................................... 834
tcsendbreak.................................. 523
tcsetattr.................................... 506
tcsetpgrp.................................... 833
tdelete...................................... 236
tdestroy..................................... 236
telldir...................................... 410
TEMP_FAILURE_RETRY.......................... 741
tempnam...................................... 447
textdomain................................... 216
tfind......................................... 236
tgamma....................................... 554
tgammaf...................................... 554
tgammafN..................................... 554
tgammafNx.................................... 554
tgammal...................................... 554
tgkill....................................... 744
thrd_create.................................. 921
thrd_current................................ 922
thrd_detach.................................. 923
thrd_equal................................... 922
thrd_exit.................................... 922
thrd_join.................................... 923
thrd_sleep................................... 922
thrd_yield................................... 922
time.......................................... 651
timegm....................................... 661
timelocal.................................... 661
times......................................... 651
tmpfile...................................... 446

```
tmpfile64.................................... 446
tmpnam....................................... 447
tmpnam_r..................................... 447
toascii....................................... 90
tolower....................................... 89
totalorder................................... 629
totalorderf.................................. 629
totalorderfN................................ 629
totalorderfNx............................... 629
totalorderl.................................. 629
totalordermag............................... 630
totalordermagf.............................. 630
totalordermagfN............................. 630
totalordermagfNx............................ 630
totalordermagl.............................. 630
toupper....................................... 89
towctrans..................................... 95
towlower...................................... 96
towupper...................................... 96
trunc......................................... 621
truncate..................................... 442
truncate64................................... 442
truncf....................................... 621
truncfN...................................... 621
truncfNx..................................... 621
truncl....................................... 621
tryagain..................................... 837
tsearch...................................... 235
tss_create................................... 927
tss_delete................................... 928
tss_get...................................... 928
tss_set...................................... 928
ttyname...................................... 503
ttyname_r.................................... 503
twalk......................................... 237
twalk_r...................................... 238
tzset......................................... 678
```
```
U
ufromfp...................................... 623
ufromfpf..................................... 623
ufromfpfN.................................... 623
ufromfpfNx................................... 623
ufromfpl..................................... 623
ufromfpx..................................... 623
ufromfpxf.................................... 623
ufromfpxfN................................... 623
ufromfpxfNx.................................. 623
ufromfpxl.................................... 623
ulimit....................................... 688
umask......................................... 437
umount....................................... 889
umount2...................................... 888
uname......................................... 878
unavail...................................... 837
ungetc....................................... 286
ungetwc...................................... 286
```

Function and Macro Index 1171

unlink....................................... 422
unlockpt..................................... 528
unsetenv..................................... 794
updwtmp...................................... 861
utime......................................... 440
utimes....................................... 441
utmpname..................................... 860
utmpxname.................................... 863

V
va_arg....................................... 954
va_copy...................................... 954
va_end....................................... 954
va_start..................................... 954
valloc......................................... 50
vasprintf.................................... 301
verr........................................... 41
verrx.......................................... 41
versionsort.................................. 411
versionsort64............................... 412
vfork......................................... 806
vfprintf..................................... 300
vfscanf...................................... 320
vfwprintf.................................... 301
vfwscanf..................................... 320
vlimit....................................... 689
vprintf...................................... 300
vscanf....................................... 319
vsnprintf.................................... 301
vsprintf..................................... 301
vsscanf...................................... 320
vswprintf.................................... 301
vswscanf..................................... 320
vsyslog...................................... 536
vwarn.......................................... 40
vwarnx......................................... 41
vwprintf..................................... 300
vwscanf...................................... 319

W
wait.......................................... 811
wait3......................................... 813
wait4......................................... 811
waitpid...................................... 809
warn........................................... 40
warnx.......................................... 41
WCOREDUMP.................................... 813
wcpcpy....................................... 105
wcpncpy...................................... 111
wcrtomb...................................... 151
wcscasecmp................................... 115
wcscat....................................... 107
wcschr....................................... 123
wcschrnul.................................... 123
wcscmp....................................... 114
wcscoll...................................... 118

```
wcscpy....................................... 104
wcscspn...................................... 125
wcsdup....................................... 104
wcsftime..................................... 667
wcslen....................................... 100
wcsncasecmp.................................. 115
wcsncat...................................... 112
wcsncmp...................................... 115
wcsncpy...................................... 110
wcsnlen...................................... 101
wcsnrtombs................................... 156
wcspbrk...................................... 126
wcsrchr...................................... 124
wcsrtombs.................................... 154
wcsspn....................................... 125
wcsstr....................................... 124
wcstod....................................... 642
wcstof....................................... 642
wcstofN...................................... 642
wcstofNx..................................... 642
wcstoimax.................................... 638
wcstok....................................... 127
wcstol....................................... 636
wcstold...................................... 642
wcstoll...................................... 637
wcstombs..................................... 160
wcstoq....................................... 637
wcstoul...................................... 637
wcstoull..................................... 638
wcstoumax.................................... 639
wcstouq...................................... 638
wcswcs....................................... 124
wcsxfrm...................................... 119
wctob......................................... 147
wctomb....................................... 158
wctrans....................................... 95
wctype......................................... 90
WEXITSTATUS.................................. 812
WIFEXITED.................................... 812
WIFSIGNALED.................................. 812
WIFSTOPPED................................... 813
wmemchr...................................... 121
wmemcmp...................................... 113
wmemcpy...................................... 102
wmemmove..................................... 103
wmempcpy..................................... 102
wmemset...................................... 104
wordexp...................................... 255
wordfree..................................... 256
wprintf...................................... 297
write......................................... 347
writev....................................... 356
wscanf....................................... 318
WSTOPSIG..................................... 813
WTERMSIG..................................... 812
```

Function and Macro Index 1172

Y
y0............................................ 555
y0f........................................... 555
y0fN.......................................... 555
y0fNx......................................... 555
y0l........................................... 555
y1............................................ 555
y1f........................................... 555

```
y1fN.......................................... 555
y1fNx......................................... 555
y1l........................................... 555
yn............................................ 556
ynf........................................... 556
ynfN.......................................... 556
ynfNx......................................... 556
ynl........................................... 556
```

### 1173

## Variable and Constant Macro Index.......................

(

(*__gconv_end_fct).......................... 178
(*__gconv_fct).............................. 178
(*__gconv_init_fct)........................ 175
(void)......................................... 39

__free_hook................................... 55
__libc_single_threaded..................... 932
__malloc_hook................................ 54
__memalign_hook.............................. 55
__realloc_hook............................... 54
__STDC_WANT_IEC_60559_BFP_EXT__............ 18
__STDC_WANT_IEC_60559_FUNCS_EXT__......... 18
__STDC_WANT_IEC_60559_TYPES_EXT__......... 18
__STDC_WANT_LIB_EXT2__...................... 18
_ATFILE_SOURCE............................... 19
_Complex_I................................... 633
_CS_LFS_CFLAGS.............................. 910
_CS_LFS_LDFLAGS............................. 910
_CS_LFS_LIBS................................ 910
_CS_LFS_LINTFLAGS........................... 910
_CS_LFS64_CFLAGS............................ 910
_CS_LFS64_LDFLAGS........................... 910
_CS_LFS64_LIBS.............................. 910
_CS_LFS64_LINTFLAGS........................ 910
_CS_PATH..................................... 910
_DEFAULT_SOURCE.............................. 19
_FILE_OFFSET_BITS............................ 17
_FORTIFY_SOURCE.............................. 19
_GNU_SOURCE................................... 18
_IOFBF....................................... 331
_IOLBF....................................... 331
_IONBF....................................... 331
_ISOC11_SOURCE............................... 18
_ISOC2X_SOURCE............................... 18
_ISOC99_SOURCE............................... 18
_LARGEFILE_SOURCE............................ 17
_LARGEFILE64_SOURCE.......................... 17
_PATH_FSTAB.................................. 879
_PATH_MNTTAB................................ 879
_PATH_MOUNTED............................... 879
_PATH_UTMP................................... 860
_PATH_WTMP................................... 860
_PC_ASYNC_IO................................ 907
_PC_CHOWN_RESTRICTED....................... 907
_PC_FILESIZEBITS............................ 907
_PC_LINK_MAX................................ 907
_PC_MAX_CANON............................... 907
_PC_MAX_INPUT............................... 907
_PC_NAME_MAX................................ 907
_PC_NO_TRUNC................................ 907
_PC_PATH_MAX................................ 907

```
_PC_PIPE_BUF................................ 907
_PC_PRIO_IO.................................. 907
_PC_REC_INCR_XFER_SIZE..................... 907
_PC_REC_MAX_XFER_SIZE...................... 908
_PC_REC_MIN_XFER_SIZE...................... 908
_PC_REC_XFER_ALIGN.......................... 908
_PC_SYNC_IO.................................. 907
_PC_VDISABLE................................ 907
_POSIX_AIO_LISTIO_MAX...................... 902
_POSIX_AIO_MAX.............................. 902
_POSIX_ARG_MAX.............................. 902
_POSIX_C_SOURCE.............................. 16
_POSIX_CHILD_MAX............................ 902
_POSIX_CHOWN_RESTRICTED.................... 905
_POSIX_JOB_CONTROL..................... 817 , 891
_POSIX_LINK_MAX............................. 905
_POSIX_MAX_CANON............................ 905
_POSIX_MAX_INPUT............................ 905
_POSIX_NAME_MAX............................. 905
_POSIX_NGROUPS_MAX.......................... 903
_POSIX_NO_TRUNC............................. 905
_POSIX_OPEN_MAX............................. 903
_POSIX_PATH_MAX............................. 906
_POSIX_PIPE_BUF............................. 906
_POSIX_SAVED_IDS............................ 891
_POSIX_SOURCE................................ 16
_POSIX_SSIZE_MAX............................ 903
_POSIX_STREAM_MAX........................... 903
_POSIX_TZNAME_MAX........................... 903
_POSIX_VDISABLE........................ 517 , 905
_POSIX_VERSION.............................. 892
_POSIX2_BC_BASE_MAX........................ 909
_POSIX2_BC_DIM_MAX.......................... 909
_POSIX2_BC_SCALE_MAX....................... 909
_POSIX2_BC_STRING_MAX...................... 909
_POSIX2_C_DEV............................... 892
_POSIX2_C_VERSION........................... 893
_POSIX2_COLL_WEIGHTS_MAX................... 909
_POSIX2_EQUIV_CLASS_MAX.................... 909
_POSIX2_EXPR_NEST_MAX...................... 909
_POSIX2_FORT_DEV............................ 892
_POSIX2_FORT_RUN............................ 892
_POSIX2_LINE_MAX............................ 909
_POSIX2_LOCALEDEF........................... 892
_POSIX2_RE_DUP_MAX.......................... 903
_POSIX2_SW_DEV.............................. 892
_REENTRANT.................................... 19
_SC_2_C_DEV.................................. 897
_SC_2_FORT_DEV.............................. 897
_SC_2_FORT_RUN.............................. 897
_SC_2_LOCALEDEF............................. 897
_SC_2_SW_DEV................................ 897
_SC_2_VERSION............................... 898
_SC_AIO_LISTIO_MAX.......................... 895
_SC_AIO_MAX.................................. 895
```

Variable and Constant Macro Index 1174

_SC_AIO_PRIO_DELTA_MAX..................... 895
_SC_ARG_MAX.................................. 893
_SC_ASYNCHRONOUS_IO........................ 894
_SC_ATEXIT_MAX.............................. 898
_SC_AVPHYS_PAGES....................... 703 , 898
_SC_BC_BASE_MAX............................. 897
_SC_BC_DIM_MAX.............................. 897
_SC_BC_SCALE_MAX............................ 897
_SC_BC_STRING_MAX........................... 897
_SC_CHAR_BIT................................ 900
_SC_CHAR_MAX................................ 900
_SC_CHAR_MIN................................ 900
_SC_CHARCLASS_NAME_MAX..................... 894
_SC_CHILD_MAX............................... 893
_SC_CLK_TCK.................................. 894
_SC_COLL_WEIGHTS_MAX....................... 897
_SC_DELAYTIMER_MAX.......................... 895
_SC_EQUIV_CLASS_MAX........................ 898
_SC_EXPR_NEST_MAX........................... 897
_SC_FSYNC.................................... 894
_SC_GETGR_R_SIZE_MAX....................... 896
_SC_GETPW_R_SIZE_MAX....................... 896
_SC_INT_MAX.................................. 900
_SC_INT_MIN.................................. 900
_SC_JOB_CONTROL............................. 894
_SC_LEVEL1_DCACHE_ASSOC.................... 898
_SC_LEVEL1_DCACHE_LINESIZE................ 898
_SC_LEVEL1_DCACHE_SIZE..................... 898
_SC_LEVEL1_ICACHE_ASSOC.................... 898
_SC_LEVEL1_ICACHE_LINESIZE................ 898
_SC_LEVEL1_ICACHE_SIZE..................... 898
_SC_LEVEL2_CACHE_ASSOC..................... 899
_SC_LEVEL2_CACHE_LINESIZE.................. 899
_SC_LEVEL2_CACHE_SIZE...................... 899
_SC_LEVEL3_CACHE_ASSOC..................... 899
_SC_LEVEL3_CACHE_LINESIZE.................. 899
_SC_LEVEL3_CACHE_SIZE...................... 899
_SC_LEVEL4_CACHE_ASSOC..................... 899
_SC_LEVEL4_CACHE_LINESIZE.................. 899
_SC_LEVEL4_CACHE_SIZE...................... 899
_SC_LINE_MAX................................ 897
_SC_LOGIN_NAME_MAX.......................... 896
_SC_LONG_BIT................................ 900
_SC_MAPPED_FILES............................ 894
_SC_MB_LEN_MAX.............................. 900
_SC_MEMLOCK.................................. 894
_SC_MEMLOCK_RANGE........................... 894
_SC_MEMORY_PROTECTION...................... 894
_SC_MESSAGE_PASSING........................ 894
_SC_MQ_OPEN_MAX............................. 895
_SC_MQ_PRIO_MAX............................. 895
_SC_NGROUPS_MAX............................. 893
_SC_NL_ARGMAX............................... 901
_SC_NL_LANGMAX.............................. 901
_SC_NL_MSGMAX............................... 901
_SC_NL_NMAX.................................. 901
_SC_NL_SETMAX............................... 901
_SC_NL_TEXTMAX.............................. 901

```
_SC_NPROCESSORS_CONF................... 704 , 898
_SC_NPROCESSORS_ONLN................... 704 , 898
_SC_NZERO.................................... 900
_SC_OPEN_MAX................................ 893
_SC_PAGESIZE....................... 360 , 702 , 898
_SC_PHYS_PAGES......................... 703 , 898
_SC_PII...................................... 895
_SC_PII_INTERNET............................ 895
_SC_PII_INTERNET_DGRAM..................... 896
_SC_PII_INTERNET_STREAM.................... 896
_SC_PII_OSI.................................. 895
_SC_PII_OSI_CLTS............................ 896
_SC_PII_OSI_COTS............................ 896
_SC_PII_OSI_M............................... 896
_SC_PII_SOCKET.............................. 895
_SC_PII_XTI.................................. 895
_SC_PRIORITIZED_IO.......................... 894
_SC_PRIORITY_SCHEDULING.................... 894
_SC_REALTIME_SIGNALS....................... 894
_SC_RTSIG_MAX............................... 895
_SC_SAVED_IDS............................... 894
_SC_SCHAR_MAX............................... 900
_SC_SCHAR_MIN............................... 901
_SC_SELECT................................... 895
_SC_SEM_NSEMS_MAX........................... 895
_SC_SEM_VALUE_MAX........................... 895
_SC_SEMAPHORES.............................. 894
_SC_SHARED_MEMORY_OBJECTS.................. 895
_SC_SHRT_MAX................................ 901
_SC_SHRT_MIN................................ 901
_SC_SIGQUEUE_MAX............................ 895
_SC_SSIZE_MAX............................... 900
_SC_STREAM_MAX.............................. 893
_SC_SYNCHRONIZED_IO........................ 894
_SC_T_IOV_MAX............................... 896
_SC_THREAD_ATTR_STACKADDR.................. 896
_SC_THREAD_ATTR_STACKSIZE.................. 896
_SC_THREAD_DESTRUCTOR_ITERATIONS......... 896
_SC_THREAD_KEYS_MAX........................ 896
_SC_THREAD_PRIO_INHERIT.................... 897
_SC_THREAD_PRIO_PROTECT.................... 897
_SC_THREAD_PRIORITY_SCHEDULING............ 897
_SC_THREAD_PROCESS_SHARED.................. 897
_SC_THREAD_SAFE_FUNCTIONS.................. 896
_SC_THREAD_STACK_MIN....................... 896
_SC_THREAD_THREADS_MAX..................... 896
_SC_THREADS.................................. 896
_SC_TIMER_MAX............................... 895
_SC_TIMERS................................... 894
_SC_TTY_NAME_MAX............................ 896
_SC_TZNAME_MAX.............................. 893
_SC_UCHAR_MAX............................... 901
_SC_UINT_MAX................................ 901
_SC_UIO_MAXIOV.............................. 895
_SC_ULONG_MAX............................... 901
_SC_USHRT_MAX............................... 901
_SC_VERSION............................. 894 , 898
_SC_WORD_BIT................................ 900
```

Variable and Constant Macro Index 1175

_SC_XOPEN_CRYPT............................. 899
_SC_XOPEN_ENH_I18N.......................... 900
_SC_XOPEN_LEGACY............................ 899
_SC_XOPEN_REALTIME.......................... 899
_SC_XOPEN_REALTIME_THREADS................ 899
_SC_XOPEN_SHM............................... 900
_SC_XOPEN_UNIX.............................. 899
_SC_XOPEN_VERSION........................... 899
_SC_XOPEN_XCU_VERSION...................... 899
_SC_XOPEN_XPG2.............................. 900
_SC_XOPEN_XPG3.............................. 900
_SC_XOPEN_XPG4.............................. 900
_THREAD_SAFE.................................. 19
_XOPEN_SOURCE................................ 17
_XOPEN_SOURCE_EXTENDED...................... 17

A
ABDAY_1...................................... 193
ABDAY_2...................................... 193
ABDAY_3...................................... 193
ABDAY_4...................................... 193
ABDAY_5...................................... 193
ABDAY_6...................................... 193
ABDAY_7...................................... 193
ABMON_1...................................... 193
ABMON_10..................................... 193
ABMON_11..................................... 193
ABMON_12..................................... 193
ABMON_2...................................... 193
ABMON_3...................................... 193
ABMON_4...................................... 193
ABMON_5...................................... 193
ABMON_6...................................... 193
ABMON_7...................................... 193
ABMON_8...................................... 193
ABMON_9...................................... 193
ACCOUNTING................................... 857
AF_FILE...................................... 458
AF_INET...................................... 458
AF_INET6..................................... 458
AF_LOCAL..................................... 458
AF_UNIX...................................... 458
AF_UNSPEC.................................... 458
ALT_DIGITS................................... 195
ALTMON_1..................................... 194
ALTMON_10.................................... 194
ALTMON_11.................................... 194
ALTMON_12.................................... 194
ALTMON_2..................................... 194
ALTMON_3..................................... 194
ALTMON_4..................................... 194
ALTMON_5..................................... 194
ALTMON_6..................................... 194
ALTMON_7..................................... 194
ALTMON_8..................................... 194
ALTMON_9..................................... 194
ALTWERASE.................................... 514

```
AM_STR....................................... 194
ARG_MAX...................................... 890
argp_err_exit_status....................... 769
argp_program_bug_address................... 769
argp_program_version....................... 769
argp_program_version_hook.................. 769
ARGP_ERR_UNKNOWN............................ 773
ARGP_HELP_BUG_ADDR.......................... 781
ARGP_HELP_DOC............................... 781
ARGP_HELP_EXIT_ERR.......................... 781
ARGP_HELP_EXIT_OK........................... 781
ARGP_HELP_LONG.............................. 781
ARGP_HELP_LONG_ONLY........................ 781
ARGP_HELP_POST_DOC.......................... 781
ARGP_HELP_PRE_DOC........................... 781
ARGP_HELP_SEE............................... 781
ARGP_HELP_SHORT_USAGE...................... 781
ARGP_HELP_STD_ERR........................... 781
ARGP_HELP_STD_HELP.......................... 781
ARGP_HELP_STD_USAGE........................ 781
ARGP_HELP_USAGE............................. 781
ARGP_IN_ORDER............................... 779
ARGP_KEY_ARG................................ 773
ARGP_KEY_ARGS............................... 773
ARGP_KEY_END................................ 774
ARGP_KEY_ERROR.............................. 774
ARGP_KEY_FINI............................... 774
ARGP_KEY_HELP_ARGS_DOC..................... 780
ARGP_KEY_HELP_DUP_ARGS_NOTE............... 780
ARGP_KEY_HELP_EXTRA........................ 780
ARGP_KEY_HELP_HEADER....................... 780
ARGP_KEY_HELP_POST_DOC..................... 780
ARGP_KEY_HELP_PRE_DOC...................... 780
ARGP_KEY_INIT............................... 774
ARGP_KEY_NO_ARGS............................ 774
ARGP_KEY_SUCCESS............................ 774
ARGP_LONG_ONLY.............................. 779
ARGP_NO_ARGS................................ 779
ARGP_NO_ERRS................................ 779
ARGP_NO_EXIT................................ 779
ARGP_NO_HELP................................ 779
ARGP_PARSE_ARGV0............................ 778
ARGP_SILENT.................................. 779
```
```
B
B0............................................ 516
B110.......................................... 516
B115200...................................... 516
B1200......................................... 516
B134.......................................... 516
B150.......................................... 516
B1800......................................... 516
B19200....................................... 516
B200.......................................... 516
B230400...................................... 516
B2400......................................... 516
B300.......................................... 516
```

Variable and Constant Macro Index 1176

B38400....................................... 516
B460800...................................... 516
B4800......................................... 516
B50........................................... 516
B57600....................................... 516
B600.......................................... 516
B75........................................... 516
B9600......................................... 516
BC_BASE_MAX.................................. 908
BC_DIM_MAX................................... 908
BC_SCALE_MAX................................ 908
BC_STRING_MAX............................... 908
BOOT_TIME............................... 857 , 862
BRKINT....................................... 509
BUFSIZ....................................... 331

C
CCTS_OFLOW................................... 512
CHAR_BIT..................................... 957
CHAR_MAX..................................... 958
CHAR_MIN..................................... 958
CHAR_WIDTH................................... 957
CHILD_MAX.................................... 890
CIGNORE...................................... 512
CLK_TCK...................................... 651
CLOCAL....................................... 511
CLOCK_MONOTONIC............................. 652
CLOCK_REALTIME.............................. 652
CLOCKS_PER_SEC.............................. 650
CODESET...................................... 193
COLL_WEIGHTS_MAX............................ 908
COREFILE..................................... 717
CPU_SETSIZE.................................. 699
CREAD......................................... 511
CRNCYSTR..................................... 195
CRTS_IFLOW................................... 512
CS5........................................... 512
CS6........................................... 512
CS7........................................... 512
CS8........................................... 512
CSIZE......................................... 512
CSTOPB....................................... 511
CURRENCY_SYMBOL............................. 195

D
D_FMT......................................... 194
D_T_FMT...................................... 194
DAY_1......................................... 193
DAY_2......................................... 193
DAY_3......................................... 193
DAY_4......................................... 193
DAY_5......................................... 193
DAY_6......................................... 193
DAY_7......................................... 193
daylight..................................... 679
DBL_DIG...................................... 962

```
DBL_EPSILON.................................. 963
DBL_MANT_DIG................................ 962
DBL_MAX...................................... 963
DBL_MAX_10_EXP.............................. 963
DBL_MAX_EXP.................................. 963
DBL_MIN...................................... 963
DBL_MIN_10_EXP.............................. 962
DBL_MIN_EXP.................................. 962
DEAD_PROCESS............................ 857 , 862
DECIMAL_POINT............................... 197
DT_BLK....................................... 405
DT_CHR....................................... 405
DT_DIR....................................... 405
DT_FIFO...................................... 405
DT_LNK....................................... 405
DT_REG....................................... 405
DT_SOCK...................................... 405
DT_UNKNOWN................................... 405
```
```
E
E2BIG.......................................... 25
EACCES......................................... 25
EADDRINUSE.................................... 29
EADDRNOTAVAIL................................ 29
EADV........................................... 34
EAFNOSUPPORT.................................. 29
EAGAIN......................................... 27
EALREADY...................................... 28
EAUTH.......................................... 31
EBACKGROUND................................... 32
EBADE.......................................... 34
EBADF..................................... 25 , 525
EBADFD......................................... 34
EBADMSG....................................... 32
EBADR.......................................... 34
EBADRPC....................................... 31
EBADRQC....................................... 34
EBADSLT....................................... 34
EBFONT......................................... 34
EBUSY.......................................... 25
ECANCELED..................................... 33
ECHILD......................................... 25
ECHO.......................................... 513
ECHOCTL...................................... 514
ECHOE......................................... 513
ECHOK......................................... 513
ECHOKE....................................... 513
ECHONL....................................... 513
ECHOPRT...................................... 513
ECHRNG......................................... 33
ECOMM.......................................... 34
ECONNABORTED.................................. 29
ECONNREFUSED.................................. 30
ECONNRESET.................................... 29
ED............................................. 32
EDEADLK....................................... 25
EDEADLOCK..................................... 34
```

Variable and Constant Macro Index 1177

EDESTADDRREQ.................................. 29
EDIED.......................................... 32
EDOM........................................... 27
EDOTDOT....................................... 34
EDQUOT......................................... 30
EEXIST......................................... 25
EFAULT......................................... 25
EFBIG.......................................... 26
EFTYPE......................................... 31
EGRATUITOUS................................... 32
EGREGIOUS..................................... 32
EHOSTDOWN..................................... 30
EHOSTUNREACH.................................. 30
EHWPOISON..................................... 35
EIDRM.......................................... 32
EIEIO.......................................... 32
EILSEQ......................................... 32
EINPROGRESS................................... 28
EINTR.......................................... 24
EINVAL.................................... 26 , 525
EIO............................................ 24
EISCONN....................................... 29
EISDIR......................................... 26
EISNAM......................................... 35
EKEYEXPIRED................................... 35
EKEYREJECTED.................................. 35
EKEYREVOKED................................... 35
EL2HLT......................................... 34
EL2NSYNC...................................... 33
EL3HLT......................................... 33
EL3RST......................................... 33
ELIBACC....................................... 35
ELIBBAD....................................... 35
ELIBEXEC...................................... 35
ELIBMAX....................................... 35
ELIBSCN....................................... 35
ELNRNG......................................... 33
ELOOP.......................................... 30
EMEDIUMTYPE................................... 35
EMFILE......................................... 26
EMLINK......................................... 27
EMPTY.................................... 857 , 861
EMSGSIZE...................................... 28
EMULTIHOP..................................... 32
ENAMETOOLONG.................................. 30
ENAVAIL....................................... 35
endorder..................................... 237
ENEEDAUTH..................................... 31
ENETDOWN...................................... 29
ENETRESET..................................... 29
ENETUNREACH................................... 29
ENFILE......................................... 26
ENOANO......................................... 34
ENOBUFS....................................... 29
ENOCSI......................................... 33
ENODATA....................................... 32
ENODEV......................................... 26
ENOENT......................................... 24

```
ENOEXEC....................................... 25
ENOKEY......................................... 35
ENOLCK......................................... 31
ENOLINK....................................... 32
ENOMEDIUM..................................... 35
ENOMEM......................................... 25
ENOMSG......................................... 32
ENONET......................................... 34
ENOPKG......................................... 34
ENOPROTOOPT................................... 28
ENOSPC......................................... 26
ENOSR.......................................... 33
ENOSTR......................................... 33
ENOSYS......................................... 31
ENOTBLK....................................... 25
ENOTCONN...................................... 29
ENOTDIR....................................... 26
ENOTEMPTY..................................... 30
ENOTNAM....................................... 35
ENOTRECOVERABLE.............................. 33
ENOTSOCK...................................... 28
ENOTSUP....................................... 31
ENOTTY.................................... 26 , 525
ENOTUNIQ...................................... 34
environ...................................... 794
ENXIO.......................................... 24
EOF........................................... 320
EOPNOTSUPP.................................... 28
EOVERFLOW..................................... 33
EOWNERDEAD.................................... 33
EPERM.......................................... 24
EPFNOSUPPORT.................................. 28
EPIPE.......................................... 27
EPROCLIM...................................... 30
EPROCUNAVAIL.................................. 31
EPROGMISMATCH................................ 31
EPROGUNAVAIL.................................. 31
EPROTO......................................... 33
EPROTONOSUPPORT.............................. 28
EPROTOTYPE.................................... 28
EQUIV_CLASS_MAX............................. 908
ERA........................................... 195
ERA_D_FMT.................................... 195
ERA_D_T_FMT.................................. 195
ERA_T_FMT.................................... 195
ERA_YEAR..................................... 195
ERANGE......................................... 27
EREMCHG....................................... 34
EREMOTE....................................... 31
EREMOTEIO..................................... 35
ERESTART...................................... 33
ERFKILL....................................... 35
EROFS.......................................... 27
ERPCMISMATCH.................................. 31
errno.......................................... 23
error_message_count.......................... 39
error_one_per_line........................... 40
ESHUTDOWN..................................... 30
```

Variable and Constant Macro Index 1178

ESOCKTNOSUPPORT.............................. 28
ESPIPE......................................... 26
ESRCH.......................................... 24
ESRMNT......................................... 34
ESTALE......................................... 30
ESTRPIPE...................................... 35
ETIME.......................................... 33
ETIMEDOUT..................................... 30
ETOOMANYREFS.................................. 30
ETXTBSY....................................... 26
EUCLEAN....................................... 35
EUNATCH....................................... 33
EUSERS......................................... 30
EWOULDBLOCK................................... 27
EXDEV.......................................... 25
EXFULL......................................... 34
EXIT_FAILURE................................ 800
EXIT_SUCCESS................................ 800
EXPR_NEST_MAX............................... 908
EXTA.......................................... 516
EXTB.......................................... 516

F
F_DUPFD................................. 383 , 385
F_GETFD................................. 383 , 386
F_GETFL................................. 383 , 392
F_GETLK................................. 384 , 394
F_GETOWN................................ 384 , 400
F_OFD_GETLK............................. 384 , 397
F_OFD_SETLK............................. 384 , 397
F_OFD_SETLKW............................ 384 , 398
F_OK.......................................... 439
F_RDLCK...................................... 396
F_SETFD................................. 383 , 386
F_SETFL................................. 384 , 392
F_SETLK................................. 384 , 395
F_SETLKW................................ 384 , 395
F_SETOWN................................ 384 , 400
F_UNLCK...................................... 396
F_WRLCK...................................... 396
FD_CLOEXEC................................... 386
FD_SETSIZE................................... 367
FE_DFL_ENV................................... 615
FE_DFL_MODE.................................. 616
FE_DIVBYZERO................................ 610
FE_DOWNWARD.................................. 614
FE_INEXACT................................... 610
FE_INVALID................................... 610
FE_NOMASK_ENV............................... 615
FE_OVERFLOW.................................. 610
FE_SNANS_ALWAYS_SIGNAL..................... 610
FE_TONEAREST................................ 614
FE_TOWARDZERO............................... 614
FE_UNDERFLOW................................ 610
FE_UPWARD.................................... 614
FILENAME_MAX................................ 904
FLT_DIG...................................... 962

```
FLT_EPSILON.................................. 963
FLT_MANT_DIG................................ 961
FLT_MAX...................................... 963
FLT_MAX_10_EXP.............................. 963
FLT_MAX_EXP.................................. 962
FLT_MIN...................................... 963
FLT_MIN_10_EXP.............................. 962
FLT_MIN_EXP.................................. 962
FLT_RADIX.................................... 961
FLT_ROUNDS................................... 961
FLUSHO....................................... 515
FNM_CASEFOLD................................ 240
FNM_EXTMATCH................................ 240
FNM_FILE_NAME............................... 239
FNM_LEADING_DIR............................. 240
FNM_NOESCAPE................................ 239
FNM_PATHNAME................................ 239
FNM_PERIOD................................... 239
FOPEN_MAX.................................... 269
FP_FAST_FMA.................................. 632
FP_ILOGB0.................................... 546
FP_ILOGBNAN.................................. 547
FP_INFINITE.................................. 605
FP_INT_DOWNWARD............................. 620
FP_INT_TONEAREST............................ 620
FP_INT_TONEARESTFROMZERO................... 620
FP_INT_TOWARDZERO........................... 620
FP_INT_UPWARD............................... 620
FP_LLOGB0.................................... 546
FP_LLOGBNAN.................................. 547
FP_NAN....................................... 605
FP_NORMAL.................................... 605
FP_SUBNORMAL................................ 605
FP_ZERO...................................... 605
FPE_DECOVF_TRAP............................. 718
FPE_FLTDIV_TRAP............................. 717
FPE_FLTOVF_TRAP............................. 717
FPE_FLTUND_TRAP............................. 718
FPE_INTDIV_TRAP............................. 717
FPE_INTOVF_TRAP............................. 717
FPE_SUBRNG_TRAP............................. 717
FRAC_DIGITS.................................. 196
FSETLOCKING_BYCALLER....................... 275
FSETLOCKING_INTERNAL....................... 275
FSETLOCKING_QUERY........................... 275
FSTAB......................................... 879
FSTAB_RO..................................... 880
FSTAB_RQ..................................... 880
FSTAB_RW..................................... 880
FSTAB_SW..................................... 880
FSTAB_XX..................................... 880
FTW_ACTIONRETVAL............................ 417
FTW_CHDIR.................................... 417
FTW_D......................................... 414
FTW_DEPTH.................................... 417
FTW_DNR...................................... 414
FTW_DP....................................... 415
FTW_F......................................... 414
```

Variable and Constant Macro Index 1179

FTW_MOUNT.................................... 417
FTW_NS....................................... 414
FTW_PHYS..................................... 417
FTW_SL....................................... 414
FTW_SLN...................................... 415

G
getdate_err.................................. 673
GETFSIZE..................................... 688
GLOB_ABORTED................................ 244
GLOB_ALTDIRFUNC............................. 247
GLOB_APPEND.................................. 245
GLOB_BRACE................................... 247
GLOB_DOOFFS.................................. 245
GLOB_ERR..................................... 245
GLOB_MAGCHAR................................ 246
GLOB_MARK.................................... 246
GLOB_NOCHECK................................ 246
GLOB_NOESCAPE............................... 246
GLOB_NOMAGIC................................ 247
GLOB_NOMATCH................................ 244
GLOB_NOSORT.................................. 246
GLOB_NOSPACE................................ 244
GLOB_ONLYDIR................................ 248
GLOB_PERIOD.................................. 246
GLOB_TILDE................................... 247
GLOB_TILDE_CHECK............................ 248
GROUPING..................................... 197

H
h_errno...................................... 471
HOST_NOT_FOUND.............................. 471
HUGE_VAL..................................... 613
HUGE_VAL_FN.................................. 613
HUGE_VAL_FNx................................ 613
HUGE_VALF.................................... 613
HUGE_VALL.................................... 613
HUPCL......................................... 511

I
I............................................. 634
ICANON....................................... 513
ICRNL......................................... 509
IEXTEN....................................... 514
IFNAMSIZ..................................... 460
IGNBRK....................................... 509
IGNCR......................................... 509
IGNPAR....................................... 509
IMAXBEL...................................... 510
in6addr_any.................................. 468
in6addr_loopback............................ 467
INADDR_ANY................................... 467
INADDR_BROADCAST............................ 467
INADDR_LOOPBACK............................. 467
INADDR_NONE.................................. 467

```
INFINITY..................................... 609
INIT_PROCESS............................ 857 , 862
INLCR......................................... 509
INPCK......................................... 508
INT_CURR_SYMBOL............................. 195
INT_FRAC_DIGITS............................. 196
INT_MAX...................................... 958
INT_MIN...................................... 958
INT_N_CS_PRECEDES........................... 197
INT_N_SEP_BY_SPACE.......................... 197
INT_N_SIGN_POSN............................. 197
INT_P_CS_PRECEDES........................... 196
INT_P_SEP_BY_SPACE.......................... 197
INT_P_SIGN_POSN............................. 197
INT_WIDTH.................................... 957
INTPTR_WIDTH................................ 957
IPPORT_RESERVED............................. 474
IPPORT_USERRESERVED........................ 474
ISIG.......................................... 514
ISTRIP....................................... 509
ITIMER_PROF.................................. 681
ITIMER_REAL.................................. 681
ITIMER_VIRTUAL.............................. 681
IXANY......................................... 510
IXOFF......................................... 510
IXON.......................................... 510
```
```
L
L_ctermid.................................... 831
L_cuserid.................................... 855
L_INCR................................... 326 , 352
L_SET.................................... 326 , 352
L_tmpnam..................................... 447
L_XTND................................... 326 , 352
LANG.......................................... 185
LANGUAGE..................................... 185
LC_ALL....................................... 185
LC_COLLATE................................... 184
LC_CTYPE..................................... 184
LC_MESSAGES.................................. 185
LC_MONETARY.................................. 184
LC_NUMERIC................................... 184
LC_TIME...................................... 184
LDBL_DIG..................................... 962
LDBL_EPSILON................................ 963
LDBL_MANT_DIG............................... 962
LDBL_MAX..................................... 963
LDBL_MAX_10_EXP............................. 963
LDBL_MAX_EXP................................ 963
LDBL_MIN..................................... 963
LDBL_MIN_10_EXP............................. 962
LDBL_MIN_EXP................................ 962
leaf.......................................... 237
LIM_CORE..................................... 689
LIM_CPU...................................... 689
LIM_DATA..................................... 689
LIM_FSIZE.................................... 689
```

Variable and Constant Macro Index 1180

LIM_MAXRSS................................... 689
LIM_STACK.................................... 689
LINE_MAX..................................... 908
LINK_MAX..................................... 903
LIO_NOP...................................... 372
LIO_READ..................................... 372
LIO_WRITE.................................... 372
LLONG_MAX.................................... 959
LLONG_MIN.................................... 959
LLONG_WIDTH.................................. 957
LOCPATH...................................... 188
LOG_ALERT.................................... 535
LOG_AUTH..................................... 534
LOG_AUTHPRIV................................ 535
LOG_CONS..................................... 533
LOG_CRIT..................................... 535
LOG_CRON..................................... 535
LOG_DAEMON................................... 534
LOG_DEBUG.................................... 536
LOG_EMERG.................................... 535
LOG_ERR...................................... 535
LOG_FTP...................................... 535
LOG_INFO..................................... 536
LOG_LOCAL0................................... 535
LOG_LOCAL1................................... 535
LOG_LOCAL2................................... 535
LOG_LOCAL3................................... 535
LOG_LOCAL4................................... 535
LOG_LOCAL5................................... 535
LOG_LOCAL6................................... 535
LOG_LOCAL7................................... 535
LOG_LPR...................................... 534
LOG_MAIL..................................... 534
LOG_NDELAY................................... 534
LOG_NEWS..................................... 535
LOG_NOTICE................................... 536
LOG_ODELAY................................... 534
LOG_PERROR................................... 533
LOG_PID...................................... 534
LOG_SYSLOG................................... 534
LOG_USER..................................... 534
LOG_UUCP..................................... 535
LOG_WARNING.................................. 535
LOGIN_PROCESS........................... 857 , 862
LONG_LONG_MAX............................... 959
LONG_LONG_MIN............................... 959
LONG_MAX..................................... 959
LONG_MIN..................................... 958
LONG_WIDTH................................... 957

```
M
M_1_PI....................................... 539
M_2_PI....................................... 539
M_2_SQRTPI................................... 540
M_ARENA_MAX................................... 52
M_ARENA_TEST.................................. 52
M_E........................................... 539
M_LN10....................................... 539
M_LN2......................................... 539
M_LOG10E..................................... 539
M_LOG2E...................................... 539
M_MMAP_MAX.................................... 51
M_MMAP_THRESHOLD............................. 51
M_PERTURB..................................... 51
M_PI.......................................... 539
M_PI_2....................................... 539
M_PI_4....................................... 539
M_SQRT1_2.................................... 540
M_SQRT2...................................... 540
M_TOP_PAD..................................... 52
M_TRIM_THRESHOLD............................. 52
MADV_DONTNEED............................... 364
MADV_HUGEPAGE............................... 364
MADV_NOHUGEPAGE............................. 365
MADV_NORMAL.................................. 364
MADV_RANDOM.................................. 364
MADV_SEQUENTIAL............................. 364
MADV_WILLNEED............................... 364
MAP_ANON..................................... 361
MAP_ANONYMOUS............................... 361
MAP_FIXED.................................... 361
MAP_HUGETLB.................................. 361
MAP_PRIVATE.................................. 361
MAP_SHARED................................... 361
MAX_CANON.................................... 903
MAX_INPUT.................................... 904
MAXNAMLEN.................................... 904
MAXSYMLINKS.................................. 420
MB_CUR_MAX................................... 145
MB_LEN_MAX................................... 145
MCL_CURRENT................................... 85
MCL_FUTURE.................................... 85
MDMBUF....................................... 512
MFD_ALLOW_SEALING........................... 366
MFD_CLOEXEC.................................. 366
MFD_HUGETLB.................................. 366
MINSIGSTKSZ.................................. 756
MLOCK_ONFAULT................................ 84
MM_APPL...................................... 337
MM_CONSOLE................................... 337
MM_ERROR..................................... 338
MM_FIRM...................................... 337
MM_HALT...................................... 338
MM_HARD...................................... 337
MM_INFO...................................... 338
MM_NOSEV..................................... 338
MM_NRECOV.................................... 337
MM_NULLACT................................... 338
```

Variable and Constant Macro Index 1181

MM_NULLLBL................................... 338
MM_NULLMC.................................... 338
MM_NULLSEV................................... 338
MM_NULLTAG................................... 338
MM_NULLTXT................................... 338
MM_OPSYS..................................... 337
MM_PRINT..................................... 337
MM_RECOVER................................... 337
MM_SOFT...................................... 337
MM_UTIL...................................... 337
MM_WARNING................................... 338
MNT_FORCE.................................... 888
MNTOPT_DEFAULTS............................. 883
MNTOPT_NOAUTO............................... 883
MNTOPT_NOSUID............................... 883
MNTOPT_RO.................................... 883
MNTOPT_RW.................................... 883
MNTOPT_SUID.................................. 883
MNTTAB....................................... 879
MNTTYPE_IGNORE.............................. 882
MNTTYPE_NFS.................................. 882
MNTTYPE_SWAP................................ 882
MON_1......................................... 194
MON_10....................................... 194
MON_11....................................... 194
MON_12....................................... 194
MON_2......................................... 194
MON_3......................................... 194
MON_4......................................... 194
MON_5......................................... 194
MON_6......................................... 194
MON_7......................................... 194
MON_8......................................... 194
MON_9......................................... 194
MON_DECIMAL_POINT........................... 196
MON_GROUPING................................ 196
MON_THOUSANDS_SEP........................... 196
MOUNTED...................................... 879
MS_ASYNC..................................... 363
MS_MANDLOCK.................................. 887
MS_MGC_MASK.................................. 886
MS_NOATIME................................... 887
MS_NODEV..................................... 887
MS_NODIRATIME............................... 887
MS_NOEXEC.................................... 886
MS_NOSUID.................................... 886
MS_RDONLY.................................... 886
MS_REMOUNT................................... 886
MS_SYNC...................................... 363
MS_SYNCHRONOUS.............................. 887
MSG_DONTROUTE............................... 487
MSG_OOB...................................... 487
MSG_PEEK..................................... 487
mtx_plain.................................... 924
mtx_recursive............................... 924
mtx_timed.................................... 924

```
N
N_CS_PRECEDES............................... 196
N_SEP_BY_SPACE.............................. 196
N_SIGN_POSN.................................. 196
NAME_MAX..................................... 904
NAN........................................... 609
NCCS.......................................... 506
NDEBUG....................................... 949
NEGATIVE_SIGN............................... 196
NEW_TIME................................ 857 , 862
NGROUPS_MAX.................................. 891
NL_ARGMAX.................................... 289
NO_ADDRESS................................... 471
NO_RECOVERY.................................. 471
NOEXPR....................................... 197
NOFLSH....................................... 514
NOKERNINFO................................... 515
NOSTR......................................... 197
NSIG.......................................... 716
NSS_STATUS_NOTFOUND........................ 840
NSS_STATUS_SUCCESS.......................... 840
NSS_STATUS_TRYAGAIN........................ 840
NSS_STATUS_UNAVAIL.......................... 840
NULL.......................................... 956
```
```
O
O_ACCMODE.................................... 388
O_APPEND..................................... 391
O_ASYNC...................................... 391
O_CREAT...................................... 389
O_DIRECTORY.................................. 389
O_EXCL....................................... 389
O_EXEC....................................... 388
O_EXLOCK..................................... 391
O_FSYNC...................................... 391
O_IGNORE_CTTY............................... 390
O_NDELAY..................................... 391
O_NOATIME.................................... 391
O_NOCTTY..................................... 390
O_NOFOLLOW................................... 389
O_NOLINK..................................... 390
O_NONBLOCK.............................. 389 , 391
O_NOTRANS.................................... 390
O_PATH....................................... 388
O_RDONLY..................................... 387
O_RDWR....................................... 388
O_READ....................................... 388
O_SHLOCK..................................... 390
O_SYNC....................................... 391
O_TMPFILE.................................... 389
O_TRUNC...................................... 390
O_WRITE...................................... 388
O_WRONLY..................................... 387
obstack_alloc_failed_handler............... 65
OLD_TIME................................ 857 , 862
ONCE_FLAG_INIT.............................. 923
ONLCR......................................... 510
```

Variable and Constant Macro Index 1182

ONOEOT....................................... 511
OPEN_MAX..................................... 890
OPOST......................................... 510
optarg....................................... 761
opterr....................................... 761
optind....................................... 761
OPTION_ALIAS................................ 771
OPTION_ARG_OPTIONAL........................ 771
OPTION_DOC................................... 772
OPTION_HIDDEN............................... 771
OPTION_NO_USAGE............................. 772
optopt....................................... 761
OXTABS....................................... 511

P
P_CS_PRECEDES............................... 196
P_SEP_BY_SPACE.............................. 196
P_SIGN_POSN.................................. 196
P_tmpdir..................................... 448
PA_CHAR...................................... 303
PA_DOUBLE.................................... 303
PA_FLAG_LONG................................ 303
PA_FLAG_LONG_DOUBLE........................ 303
PA_FLAG_LONG_LONG........................... 303
PA_FLAG_MASK................................ 303
PA_FLAG_PTR.................................. 303
PA_FLAG_SHORT............................... 303
PA_FLOAT..................................... 303
PA_INT....................................... 303
PA_LAST...................................... 303
PA_POINTER................................... 303
PA_STRING.................................... 303
PARENB....................................... 511
PARMRK....................................... 509
PARODD....................................... 512
PATH_MAX..................................... 904
PENDIN....................................... 515
PF_CCITT..................................... 479
PF_FILE...................................... 462
PF_IMPLINK................................... 479
PF_INET...................................... 463
PF_INET6..................................... 463
PF_ISO....................................... 479
PF_LOCAL..................................... 462
PF_NS......................................... 479
PF_ROUTE..................................... 479
PF_UNIX...................................... 462
PI............................................ 540
PIPE_BUF..................................... 904
PKEY_DISABLE_ACCESS.......................... 82
PKEY_DISABLE_WRITE........................... 81
PM_STR....................................... 194
POSITIVE_SIGN............................... 196
POSIX_MADV_DONTNEED........................ 365
POSIX_MADV_NORMAL........................... 365
POSIX_MADV_RANDOM........................... 365
POSIX_MADV_SEQUENTIAL...................... 365

```
POSIX_MADV_WILLNEED........................ 365
POSIX_REC_INCR_XFER_SIZE................... 906
POSIX_REC_MAX_XFER_SIZE.................... 906
POSIX_REC_MIN_XFER_SIZE.................... 906
POSIX_REC_XFER_ALIGN....................... 906
postorder.................................... 237
preorder..................................... 237
PRIO_MAX..................................... 697
PRIO_MIN..................................... 697
PRIO_PGRP.................................... 698
PRIO_PROCESS................................ 698
PRIO_USER.................................... 698
program_invocation_name..................... 37
program_invocation_short_name.............. 37
PROT_EXEC..................................... 78
PROT_NONE..................................... 78
PROT_READ..................................... 78
PROT_WRITE.................................... 77
PTHREAD_ATTR_NO_SIGMASK_NP................ 930
PTRDIFF_WIDTH............................... 957
PWD........................................... 403
```
```
R
R_OK.......................................... 439
RADIXCHAR.................................... 197
RAND_MAX..................................... 592
RE_DUP_MAX................................... 891
REG_BADBR.................................... 250
REG_BADPAT................................... 250
REG_BADRPT................................... 250
REG_EBRACE................................... 250
REG_EBRACK................................... 250
REG_ECOLLATE................................ 250
REG_ECTYPE................................... 250
REG_EESCAPE.................................. 250
REG_EPAREN................................... 250
REG_ERANGE................................... 250
REG_ESPACE.............................. 250 , 251
REG_ESUBREG.................................. 250
REG_EXTENDED................................ 250
REG_ICASE.................................... 250
REG_NEWLINE.................................. 251
REG_NOMATCH.................................. 251
REG_NOSUB.................................... 251
REG_NOTBOL................................... 251
REG_NOTEOL................................... 251
RLIM_INFINITY............................... 688
RLIM_NLIMITS................................ 688
RLIMIT_AS.................................... 688
RLIMIT_CORE.................................. 687
RLIMIT_CPU................................... 687
RLIMIT_DATA.................................. 687
RLIMIT_FSIZE................................ 687
RLIMIT_MEMLOCK.............................. 688
RLIMIT_NOFILE............................... 688
RLIMIT_NPROC................................ 688
RLIMIT_OFILE................................ 688
```

Variable and Constant Macro Index 1183

RLIMIT_RSS................................... 688
RLIMIT_STACK................................ 687
RUN_LVL................................. 857 , 862
RUSAGE_CHILDREN............................. 684
RUSAGE_SELF.................................. 684
RWF_APPEND................................... 357
RWF_DSYNC.................................... 357
RWF_HIPRI.................................... 357
RWF_NOWAIT................................... 357
RWF_SYNC..................................... 357

S
S_IEXEC...................................... 434
S_IFBLK...................................... 432
S_IFCHR...................................... 432
S_IFDIR...................................... 432
S_IFIFO...................................... 432
S_IFLNK...................................... 432
S_IFMT....................................... 432
S_IFREG...................................... 432
S_IFSOCK..................................... 432
S_IREAD...................................... 434
S_IRGRP...................................... 435
S_IROTH...................................... 435
S_IRUSR...................................... 434
S_IRWXG...................................... 435
S_IRWXO...................................... 435
S_IRWXU...................................... 435
S_ISGID...................................... 435
S_ISUID...................................... 435
S_ISVTX...................................... 435
S_IWGRP...................................... 435
S_IWOTH...................................... 435
S_IWRITE..................................... 434
S_IWUSR...................................... 434
S_IXGRP...................................... 435
S_IXOTH...................................... 435
S_IXUSR...................................... 434
SA_NOCLDSTOP................................ 730
SA_ONSTACK................................... 730
SA_RESTART................................... 730
SCHAR_MAX.................................... 958
SCHAR_MIN.................................... 958
SCHAR_WIDTH.................................. 957
SCHED_FIFO................................... 693
SCHED_OTHER.................................. 693
SCHED_RR..................................... 693
SEEK_CUR................................ 325 , 350
SEEK_END................................ 325 , 350
SEEK_SET................................ 325 , 350
SETFSIZE..................................... 689
SHRT_MAX..................................... 958
SHRT_MIN..................................... 958
SHRT_WIDTH................................... 957
SIG_ATOMIC_WIDTH............................ 957
SIG_BLOCK.................................... 748
SIG_DFL...................................... 725

```
SIG_ERR...................................... 727
SIG_IGN...................................... 725
SIG_SETMASK.................................. 748
SIG_UNBLOCK.................................. 748
SIGABRT...................................... 718
SIGALRM...................................... 720
SIGBUS....................................... 718
SIGCHLD...................................... 721
SIGCLD....................................... 721
SIGCONT...................................... 721
SIGEMT....................................... 719
SIGFPE....................................... 717
SIGHUP....................................... 720
SIGILL....................................... 718
SIGINFO...................................... 724
SIGINT....................................... 719
SIGIO......................................... 721
SIGIOT....................................... 718
SIGKILL...................................... 720
SIGLOST...................................... 723
signgam...................................... 553
SIGPIPE...................................... 723
SIGPOLL...................................... 721
SIGPROF...................................... 720
SIGQUIT...................................... 719
SIGSEGV...................................... 718
SIGSTKSZ..................................... 756
SIGSTOP...................................... 721
SIGSYS....................................... 719
SIGTERM...................................... 719
SIGTRAP...................................... 719
SIGTSTP...................................... 722
SIGTTIN...................................... 722
SIGTTOU...................................... 722
SIGURG....................................... 721
SIGUSR1...................................... 723
SIGUSR2...................................... 723
SIGVTALRM.................................... 720
SIGWINCH..................................... 723
SIGXCPU...................................... 723
SIGXFSZ...................................... 723
SIZE_WIDTH................................... 957
SNAN.......................................... 610
SNANF......................................... 610
SNANFN....................................... 610
SNANFNx...................................... 610
SNANL......................................... 610
SO_BROADCAST................................ 500
SO_DEBUG..................................... 499
SO_DONTROUTE................................ 500
SO_ERROR..................................... 501
SO_KEEPALIVE................................ 500
SO_LINGER.................................... 500
SO_OOBINLINE................................ 500
SO_RCVBUF.................................... 501
SO_REUSEADDR................................ 500
SO_SNDBUF.................................... 501
SO_STYLE..................................... 501
```

Variable and Constant Macro Index 1184

SO_TYPE...................................... 501
SOCK_DGRAM................................... 456
SOCK_RAW..................................... 457
SOCK_STREAM.................................. 456
SOL_SOCKET................................... 499
SS_DISABLE................................... 756
SS_ONSTACK................................... 756
SSIZE_MAX.................................... 891
stderr....................................... 266
STDERR_FILENO............................... 353
stdin......................................... 266
STDIN_FILENO................................ 353
stdout....................................... 266
STDOUT_FILENO............................... 353
STREAM_MAX................................... 890
SYMLINK_MAX.................................. 906

T

T_FMT......................................... 195
T_FMT_AMPM................................... 195
TCIFLUSH..................................... 524
TCIOFF....................................... 525
TCIOFLUSH.................................... 524
TCION......................................... 525
TCOFLUSH..................................... 524
TCOOFF....................................... 525
TCOON......................................... 525
TCSADRAIN.................................... 506
TCSAFLUSH.................................... 506
TCSANOW...................................... 506
TCSASOFT..................................... 507
THOUSANDS_SEP............................... 197
THOUSEP...................................... 197
thrd_busy.................................... 921
thrd_error................................... 921
thrd_nomem................................... 921
thrd_success................................ 921
thrd_timedout............................... 921
thread_local................................ 927
TIME_ERROR................................... 655
timezone..................................... 678
TMP_MAX...................................... 447
TOSTOP....................................... 514
TRY_AGAIN.................................... 471
TSS_DTOR_ITERATIONS........................ 927
tzname....................................... 678
TZNAME_MAX................................... 890

```
U
UCHAR_MAX.................................... 958
UCHAR_WIDTH.................................. 957
UINT_MAX..................................... 958
UINT_WIDTH................................... 957
UINTPTR_WIDTH............................... 957
ULLONG_MAX................................... 959
ULLONG_WIDTH................................ 957
ULONG_LONG_MAX.............................. 959
ULONG_MAX.................................... 959
ULONG_WIDTH.................................. 957
USER_PROCESS............................ 857 , 862
USHRT_MAX.................................... 958
USHRT_WIDTH.................................. 957
```
```
V
VDISCARD..................................... 520
VDSUSP....................................... 519
VEOF.......................................... 517
VEOL.......................................... 517
VEOL2......................................... 517
VERASE....................................... 517
VINTR......................................... 518
VKILL......................................... 518
VLNEXT....................................... 520
VMIN.......................................... 521
VQUIT......................................... 519
VREPRINT..................................... 518
VSTART....................................... 520
VSTATUS...................................... 520
VSTOP......................................... 520
VSUSP......................................... 519
VTIME......................................... 521
VWERASE...................................... 518
```
```
W
W_OK.......................................... 439
WAIT_ANY..................................... 810
WAIT_MYPGRP.................................. 811
WCHAR_MAX............................... 141 , 959
WCHAR_MIN.................................... 141
WCHAR_WIDTH.................................. 957
WEOF..................................... 141 , 321
WINT_WIDTH................................... 957
WNOHANG...................................... 811
WRDE_APPEND.................................. 256
WRDE_BADCHAR................................ 256
WRDE_BADVAL.................................. 256
WRDE_CMDSUB.................................. 256
WRDE_DOOFFS.................................. 256
WRDE_NOCMD................................... 256
WRDE_NOSPACE................................ 256
WRDE_REUSE................................... 257
WRDE_SHOWERR................................ 257
WRDE_SYNTAX.................................. 256
WRDE_UNDEF................................... 257
```

Variable and Constant Macro Index 1185

WUNTRACED.................................... 811

X
X_OK.......................................... 439

```
Y
YESEXPR...................................... 197
YESSTR....................................... 197
```

### 1186

## Program and File Index.................................

/
/etc/group................................... 868
/etc/hosts................................... 469
/etc/localtime.............................. 677
/etc/networks............................... 501
/etc/passwd.................................. 864
/etc/protocols.............................. 477
/etc/services............................... 474
/usr/share/zoneinfo........................ 677

A
argp.h....................................... 768
argz.h....................................... 135
arpa/inet.h.................................. 468
assert.h..................................... 949

C
cd............................................ 402
chgrp......................................... 433
chown......................................... 433
complex.h.......................... 539 , 633 , 634
ctype.h.................................... 87 , 89

D
dirent.h................... 15 , 404 , 406 , 407 , 410

E
envz.h....................................... 138
errno.h.................................... 23 , 24
execinfo.h................................... 918

F

fcntl.h...... 15 , 342 , 383 , 384 , 386 , 387 , 393 , 400
fcntl.h...................................... 397
float.h...................................... 961
fnmatch.h.................................... 239

G
gcc............................................. 2
gconv.h...................................... 172
grp.h................................ 15 , 850 , 868

H
hostid....................................... 875
hostname..................................... 875

```
I
iconv.h............................. 163 , 164 , 165
```
```
K
kill.......................................... 719
ksh........................................... 240
```
```
L
langinfo.h................................... 193
limits.h................... 15 , 145 , 890 , 903 , 957
locale....................................... 187
locale.h................................ 185 , 189
localtime.................................... 677
ls............................................ 425
```
```
M
malloc.h............................... 51 , 54 , 56
math.h.................... 539 , 605 , 617 , 618 , 620
mcheck.h...................................... 52
mkdir......................................... 424
```
```
N
netdb.h........................ 469 , 474 , 477 , 501
netinet/in.h.................. 464 , 467 , 474 , 476
```
```
O
obstack.h..................................... 64
```
```
P
printf.h................................ 305 , 306
pt_chown.................................... 1091
pwd.h..................................... 15 , 864
```

Program and File Index 1187

S
setjmp.h................................ 706 , 707
sh............................................ 803
signal.h.... 15 , 716 , 725 , 727 , 730 , 742 , 743 , 747 ,
748 , 751 , 757
stdarg.h................................ 952 , 953
stddef.h..................................... 956
stdint.h..................................... 601
stdio.h.. 266 , 267 , 277 , 280 , 287 , 296 , 300 , 318 , 323 ,
326 , 329 , 330 , 333 , 335 , 352 , 423 , 446 , 724 , 831 , 855
stdlib.h.. 45 , 47 , 48 , 49 , 74 , 145 , 159 , 229 , 448 , 528 ,
592 , 595 , 602 , 617 , 635 , 640 , 642 , 793 , 800 , 801 , 803
string.h..... 37 , 99 , 101 , 106 , 113 , 117 , 121 , 126 ,
724 , 725
sys/param.h.................................. 876
sys/resource.h..................... 684 , 686 , 697
sys/socket.h... 456 , 458 , 459 , 461 , 463 , 480 , 481 ,
486 , 487 , 494 , 499
sys/stat.h....... 15 , 425 , 431 , 434 , 437 , 445 , 453
sys/time.h.............................. 441 , 680
sys/times.h.............................. 15 , 650
sys/timex.h.................................. 654
sys/types.h..... 366 , 805 , 831 , 833 , 847 , 848 , 849
sys/un.h..................................... 462
sys/utsname.h............................... 877
sys/vlimit.h................................ 689
sys/wait.h......................... 809 , 812 , 813

```
T
termios.h................................ 15 , 505
threads.h.................................... 921
time.h......................... 439 , 649 , 662 , 676
```
```
U
ulimit.h..................................... 688
umask......................................... 436
unistd.h... 342 , 345 , 353 , 384 , 402 , 418 , 420 , 422 ,
423 , 433 , 439 , 450 , 503 , 680 , 761 , 801 , 805 , 807 , 831 ,
833 , 847 , 848 , 849 , 855 , 875 , 891 , 904 , 905
utime.h...................................... 440
utmp.h................................... 856 , 863
utmpx.h...................................... 861
```
```
W
wchar.h.... 101 , 106 , 117 , 141 , 142 , 145 , 146 , 147 ,
148 , 150 , 151 , 153 , 155 , 277 , 280 , 635
wctype.h................ 90 , 91 , 92 , 93 , 94 , 95 , 96
```
```
Z
zoneinfo..................................... 677
```

