书籍 《编译原理 第二版》书摘


## 类型检查

语意分析的一个重要部分是类型检查(type checking)。编译器检查每个运算符是否具有匹配的运算分量。比如，很多程序设计语言的定义中要求一个数组的下标必须是整数。如果用一个浮点数作为数组下标，编译器就必须报告错误。


## C 语言的静态作用域策略概述如下

1. 一个 C 程序由一个顶层的变量和函数声明的序列组成。
2. 函数内部可以声明变量，变量包括局部变量和参数。每个这样的声明的作用域被限制在它们所出现的那个函数内。
3. 名字 `x` 的一个顶层声明的作用域包括其后的所有程序。但是如果一个函数中也有一个 $x$ 的声明，那么函数中的那些语句就不在这个顶层声明的作用域内。


## 文法定义

一个上下文无关文法(context-free grammar) 由四个元素组成：

1. 一个终结符号集合，它们有时也称为 “词法单元”。终结符号是该文法所定义的语言的基本符号的集合。
2. 一个非终结符号集合，它们有时也被称为 “语法变量”。每个非终结符号表示一个终结符号串的集合。
3. 一个产生式集合，其中每个产生式包括一个称为产生式头或左部的非终结符号、一个箭头，和一个称为产生式体或右部的由终结符号及非终结符号组成的序列。产生式主要用来表示某个构造的某种书写形式。如果产生式头非终结符号代表一个构造，那么该产生式体就代表了该构造的一种书写方式。
4. 指定一个非终结符号为开始符号。(2.2.1)


## 多优先级运算符表达式文法的设计

我们可以将因子(factor) 理解成不能被任何运算符分开的表达式。不能分开的意思是说当在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的运算分量。当然，因子本身作为一个整体可以成为该运算符的一个运算分量。如果这个因子是一个由括号括起来的表达式，那么括号将起到保护其不被分开的作用。如果因子就是一个运算分量，那么它当然不能被分开。

一个（不是因子的）项（term）是一个可能被高优先级的运算符分开，但不能被低优先级运算符分开的表达式。一个（不是因子也不是项的）表达式可能被任何一个运算符分开。

我们可以把这种思想推广到具有任意 n 层优先级的情况。我们需要 n + 1 个非终结符号。通常，这个非终结符号的产生式体只能是单个运算分量或括号括起来的表达式。然后，对于每个优先级都有一个非终结符，表示能被该优先级或更高优先级的运算符分开的表达式。通常，这个非终结符的产生式有一些产生式体表示了该优先级的运算符的应用。另有一个产生式体只包含了代表更高一级优先级的非终结符号。（2.3.1）


## 语法制导翻译

语法制导翻译是通过向一个文法的产生式附加一些规则或程序片段而得到的。(2.3)


### 语法制导翻译相关的两个概念

属性：属性表示与某个程序构造相关的任意的量。属性可以是多种多样的，比如表达式的数据类型、生成的代码中的指令数量或为某个构造生成的代码中第一条指令的位置等。因为我们用文法符号（终结符号或者非终结符号）来表示程序构造，所以我们将属性的概念从程序构造拓展到表示这些构造的文法符号上。

语法制导的翻译方案：翻译方案是一种将程序片段附加到一个文法的各个产生式上的表示法。当在语法分析过程中使用一个表达式时，相应的程序片段就会执行。这些程序片段的执行效果按照语法分析过程的顺序组合起来，得到的结果就是这次分析/综合过程处理源程序得到的翻译结果。(2.3)


### 语法制导定义(syntax-directed definition)

把每个文法符号和一个属性集合相关联，并且把每个产生式和一组语义规则(semantic rule)想关联，这些规则用于计算与该产生式中符号相关联的属性值。(2.3.2)

如果某个属性在语法分析树节点 $N$ 上的值是由 $N$ 的子节点以及 $N$ 本身的属性值确定的，那么这个属性就称为综合属性(synthesized attribute)。综合属性具有一个很好的性质：只需要对语法分析树进行一次自底向上的遍历，就可以计算出属性的值。(2.3.2)


### 后缀表示的归纳定义

1. 如果 $E$ 是一个常量或者变量，则 $E$ 的后缀表示是 $E$ 本身。
2. 如果 $E$ 是一个形如 $E_1\ op \ E_2$ 的表达式，其中 $op$ 是一个二目运算符，那么 $E$ 的后缀表达式是 $E_{1}^{’} \ E_{2}^{'} \ op$ ，这里 $E_{1}^{‘}$ 和 $E_{2}^{'}$ 分别是 $E_{1}$ 和 $E_{2}$ 的后缀表示。
3. 如果 $E$ 是一个形如 ($E_{1}$) 的被括号括起来的表达式，则 $E$ 的后缀表示就是 $E_{1}$ 的后置表示。(2.3.1)


## 自顶向下分析方法

示例文法


```
stmt -> expr;
      | if (expr) stmt
      | for (optexpr; optexpr; optexpr) stmt
      | other

optexpr -> ε
         | expr 
```


### 自顶向下方法构造语法分析树

在自顶向下地构造一棵语法分析树时，从标号为开始非终结符 stmt 的根节点开始，反复执行下面两个步骤：

1. 在标号为非终结符号 $A$ 的节点 $N$ 上，选择 $A$ 的一个产生式，并为该产生式体中的各个符号构造出 $N$ 的子节点。
2. 寻找下一个结点来构造子树，通常选择的是语法分析树最左边的尚未拓展的非终结符。

一般来说，为一个非终结符号选择产生式是一个“尝试并犯错”的过程。也就是说，我们首先选择一个产生式，并在这个产生式不合适时进行回溯，再尝试另一个产生式。一个产生式“不合适”是指使用了该产生式之后，我们无法构造得到一棵与当前输入串相匹配的语法分析树。(2.4.1)


### 预测分析法

递归下降分析方法(recursive-descent parsing) 是一种自顶向下的语法分析方法，它使用一组递归过程来处理输入。文法的每个非终结符都有一个相关联的过程。预测分析法(predictive parsing) 是递归下降分析法的一种简单形式，在预测分析法中，各个非终结符号对应的过程中的控制流可以由向前看符号(lookahead) 无二义地确定。在分析输入串时出现的过程调用序列隐式地定义了该输入串的一棵语法分析树。如果需要，还可以通过这些过程调用来构建一个显式的语法分析树。(2.4.2)


### 左递归消除算法

考虑有两个产生式 $A \rightarrow A \alpha | \beta$ 的非终结符号 $A$ , 其中 $\alpha$ 和 $\beta$ 是不以 $A$ 开头的终结符号/非终结符符号的序列。因为产生式 $A \rightarrow A\alpha$ 的右部的最左符号是 $A$ 自身，非终结符号 $A$ 和它的产生式就称为左递归的(left recursive)。不断应用这个产生式将在 $A$ 的右边生成一个 $\alpha$ 的序列，当 $A$ 最终被替换为 $\beta$ 时，就得到一个在 $\beta$ 后跟有 0 个或多个 $\alpha$ 的序列。预测分析器不能处理左递归的文法。

使用一个新的非终结符号 $R$ ，并按照如下方式改写 $A$ 的产生式可以达到相同的效果。

$$ \begin{align}
  &A \rightarrow \beta R \nonumber \\\\
  &R \rightarrow \alpha R\ |\ \epsilon \nonumber
\end{align}
$$

非终结符号 $R$ 和它的产生式 $R \rightarrow \alpha R$ 是右递归的(right recursive), 因为这个产生式的右部的最后一个符号就是 $R$ 本身。(2.4.5)


## 标志符

字符串可以作为标识符，来为变量、数组、函数等命名。为了简化语法分析器，语言的文法通常把标志符当作终结符号进行处理。当某个标志符出现在输入中时，语法分析器都会得到相同的终结符号。(2.6.4)

