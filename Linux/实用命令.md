## 查看动态库导出函数列表

**1、objdump**

``` bash
objdump -tT xxx.so
```

**2、nm**

``` bash
nm -D xxx.so
```

-D 或 -dynamic 选项表示：显示动态符号。该选项仅对于动态库有意义。

## Linux 多个静态库打包成一个静态库

[Linux 多个静态库打包成一个静态库](https://blog.csdn.net/listener51/article/details/104400299)

``` bash
# 将libabc.a libxyz.a 打包成libaz.a
ar -rcT libaz.a libabc.a libxyz.a
```

## GCC 解析符号名工具

``` bash
c++filt 符号名
```

## 端口查看

``` bash
# 查看端口的使用的情况

## lsof 命令 比如查看 80 端口的使用的情况。

lsof -i tcp: 80
# 列出所有的端口
netstat -ntlp
# 查看端口的状态
 /etc/init.d/iptables status
```

## gcore

给运行中的进程创建一个 core 文件。

[gcore manual](https://www.linux.org/docs/man1/gcore.html)

``` bash
NAME
       gcore - Generate a core file of a running program

SYNOPSIS
       gcore [-o filename] pid

DESCRIPTION
       Generate a core dump of a running program with process ID pid.  Produced file is equivalent to a kernel
       produced core file as if the process crashed (and if "ulimit -c" were used to set up an appropriate core dump
       limit).  Unlike after a crash, after gcore the program remains running without any change.

OPTIONS
       -o filename
           The optional argument filename specifies the file name where to put the core dump.  If not specified, the
           file name defaults to core.pid, where pid is the running program process ID.
```



## gstack

打印正在运行的进程的堆栈。可以用来查看进程死锁的位置。

[gstack manual](https://linux.die.net/man/1/gstack)

```bash
Name
	gstack - print a stack trace of a running process

Synopsis
	gstack pid

Description
	gstack attaches to the active process named by the pid on the command line, and prints out an execution stack trace. If ELF symbols exist in the binary (usually the case unless you have run strip(1)), then symbolic addresses are printed as well.

If the process is part of a thread group, then gstack will print out a stack trace for each of the threads in the group.
```

